var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
  new MutationObserver((s) => {
    for (const y of s) if (y.type === "childList") for (const t of y.addedNodes) t.tagName === "LINK" && t.rel === "modulepreload" && i(t);
  }).observe(document, { childList: true, subtree: true });
  function n(s) {
    const y = {};
    return s.integrity && (y.integrity = s.integrity), s.referrerPolicy && (y.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? y.credentials = "include" : s.crossOrigin === "anonymous" ? y.credentials = "omit" : y.credentials = "same-origin", y;
  }
  function i(s) {
    if (s.ep) return;
    s.ep = true;
    const y = n(s);
    fetch(s.href, y);
  }
})();
var vc = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $d(v) {
  return v && v.__esModule && Object.prototype.hasOwnProperty.call(v, "default") ? v.default : v;
}
function ly(v) {
  if (Object.prototype.hasOwnProperty.call(v, "__esModule")) return v;
  var e = v.default;
  if (typeof e == "function") {
    var n = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: true }), Object.keys(v).forEach(function(i) {
    var s = Object.getOwnPropertyDescriptor(v, i);
    Object.defineProperty(n, i, s.get ? s : { enumerable: true, get: function() {
      return v[i];
    } });
  }), n;
}
var Ic = { exports: {} }, Tf;
function fy() {
  return Tf || (Tf = 1, function(v, e) {
    var n = {};
    /*! For license information please see stellar-sdk.min.js.LICENSE.txt */
    (function(i, s) {
      v.exports = s();
    })(self, () => (() => {
      var i = { 15: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.FastSigning = void 0, o.generate = function(r) {
          return h.generate(r);
        }, o.sign = function(r, m) {
          return h.sign(r, m);
        }, o.verify = function(r, m, g) {
          return h.verify(r, m, g);
        };
        var h = {};
        o.FastSigning = typeof window > "u" ? function() {
          var r;
          try {
            r = u(Object(function() {
              var m = new Error("Cannot find module 'sodium-native'");
              throw m.code = "MODULE_NOT_FOUND", m;
            }()));
          } catch {
            return f();
          }
          return Object.keys(r).length ? (h.generate = function(m) {
            var g = c.alloc(r.crypto_sign_PUBLICKEYBYTES), a = c.alloc(r.crypto_sign_SECRETKEYBYTES);
            return r.crypto_sign_seed_keypair(g, a, m), g;
          }, h.sign = function(m, g) {
            m = c.from(m);
            var a = c.alloc(r.crypto_sign_BYTES);
            return r.crypto_sign_detached(a, m, g), a;
          }, h.verify = function(m, g, a) {
            m = c.from(m);
            try {
              return r.crypto_sign_verify_detached(g, m, a);
            } catch {
              return false;
            }
          }, true) : f();
        }() : f();
        function f() {
          var r = u(4940);
          return h.generate = function(m) {
            var g = new Uint8Array(m), a = r.sign.keyPair.fromSeed(g);
            return c.from(a.publicKey);
          }, h.sign = function(m, g) {
            m = c.from(m), m = new Uint8Array(m.toJSON().data), g = new Uint8Array(g.toJSON().data);
            var a = r.sign.detached(m, g);
            return c.from(a);
          }, h.verify = function(m, g, a) {
            return m = c.from(m), m = new Uint8Array(m.toJSON().data), g = new Uint8Array(g.toJSON().data), a = new Uint8Array(a.toJSON().data), r.sign.detached.verify(m, g, a);
          }, false;
        }
      }, 41: (t, o, u) => {
        var c = u(655), h = u(8068), f = u(9675), r = u(5795);
        t.exports = function(m, g, a) {
          if (!m || typeof m != "object" && typeof m != "function") throw new f("`obj` must be an object or a function`");
          if (typeof g != "string" && typeof g != "symbol") throw new f("`property` must be a string or a symbol`");
          if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new f("`nonEnumerable`, if provided, must be a boolean or null");
          if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new f("`nonWritable`, if provided, must be a boolean or null");
          if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new f("`nonConfigurable`, if provided, must be a boolean or null");
          if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new f("`loose`, if provided, must be a boolean");
          var l = arguments.length > 3 ? arguments[3] : null, d = arguments.length > 4 ? arguments[4] : null, b = arguments.length > 5 ? arguments[5] : null, S = arguments.length > 6 && arguments[6], E = !!r && r(m, g);
          if (c) c(m, g, { configurable: b === null && E ? E.configurable : !b, enumerable: l === null && E ? E.enumerable : !l, value: a, writable: d === null && E ? E.writable : !d });
          else {
            if (!S && (l || d || b)) throw new h("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
            m[g] = a;
          }
        };
      }, 76: (t) => {
        t.exports = Function.prototype.call;
      }, 149: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.restoreFootprint = function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = new h.default.RestoreFootprintOp({ ext: new h.default.ExtensionPoint(0) }), m = { body: h.default.OperationBody.restoreFootprint(r) };
          return this.setSourceAccount(m, f ?? {}), new h.default.Operation(m);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 225: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.SignerKey = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(7120);
        function r(a) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, r(a);
        }
        function m(a, l) {
          for (var d = 0; d < l.length; d++) {
            var b = l[d];
            b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, g(b.key), b);
          }
        }
        function g(a) {
          var l = function(d, b) {
            if (r(d) != "object" || !d) return d;
            var S = d[Symbol.toPrimitive];
            if (S !== void 0) {
              var E = S.call(d, b);
              if (r(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(d);
          }(a, "string");
          return r(l) == "symbol" ? l : l + "";
        }
        o.SignerKey = function() {
          return function(a, l, d) {
            return d && m(a, d), Object.defineProperty(a, "prototype", { writable: false }), a;
          }(function a() {
            (function(l, d) {
              if (!(l instanceof d)) throw new TypeError("Cannot call a class as a function");
            })(this, a);
          }, null, [{ key: "decodeAddress", value: function(a) {
            var l = { ed25519PublicKey: h.default.SignerKey.signerKeyTypeEd25519, preAuthTx: h.default.SignerKey.signerKeyTypePreAuthTx, sha256Hash: h.default.SignerKey.signerKeyTypeHashX, signedPayload: h.default.SignerKey.signerKeyTypeEd25519SignedPayload }, d = f.StrKey.getVersionByteForPrefix(a), b = l[d];
            if (!b) throw new Error("invalid signer key type (".concat(d, ")"));
            var S = (0, f.decodeCheck)(d, a);
            return b(d === "signedPayload" ? new h.default.SignerKeyEd25519SignedPayload({ ed25519: S.slice(0, 32), payload: S.slice(36) }) : S);
          } }, { key: "encodeSignerKey", value: function(a) {
            var l, d;
            switch (a.switch()) {
              case h.default.SignerKeyType.signerKeyTypeEd25519():
                l = "ed25519PublicKey", d = a.value();
                break;
              case h.default.SignerKeyType.signerKeyTypePreAuthTx():
                l = "preAuthTx", d = a.value();
                break;
              case h.default.SignerKeyType.signerKeyTypeHashX():
                l = "sha256Hash", d = a.value();
                break;
              case h.default.SignerKeyType.signerKeyTypeEd25519SignedPayload():
                l = "signedPayload", d = a.ed25519SignedPayload().toXDR("raw");
                break;
              default:
                throw new Error("invalid SignerKey (type: ".concat(a.switch(), ")"));
            }
            return (0, f.encodeCheck)(l, d);
          } }]);
        }();
      }, 251: (t, o) => {
        o.read = function(u, c, h, f, r) {
          var m, g, a = 8 * r - f - 1, l = (1 << a) - 1, d = l >> 1, b = -7, S = h ? r - 1 : 0, E = h ? -1 : 1, R = u[c + S];
          for (S += E, m = R & (1 << -b) - 1, R >>= -b, b += a; b > 0; m = 256 * m + u[c + S], S += E, b -= 8) ;
          for (g = m & (1 << -b) - 1, m >>= -b, b += f; b > 0; g = 256 * g + u[c + S], S += E, b -= 8) ;
          if (m === 0) m = 1 - d;
          else {
            if (m === l) return g ? NaN : 1 / 0 * (R ? -1 : 1);
            g += Math.pow(2, f), m -= d;
          }
          return (R ? -1 : 1) * g * Math.pow(2, m - f);
        }, o.write = function(u, c, h, f, r, m) {
          var g, a, l, d = 8 * m - r - 1, b = (1 << d) - 1, S = b >> 1, E = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, R = f ? 0 : m - 1, k = f ? 1 : -1, w = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
          for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (a = isNaN(c) ? 1 : 0, g = b) : (g = Math.floor(Math.log(c) / Math.LN2), c * (l = Math.pow(2, -g)) < 1 && (g--, l *= 2), (c += g + S >= 1 ? E / l : E * Math.pow(2, 1 - S)) * l >= 2 && (g++, l /= 2), g + S >= b ? (a = 0, g = b) : g + S >= 1 ? (a = (c * l - 1) * Math.pow(2, r), g += S) : (a = c * Math.pow(2, S - 1) * Math.pow(2, r), g = 0)); r >= 8; u[h + R] = 255 & a, R += k, a /= 256, r -= 8) ;
          for (g = g << r | a, d += r; d > 0; u[h + R] = 255 & g, R += k, g /= 256, d -= 8) ;
          u[h + R - k] |= 128 * w;
        };
      }, 345: (t, o, u) => {
        t.exports = u(7007).EventEmitter;
      }, 356: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true });
        var c = { xdr: true, cereal: true, hash: true, sign: true, verify: true, FastSigning: true, getLiquidityPoolId: true, LiquidityPoolFeeV18: true, Keypair: true, UnsignedHyper: true, Hyper: true, TransactionBase: true, Transaction: true, FeeBumpTransaction: true, TransactionBuilder: true, TimeoutInfinite: true, BASE_FEE: true, Asset: true, LiquidityPoolAsset: true, LiquidityPoolId: true, Operation: true, AuthRequiredFlag: true, AuthRevocableFlag: true, AuthImmutableFlag: true, AuthClawbackEnabledFlag: true, Account: true, MuxedAccount: true, Claimant: true, Networks: true, StrKey: true, SignerKey: true, Soroban: true, decodeAddressToMuxedAccount: true, encodeMuxedAccountToAddress: true, extractBaseAddress: true, encodeMuxedAccount: true, Contract: true, Address: true };
        Object.defineProperty(o, "Account", { enumerable: true, get: function() {
          return q.Account;
        } }), Object.defineProperty(o, "Address", { enumerable: true, get: function() {
          return te.Address;
        } }), Object.defineProperty(o, "Asset", { enumerable: true, get: function() {
          return R.Asset;
        } }), Object.defineProperty(o, "AuthClawbackEnabledFlag", { enumerable: true, get: function() {
          return F.AuthClawbackEnabledFlag;
        } }), Object.defineProperty(o, "AuthImmutableFlag", { enumerable: true, get: function() {
          return F.AuthImmutableFlag;
        } }), Object.defineProperty(o, "AuthRequiredFlag", { enumerable: true, get: function() {
          return F.AuthRequiredFlag;
        } }), Object.defineProperty(o, "AuthRevocableFlag", { enumerable: true, get: function() {
          return F.AuthRevocableFlag;
        } }), Object.defineProperty(o, "BASE_FEE", { enumerable: true, get: function() {
          return E.BASE_FEE;
        } }), Object.defineProperty(o, "Claimant", { enumerable: true, get: function() {
          return H.Claimant;
        } }), Object.defineProperty(o, "Contract", { enumerable: true, get: function() {
          return Y.Contract;
        } }), Object.defineProperty(o, "FastSigning", { enumerable: true, get: function() {
          return m.FastSigning;
        } }), Object.defineProperty(o, "FeeBumpTransaction", { enumerable: true, get: function() {
          return S.FeeBumpTransaction;
        } }), Object.defineProperty(o, "Hyper", { enumerable: true, get: function() {
          return l.Hyper;
        } }), Object.defineProperty(o, "Keypair", { enumerable: true, get: function() {
          return a.Keypair;
        } }), Object.defineProperty(o, "LiquidityPoolAsset", { enumerable: true, get: function() {
          return k.LiquidityPoolAsset;
        } }), Object.defineProperty(o, "LiquidityPoolFeeV18", { enumerable: true, get: function() {
          return g.LiquidityPoolFeeV18;
        } }), Object.defineProperty(o, "LiquidityPoolId", { enumerable: true, get: function() {
          return w.LiquidityPoolId;
        } }), Object.defineProperty(o, "MuxedAccount", { enumerable: true, get: function() {
          return D.MuxedAccount;
        } }), Object.defineProperty(o, "Networks", { enumerable: true, get: function() {
          return _.Networks;
        } }), Object.defineProperty(o, "Operation", { enumerable: true, get: function() {
          return F.Operation;
        } }), Object.defineProperty(o, "SignerKey", { enumerable: true, get: function() {
          return L.SignerKey;
        } }), Object.defineProperty(o, "Soroban", { enumerable: true, get: function() {
          return j.Soroban;
        } }), Object.defineProperty(o, "StrKey", { enumerable: true, get: function() {
          return T.StrKey;
        } }), Object.defineProperty(o, "TimeoutInfinite", { enumerable: true, get: function() {
          return E.TimeoutInfinite;
        } }), Object.defineProperty(o, "Transaction", { enumerable: true, get: function() {
          return b.Transaction;
        } }), Object.defineProperty(o, "TransactionBase", { enumerable: true, get: function() {
          return d.TransactionBase;
        } }), Object.defineProperty(o, "TransactionBuilder", { enumerable: true, get: function() {
          return E.TransactionBuilder;
        } }), Object.defineProperty(o, "UnsignedHyper", { enumerable: true, get: function() {
          return l.UnsignedHyper;
        } }), Object.defineProperty(o, "cereal", { enumerable: true, get: function() {
          return f.default;
        } }), Object.defineProperty(o, "decodeAddressToMuxedAccount", { enumerable: true, get: function() {
          return z.decodeAddressToMuxedAccount;
        } }), o.default = void 0, Object.defineProperty(o, "encodeMuxedAccount", { enumerable: true, get: function() {
          return z.encodeMuxedAccount;
        } }), Object.defineProperty(o, "encodeMuxedAccountToAddress", { enumerable: true, get: function() {
          return z.encodeMuxedAccountToAddress;
        } }), Object.defineProperty(o, "extractBaseAddress", { enumerable: true, get: function() {
          return z.extractBaseAddress;
        } }), Object.defineProperty(o, "getLiquidityPoolId", { enumerable: true, get: function() {
          return g.getLiquidityPoolId;
        } }), Object.defineProperty(o, "hash", { enumerable: true, get: function() {
          return r.hash;
        } }), Object.defineProperty(o, "sign", { enumerable: true, get: function() {
          return m.sign;
        } }), Object.defineProperty(o, "verify", { enumerable: true, get: function() {
          return m.verify;
        } }), Object.defineProperty(o, "xdr", { enumerable: true, get: function() {
          return h.default;
        } });
        var h = $(u(1918)), f = $(u(3335)), r = u(9152), m = u(15), g = u(5578), a = u(6691), l = u(3740), d = u(3758), b = u(380), S = u(9260), E = u(6396), R = u(1764), k = u(2262), w = u(9353), F = u(7237), I = u(4172);
        Object.keys(I).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === I[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return I[oe];
          } }));
        });
        var q = u(2135), D = u(2243), H = u(1387), _ = u(6202), T = u(7120), L = u(225), j = u(4062), z = u(6160), Y = u(7452), te = u(1180), G = u(8549);
        Object.keys(G).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === G[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return G[oe];
          } }));
        });
        var K = u(7177);
        Object.keys(K).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === K[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return K[oe];
          } }));
        });
        var J = u(3919);
        Object.keys(J).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === J[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return J[oe];
          } }));
        });
        var B = u(4842);
        Object.keys(B).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === B[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return B[oe];
          } }));
        });
        var Z = u(5328);
        Object.keys(Z).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === Z[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return Z[oe];
          } }));
        });
        var ie = u(3564);
        function $(oe) {
          return oe && oe.__esModule ? oe : { default: oe };
        }
        Object.keys(ie).forEach(function(oe) {
          oe !== "default" && oe !== "__esModule" && (Object.prototype.hasOwnProperty.call(c, oe) || oe in o && o[oe] === ie[oe] || Object.defineProperty(o, oe, { enumerable: true, get: function() {
            return ie[oe];
          } }));
        }), o.default = t.exports;
      }, 380: (t, o, u) => {
        var c = u(8287).Buffer;
        function h(I) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(q) {
            return typeof q;
          } : function(q) {
            return q && typeof Symbol == "function" && q.constructor === Symbol && q !== Symbol.prototype ? "symbol" : typeof q;
          }, h(I);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Transaction = void 0;
        var f, r = (f = u(1918)) && f.__esModule ? f : { default: f }, m = u(9152), g = u(7120), a = u(7237), l = u(4172), d = u(3758), b = u(6160);
        function S(I, q) {
          for (var D = 0; D < q.length; D++) {
            var H = q[D];
            H.enumerable = H.enumerable || false, H.configurable = true, "value" in H && (H.writable = true), Object.defineProperty(I, E(H.key), H);
          }
        }
        function E(I) {
          var q = function(D, H) {
            if (h(D) != "object" || !D) return D;
            var _ = D[Symbol.toPrimitive];
            if (_ !== void 0) {
              var T = _.call(D, H);
              if (h(T) != "object") return T;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(D);
          }(I, "string");
          return h(q) == "symbol" ? q : q + "";
        }
        function R(I, q, D) {
          return q = w(q), function(H, _) {
            if (_ && (h(_) == "object" || typeof _ == "function")) return _;
            if (_ !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(T) {
              if (T === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return T;
            }(H);
          }(I, k() ? Reflect.construct(q, D || [], w(I).constructor) : q.apply(I, D));
        }
        function k() {
          try {
            var I = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (k = function() {
            return !!I;
          })();
        }
        function w(I) {
          return w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(q) {
            return q.__proto__ || Object.getPrototypeOf(q);
          }, w(I);
        }
        function F(I, q) {
          return F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(D, H) {
            return D.__proto__ = H, D;
          }, F(I, q);
        }
        o.Transaction = function(I) {
          function q(D, H) {
            var _;
            if (function(Z, ie) {
              if (!(Z instanceof ie)) throw new TypeError("Cannot call a class as a function");
            }(this, q), typeof D == "string") {
              var T = c.from(D, "base64");
              D = r.default.TransactionEnvelope.fromXDR(T);
            }
            var L = D.switch();
            if (L !== r.default.EnvelopeType.envelopeTypeTxV0() && L !== r.default.EnvelopeType.envelopeTypeTx()) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(L.name, "."));
            var j = D.value(), z = j.tx(), Y = z.fee().toString();
            (_ = R(this, q, [z, (j.signatures() || []).slice(), Y, H]))._envelopeType = L, _._memo = z.memo(), _._sequence = z.seqNum().toString(), _._envelopeType === r.default.EnvelopeType.envelopeTypeTxV0() ? _._source = g.StrKey.encodeEd25519PublicKey(_.tx.sourceAccountEd25519()) : _._source = (0, b.encodeMuxedAccountToAddress)(_.tx.sourceAccount());
            var te = null, G = null;
            switch (_._envelopeType) {
              case r.default.EnvelopeType.envelopeTypeTxV0():
                G = z.timeBounds();
                break;
              case r.default.EnvelopeType.envelopeTypeTx():
                switch (z.cond().switch()) {
                  case r.default.PreconditionType.precondTime():
                    G = z.cond().timeBounds();
                    break;
                  case r.default.PreconditionType.precondV2():
                    G = (te = z.cond().v2()).timeBounds();
                }
            }
            if (G && (_._timeBounds = { minTime: G.minTime().toString(), maxTime: G.maxTime().toString() }), te) {
              var K = te.ledgerBounds();
              K && (_._ledgerBounds = { minLedger: K.minLedger(), maxLedger: K.maxLedger() });
              var J = te.minSeqNum();
              J && (_._minAccountSequence = J.toString()), _._minAccountSequenceAge = te.minSeqAge(), _._minAccountSequenceLedgerGap = te.minSeqLedgerGap(), _._extraSigners = te.extraSigners();
            }
            var B = z.operations() || [];
            return _._operations = B.map(function(Z) {
              return a.Operation.fromXDRObject(Z);
            }), _;
          }
          return function(D, H) {
            if (typeof H != "function" && H !== null) throw new TypeError("Super expression must either be null or a function");
            D.prototype = Object.create(H && H.prototype, { constructor: { value: D, writable: true, configurable: true } }), Object.defineProperty(D, "prototype", { writable: false }), H && F(D, H);
          }(q, I), function(D, H, _) {
            return H && S(D.prototype, H), Object.defineProperty(D, "prototype", { writable: false }), D;
          }(q, [{ key: "timeBounds", get: function() {
            return this._timeBounds;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "ledgerBounds", get: function() {
            return this._ledgerBounds;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequence", get: function() {
            return this._minAccountSequence;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequenceAge", get: function() {
            return this._minAccountSequenceAge;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "minAccountSequenceLedgerGap", get: function() {
            return this._minAccountSequenceLedgerGap;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "extraSigners", get: function() {
            return this._extraSigners;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "sequence", get: function() {
            return this._sequence;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "source", get: function() {
            return this._source;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "operations", get: function() {
            return this._operations;
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "memo", get: function() {
            return l.Memo.fromXDRObject(this._memo);
          }, set: function(D) {
            throw new Error("Transaction is immutable");
          } }, { key: "signatureBase", value: function() {
            var D = this.tx;
            this._envelopeType === r.default.EnvelopeType.envelopeTypeTxV0() && (D = r.default.Transaction.fromXDR(c.concat([r.default.PublicKeyType.publicKeyTypeEd25519().toXDR(), D.toXDR()])));
            var H = new r.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(D);
            return new r.default.TransactionSignaturePayload({ networkId: r.default.Hash.fromXDR((0, m.hash)(this.networkPassphrase)), taggedTransaction: H }).toXDR();
          } }, { key: "toEnvelope", value: function() {
            var D, H = this.tx.toXDR(), _ = this.signatures.slice();
            switch (this._envelopeType) {
              case r.default.EnvelopeType.envelopeTypeTxV0():
                D = new r.default.TransactionEnvelope.envelopeTypeTxV0(new r.default.TransactionV0Envelope({ tx: r.default.TransactionV0.fromXDR(H), signatures: _ }));
                break;
              case r.default.EnvelopeType.envelopeTypeTx():
                D = new r.default.TransactionEnvelope.envelopeTypeTx(new r.default.TransactionV1Envelope({ tx: r.default.Transaction.fromXDR(H), signatures: _ }));
                break;
              default:
                throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
            }
            return D;
          } }, { key: "getClaimableBalanceId", value: function(D) {
            if (!Number.isInteger(D) || D < 0 || D >= this.operations.length) throw new RangeError("invalid operation index");
            var H = this.operations[D];
            try {
              H = a.Operation.createClaimableBalance(H);
            } catch (j) {
              throw new TypeError("expected createClaimableBalance, got ".concat(H.type, ": ").concat(j));
            }
            var _ = g.StrKey.decodeEd25519PublicKey((0, b.extractBaseAddress)(this.source)), T = r.default.HashIdPreimage.envelopeTypeOpId(new r.default.HashIdPreimageOperationId({ sourceAccount: r.default.AccountId.publicKeyTypeEd25519(_), seqNum: r.default.SequenceNumber.fromString(this.sequence), opNum: D })), L = (0, m.hash)(T.toXDR("raw"));
            return r.default.ClaimableBalanceId.claimableBalanceIdTypeV0(L).toXDR("hex");
          } }]);
        }(d.TransactionBase);
      }, 392: (t, o, u) => {
        var c = u(2861).Buffer;
        function h(f, r) {
          this._block = c.alloc(f), this._finalSize = r, this._blockSize = f, this._len = 0;
        }
        h.prototype.update = function(f, r) {
          typeof f == "string" && (r = r || "utf8", f = c.from(f, r));
          for (var m = this._block, g = this._blockSize, a = f.length, l = this._len, d = 0; d < a; ) {
            for (var b = l % g, S = Math.min(a - d, g - b), E = 0; E < S; E++) m[b + E] = f[d + E];
            d += S, (l += S) % g == 0 && this._update(m);
          }
          return this._len += a, this;
        }, h.prototype.digest = function(f) {
          var r = this._len % this._blockSize;
          this._block[r] = 128, this._block.fill(0, r + 1), r >= this._finalSize && (this._update(this._block), this._block.fill(0));
          var m = 8 * this._len;
          if (m <= 4294967295) this._block.writeUInt32BE(m, this._blockSize - 4);
          else {
            var g = (4294967295 & m) >>> 0, a = (m - g) / 4294967296;
            this._block.writeUInt32BE(a, this._blockSize - 8), this._block.writeUInt32BE(g, this._blockSize - 4);
          }
          this._update(this._block);
          var l = this._hash();
          return f ? l.toString(f) : l;
        }, h.prototype._update = function() {
          throw new Error("_update must be implemented by subclass");
        }, t.exports = h;
      }, 414: (t) => {
        t.exports = Math.round;
      }, 453: (t, o, u) => {
        var c, h = u(9612), f = u(9383), r = u(1237), m = u(9290), g = u(9538), a = u(8068), l = u(9675), d = u(5345), b = u(1514), S = u(8968), E = u(6188), R = u(8002), k = u(5880), w = u(414), F = u(3093), I = Function, q = function(xe) {
          try {
            return I('"use strict"; return (' + xe + ").constructor;")();
          } catch {
          }
        }, D = u(5795), H = u(655), _ = function() {
          throw new l();
        }, T = D ? function() {
          try {
            return _;
          } catch {
            try {
              return D(arguments, "callee").get;
            } catch {
              return _;
            }
          }
        }() : _, L = u(4039)(), j = u(3628), z = u(1064), Y = u(8648), te = u(1002), G = u(76), K = {}, J = typeof Uint8Array < "u" && j ? j(Uint8Array) : c, B = { __proto__: null, "%AggregateError%": typeof AggregateError > "u" ? c : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? c : ArrayBuffer, "%ArrayIteratorPrototype%": L && j ? j([][Symbol.iterator]()) : c, "%AsyncFromSyncIteratorPrototype%": c, "%AsyncFunction%": K, "%AsyncGenerator%": K, "%AsyncGeneratorFunction%": K, "%AsyncIteratorPrototype%": K, "%Atomics%": typeof Atomics > "u" ? c : Atomics, "%BigInt%": typeof BigInt > "u" ? c : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? c : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? c : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? c : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": f, "%eval%": eval, "%EvalError%": r, "%Float16Array%": typeof Float16Array > "u" ? c : Float16Array, "%Float32Array%": typeof Float32Array > "u" ? c : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? c : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? c : FinalizationRegistry, "%Function%": I, "%GeneratorFunction%": K, "%Int8Array%": typeof Int8Array > "u" ? c : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? c : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? c : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": L && j ? j(j([][Symbol.iterator]())) : c, "%JSON%": typeof JSON == "object" ? JSON : c, "%Map%": typeof Map > "u" ? c : Map, "%MapIteratorPrototype%": typeof Map < "u" && L && j ? j((/* @__PURE__ */ new Map())[Symbol.iterator]()) : c, "%Math%": Math, "%Number%": Number, "%Object%": h, "%Object.getOwnPropertyDescriptor%": D, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? c : Promise, "%Proxy%": typeof Proxy > "u" ? c : Proxy, "%RangeError%": m, "%ReferenceError%": g, "%Reflect%": typeof Reflect > "u" ? c : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? c : Set, "%SetIteratorPrototype%": typeof Set < "u" && L && j ? j((/* @__PURE__ */ new Set())[Symbol.iterator]()) : c, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? c : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": L && j ? j(""[Symbol.iterator]()) : c, "%Symbol%": L ? Symbol : c, "%SyntaxError%": a, "%ThrowTypeError%": T, "%TypedArray%": J, "%TypeError%": l, "%Uint8Array%": typeof Uint8Array > "u" ? c : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? c : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? c : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? c : Uint32Array, "%URIError%": d, "%WeakMap%": typeof WeakMap > "u" ? c : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? c : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? c : WeakSet, "%Function.prototype.call%": G, "%Function.prototype.apply%": te, "%Object.defineProperty%": H, "%Object.getPrototypeOf%": z, "%Math.abs%": b, "%Math.floor%": S, "%Math.max%": E, "%Math.min%": R, "%Math.pow%": k, "%Math.round%": w, "%Math.sign%": F, "%Reflect.getPrototypeOf%": Y };
        if (j) try {
          null.error;
        } catch (xe) {
          var Z = j(j(xe));
          B["%Error.prototype%"] = Z;
        }
        var ie = function xe(Ve) {
          var _e;
          if (Ve === "%AsyncFunction%") _e = q("async function () {}");
          else if (Ve === "%GeneratorFunction%") _e = q("function* () {}");
          else if (Ve === "%AsyncGeneratorFunction%") _e = q("async function* () {}");
          else if (Ve === "%AsyncGenerator%") {
            var Be = xe("%AsyncGeneratorFunction%");
            Be && (_e = Be.prototype);
          } else if (Ve === "%AsyncIteratorPrototype%") {
            var Qe = xe("%AsyncGenerator%");
            Qe && j && (_e = j(Qe.prototype));
          }
          return B[Ve] = _e, _e;
        }, $ = { __proto__: null, "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, oe = u(6743), ce = u(9957), ye = oe.call(G, Array.prototype.concat), ae = oe.call(te, Array.prototype.splice), ue = oe.call(G, String.prototype.replace), ne = oe.call(G, String.prototype.slice), ge = oe.call(G, RegExp.prototype.exec), Te = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, pe = /\\(\\)?/g, Oe = function(xe, Ve) {
          var _e, Be = xe;
          if (ce($, Be) && (Be = "%" + (_e = $[Be])[0] + "%"), ce(B, Be)) {
            var Qe = B[Be];
            if (Qe === K && (Qe = ie(Be)), Qe === void 0 && !Ve) throw new l("intrinsic " + xe + " exists, but is not available. Please file an issue!");
            return { alias: _e, name: Be, value: Qe };
          }
          throw new a("intrinsic " + xe + " does not exist!");
        };
        t.exports = function(xe, Ve) {
          if (typeof xe != "string" || xe.length === 0) throw new l("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && typeof Ve != "boolean") throw new l('"allowMissing" argument must be a boolean');
          if (ge(/^%?[^%]*%?$/, xe) === null) throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          var _e = function(Q) {
            var se = ne(Q, 0, 1), X = ne(Q, -1);
            if (se === "%" && X !== "%") throw new a("invalid intrinsic syntax, expected closing `%`");
            if (X === "%" && se !== "%") throw new a("invalid intrinsic syntax, expected opening `%`");
            var de = [];
            return ue(Q, Te, function(tt, Ne, ut, Ze) {
              de[de.length] = ut ? ue(Ze, pe, "$1") : Ne || tt;
            }), de;
          }(xe), Be = _e.length > 0 ? _e[0] : "", Qe = Oe("%" + Be + "%", Ve), ee = Qe.name, P = Qe.value, x = false, O = Qe.alias;
          O && (Be = O[0], ae(_e, ye([0, 1], O)));
          for (var V = 1, N = true; V < _e.length; V += 1) {
            var C = _e[V], p = ne(C, 0, 1), A = ne(C, -1);
            if ((p === '"' || p === "'" || p === "`" || A === '"' || A === "'" || A === "`") && p !== A) throw new a("property names with quotes must have matching quotes");
            if (C !== "constructor" && N || (x = true), ce(B, ee = "%" + (Be += "." + C) + "%")) P = B[ee];
            else if (P != null) {
              if (!(C in P)) {
                if (!Ve) throw new l("base intrinsic for " + xe + " exists, but the property is not available.");
                return;
              }
              if (D && V + 1 >= _e.length) {
                var U = D(P, C);
                P = (N = !!U) && "get" in U && !("originalValue" in U.get) ? U.get : P[C];
              } else N = ce(P, C), P = P[C];
              N && !x && (B[ee] = P);
            }
          }
          return P;
        };
      }, 487: (t, o, u) => {
        var c = u(6897), h = u(655), f = u(3126), r = u(2205);
        t.exports = function(m) {
          var g = f(arguments), a = m.length - (arguments.length - 1);
          return c(g, 1 + (a > 0 ? a : 0), true);
        }, h ? h(t.exports, "apply", { value: r }) : t.exports.apply = r;
      }, 507: (t, o, u) => {
        var c = u(453), h = u(6556), f = u(8859), r = u(9675), m = c("%Map%", true), g = h("Map.prototype.get", true), a = h("Map.prototype.set", true), l = h("Map.prototype.has", true), d = h("Map.prototype.delete", true), b = h("Map.prototype.size", true);
        t.exports = !!m && function() {
          var S, E = { assert: function(R) {
            if (!E.has(R)) throw new r("Side channel does not contain " + f(R));
          }, delete: function(R) {
            if (S) {
              var k = d(S, R);
              return b(S) === 0 && (S = void 0), k;
            }
            return false;
          }, get: function(R) {
            if (S) return g(S, R);
          }, has: function(R) {
            return !!S && l(S, R);
          }, set: function(R, k) {
            S || (S = new m()), a(S, R, k);
          } };
          return E;
        };
      }, 537: (t, o, u) => {
        var c = Object.getOwnPropertyDescriptors || function(K) {
          for (var J = Object.keys(K), B = {}, Z = 0; Z < J.length; Z++) B[J[Z]] = Object.getOwnPropertyDescriptor(K, J[Z]);
          return B;
        }, h = /%[sdj%]/g;
        o.format = function(K) {
          if (!F(K)) {
            for (var J = [], B = 0; B < arguments.length; B++) J.push(g(arguments[B]));
            return J.join(" ");
          }
          B = 1;
          for (var Z = arguments, ie = Z.length, $ = String(K).replace(h, function(ce) {
            if (ce === "%%") return "%";
            if (B >= ie) return ce;
            switch (ce) {
              case "%s":
                return String(Z[B++]);
              case "%d":
                return Number(Z[B++]);
              case "%j":
                try {
                  return JSON.stringify(Z[B++]);
                } catch {
                  return "[Circular]";
                }
              default:
                return ce;
            }
          }), oe = Z[B]; B < ie; oe = Z[++B]) k(oe) || !D(oe) ? $ += " " + oe : $ += " " + g(oe);
          return $;
        }, o.deprecate = function(K, J) {
          if (typeof process < "u" && process.noDeprecation === true) return K;
          if (typeof process > "u") return function() {
            return o.deprecate(K, J).apply(this, arguments);
          };
          var B = false;
          return function() {
            if (!B) {
              if (process.throwDeprecation) throw new Error(J);
              process.traceDeprecation ? console.trace(J) : console.error(J), B = true;
            }
            return K.apply(this, arguments);
          };
        };
        var f = {}, r = /^$/;
        if (n.NODE_DEBUG) {
          var m = n.NODE_DEBUG;
          m = m.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), r = new RegExp("^" + m + "$", "i");
        }
        function g(K, J) {
          var B = { seen: [], stylize: l };
          return arguments.length >= 3 && (B.depth = arguments[2]), arguments.length >= 4 && (B.colors = arguments[3]), R(J) ? B.showHidden = J : J && o._extend(B, J), I(B.showHidden) && (B.showHidden = false), I(B.depth) && (B.depth = 2), I(B.colors) && (B.colors = false), I(B.customInspect) && (B.customInspect = true), B.colors && (B.stylize = a), d(B, K, B.depth);
        }
        function a(K, J) {
          var B = g.styles[J];
          return B ? "\x1B[" + g.colors[B][0] + "m" + K + "\x1B[" + g.colors[B][1] + "m" : K;
        }
        function l(K, J) {
          return K;
        }
        function d(K, J, B) {
          if (K.customInspect && J && T(J.inspect) && J.inspect !== o.inspect && (!J.constructor || J.constructor.prototype !== J)) {
            var Z = J.inspect(B, K);
            return F(Z) || (Z = d(K, Z, B)), Z;
          }
          var ie = function(ge, Te) {
            if (I(Te)) return ge.stylize("undefined", "undefined");
            if (F(Te)) {
              var pe = "'" + JSON.stringify(Te).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return ge.stylize(pe, "string");
            }
            if (w(Te)) return ge.stylize("" + Te, "number");
            if (R(Te)) return ge.stylize("" + Te, "boolean");
            if (k(Te)) return ge.stylize("null", "null");
          }(K, J);
          if (ie) return ie;
          var $ = Object.keys(J), oe = function(ge) {
            var Te = {};
            return ge.forEach(function(pe, Oe) {
              Te[pe] = true;
            }), Te;
          }($);
          if (K.showHidden && ($ = Object.getOwnPropertyNames(J)), _(J) && ($.indexOf("message") >= 0 || $.indexOf("description") >= 0)) return b(J);
          if ($.length === 0) {
            if (T(J)) {
              var ce = J.name ? ": " + J.name : "";
              return K.stylize("[Function" + ce + "]", "special");
            }
            if (q(J)) return K.stylize(RegExp.prototype.toString.call(J), "regexp");
            if (H(J)) return K.stylize(Date.prototype.toString.call(J), "date");
            if (_(J)) return b(J);
          }
          var ye, ae = "", ue = false, ne = ["{", "}"];
          return E(J) && (ue = true, ne = ["[", "]"]), T(J) && (ae = " [Function" + (J.name ? ": " + J.name : "") + "]"), q(J) && (ae = " " + RegExp.prototype.toString.call(J)), H(J) && (ae = " " + Date.prototype.toUTCString.call(J)), _(J) && (ae = " " + b(J)), $.length !== 0 || ue && J.length != 0 ? B < 0 ? q(J) ? K.stylize(RegExp.prototype.toString.call(J), "regexp") : K.stylize("[Object]", "special") : (K.seen.push(J), ye = ue ? function(ge, Te, pe, Oe, xe) {
            for (var Ve = [], _e = 0, Be = Te.length; _e < Be; ++_e) Y(Te, String(_e)) ? Ve.push(S(ge, Te, pe, Oe, String(_e), true)) : Ve.push("");
            return xe.forEach(function(Qe) {
              Qe.match(/^\d+$/) || Ve.push(S(ge, Te, pe, Oe, Qe, true));
            }), Ve;
          }(K, J, B, oe, $) : $.map(function(ge) {
            return S(K, J, B, oe, ge, ue);
          }), K.seen.pop(), function(ge, Te, pe) {
            var Oe = ge.reduce(function(xe, Ve) {
              return Ve.indexOf(`
`) >= 0, xe + Ve.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            return Oe > 60 ? pe[0] + (Te === "" ? "" : Te + `
 `) + " " + ge.join(`,
  `) + " " + pe[1] : pe[0] + Te + " " + ge.join(", ") + " " + pe[1];
          }(ye, ae, ne)) : ne[0] + ae + ne[1];
        }
        function b(K) {
          return "[" + Error.prototype.toString.call(K) + "]";
        }
        function S(K, J, B, Z, ie, $) {
          var oe, ce, ye;
          if ((ye = Object.getOwnPropertyDescriptor(J, ie) || { value: J[ie] }).get ? ce = ye.set ? K.stylize("[Getter/Setter]", "special") : K.stylize("[Getter]", "special") : ye.set && (ce = K.stylize("[Setter]", "special")), Y(Z, ie) || (oe = "[" + ie + "]"), ce || (K.seen.indexOf(ye.value) < 0 ? (ce = k(B) ? d(K, ye.value, null) : d(K, ye.value, B - 1)).indexOf(`
`) > -1 && (ce = $ ? ce.split(`
`).map(function(ae) {
            return "  " + ae;
          }).join(`
`).slice(2) : `
` + ce.split(`
`).map(function(ae) {
            return "   " + ae;
          }).join(`
`)) : ce = K.stylize("[Circular]", "special")), I(oe)) {
            if ($ && ie.match(/^\d+$/)) return ce;
            (oe = JSON.stringify("" + ie)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (oe = oe.slice(1, -1), oe = K.stylize(oe, "name")) : (oe = oe.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), oe = K.stylize(oe, "string"));
          }
          return oe + ": " + ce;
        }
        function E(K) {
          return Array.isArray(K);
        }
        function R(K) {
          return typeof K == "boolean";
        }
        function k(K) {
          return K === null;
        }
        function w(K) {
          return typeof K == "number";
        }
        function F(K) {
          return typeof K == "string";
        }
        function I(K) {
          return K === void 0;
        }
        function q(K) {
          return D(K) && L(K) === "[object RegExp]";
        }
        function D(K) {
          return typeof K == "object" && K !== null;
        }
        function H(K) {
          return D(K) && L(K) === "[object Date]";
        }
        function _(K) {
          return D(K) && (L(K) === "[object Error]" || K instanceof Error);
        }
        function T(K) {
          return typeof K == "function";
        }
        function L(K) {
          return Object.prototype.toString.call(K);
        }
        function j(K) {
          return K < 10 ? "0" + K.toString(10) : K.toString(10);
        }
        o.debuglog = function(K) {
          if (K = K.toUpperCase(), !f[K]) if (r.test(K)) {
            var J = process.pid;
            f[K] = function() {
              var B = o.format.apply(o, arguments);
              console.error("%s %d: %s", K, J, B);
            };
          } else f[K] = function() {
          };
          return f[K];
        }, o.inspect = g, g.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, g.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, o.types = u(9032), o.isArray = E, o.isBoolean = R, o.isNull = k, o.isNullOrUndefined = function(K) {
          return K == null;
        }, o.isNumber = w, o.isString = F, o.isSymbol = function(K) {
          return typeof K == "symbol";
        }, o.isUndefined = I, o.isRegExp = q, o.types.isRegExp = q, o.isObject = D, o.isDate = H, o.types.isDate = H, o.isError = _, o.types.isNativeError = _, o.isFunction = T, o.isPrimitive = function(K) {
          return K === null || typeof K == "boolean" || typeof K == "number" || typeof K == "string" || typeof K == "symbol" || K === void 0;
        }, o.isBuffer = u(1135);
        var z = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function Y(K, J) {
          return Object.prototype.hasOwnProperty.call(K, J);
        }
        o.log = function() {
          var K, J;
          console.log("%s - %s", (K = /* @__PURE__ */ new Date(), J = [j(K.getHours()), j(K.getMinutes()), j(K.getSeconds())].join(":"), [K.getDate(), z[K.getMonth()], J].join(" ")), o.format.apply(o, arguments));
        }, o.inherits = u(6698), o._extend = function(K, J) {
          if (!J || !D(J)) return K;
          for (var B = Object.keys(J), Z = B.length; Z--; ) K[B[Z]] = J[B[Z]];
          return K;
        };
        var te = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
        function G(K, J) {
          if (!K) {
            var B = new Error("Promise was rejected with a falsy value");
            B.reason = K, K = B;
          }
          return J(K);
        }
        o.promisify = function(K) {
          if (typeof K != "function") throw new TypeError('The "original" argument must be of type Function');
          if (te && K[te]) {
            var J;
            if (typeof (J = K[te]) != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(J, te, { value: J, enumerable: false, writable: false, configurable: true }), J;
          }
          function J() {
            for (var B, Z, ie = new Promise(function(ce, ye) {
              B = ce, Z = ye;
            }), $ = [], oe = 0; oe < arguments.length; oe++) $.push(arguments[oe]);
            $.push(function(ce, ye) {
              ce ? Z(ce) : B(ye);
            });
            try {
              K.apply(this, $);
            } catch (ce) {
              Z(ce);
            }
            return ie;
          }
          return Object.setPrototypeOf(J, Object.getPrototypeOf(K)), te && Object.defineProperty(J, te, { value: J, enumerable: false, writable: false, configurable: true }), Object.defineProperties(J, c(K));
        }, o.promisify.custom = te, o.callbackify = function(K) {
          if (typeof K != "function") throw new TypeError('The "original" argument must be of type Function');
          function J() {
            for (var B = [], Z = 0; Z < arguments.length; Z++) B.push(arguments[Z]);
            var ie = B.pop();
            if (typeof ie != "function") throw new TypeError("The last argument must be of type Function");
            var $ = this, oe = function() {
              return ie.apply($, arguments);
            };
            K.apply(this, B).then(function(ce) {
              process.nextTick(oe.bind(null, null, ce));
            }, function(ce) {
              process.nextTick(G.bind(null, ce, oe));
            });
          }
          return Object.setPrototypeOf(J, Object.getPrototypeOf(K)), Object.defineProperties(J, c(K)), J;
        };
      }, 592: (t, o, u) => {
        var c = u(655), h = function() {
          return !!c;
        };
        h.hasArrayLengthDefineBug = function() {
          if (!c) return null;
          try {
            return c([], "length", { value: 1 }).length !== 1;
          } catch {
            return true;
          }
        }, t.exports = h;
      }, 645: (t, o) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.trimEnd = void 0, o.trimEnd = function(u, c) {
          for (var h = typeof u == "number", f = String(u); f.endsWith(c); ) f = f.slice(0, -1);
          return h ? Number(f) : f;
        };
      }, 655: (t) => {
        var o = Object.defineProperty || false;
        if (o) try {
          o({}, "a", { value: 1 });
        } catch {
          o = false;
        }
        t.exports = o;
      }, 721: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.endSponsoringFutureReserves = function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = {};
          return r.body = h.default.OperationBody.endSponsoringFutureReserves(), this.setSourceAccount(r, f), new h.default.Operation(r);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 784: (t, o, u) => {
        u.d(o, { $D: () => S, Af: () => a, WC: () => l, fG: () => b, jr: () => E, tR: () => d });
        var c = u(356), h = u(4076);
        function f(R) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, f(R);
        }
        function r(R, k) {
          var w = Object.keys(R);
          if (Object.getOwnPropertySymbols) {
            var F = Object.getOwnPropertySymbols(R);
            k && (F = F.filter(function(I) {
              return Object.getOwnPropertyDescriptor(R, I).enumerable;
            })), w.push.apply(w, F);
          }
          return w;
        }
        function m(R) {
          for (var k = 1; k < arguments.length; k++) {
            var w = arguments[k] != null ? arguments[k] : {};
            k % 2 ? r(Object(w), true).forEach(function(F) {
              g(R, F, w[F]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(R, Object.getOwnPropertyDescriptors(w)) : r(Object(w)).forEach(function(F) {
              Object.defineProperty(R, F, Object.getOwnPropertyDescriptor(w, F));
            });
          }
          return R;
        }
        function g(R, k, w) {
          return (k = function(F) {
            var I = function(q, D) {
              if (f(q) != "object" || !q) return q;
              var H = q[Symbol.toPrimitive];
              if (H !== void 0) {
                var _ = H.call(q, D);
                if (f(_) != "object") return _;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (D === "string" ? String : Number)(q);
            }(F, "string");
            return f(I) == "symbol" ? I : I + "";
          }(k)) in R ? Object.defineProperty(R, k, { value: w, enumerable: true, configurable: true, writable: true }) : R[k] = w, R;
        }
        function a(R) {
          var k = R.errorResultXdr, w = R.diagnosticEventsXdr;
          return delete R.errorResultXdr, delete R.diagnosticEventsXdr, k ? m(m(m({}, R), w !== void 0 && w.length > 0 && { diagnosticEvents: w.map(function(F) {
            return c.xdr.DiagnosticEvent.fromXDR(F, "base64");
          }) }), {}, { errorResult: c.xdr.TransactionResult.fromXDR(k, "base64") }) : m({}, R);
        }
        function l(R) {
          var k, w = c.xdr.TransactionMeta.fromXDR(R.resultMetaXdr, "base64"), F = { ledger: R.ledger, createdAt: R.createdAt, applicationOrder: R.applicationOrder, feeBump: R.feeBump, envelopeXdr: c.xdr.TransactionEnvelope.fromXDR(R.envelopeXdr, "base64"), resultXdr: c.xdr.TransactionResult.fromXDR(R.resultXdr, "base64"), resultMetaXdr: w };
          return w.switch() === 3 && w.v3().sorobanMeta() !== null && (F.returnValue = (k = w.v3().sorobanMeta()) === null || k === void 0 ? void 0 : k.returnValue()), "diagnosticEventsXdr" in R && R.diagnosticEventsXdr && (F.diagnosticEventsXdr = R.diagnosticEventsXdr.map(function(I) {
            return c.xdr.DiagnosticEvent.fromXDR(I, "base64");
          })), F;
        }
        function d(R) {
          return m({ status: R.status, txHash: R.txHash }, l(R));
        }
        function b(R) {
          var k;
          return { latestLedger: R.latestLedger, cursor: R.cursor, events: ((k = R.events) !== null && k !== void 0 ? k : []).map(function(w) {
            var F = m({}, w);
            return delete F.contractId, m(m(m({}, F), w.contractId !== "" && { contractId: new c.Contract(w.contractId) }), {}, { topic: w.topic.map(function(I) {
              return c.xdr.ScVal.fromXDR(I, "base64");
            }), value: c.xdr.ScVal.fromXDR(w.value, "base64") });
          }) };
        }
        function S(R) {
          var k;
          return { latestLedger: R.latestLedger, entries: ((k = R.entries) !== null && k !== void 0 ? k : []).map(function(w) {
            if (!w.key || !w.xdr) throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(w)));
            return m({ lastModifiedLedgerSeq: w.lastModifiedLedgerSeq, key: c.xdr.LedgerKey.fromXDR(w.key, "base64"), val: c.xdr.LedgerEntryData.fromXDR(w.xdr, "base64") }, w.liveUntilLedgerSeq !== void 0 && { liveUntilLedgerSeq: w.liveUntilLedgerSeq });
          }) };
        }
        function E(R) {
          var k, w;
          if (!h.j.isSimulationRaw(R)) return R;
          var F = { _parsed: true, id: R.id, latestLedger: R.latestLedger, events: (k = (w = R.events) === null || w === void 0 ? void 0 : w.map(function(I) {
            return c.xdr.DiagnosticEvent.fromXDR(I, "base64");
          })) !== null && k !== void 0 ? k : [] };
          return typeof R.error == "string" ? m(m({}, F), {}, { error: R.error }) : function(I, q) {
            var D, H, _, T, L, j = m(m(m({}, q), {}, { transactionData: new c.SorobanDataBuilder(I.transactionData), minResourceFee: I.minResourceFee }, (D = (H = I.results) === null || H === void 0 ? void 0 : H.length) !== null && D !== void 0 && D && { result: I.results.map(function(z) {
              var Y;
              return { auth: ((Y = z.auth) !== null && Y !== void 0 ? Y : []).map(function(te) {
                return c.xdr.SorobanAuthorizationEntry.fromXDR(te, "base64");
              }), retval: z.xdr ? c.xdr.ScVal.fromXDR(z.xdr, "base64") : c.xdr.ScVal.scvVoid() };
            })[0] }), (_ = (T = I.stateChanges) === null || T === void 0 ? void 0 : T.length) !== null && _ !== void 0 && _ && { stateChanges: (L = I.stateChanges) === null || L === void 0 ? void 0 : L.map(function(z) {
              return { type: z.type, key: c.xdr.LedgerKey.fromXDR(z.key, "base64"), before: z.before ? c.xdr.LedgerEntry.fromXDR(z.before, "base64") : null, after: z.after ? c.xdr.LedgerEntry.fromXDR(z.after, "base64") : null };
            }) });
            return I.restorePreamble && I.restorePreamble.transactionData !== "" ? m(m({}, j), {}, { restorePreamble: { minResourceFee: I.restorePreamble.minResourceFee, transactionData: new c.SorobanDataBuilder(I.restorePreamble.transactionData) } }) : j;
          }(R, F);
        }
      }, 862: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.manageSellOffer = function(r) {
          var m = {};
          if (m.selling = r.selling.toXDRObject(), m.buying = r.buying.toXDRObject(), !this.isValidAmount(r.amount, true)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (m.amount = this._toXDRAmount(r.amount), r.price === void 0) throw new TypeError("price argument is required");
          m.price = this._toXDRPrice(r.price), r.offerId !== void 0 ? r.offerId = r.offerId.toString() : r.offerId = "0", m.offerId = h.Hyper.fromString(r.offerId);
          var g = new f.default.ManageSellOfferOp(m), a = {};
          return a.body = f.default.OperationBody.manageSellOffer(g), this.setSourceAccount(a, r), new f.default.Operation(a);
        };
        var c, h = u(3740), f = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 920: (t, o, u) => {
        var c = u(9675), h = u(8859), f = u(4803), r = u(507), m = u(2271) || r || f;
        t.exports = function() {
          var g, a = { assert: function(l) {
            if (!a.has(l)) throw new c("Side channel does not contain " + h(l));
          }, delete: function(l) {
            return !!g && g.delete(l);
          }, get: function(l) {
            return g && g.get(l);
          }, has: function(l) {
            return !!g && g.has(l);
          }, set: function(l, d) {
            g || (g = m()), g.set(l, d);
          } };
          return a;
        };
      }, 1002: (t) => {
        t.exports = Function.prototype.apply;
      }, 1064: (t, o, u) => {
        var c = u(9612);
        t.exports = c.getPrototypeOf || null;
      }, 1083: (t, o, u) => {
        var c = u(1568), h = u(8835), f = t.exports;
        for (var r in c) c.hasOwnProperty(r) && (f[r] = c[r]);
        function m(g) {
          if (typeof g == "string" && (g = h.parse(g)), g.protocol || (g.protocol = "https:"), g.protocol !== "https:") throw new Error('Protocol "' + g.protocol + '" not supported. Expected "https:"');
          return g;
        }
        f.request = function(g, a) {
          return g = m(g), c.request.call(this, g, a);
        }, f.get = function(g, a) {
          return g = m(g), c.get.call(this, g, a);
        };
      }, 1135: (t) => {
        t.exports = function(o) {
          return o && typeof o == "object" && typeof o.copy == "function" && typeof o.fill == "function" && typeof o.readUInt8 == "function";
        };
      }, 1180: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Address = void 0;
        var c, h = u(7120), f = (c = u(1918)) && c.__esModule ? c : { default: c };
        function r(a) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, r(a);
        }
        function m(a, l) {
          for (var d = 0; d < l.length; d++) {
            var b = l[d];
            b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, g(b.key), b);
          }
        }
        function g(a) {
          var l = function(d, b) {
            if (r(d) != "object" || !d) return d;
            var S = d[Symbol.toPrimitive];
            if (S !== void 0) {
              var E = S.call(d, b);
              if (r(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(d);
          }(a, "string");
          return r(l) == "symbol" ? l : l + "";
        }
        o.Address = function() {
          function a(l) {
            if (function(d, b) {
              if (!(d instanceof b)) throw new TypeError("Cannot call a class as a function");
            }(this, a), h.StrKey.isValidEd25519PublicKey(l)) this._type = "account", this._key = h.StrKey.decodeEd25519PublicKey(l);
            else {
              if (!h.StrKey.isValidContract(l)) throw new Error("Unsupported address type: ".concat(l));
              this._type = "contract", this._key = h.StrKey.decodeContract(l);
            }
          }
          return function(l, d, b) {
            return d && m(l.prototype, d), b && m(l, b), Object.defineProperty(l, "prototype", { writable: false }), l;
          }(a, [{ key: "toString", value: function() {
            switch (this._type) {
              case "account":
                return h.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return h.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          } }, { key: "toScVal", value: function() {
            return f.default.ScVal.scvAddress(this.toScAddress());
          } }, { key: "toScAddress", value: function() {
            switch (this._type) {
              case "account":
                return f.default.ScAddress.scAddressTypeAccount(f.default.PublicKey.publicKeyTypeEd25519(this._key));
              case "contract":
                return f.default.ScAddress.scAddressTypeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          } }, { key: "toBuffer", value: function() {
            return this._key;
          } }], [{ key: "fromString", value: function(l) {
            return new a(l);
          } }, { key: "account", value: function(l) {
            return new a(h.StrKey.encodeEd25519PublicKey(l));
          } }, { key: "contract", value: function(l) {
            return new a(h.StrKey.encodeContract(l));
          } }, { key: "fromScVal", value: function(l) {
            return a.fromScAddress(l.address());
          } }, { key: "fromScAddress", value: function(l) {
            switch (l.switch().value) {
              case f.default.ScAddressType.scAddressTypeAccount().value:
                return a.account(l.accountId().ed25519());
              case f.default.ScAddressType.scAddressTypeContract().value:
                return a.contract(l.contractId());
              default:
                throw new Error("Unsupported address type");
            }
          } }]);
        }();
      }, 1237: (t) => {
        t.exports = EvalError;
      }, 1242: (t, o, u) => {
        var c;
        Object.defineProperty(o, "__esModule", { value: true }), o.default = void 0;
        var h = ((c = u(1594)) && c.__esModule ? c : { default: c }).default.clone();
        h.DEBUG = true, o.default = h;
      }, 1270: function(t, o, u) {
        var c;
        t = u.nmd(t), function() {
          o && o.nodeType, t && t.nodeType;
          var h = typeof u.g == "object" && u.g;
          h.global !== h && h.window !== h && h.self;
          var f, r = 2147483647, m = 36, g = /^xn--/, a = /[^\x20-\x7E]/, l = /[\x2E\u3002\uFF0E\uFF61]/g, d = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, b = Math.floor, S = String.fromCharCode;
          function E(_) {
            throw new RangeError(d[_]);
          }
          function R(_, T) {
            for (var L = _.length, j = []; L--; ) j[L] = T(_[L]);
            return j;
          }
          function k(_, T) {
            var L = _.split("@"), j = "";
            return L.length > 1 && (j = L[0] + "@", _ = L[1]), j + R((_ = _.replace(l, ".")).split("."), T).join(".");
          }
          function w(_) {
            for (var T, L, j = [], z = 0, Y = _.length; z < Y; ) (T = _.charCodeAt(z++)) >= 55296 && T <= 56319 && z < Y ? (64512 & (L = _.charCodeAt(z++))) == 56320 ? j.push(((1023 & T) << 10) + (1023 & L) + 65536) : (j.push(T), z--) : j.push(T);
            return j;
          }
          function F(_) {
            return R(_, function(T) {
              var L = "";
              return T > 65535 && (L += S((T -= 65536) >>> 10 & 1023 | 55296), T = 56320 | 1023 & T), L += S(T);
            }).join("");
          }
          function I(_, T) {
            return _ + 22 + 75 * (_ < 26) - ((T != 0) << 5);
          }
          function q(_, T, L) {
            var j = 0;
            for (_ = L ? b(_ / 700) : _ >> 1, _ += b(_ / T); _ > 455; j += m) _ = b(_ / 35);
            return b(j + 36 * _ / (_ + 38));
          }
          function D(_) {
            var T, L, j, z, Y, te, G, K, J, B, Z, ie = [], $ = _.length, oe = 0, ce = 128, ye = 72;
            for ((L = _.lastIndexOf("-")) < 0 && (L = 0), j = 0; j < L; ++j) _.charCodeAt(j) >= 128 && E("not-basic"), ie.push(_.charCodeAt(j));
            for (z = L > 0 ? L + 1 : 0; z < $; ) {
              for (Y = oe, te = 1, G = m; z >= $ && E("invalid-input"), ((K = (Z = _.charCodeAt(z++)) - 48 < 10 ? Z - 22 : Z - 65 < 26 ? Z - 65 : Z - 97 < 26 ? Z - 97 : m) >= m || K > b((r - oe) / te)) && E("overflow"), oe += K * te, !(K < (J = G <= ye ? 1 : G >= ye + 26 ? 26 : G - ye)); G += m) te > b(r / (B = m - J)) && E("overflow"), te *= B;
              ye = q(oe - Y, T = ie.length + 1, Y == 0), b(oe / T) > r - ce && E("overflow"), ce += b(oe / T), oe %= T, ie.splice(oe++, 0, ce);
            }
            return F(ie);
          }
          function H(_) {
            var T, L, j, z, Y, te, G, K, J, B, Z, ie, $, oe, ce, ye = [];
            for (ie = (_ = w(_)).length, T = 128, L = 0, Y = 72, te = 0; te < ie; ++te) (Z = _[te]) < 128 && ye.push(S(Z));
            for (j = z = ye.length, z && ye.push("-"); j < ie; ) {
              for (G = r, te = 0; te < ie; ++te) (Z = _[te]) >= T && Z < G && (G = Z);
              for (G - T > b((r - L) / ($ = j + 1)) && E("overflow"), L += (G - T) * $, T = G, te = 0; te < ie; ++te) if ((Z = _[te]) < T && ++L > r && E("overflow"), Z == T) {
                for (K = L, J = m; !(K < (B = J <= Y ? 1 : J >= Y + 26 ? 26 : J - Y)); J += m) ce = K - B, oe = m - B, ye.push(S(I(B + ce % oe, 0))), K = b(ce / oe);
                ye.push(S(I(K, 0))), Y = q(L, $, j == z), L = 0, ++j;
              }
              ++L, ++T;
            }
            return ye.join("");
          }
          f = { version: "1.4.1", ucs2: { decode: w, encode: F }, decode: D, encode: H, toASCII: function(_) {
            return k(_, function(T) {
              return a.test(T) ? "xn--" + H(T) : T;
            });
          }, toUnicode: function(_) {
            return k(_, function(T) {
              return g.test(T) ? D(T.slice(4).toLowerCase()) : T;
            });
          } }, (c = (function() {
            return f;
          }).call(o, u, o, t)) === void 0 || (t.exports = c);
        }();
      }, 1293: (t, o, u) => {
        var c = u(5546), h = u(2708);
        t.exports = { parse: function(f) {
          var r = c.parse(f.toString());
          return h.compile(r);
        } };
      }, 1333: (t) => {
        t.exports = function() {
          if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return false;
          if (typeof Symbol.iterator == "symbol") return true;
          var o = {}, u = Symbol("test"), c = Object(u);
          if (typeof u == "string" || Object.prototype.toString.call(u) !== "[object Symbol]" || Object.prototype.toString.call(c) !== "[object Symbol]") return false;
          for (var h in o[u] = 42, o) return false;
          if (typeof Object.keys == "function" && Object.keys(o).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(o).length !== 0) return false;
          var f = Object.getOwnPropertySymbols(o);
          if (f.length !== 1 || f[0] !== u || !Object.prototype.propertyIsEnumerable.call(o, u)) return false;
          if (typeof Object.getOwnPropertyDescriptor == "function") {
            var r = Object.getOwnPropertyDescriptor(o, u);
            if (r.value !== 42 || r.enumerable !== true) return false;
          }
          return true;
        };
      }, 1346: (t, o) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.verifyChecksum = function(u, c) {
          if (u.length !== c.length) return false;
          if (u.length === 0) return true;
          for (var h = 0; h < u.length; h += 1) if (u[h] !== c[h]) return false;
          return true;
        };
      }, 1387: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Claimant = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6691), r = u(7120);
        function m(l) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, m(l);
        }
        function g(l, d) {
          for (var b = 0; b < d.length; b++) {
            var S = d[b];
            S.enumerable = S.enumerable || false, S.configurable = true, "value" in S && (S.writable = true), Object.defineProperty(l, a(S.key), S);
          }
        }
        function a(l) {
          var d = function(b, S) {
            if (m(b) != "object" || !b) return b;
            var E = b[Symbol.toPrimitive];
            if (E !== void 0) {
              var R = E.call(b, S);
              if (m(R) != "object") return R;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(b);
          }(l, "string");
          return m(d) == "symbol" ? d : d + "";
        }
        o.Claimant = function() {
          return function(l, d, b) {
            return d && g(l.prototype, d), b && g(l, b), Object.defineProperty(l, "prototype", { writable: false }), l;
          }(function l(d, b) {
            if (function(S, E) {
              if (!(S instanceof E)) throw new TypeError("Cannot call a class as a function");
            }(this, l), d && !r.StrKey.isValidEd25519PublicKey(d)) throw new Error("Destination is invalid");
            if (this._destination = d, b) {
              if (!(b instanceof h.default.ClaimPredicate)) throw new Error("Predicate should be an xdr.ClaimPredicate");
              this._predicate = b;
            } else this._predicate = h.default.ClaimPredicate.claimPredicateUnconditional();
          }, [{ key: "toXDRObject", value: function() {
            var l = new h.default.ClaimantV0({ destination: f.Keypair.fromPublicKey(this._destination).xdrAccountId(), predicate: this._predicate });
            return h.default.Claimant.claimantTypeV0(l);
          } }, { key: "destination", get: function() {
            return this._destination;
          }, set: function(l) {
            throw new Error("Claimant is immutable");
          } }, { key: "predicate", get: function() {
            return this._predicate;
          }, set: function(l) {
            throw new Error("Claimant is immutable");
          } }], [{ key: "predicateUnconditional", value: function() {
            return h.default.ClaimPredicate.claimPredicateUnconditional();
          } }, { key: "predicateAnd", value: function(l, d) {
            if (!(l instanceof h.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
            if (!(d instanceof h.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return h.default.ClaimPredicate.claimPredicateAnd([l, d]);
          } }, { key: "predicateOr", value: function(l, d) {
            if (!(l instanceof h.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
            if (!(d instanceof h.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return h.default.ClaimPredicate.claimPredicateOr([l, d]);
          } }, { key: "predicateNot", value: function(l) {
            if (!(l instanceof h.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
            return h.default.ClaimPredicate.claimPredicateNot(l);
          } }, { key: "predicateBeforeAbsoluteTime", value: function(l) {
            return h.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(h.default.Int64.fromString(l));
          } }, { key: "predicateBeforeRelativeTime", value: function(l) {
            return h.default.ClaimPredicate.claimPredicateBeforeRelativeTime(h.default.Int64.fromString(l));
          } }, { key: "fromXDR", value: function(l) {
            var d;
            if (l.switch() === h.default.ClaimantType.claimantTypeV0()) return d = l.v0(), new this(r.StrKey.encodeEd25519PublicKey(d.destination().ed25519()), d.predicate());
            throw new Error("Invalid claimant type: ".concat(l.switch().name));
          } }]);
        }();
      }, 1411: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.manageData = function(r) {
          var m = {};
          if (!(typeof r.name == "string" && r.name.length <= 64)) throw new Error("name must be a string, up to 64 characters");
          if (m.dataName = r.name, typeof r.value != "string" && !c.isBuffer(r.value) && r.value !== null) throw new Error("value must be a string, Buffer or null");
          if (typeof r.value == "string" ? m.dataValue = c.from(r.value) : m.dataValue = r.value, m.dataValue !== null && m.dataValue.length > 64) throw new Error("value cannot be longer that 64 bytes");
          var g = new f.default.ManageDataOp(m), a = {};
          return a.body = f.default.OperationBody.manageData(g), this.setSourceAccount(a, r), new f.default.Operation(a);
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h };
      }, 1430: function(t, o, u) {
        var c, h;
        (function(f, r) {
          t.exports ? t.exports = r() : (h = typeof (c = r) == "function" ? c.call(o, u, o, t) : c) === void 0 || (t.exports = h);
        })(0, function(f) {
          var r = f && f.IPv6;
          return { best: function(m) {
            var g, a, l = m.toLowerCase().split(":"), d = l.length, b = 8;
            for (l[0] === "" && l[1] === "" && l[2] === "" ? (l.shift(), l.shift()) : l[0] === "" && l[1] === "" ? l.shift() : l[d - 1] === "" && l[d - 2] === "" && l.pop(), l[(d = l.length) - 1].indexOf(".") !== -1 && (b = 7), g = 0; g < d && l[g] !== ""; g++) ;
            if (g < b) for (l.splice(g, 1, "0000"); l.length < b; ) l.splice(g, 0, "0000");
            for (var S = 0; S < b; S++) {
              a = l[S].split("");
              for (var E = 0; E < 3 && a[0] === "0" && a.length > 1; E++) a.splice(0, 1);
              l[S] = a.join("");
            }
            var R = -1, k = 0, w = 0, F = -1, I = false;
            for (S = 0; S < b; S++) I ? l[S] === "0" ? w += 1 : (I = false, w > k && (R = F, k = w)) : l[S] === "0" && (I = true, F = S, w = 1);
            w > k && (R = F, k = w), k > 1 && l.splice(R, k, ""), d = l.length;
            var q = "";
            for (l[0] === "" && (q = ":"), S = 0; S < d && (q += l[S], S !== d - 1); S++) q += ":";
            return l[d - 1] === "" && (q += ":"), q;
          }, noConflict: function() {
            return f.IPv6 === this && (f.IPv6 = r), this;
          } };
        });
      }, 1514: (t) => {
        t.exports = Math.abs;
      }, 1568: (t, o, u) => {
        var c = u(5537), h = u(6917), f = u(7510), r = u(6866), m = u(8835), g = o;
        g.request = function(a, l) {
          a = typeof a == "string" ? m.parse(a) : f(a);
          var d = u.g.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", b = a.protocol || d, S = a.hostname || a.host, E = a.port, R = a.path || "/";
          S && S.indexOf(":") !== -1 && (S = "[" + S + "]"), a.url = (S ? b + "//" + S : "") + (E ? ":" + E : "") + R, a.method = (a.method || "GET").toUpperCase(), a.headers = a.headers || {};
          var k = new c(a);
          return l && k.on("response", l), k;
        }, g.get = function(a, l) {
          var d = g.request(a, l);
          return d.end(), d;
        }, g.ClientRequest = c, g.IncomingMessage = h.IncomingMessage, g.Agent = function() {
        }, g.Agent.defaultMaxSockets = 4, g.globalAgent = new g.Agent(), g.STATUS_CODES = r, g.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
      }, 1594: function(t, o, u) {
        var c;
        (function() {
          var h, f = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, r = Math.ceil, m = Math.floor, g = "[BigNumber Error] ", a = g + "Number primitive has more than 15 significant digits: ", l = 1e14, d = 14, b = 9007199254740991, S = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], E = 1e7, R = 1e9;
          function k(_) {
            var T = 0 | _;
            return _ > 0 || _ === T ? T : T - 1;
          }
          function w(_) {
            for (var T, L, j = 1, z = _.length, Y = _[0] + ""; j < z; ) {
              for (T = _[j++] + "", L = d - T.length; L--; T = "0" + T) ;
              Y += T;
            }
            for (z = Y.length; Y.charCodeAt(--z) === 48; ) ;
            return Y.slice(0, z + 1 || 1);
          }
          function F(_, T) {
            var L, j, z = _.c, Y = T.c, te = _.s, G = T.s, K = _.e, J = T.e;
            if (!te || !G) return null;
            if (L = z && !z[0], j = Y && !Y[0], L || j) return L ? j ? 0 : -G : te;
            if (te != G) return te;
            if (L = te < 0, j = K == J, !z || !Y) return j ? 0 : !z ^ L ? 1 : -1;
            if (!j) return K > J ^ L ? 1 : -1;
            for (G = (K = z.length) < (J = Y.length) ? K : J, te = 0; te < G; te++) if (z[te] != Y[te]) return z[te] > Y[te] ^ L ? 1 : -1;
            return K == J ? 0 : K > J ^ L ? 1 : -1;
          }
          function I(_, T, L, j) {
            if (_ < T || _ > L || _ !== m(_)) throw Error(g + (j || "Argument") + (typeof _ == "number" ? _ < T || _ > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(_));
          }
          function q(_) {
            var T = _.c.length - 1;
            return k(_.e / d) == T && _.c[T] % 2 != 0;
          }
          function D(_, T) {
            return (_.length > 1 ? _.charAt(0) + "." + _.slice(1) : _) + (T < 0 ? "e" : "e+") + T;
          }
          function H(_, T, L) {
            var j, z;
            if (T < 0) {
              for (z = L + "."; ++T; z += L) ;
              _ = z + _;
            } else if (++T > (j = _.length)) {
              for (z = L, T -= j; --T; z += L) ;
              _ += z;
            } else T < j && (_ = _.slice(0, T) + "." + _.slice(T));
            return _;
          }
          h = function _(T) {
            var L, j, z, Y, te, G, K, J, B, Z, ie = _e.prototype = { constructor: _e, toString: null, valueOf: null }, $ = new _e(1), oe = 20, ce = 4, ye = -7, ae = 21, ue = -1e7, ne = 1e7, ge = false, Te = 1, pe = 0, Oe = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, xe = "0123456789abcdefghijklmnopqrstuvwxyz", Ve = true;
            function _e(O, V) {
              var N, C, p, A, U, Q, se, X, de = this;
              if (!(de instanceof _e)) return new _e(O, V);
              if (V == null) {
                if (O && O._isBigNumber === true) return de.s = O.s, void (!O.c || O.e > ne ? de.c = de.e = null : O.e < ue ? de.c = [de.e = 0] : (de.e = O.e, de.c = O.c.slice()));
                if ((Q = typeof O == "number") && 0 * O == 0) {
                  if (de.s = 1 / O < 0 ? (O = -O, -1) : 1, O === ~~O) {
                    for (A = 0, U = O; U >= 10; U /= 10, A++) ;
                    return void (A > ne ? de.c = de.e = null : (de.e = A, de.c = [O]));
                  }
                  X = String(O);
                } else {
                  if (!f.test(X = String(O))) return z(de, X, Q);
                  de.s = X.charCodeAt(0) == 45 ? (X = X.slice(1), -1) : 1;
                }
                (A = X.indexOf(".")) > -1 && (X = X.replace(".", "")), (U = X.search(/e/i)) > 0 ? (A < 0 && (A = U), A += +X.slice(U + 1), X = X.substring(0, U)) : A < 0 && (A = X.length);
              } else {
                if (I(V, 2, xe.length, "Base"), V == 10 && Ve) return P(de = new _e(O), oe + de.e + 1, ce);
                if (X = String(O), Q = typeof O == "number") {
                  if (0 * O != 0) return z(de, X, Q, V);
                  if (de.s = 1 / O < 0 ? (X = X.slice(1), -1) : 1, _e.DEBUG && X.replace(/^0\.0*|\./, "").length > 15) throw Error(a + O);
                } else de.s = X.charCodeAt(0) === 45 ? (X = X.slice(1), -1) : 1;
                for (N = xe.slice(0, V), A = U = 0, se = X.length; U < se; U++) if (N.indexOf(C = X.charAt(U)) < 0) {
                  if (C == ".") {
                    if (U > A) {
                      A = se;
                      continue;
                    }
                  } else if (!p && (X == X.toUpperCase() && (X = X.toLowerCase()) || X == X.toLowerCase() && (X = X.toUpperCase()))) {
                    p = true, U = -1, A = 0;
                    continue;
                  }
                  return z(de, String(O), Q, V);
                }
                Q = false, (A = (X = j(X, V, 10, de.s)).indexOf(".")) > -1 ? X = X.replace(".", "") : A = X.length;
              }
              for (U = 0; X.charCodeAt(U) === 48; U++) ;
              for (se = X.length; X.charCodeAt(--se) === 48; ) ;
              if (X = X.slice(U, ++se)) {
                if (se -= U, Q && _e.DEBUG && se > 15 && (O > b || O !== m(O))) throw Error(a + de.s * O);
                if ((A = A - U - 1) > ne) de.c = de.e = null;
                else if (A < ue) de.c = [de.e = 0];
                else {
                  if (de.e = A, de.c = [], U = (A + 1) % d, A < 0 && (U += d), U < se) {
                    for (U && de.c.push(+X.slice(0, U)), se -= d; U < se; ) de.c.push(+X.slice(U, U += d));
                    U = d - (X = X.slice(U)).length;
                  } else U -= se;
                  for (; U--; X += "0") ;
                  de.c.push(+X);
                }
              } else de.c = [de.e = 0];
            }
            function Be(O, V, N, C) {
              var p, A, U, Q, se;
              if (N == null ? N = ce : I(N, 0, 8), !O.c) return O.toString();
              if (p = O.c[0], U = O.e, V == null) se = w(O.c), se = C == 1 || C == 2 && (U <= ye || U >= ae) ? D(se, U) : H(se, U, "0");
              else if (A = (O = P(new _e(O), V, N)).e, Q = (se = w(O.c)).length, C == 1 || C == 2 && (V <= A || A <= ye)) {
                for (; Q < V; se += "0", Q++) ;
                se = D(se, A);
              } else if (V -= U, se = H(se, A, "0"), A + 1 > Q) {
                if (--V > 0) for (se += "."; V--; se += "0") ;
              } else if ((V += A - Q) > 0) for (A + 1 == Q && (se += "."); V--; se += "0") ;
              return O.s < 0 && p ? "-" + se : se;
            }
            function Qe(O, V) {
              for (var N, C, p = 1, A = new _e(O[0]); p < O.length; p++) (!(C = new _e(O[p])).s || (N = F(A, C)) === V || N === 0 && A.s === V) && (A = C);
              return A;
            }
            function ee(O, V, N) {
              for (var C = 1, p = V.length; !V[--p]; V.pop()) ;
              for (p = V[0]; p >= 10; p /= 10, C++) ;
              return (N = C + N * d - 1) > ne ? O.c = O.e = null : N < ue ? O.c = [O.e = 0] : (O.e = N, O.c = V), O;
            }
            function P(O, V, N, C) {
              var p, A, U, Q, se, X, de, tt = O.c, Ne = S;
              if (tt) {
                e: {
                  for (p = 1, Q = tt[0]; Q >= 10; Q /= 10, p++) ;
                  if ((A = V - p) < 0) A += d, U = V, se = tt[X = 0], de = m(se / Ne[p - U - 1] % 10);
                  else if ((X = r((A + 1) / d)) >= tt.length) {
                    if (!C) break e;
                    for (; tt.length <= X; tt.push(0)) ;
                    se = de = 0, p = 1, U = (A %= d) - d + 1;
                  } else {
                    for (se = Q = tt[X], p = 1; Q >= 10; Q /= 10, p++) ;
                    de = (U = (A %= d) - d + p) < 0 ? 0 : m(se / Ne[p - U - 1] % 10);
                  }
                  if (C = C || V < 0 || tt[X + 1] != null || (U < 0 ? se : se % Ne[p - U - 1]), C = N < 4 ? (de || C) && (N == 0 || N == (O.s < 0 ? 3 : 2)) : de > 5 || de == 5 && (N == 4 || C || N == 6 && (A > 0 ? U > 0 ? se / Ne[p - U] : 0 : tt[X - 1]) % 10 & 1 || N == (O.s < 0 ? 8 : 7)), V < 1 || !tt[0]) return tt.length = 0, C ? (V -= O.e + 1, tt[0] = Ne[(d - V % d) % d], O.e = -V || 0) : tt[0] = O.e = 0, O;
                  if (A == 0 ? (tt.length = X, Q = 1, X--) : (tt.length = X + 1, Q = Ne[d - A], tt[X] = U > 0 ? m(se / Ne[p - U] % Ne[U]) * Q : 0), C) for (; ; ) {
                    if (X == 0) {
                      for (A = 1, U = tt[0]; U >= 10; U /= 10, A++) ;
                      for (U = tt[0] += Q, Q = 1; U >= 10; U /= 10, Q++) ;
                      A != Q && (O.e++, tt[0] == l && (tt[0] = 1));
                      break;
                    }
                    if (tt[X] += Q, tt[X] != l) break;
                    tt[X--] = 0, Q = 1;
                  }
                  for (A = tt.length; tt[--A] === 0; tt.pop()) ;
                }
                O.e > ne ? O.c = O.e = null : O.e < ue && (O.c = [O.e = 0]);
              }
              return O;
            }
            function x(O) {
              var V, N = O.e;
              return N === null ? O.toString() : (V = w(O.c), V = N <= ye || N >= ae ? D(V, N) : H(V, N, "0"), O.s < 0 ? "-" + V : V);
            }
            return _e.clone = _, _e.ROUND_UP = 0, _e.ROUND_DOWN = 1, _e.ROUND_CEIL = 2, _e.ROUND_FLOOR = 3, _e.ROUND_HALF_UP = 4, _e.ROUND_HALF_DOWN = 5, _e.ROUND_HALF_EVEN = 6, _e.ROUND_HALF_CEIL = 7, _e.ROUND_HALF_FLOOR = 8, _e.EUCLID = 9, _e.config = _e.set = function(O) {
              var V, N;
              if (O != null) {
                if (typeof O != "object") throw Error(g + "Object expected: " + O);
                if (O.hasOwnProperty(V = "DECIMAL_PLACES") && (I(N = O[V], 0, R, V), oe = N), O.hasOwnProperty(V = "ROUNDING_MODE") && (I(N = O[V], 0, 8, V), ce = N), O.hasOwnProperty(V = "EXPONENTIAL_AT") && ((N = O[V]) && N.pop ? (I(N[0], -1e9, 0, V), I(N[1], 0, R, V), ye = N[0], ae = N[1]) : (I(N, -1e9, R, V), ye = -(ae = N < 0 ? -N : N))), O.hasOwnProperty(V = "RANGE")) if ((N = O[V]) && N.pop) I(N[0], -1e9, -1, V), I(N[1], 1, R, V), ue = N[0], ne = N[1];
                else {
                  if (I(N, -1e9, R, V), !N) throw Error(g + V + " cannot be zero: " + N);
                  ue = -(ne = N < 0 ? -N : N);
                }
                if (O.hasOwnProperty(V = "CRYPTO")) {
                  if ((N = O[V]) !== !!N) throw Error(g + V + " not true or false: " + N);
                  if (N) {
                    if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw ge = !N, Error(g + "crypto unavailable");
                    ge = N;
                  } else ge = N;
                }
                if (O.hasOwnProperty(V = "MODULO_MODE") && (I(N = O[V], 0, 9, V), Te = N), O.hasOwnProperty(V = "POW_PRECISION") && (I(N = O[V], 0, R, V), pe = N), O.hasOwnProperty(V = "FORMAT")) {
                  if (typeof (N = O[V]) != "object") throw Error(g + V + " not an object: " + N);
                  Oe = N;
                }
                if (O.hasOwnProperty(V = "ALPHABET")) {
                  if (typeof (N = O[V]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(N)) throw Error(g + V + " invalid: " + N);
                  Ve = N.slice(0, 10) == "0123456789", xe = N;
                }
              }
              return { DECIMAL_PLACES: oe, ROUNDING_MODE: ce, EXPONENTIAL_AT: [ye, ae], RANGE: [ue, ne], CRYPTO: ge, MODULO_MODE: Te, POW_PRECISION: pe, FORMAT: Oe, ALPHABET: xe };
            }, _e.isBigNumber = function(O) {
              if (!O || O._isBigNumber !== true) return false;
              if (!_e.DEBUG) return true;
              var V, N, C = O.c, p = O.e, A = O.s;
              e: if ({}.toString.call(C) == "[object Array]") {
                if ((A === 1 || A === -1) && p >= -1e9 && p <= R && p === m(p)) {
                  if (C[0] === 0) {
                    if (p === 0 && C.length === 1) return true;
                    break e;
                  }
                  if ((V = (p + 1) % d) < 1 && (V += d), String(C[0]).length == V) {
                    for (V = 0; V < C.length; V++) if ((N = C[V]) < 0 || N >= l || N !== m(N)) break e;
                    if (N !== 0) return true;
                  }
                }
              } else if (C === null && p === null && (A === null || A === 1 || A === -1)) return true;
              throw Error(g + "Invalid BigNumber: " + O);
            }, _e.maximum = _e.max = function() {
              return Qe(arguments, -1);
            }, _e.minimum = _e.min = function() {
              return Qe(arguments, 1);
            }, _e.random = (Y = 9007199254740992, te = Math.random() * Y & 2097151 ? function() {
              return m(Math.random() * Y);
            } : function() {
              return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
            }, function(O) {
              var V, N, C, p, A, U = 0, Q = [], se = new _e($);
              if (O == null ? O = oe : I(O, 0, R), p = r(O / d), ge) if (crypto.getRandomValues) {
                for (V = crypto.getRandomValues(new Uint32Array(p *= 2)); U < p; ) (A = 131072 * V[U] + (V[U + 1] >>> 11)) >= 9e15 ? (N = crypto.getRandomValues(new Uint32Array(2)), V[U] = N[0], V[U + 1] = N[1]) : (Q.push(A % 1e14), U += 2);
                U = p / 2;
              } else {
                if (!crypto.randomBytes) throw ge = false, Error(g + "crypto unavailable");
                for (V = crypto.randomBytes(p *= 7); U < p; ) (A = 281474976710656 * (31 & V[U]) + 1099511627776 * V[U + 1] + 4294967296 * V[U + 2] + 16777216 * V[U + 3] + (V[U + 4] << 16) + (V[U + 5] << 8) + V[U + 6]) >= 9e15 ? crypto.randomBytes(7).copy(V, U) : (Q.push(A % 1e14), U += 7);
                U = p / 7;
              }
              if (!ge) for (; U < p; ) (A = te()) < 9e15 && (Q[U++] = A % 1e14);
              for (p = Q[--U], O %= d, p && O && (A = S[d - O], Q[U] = m(p / A) * A); Q[U] === 0; Q.pop(), U--) ;
              if (U < 0) Q = [C = 0];
              else {
                for (C = -1; Q[0] === 0; Q.splice(0, 1), C -= d) ;
                for (U = 1, A = Q[0]; A >= 10; A /= 10, U++) ;
                U < d && (C -= d - U);
              }
              return se.e = C, se.c = Q, se;
            }), _e.sum = function() {
              for (var O = 1, V = arguments, N = new _e(V[0]); O < V.length; ) N = N.plus(V[O++]);
              return N;
            }, j = /* @__PURE__ */ function() {
              var O = "0123456789";
              function V(N, C, p, A) {
                for (var U, Q, se = [0], X = 0, de = N.length; X < de; ) {
                  for (Q = se.length; Q--; se[Q] *= C) ;
                  for (se[0] += A.indexOf(N.charAt(X++)), U = 0; U < se.length; U++) se[U] > p - 1 && (se[U + 1] == null && (se[U + 1] = 0), se[U + 1] += se[U] / p | 0, se[U] %= p);
                }
                return se.reverse();
              }
              return function(N, C, p, A, U) {
                var Q, se, X, de, tt, Ne, ut, Ze, Et = N.indexOf("."), rr = oe, je = ce;
                for (Et >= 0 && (de = pe, pe = 0, N = N.replace(".", ""), Ne = (Ze = new _e(C)).pow(N.length - Et), pe = de, Ze.c = V(H(w(Ne.c), Ne.e, "0"), 10, p, O), Ze.e = Ze.c.length), X = de = (ut = V(N, C, p, U ? (Q = xe, O) : (Q = O, xe))).length; ut[--de] == 0; ut.pop()) ;
                if (!ut[0]) return Q.charAt(0);
                if (Et < 0 ? --X : (Ne.c = ut, Ne.e = X, Ne.s = A, ut = (Ne = L(Ne, Ze, rr, je, p)).c, tt = Ne.r, X = Ne.e), Et = ut[se = X + rr + 1], de = p / 2, tt = tt || se < 0 || ut[se + 1] != null, tt = je < 4 ? (Et != null || tt) && (je == 0 || je == (Ne.s < 0 ? 3 : 2)) : Et > de || Et == de && (je == 4 || tt || je == 6 && 1 & ut[se - 1] || je == (Ne.s < 0 ? 8 : 7)), se < 1 || !ut[0]) N = tt ? H(Q.charAt(1), -rr, Q.charAt(0)) : Q.charAt(0);
                else {
                  if (ut.length = se, tt) for (--p; ++ut[--se] > p; ) ut[se] = 0, se || (++X, ut = [1].concat(ut));
                  for (de = ut.length; !ut[--de]; ) ;
                  for (Et = 0, N = ""; Et <= de; N += Q.charAt(ut[Et++])) ;
                  N = H(N, X, Q.charAt(0));
                }
                return N;
              };
            }(), L = /* @__PURE__ */ function() {
              function O(C, p, A) {
                var U, Q, se, X, de = 0, tt = C.length, Ne = p % E, ut = p / E | 0;
                for (C = C.slice(); tt--; ) de = ((Q = Ne * (se = C[tt] % E) + (U = ut * se + (X = C[tt] / E | 0) * Ne) % E * E + de) / A | 0) + (U / E | 0) + ut * X, C[tt] = Q % A;
                return de && (C = [de].concat(C)), C;
              }
              function V(C, p, A, U) {
                var Q, se;
                if (A != U) se = A > U ? 1 : -1;
                else for (Q = se = 0; Q < A; Q++) if (C[Q] != p[Q]) {
                  se = C[Q] > p[Q] ? 1 : -1;
                  break;
                }
                return se;
              }
              function N(C, p, A, U) {
                for (var Q = 0; A--; ) C[A] -= Q, Q = C[A] < p[A] ? 1 : 0, C[A] = Q * U + C[A] - p[A];
                for (; !C[0] && C.length > 1; C.splice(0, 1)) ;
              }
              return function(C, p, A, U, Q) {
                var se, X, de, tt, Ne, ut, Ze, Et, rr, je, Ge, at, Ae, qe, Ft, Dt, wr, Nt = C.s == p.s ? 1 : -1, yr = C.c, Ur = p.c;
                if (!(yr && yr[0] && Ur && Ur[0])) return new _e(C.s && p.s && (yr ? !Ur || yr[0] != Ur[0] : Ur) ? yr && yr[0] == 0 || !Ur ? 0 * Nt : Nt / 0 : NaN);
                for (rr = (Et = new _e(Nt)).c = [], Nt = A + (X = C.e - p.e) + 1, Q || (Q = l, X = k(C.e / d) - k(p.e / d), Nt = Nt / d | 0), de = 0; Ur[de] == (yr[de] || 0); de++) ;
                if (Ur[de] > (yr[de] || 0) && X--, Nt < 0) rr.push(1), tt = true;
                else {
                  for (qe = yr.length, Dt = Ur.length, de = 0, Nt += 2, (Ne = m(Q / (Ur[0] + 1))) > 1 && (Ur = O(Ur, Ne, Q), yr = O(yr, Ne, Q), Dt = Ur.length, qe = yr.length), Ae = Dt, Ge = (je = yr.slice(0, Dt)).length; Ge < Dt; je[Ge++] = 0) ;
                  wr = Ur.slice(), wr = [0].concat(wr), Ft = Ur[0], Ur[1] >= Q / 2 && Ft++;
                  do {
                    if (Ne = 0, (se = V(Ur, je, Dt, Ge)) < 0) {
                      if (at = je[0], Dt != Ge && (at = at * Q + (je[1] || 0)), (Ne = m(at / Ft)) > 1) for (Ne >= Q && (Ne = Q - 1), Ze = (ut = O(Ur, Ne, Q)).length, Ge = je.length; V(ut, je, Ze, Ge) == 1; ) Ne--, N(ut, Dt < Ze ? wr : Ur, Ze, Q), Ze = ut.length, se = 1;
                      else Ne == 0 && (se = Ne = 1), Ze = (ut = Ur.slice()).length;
                      if (Ze < Ge && (ut = [0].concat(ut)), N(je, ut, Ge, Q), Ge = je.length, se == -1) for (; V(Ur, je, Dt, Ge) < 1; ) Ne++, N(je, Dt < Ge ? wr : Ur, Ge, Q), Ge = je.length;
                    } else se === 0 && (Ne++, je = [0]);
                    rr[de++] = Ne, je[0] ? je[Ge++] = yr[Ae] || 0 : (je = [yr[Ae]], Ge = 1);
                  } while ((Ae++ < qe || je[0] != null) && Nt--);
                  tt = je[0] != null, rr[0] || rr.splice(0, 1);
                }
                if (Q == l) {
                  for (de = 1, Nt = rr[0]; Nt >= 10; Nt /= 10, de++) ;
                  P(Et, A + (Et.e = de + X * d - 1) + 1, U, tt);
                } else Et.e = X, Et.r = +tt;
                return Et;
              };
            }(), G = /^(-?)0([xbo])(?=\w[\w.]*$)/i, K = /^([^.]+)\.$/, J = /^\.([^.]+)$/, B = /^-?(Infinity|NaN)$/, Z = /^\s*\+(?=[\w.])|^\s+|\s+$/g, z = function(O, V, N, C) {
              var p, A = N ? V : V.replace(Z, "");
              if (B.test(A)) O.s = isNaN(A) ? null : A < 0 ? -1 : 1;
              else {
                if (!N && (A = A.replace(G, function(U, Q, se) {
                  return p = (se = se.toLowerCase()) == "x" ? 16 : se == "b" ? 2 : 8, C && C != p ? U : Q;
                }), C && (p = C, A = A.replace(K, "$1").replace(J, "0.$1")), V != A)) return new _e(A, p);
                if (_e.DEBUG) throw Error(g + "Not a" + (C ? " base " + C : "") + " number: " + V);
                O.s = null;
              }
              O.c = O.e = null;
            }, ie.absoluteValue = ie.abs = function() {
              var O = new _e(this);
              return O.s < 0 && (O.s = 1), O;
            }, ie.comparedTo = function(O, V) {
              return F(this, new _e(O, V));
            }, ie.decimalPlaces = ie.dp = function(O, V) {
              var N, C, p, A = this;
              if (O != null) return I(O, 0, R), V == null ? V = ce : I(V, 0, 8), P(new _e(A), O + A.e + 1, V);
              if (!(N = A.c)) return null;
              if (C = ((p = N.length - 1) - k(this.e / d)) * d, p = N[p]) for (; p % 10 == 0; p /= 10, C--) ;
              return C < 0 && (C = 0), C;
            }, ie.dividedBy = ie.div = function(O, V) {
              return L(this, new _e(O, V), oe, ce);
            }, ie.dividedToIntegerBy = ie.idiv = function(O, V) {
              return L(this, new _e(O, V), 0, 1);
            }, ie.exponentiatedBy = ie.pow = function(O, V) {
              var N, C, p, A, U, Q, se, X, de = this;
              if ((O = new _e(O)).c && !O.isInteger()) throw Error(g + "Exponent not an integer: " + x(O));
              if (V != null && (V = new _e(V)), U = O.e > 14, !de.c || !de.c[0] || de.c[0] == 1 && !de.e && de.c.length == 1 || !O.c || !O.c[0]) return X = new _e(Math.pow(+x(de), U ? O.s * (2 - q(O)) : +x(O))), V ? X.mod(V) : X;
              if (Q = O.s < 0, V) {
                if (V.c ? !V.c[0] : !V.s) return new _e(NaN);
                (C = !Q && de.isInteger() && V.isInteger()) && (de = de.mod(V));
              } else {
                if (O.e > 9 && (de.e > 0 || de.e < -1 || (de.e == 0 ? de.c[0] > 1 || U && de.c[1] >= 24e7 : de.c[0] < 8e13 || U && de.c[0] <= 9999975e7))) return A = de.s < 0 && q(O) ? -0 : 0, de.e > -1 && (A = 1 / A), new _e(Q ? 1 / A : A);
                pe && (A = r(pe / d + 2));
              }
              for (U ? (N = new _e(0.5), Q && (O.s = 1), se = q(O)) : se = (p = Math.abs(+x(O))) % 2, X = new _e($); ; ) {
                if (se) {
                  if (!(X = X.times(de)).c) break;
                  A ? X.c.length > A && (X.c.length = A) : C && (X = X.mod(V));
                }
                if (p) {
                  if ((p = m(p / 2)) === 0) break;
                  se = p % 2;
                } else if (P(O = O.times(N), O.e + 1, 1), O.e > 14) se = q(O);
                else {
                  if ((p = +x(O)) == 0) break;
                  se = p % 2;
                }
                de = de.times(de), A ? de.c && de.c.length > A && (de.c.length = A) : C && (de = de.mod(V));
              }
              return C ? X : (Q && (X = $.div(X)), V ? X.mod(V) : A ? P(X, pe, ce, void 0) : X);
            }, ie.integerValue = function(O) {
              var V = new _e(this);
              return O == null ? O = ce : I(O, 0, 8), P(V, V.e + 1, O);
            }, ie.isEqualTo = ie.eq = function(O, V) {
              return F(this, new _e(O, V)) === 0;
            }, ie.isFinite = function() {
              return !!this.c;
            }, ie.isGreaterThan = ie.gt = function(O, V) {
              return F(this, new _e(O, V)) > 0;
            }, ie.isGreaterThanOrEqualTo = ie.gte = function(O, V) {
              return (V = F(this, new _e(O, V))) === 1 || V === 0;
            }, ie.isInteger = function() {
              return !!this.c && k(this.e / d) > this.c.length - 2;
            }, ie.isLessThan = ie.lt = function(O, V) {
              return F(this, new _e(O, V)) < 0;
            }, ie.isLessThanOrEqualTo = ie.lte = function(O, V) {
              return (V = F(this, new _e(O, V))) === -1 || V === 0;
            }, ie.isNaN = function() {
              return !this.s;
            }, ie.isNegative = function() {
              return this.s < 0;
            }, ie.isPositive = function() {
              return this.s > 0;
            }, ie.isZero = function() {
              return !!this.c && this.c[0] == 0;
            }, ie.minus = function(O, V) {
              var N, C, p, A, U = this, Q = U.s;
              if (V = (O = new _e(O, V)).s, !Q || !V) return new _e(NaN);
              if (Q != V) return O.s = -V, U.plus(O);
              var se = U.e / d, X = O.e / d, de = U.c, tt = O.c;
              if (!se || !X) {
                if (!de || !tt) return de ? (O.s = -V, O) : new _e(tt ? U : NaN);
                if (!de[0] || !tt[0]) return tt[0] ? (O.s = -V, O) : new _e(de[0] ? U : ce == 3 ? -0 : 0);
              }
              if (se = k(se), X = k(X), de = de.slice(), Q = se - X) {
                for ((A = Q < 0) ? (Q = -Q, p = de) : (X = se, p = tt), p.reverse(), V = Q; V--; p.push(0)) ;
                p.reverse();
              } else for (C = (A = (Q = de.length) < (V = tt.length)) ? Q : V, Q = V = 0; V < C; V++) if (de[V] != tt[V]) {
                A = de[V] < tt[V];
                break;
              }
              if (A && (p = de, de = tt, tt = p, O.s = -O.s), (V = (C = tt.length) - (N = de.length)) > 0) for (; V--; de[N++] = 0) ;
              for (V = l - 1; C > Q; ) {
                if (de[--C] < tt[C]) {
                  for (N = C; N && !de[--N]; de[N] = V) ;
                  --de[N], de[C] += l;
                }
                de[C] -= tt[C];
              }
              for (; de[0] == 0; de.splice(0, 1), --X) ;
              return de[0] ? ee(O, de, X) : (O.s = ce == 3 ? -1 : 1, O.c = [O.e = 0], O);
            }, ie.modulo = ie.mod = function(O, V) {
              var N, C, p = this;
              return O = new _e(O, V), !p.c || !O.s || O.c && !O.c[0] ? new _e(NaN) : !O.c || p.c && !p.c[0] ? new _e(p) : (Te == 9 ? (C = O.s, O.s = 1, N = L(p, O, 0, 3), O.s = C, N.s *= C) : N = L(p, O, 0, Te), (O = p.minus(N.times(O))).c[0] || Te != 1 || (O.s = p.s), O);
            }, ie.multipliedBy = ie.times = function(O, V) {
              var N, C, p, A, U, Q, se, X, de, tt, Ne, ut, Ze, Et, rr, je = this, Ge = je.c, at = (O = new _e(O, V)).c;
              if (!(Ge && at && Ge[0] && at[0])) return !je.s || !O.s || Ge && !Ge[0] && !at || at && !at[0] && !Ge ? O.c = O.e = O.s = null : (O.s *= je.s, Ge && at ? (O.c = [0], O.e = 0) : O.c = O.e = null), O;
              for (C = k(je.e / d) + k(O.e / d), O.s *= je.s, (se = Ge.length) < (tt = at.length) && (Ze = Ge, Ge = at, at = Ze, p = se, se = tt, tt = p), p = se + tt, Ze = []; p--; Ze.push(0)) ;
              for (Et = l, rr = E, p = tt; --p >= 0; ) {
                for (N = 0, Ne = at[p] % rr, ut = at[p] / rr | 0, A = p + (U = se); A > p; ) N = ((X = Ne * (X = Ge[--U] % rr) + (Q = ut * X + (de = Ge[U] / rr | 0) * Ne) % rr * rr + Ze[A] + N) / Et | 0) + (Q / rr | 0) + ut * de, Ze[A--] = X % Et;
                Ze[A] = N;
              }
              return N ? ++C : Ze.splice(0, 1), ee(O, Ze, C);
            }, ie.negated = function() {
              var O = new _e(this);
              return O.s = -O.s || null, O;
            }, ie.plus = function(O, V) {
              var N, C = this, p = C.s;
              if (V = (O = new _e(O, V)).s, !p || !V) return new _e(NaN);
              if (p != V) return O.s = -V, C.minus(O);
              var A = C.e / d, U = O.e / d, Q = C.c, se = O.c;
              if (!A || !U) {
                if (!Q || !se) return new _e(p / 0);
                if (!Q[0] || !se[0]) return se[0] ? O : new _e(Q[0] ? C : 0 * p);
              }
              if (A = k(A), U = k(U), Q = Q.slice(), p = A - U) {
                for (p > 0 ? (U = A, N = se) : (p = -p, N = Q), N.reverse(); p--; N.push(0)) ;
                N.reverse();
              }
              for ((p = Q.length) - (V = se.length) < 0 && (N = se, se = Q, Q = N, V = p), p = 0; V; ) p = (Q[--V] = Q[V] + se[V] + p) / l | 0, Q[V] = l === Q[V] ? 0 : Q[V] % l;
              return p && (Q = [p].concat(Q), ++U), ee(O, Q, U);
            }, ie.precision = ie.sd = function(O, V) {
              var N, C, p, A = this;
              if (O != null && O !== !!O) return I(O, 1, R), V == null ? V = ce : I(V, 0, 8), P(new _e(A), O, V);
              if (!(N = A.c)) return null;
              if (C = (p = N.length - 1) * d + 1, p = N[p]) {
                for (; p % 10 == 0; p /= 10, C--) ;
                for (p = N[0]; p >= 10; p /= 10, C++) ;
              }
              return O && A.e + 1 > C && (C = A.e + 1), C;
            }, ie.shiftedBy = function(O) {
              return I(O, -9007199254740991, b), this.times("1e" + O);
            }, ie.squareRoot = ie.sqrt = function() {
              var O, V, N, C, p, A = this, U = A.c, Q = A.s, se = A.e, X = oe + 4, de = new _e("0.5");
              if (Q !== 1 || !U || !U[0]) return new _e(!Q || Q < 0 && (!U || U[0]) ? NaN : U ? A : 1 / 0);
              if ((Q = Math.sqrt(+x(A))) == 0 || Q == 1 / 0 ? (((V = w(U)).length + se) % 2 == 0 && (V += "0"), Q = Math.sqrt(+V), se = k((se + 1) / 2) - (se < 0 || se % 2), N = new _e(V = Q == 1 / 0 ? "5e" + se : (V = Q.toExponential()).slice(0, V.indexOf("e") + 1) + se)) : N = new _e(Q + ""), N.c[0]) {
                for ((Q = (se = N.e) + X) < 3 && (Q = 0); ; ) if (p = N, N = de.times(p.plus(L(A, p, X, 1))), w(p.c).slice(0, Q) === (V = w(N.c)).slice(0, Q)) {
                  if (N.e < se && --Q, (V = V.slice(Q - 3, Q + 1)) != "9999" && (C || V != "4999")) {
                    +V && (+V.slice(1) || V.charAt(0) != "5") || (P(N, N.e + oe + 2, 1), O = !N.times(N).eq(A));
                    break;
                  }
                  if (!C && (P(p, p.e + oe + 2, 0), p.times(p).eq(A))) {
                    N = p;
                    break;
                  }
                  X += 4, Q += 4, C = 1;
                }
              }
              return P(N, N.e + oe + 1, ce, O);
            }, ie.toExponential = function(O, V) {
              return O != null && (I(O, 0, R), O++), Be(this, O, V, 1);
            }, ie.toFixed = function(O, V) {
              return O != null && (I(O, 0, R), O = O + this.e + 1), Be(this, O, V);
            }, ie.toFormat = function(O, V, N) {
              var C, p = this;
              if (N == null) O != null && V && typeof V == "object" ? (N = V, V = null) : O && typeof O == "object" ? (N = O, O = V = null) : N = Oe;
              else if (typeof N != "object") throw Error(g + "Argument not an object: " + N);
              if (C = p.toFixed(O, V), p.c) {
                var A, U = C.split("."), Q = +N.groupSize, se = +N.secondaryGroupSize, X = N.groupSeparator || "", de = U[0], tt = U[1], Ne = p.s < 0, ut = Ne ? de.slice(1) : de, Ze = ut.length;
                if (se && (A = Q, Q = se, se = A, Ze -= A), Q > 0 && Ze > 0) {
                  for (A = Ze % Q || Q, de = ut.substr(0, A); A < Ze; A += Q) de += X + ut.substr(A, Q);
                  se > 0 && (de += X + ut.slice(A)), Ne && (de = "-" + de);
                }
                C = tt ? de + (N.decimalSeparator || "") + ((se = +N.fractionGroupSize) ? tt.replace(new RegExp("\\d{" + se + "}\\B", "g"), "$&" + (N.fractionGroupSeparator || "")) : tt) : de;
              }
              return (N.prefix || "") + C + (N.suffix || "");
            }, ie.toFraction = function(O) {
              var V, N, C, p, A, U, Q, se, X, de, tt, Ne, ut = this, Ze = ut.c;
              if (O != null && (!(Q = new _e(O)).isInteger() && (Q.c || Q.s !== 1) || Q.lt($))) throw Error(g + "Argument " + (Q.isInteger() ? "out of range: " : "not an integer: ") + x(Q));
              if (!Ze) return new _e(ut);
              for (V = new _e($), X = N = new _e($), C = se = new _e($), Ne = w(Ze), A = V.e = Ne.length - ut.e - 1, V.c[0] = S[(U = A % d) < 0 ? d + U : U], O = !O || Q.comparedTo(V) > 0 ? A > 0 ? V : X : Q, U = ne, ne = 1 / 0, Q = new _e(Ne), se.c[0] = 0; de = L(Q, V, 0, 1), (p = N.plus(de.times(C))).comparedTo(O) != 1; ) N = C, C = p, X = se.plus(de.times(p = X)), se = p, V = Q.minus(de.times(p = V)), Q = p;
              return p = L(O.minus(N), C, 0, 1), se = se.plus(p.times(X)), N = N.plus(p.times(C)), se.s = X.s = ut.s, tt = L(X, C, A *= 2, ce).minus(ut).abs().comparedTo(L(se, N, A, ce).minus(ut).abs()) < 1 ? [X, C] : [se, N], ne = U, tt;
            }, ie.toNumber = function() {
              return +x(this);
            }, ie.toPrecision = function(O, V) {
              return O != null && I(O, 1, R), Be(this, O, V, 2);
            }, ie.toString = function(O) {
              var V, N = this, C = N.s, p = N.e;
              return p === null ? C ? (V = "Infinity", C < 0 && (V = "-" + V)) : V = "NaN" : (O == null ? V = p <= ye || p >= ae ? D(w(N.c), p) : H(w(N.c), p, "0") : O === 10 && Ve ? V = H(w((N = P(new _e(N), oe + p + 1, ce)).c), N.e, "0") : (I(O, 2, xe.length, "Base"), V = j(H(w(N.c), p, "0"), 10, O, C, true)), C < 0 && N.c[0] && (V = "-" + V)), V;
            }, ie.valueOf = ie.toJSON = function() {
              return x(this);
            }, ie._isBigNumber = true, T != null && _e.set(T), _e;
          }(), h.default = h.BigNumber = h, (c = (function() {
            return h;
          }).call(o, u, o, t)) === void 0 || (t.exports = c);
        })();
      }, 1731: (t, o, u) => {
        var c = u(8287).Buffer, h = u(8835).parse, f = u(7007), r = u(1083), m = u(1568), g = u(537), a = ["pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "secureProtocol", "servername", "checkServerIdentity"], l = [239, 187, 191], d = 262144, b = /^(cookie|authorization)$/i;
        function S(k, w) {
          var F = S.CONNECTING, I = w && w.headers, q = false;
          Object.defineProperty(this, "readyState", { get: function() {
            return F;
          } }), Object.defineProperty(this, "url", { get: function() {
            return k;
          } });
          var D, H = this;
          function _(J) {
            F !== S.CLOSED && (F = S.CONNECTING, G("error", new E("error", { message: J })), Y && (k = Y, Y = null, q = false), setTimeout(function() {
              F !== S.CONNECTING || H.connectionInProgress || (H.connectionInProgress = true, te());
            }, H.reconnectInterval));
          }
          H.reconnectInterval = 1e3, H.connectionInProgress = false;
          var T = "";
          I && I["Last-Event-ID"] && (T = I["Last-Event-ID"], delete I["Last-Event-ID"]);
          var L = false, j = "", z = "", Y = null;
          function te() {
            var J = h(k), B = J.protocol === "https:";
            if (J.headers = { "Cache-Control": "no-cache", Accept: "text/event-stream" }, T && (J.headers["Last-Event-ID"] = T), I) {
              var Z = q ? function(ae) {
                var ue = {};
                for (var ne in ae) b.test(ne) || (ue[ne] = ae[ne]);
                return ue;
              }(I) : I;
              for (var ie in Z) {
                var $ = Z[ie];
                $ && (J.headers[ie] = $);
              }
            }
            if (J.rejectUnauthorized = !(w && !w.rejectUnauthorized), w && w.createConnection !== void 0 && (J.createConnection = w.createConnection), w && w.proxy) {
              var oe = h(w.proxy);
              B = oe.protocol === "https:", J.protocol = B ? "https:" : "http:", J.path = k, J.headers.Host = J.host, J.hostname = oe.hostname, J.host = oe.host, J.port = oe.port;
            }
            if (w && w.https) {
              for (var ce in w.https) if (a.indexOf(ce) !== -1) {
                var ye = w.https[ce];
                ye !== void 0 && (J[ce] = ye);
              }
            }
            w && w.withCredentials !== void 0 && (J.withCredentials = w.withCredentials), D = (B ? r : m).request(J, function(ae) {
              if (H.connectionInProgress = false, ae.statusCode === 500 || ae.statusCode === 502 || ae.statusCode === 503 || ae.statusCode === 504) return G("error", new E("error", { status: ae.statusCode, message: ae.statusMessage })), void _();
              if (ae.statusCode === 301 || ae.statusCode === 302 || ae.statusCode === 307) {
                var ue = ae.headers.location;
                if (!ue) return void G("error", new E("error", { status: ae.statusCode, message: ae.statusMessage }));
                var ne = new URL(k).origin, ge = new URL(ue).origin;
                return q = ne !== ge, ae.statusCode === 307 && (Y = k), k = ue, void process.nextTick(te);
              }
              if (ae.statusCode !== 200) return G("error", new E("error", { status: ae.statusCode, message: ae.statusMessage })), H.close();
              var Te, pe;
              F = S.OPEN, ae.on("close", function() {
                ae.removeAllListeners("close"), ae.removeAllListeners("end"), _();
              }), ae.on("end", function() {
                ae.removeAllListeners("close"), ae.removeAllListeners("end"), _();
              }), G("open", new E("open"));
              var Oe = 0, xe = -1, Ve = 0, _e = 0;
              ae.on("data", function(Be) {
                Te ? (Be.length > Te.length - _e && ((Ve = 2 * Te.length + Be.length) > d && (Ve = Te.length + Be.length + d), pe = c.alloc(Ve), Te.copy(pe, 0, 0, _e), Te = pe), Be.copy(Te, _e), _e += Be.length) : (function(N) {
                  return l.every(function(C, p) {
                    return N[p] === C;
                  });
                }(Te = Be) && (Te = Te.slice(l.length)), _e = Te.length);
                for (var Qe = 0, ee = _e; Qe < ee; ) {
                  L && (Te[Qe] === 10 && ++Qe, L = false);
                  for (var P, x = -1, O = xe, V = Oe; x < 0 && V < ee; ++V) (P = Te[V]) === 58 ? O < 0 && (O = V - Qe) : P === 13 ? (L = true, x = V - Qe) : P === 10 && (x = V - Qe);
                  if (x < 0) {
                    Oe = ee - Qe, xe = O;
                    break;
                  }
                  Oe = 0, xe = -1, K(Te, Qe, O, x), Qe += x + 1;
                }
                Qe === ee ? (Te = void 0, _e = 0) : Qe > 0 && (Te = Te.slice(Qe, _e), _e = Te.length);
              });
            }), D.on("error", function(ae) {
              H.connectionInProgress = false, _(ae.message);
            }), D.setNoDelay && D.setNoDelay(true), D.end();
          }
          function G() {
            H.listeners(arguments[0]).length > 0 && H.emit.apply(H, arguments);
          }
          function K(J, B, Z, ie) {
            if (ie === 0) {
              if (j.length > 0) {
                var $ = z || "message";
                G($, new R($, { data: j.slice(0, -1), lastEventId: T, origin: new URL(k).origin })), j = "";
              }
              z = void 0;
            } else if (Z > 0) {
              var oe = Z < 0, ce = 0, ye = J.slice(B, B + (oe ? ie : Z)).toString();
              B += ce = oe ? ie : J[B + Z + 1] !== 32 ? Z + 1 : Z + 2;
              var ae = ie - ce, ue = J.slice(B, B + ae).toString();
              if (ye === "data") j += ue + `
`;
              else if (ye === "event") z = ue;
              else if (ye === "id") T = ue;
              else if (ye === "retry") {
                var ne = parseInt(ue, 10);
                Number.isNaN(ne) || (H.reconnectInterval = ne);
              }
            }
          }
          te(), this._close = function() {
            F !== S.CLOSED && (F = S.CLOSED, D.abort && D.abort(), D.xhr && D.xhr.abort && D.xhr.abort());
          };
        }
        function E(k, w) {
          if (Object.defineProperty(this, "type", { writable: false, value: k, enumerable: true }), w) for (var F in w) w.hasOwnProperty(F) && Object.defineProperty(this, F, { writable: false, value: w[F], enumerable: true });
        }
        function R(k, w) {
          for (var F in Object.defineProperty(this, "type", { writable: false, value: k, enumerable: true }), w) w.hasOwnProperty(F) && Object.defineProperty(this, F, { writable: false, value: w[F], enumerable: true });
        }
        t.exports = S, g.inherits(S, f.EventEmitter), S.prototype.constructor = S, ["open", "error", "message"].forEach(function(k) {
          Object.defineProperty(S.prototype, "on" + k, { get: function() {
            var w = this.listeners(k)[0];
            return w ? w._listener ? w._listener : w : void 0;
          }, set: function(w) {
            this.removeAllListeners(k), this.addEventListener(k, w);
          } });
        }), Object.defineProperty(S, "CONNECTING", { enumerable: true, value: 0 }), Object.defineProperty(S, "OPEN", { enumerable: true, value: 1 }), Object.defineProperty(S, "CLOSED", { enumerable: true, value: 2 }), S.prototype.CONNECTING = 0, S.prototype.OPEN = 1, S.prototype.CLOSED = 2, S.prototype.close = function() {
          this._close();
        }, S.prototype.addEventListener = function(k, w) {
          typeof w == "function" && (w._listener = w, this.on(k, w));
        }, S.prototype.dispatchEvent = function(k) {
          if (!k.type) throw new Error("UNSPECIFIED_EVENT_TYPE_ERR");
          this.emit(k.type, k.detail);
        }, S.prototype.removeEventListener = function(k, w) {
          typeof w == "function" && (w._listener = void 0, this.removeListener(k, w));
        };
      }, 1734: (t) => {
        var o = Object.prototype.toString, u = Math.max, c = function(h, f) {
          for (var r = [], m = 0; m < h.length; m += 1) r[m] = h[m];
          for (var g = 0; g < f.length; g += 1) r[g + h.length] = f[g];
          return r;
        };
        t.exports = function(h) {
          var f = this;
          if (typeof f != "function" || o.apply(f) !== "[object Function]") throw new TypeError("Function.prototype.bind called on incompatible " + f);
          for (var r, m = function(b, S) {
            for (var E = [], R = S, k = 0; R < b.length; R += 1, k += 1) E[k] = b[R];
            return E;
          }(arguments, 1), g = u(0, f.length - m.length), a = [], l = 0; l < g; l++) a[l] = "$" + l;
          if (r = Function("binder", "return function (" + function(b, S) {
            for (var E = "", R = 0; R < b.length; R += 1) E += b[R], R + 1 < b.length && (E += S);
            return E;
          }(a, ",") + "){ return binder.apply(this,arguments); }")(function() {
            if (this instanceof r) {
              var b = f.apply(this, c(m, arguments));
              return Object(b) === b ? b : this;
            }
            return f.apply(h, c(m, arguments));
          }), f.prototype) {
            var d = function() {
            };
            d.prototype = f.prototype, r.prototype = new d(), d.prototype = null;
          }
          return r;
        };
      }, 1764: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.Asset = void 0;
        var h, f = u(645), r = (h = u(1918)) && h.__esModule ? h : { default: h }, m = u(6691), g = u(7120), a = u(9152);
        function l(E) {
          return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
            return typeof R;
          } : function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
          }, l(E);
        }
        function d(E, R) {
          for (var k = 0; k < R.length; k++) {
            var w = R[k];
            w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(E, b(w.key), w);
          }
        }
        function b(E) {
          var R = function(k, w) {
            if (l(k) != "object" || !k) return k;
            var F = k[Symbol.toPrimitive];
            if (F !== void 0) {
              var I = F.call(k, w);
              if (l(I) != "object") return I;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(k);
          }(E, "string");
          return l(R) == "symbol" ? R : R + "";
        }
        o.Asset = function() {
          function E(R, k) {
            if (function(w, F) {
              if (!(w instanceof F)) throw new TypeError("Cannot call a class as a function");
            }(this, E), !/^[a-zA-Z0-9]{1,12}$/.test(R)) throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
            if (String(R).toLowerCase() !== "xlm" && !k) throw new Error("Issuer cannot be null");
            if (k && !g.StrKey.isValidEd25519PublicKey(k)) throw new Error("Issuer is invalid");
            String(R).toLowerCase() === "xlm" ? this.code = "XLM" : this.code = R, this.issuer = k;
          }
          return function(R, k, w) {
            return k && d(R.prototype, k), w && d(R, w), Object.defineProperty(R, "prototype", { writable: false }), R;
          }(E, [{ key: "toXDRObject", value: function() {
            return this._toXDRObject(r.default.Asset);
          } }, { key: "toChangeTrustXDRObject", value: function() {
            return this._toXDRObject(r.default.ChangeTrustAsset);
          } }, { key: "toTrustLineXDRObject", value: function() {
            return this._toXDRObject(r.default.TrustLineAsset);
          } }, { key: "contractId", value: function(R) {
            var k = (0, a.hash)(c.from(R)), w = r.default.HashIdPreimage.envelopeTypeContractId(new r.default.HashIdPreimageContractId({ networkId: k, contractIdPreimage: r.default.ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject()) }));
            return g.StrKey.encodeContract((0, a.hash)(w.toXDR()));
          } }, { key: "_toXDRObject", value: function() {
            var R, k, w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r.default.Asset;
            if (this.isNative()) return w.assetTypeNative();
            this.code.length <= 4 ? (R = r.default.AlphaNum4, k = "assetTypeCreditAlphanum4") : (R = r.default.AlphaNum12, k = "assetTypeCreditAlphanum12");
            var F = this.code.length <= 4 ? 4 : 12;
            return new w(k, new R({ assetCode: this.code.padEnd(F, "\0"), issuer: m.Keypair.fromPublicKey(this.issuer).xdrAccountId() }));
          } }, { key: "getCode", value: function() {
            if (this.code !== void 0) return String(this.code);
          } }, { key: "getIssuer", value: function() {
            if (this.issuer !== void 0) return String(this.issuer);
          } }, { key: "getAssetType", value: function() {
            switch (this.getRawAssetType().value) {
              case r.default.AssetType.assetTypeNative().value:
                return "native";
              case r.default.AssetType.assetTypeCreditAlphanum4().value:
                return "credit_alphanum4";
              case r.default.AssetType.assetTypeCreditAlphanum12().value:
                return "credit_alphanum12";
              default:
                return "unknown";
            }
          } }, { key: "getRawAssetType", value: function() {
            return this.isNative() ? r.default.AssetType.assetTypeNative() : this.code.length <= 4 ? r.default.AssetType.assetTypeCreditAlphanum4() : r.default.AssetType.assetTypeCreditAlphanum12();
          } }, { key: "isNative", value: function() {
            return !this.issuer;
          } }, { key: "equals", value: function(R) {
            return this.code === R.getCode() && this.issuer === R.getIssuer();
          } }, { key: "toString", value: function() {
            return this.isNative() ? "native" : "".concat(this.getCode(), ":").concat(this.getIssuer());
          } }], [{ key: "native", value: function() {
            return new E("XLM");
          } }, { key: "fromOperation", value: function(R) {
            var k, w;
            switch (R.switch()) {
              case r.default.AssetType.assetTypeNative():
                return this.native();
              case r.default.AssetType.assetTypeCreditAlphanum4():
                k = R.alphaNum4();
              case r.default.AssetType.assetTypeCreditAlphanum12():
                return k = k || R.alphaNum12(), w = g.StrKey.encodeEd25519PublicKey(k.issuer().ed25519()), new this((0, f.trimEnd)(k.assetCode(), "\0"), w);
              default:
                throw new Error("Invalid asset type: ".concat(R.switch().name));
            }
          } }, { key: "compare", value: function(R, k) {
            if (!(R && R instanceof E)) throw new Error("assetA is invalid");
            if (!(k && k instanceof E)) throw new Error("assetB is invalid");
            if (R.equals(k)) return 0;
            var w = R.getRawAssetType().value, F = k.getRawAssetType().value;
            if (w !== F) return w < F ? -1 : 1;
            var I = S(R.getCode(), k.getCode());
            return I !== 0 ? I : S(R.getIssuer(), k.getIssuer());
          } }]);
        }();
        function S(E, R) {
          return c.compare(c.from(E, "ascii"), c.from(R, "ascii"));
        }
      }, 1804: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.setTrustLineFlags = function() {
          var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = {};
          if (r(m.flags) !== "object" || Object.keys(m.flags).length === 0) throw new Error("opts.flags must be a map of boolean flags to modify");
          var a = { authorized: h.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: h.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: h.default.TrustLineFlags.trustlineClawbackEnabledFlag() }, l = 0, d = 0;
          Object.keys(m.flags).forEach(function(S) {
            if (!Object.prototype.hasOwnProperty.call(a, S)) throw new Error("unsupported flag name specified: ".concat(S));
            var E = m.flags[S], R = a[S].value;
            E === true ? d |= R : E === false && (l |= R);
          }), g.trustor = f.Keypair.fromPublicKey(m.trustor).xdrAccountId(), g.asset = m.asset.toXDRObject(), g.clearFlags = l, g.setFlags = d;
          var b = { body: h.default.OperationBody.setTrustLineFlags(new h.default.SetTrustLineFlagsOp(g)) };
          return this.setSourceAccount(b, m), new h.default.Operation(b);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6691);
        function r(m) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, r(m);
        }
      }, 1918: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.default = void 0;
        var c, h = (c = u(7938)) && c.__esModule ? c : { default: c };
        o.default = h.default;
      }, 1922: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.manageBuyOffer = function(r) {
          var m = {};
          if (m.selling = r.selling.toXDRObject(), m.buying = r.buying.toXDRObject(), !this.isValidAmount(r.buyAmount, true)) throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
          if (m.buyAmount = this._toXDRAmount(r.buyAmount), r.price === void 0) throw new TypeError("price argument is required");
          m.price = this._toXDRPrice(r.price), r.offerId !== void 0 ? r.offerId = r.offerId.toString() : r.offerId = "0", m.offerId = h.Hyper.fromString(r.offerId);
          var g = new f.default.ManageBuyOfferOp(m), a = {};
          return a.body = f.default.OperationBody.manageBuyOffer(g), this.setSourceAccount(a, r), new f.default.Operation(a);
        };
        var c, h = u(3740), f = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 1924: (t, o, u) => {
        u.r(o), u.d(o, { StellarBase: () => r, default: () => m, httpClient: () => c.ok });
        var c = u(9983), h = u(4356), f = {};
        for (const g in h) ["default", "StellarBase", "httpClient"].indexOf(g) < 0 && (f[g] = () => h[g]);
        u.d(o, f);
        var r = u(356);
        const m = (t = u.hmd(t)).exports;
      }, 2018: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.setOptions = function(a) {
          var l = {};
          if (a.inflationDest) {
            if (!m.StrKey.isValidEd25519PublicKey(a.inflationDest)) throw new Error("inflationDest is invalid");
            l.inflationDest = r.Keypair.fromPublicKey(a.inflationDest).xdrAccountId();
          }
          if (l.clearFlags = this._checkUnsignedIntValue("clearFlags", a.clearFlags), l.setFlags = this._checkUnsignedIntValue("setFlags", a.setFlags), l.masterWeight = this._checkUnsignedIntValue("masterWeight", a.masterWeight, g), l.lowThreshold = this._checkUnsignedIntValue("lowThreshold", a.lowThreshold, g), l.medThreshold = this._checkUnsignedIntValue("medThreshold", a.medThreshold, g), l.highThreshold = this._checkUnsignedIntValue("highThreshold", a.highThreshold, g), a.homeDomain !== void 0 && typeof a.homeDomain != "string") throw new TypeError("homeDomain argument must be of type String");
          if (l.homeDomain = a.homeDomain, a.signer) {
            var d, b = this._checkUnsignedIntValue("signer.weight", a.signer.weight, g), S = 0;
            if (a.signer.ed25519PublicKey) {
              if (!m.StrKey.isValidEd25519PublicKey(a.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
              var E = m.StrKey.decodeEd25519PublicKey(a.signer.ed25519PublicKey);
              d = new f.default.SignerKey.signerKeyTypeEd25519(E), S += 1;
            }
            if (a.signer.preAuthTx) {
              if (typeof a.signer.preAuthTx == "string" && (a.signer.preAuthTx = c.from(a.signer.preAuthTx, "hex")), !c.isBuffer(a.signer.preAuthTx) || a.signer.preAuthTx.length !== 32) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
              d = new f.default.SignerKey.signerKeyTypePreAuthTx(a.signer.preAuthTx), S += 1;
            }
            if (a.signer.sha256Hash) {
              if (typeof a.signer.sha256Hash == "string" && (a.signer.sha256Hash = c.from(a.signer.sha256Hash, "hex")), !c.isBuffer(a.signer.sha256Hash) || a.signer.sha256Hash.length !== 32) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
              d = new f.default.SignerKey.signerKeyTypeHashX(a.signer.sha256Hash), S += 1;
            }
            if (a.signer.ed25519SignedPayload) {
              if (!m.StrKey.isValidSignedPayload(a.signer.ed25519SignedPayload)) throw new Error("signer.ed25519SignedPayload is invalid.");
              var R = m.StrKey.decodeSignedPayload(a.signer.ed25519SignedPayload), k = f.default.SignerKeyEd25519SignedPayload.fromXDR(R);
              d = f.default.SignerKey.signerKeyTypeEd25519SignedPayload(k), S += 1;
            }
            if (S !== 1) throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
            l.signer = new f.default.Signer({ key: d, weight: b });
          }
          var w = new f.default.SetOptionsOp(l), F = {};
          return F.body = f.default.OperationBody.setOptions(w), this.setSourceAccount(F, a), new f.default.Operation(F);
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(6691), m = u(7120);
        function g(a, l) {
          if (a >= 0 && a <= 255) return true;
          throw new Error("".concat(l, " value must be between 0 and 255"));
        }
      }, 2075: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.pathPaymentStrictReceive = function(r) {
          switch (true) {
            case !r.sendAsset:
              throw new Error("Must specify a send asset");
            case !this.isValidAmount(r.sendMax):
              throw new TypeError(this.constructAmountRequirementsError("sendMax"));
            case !r.destAsset:
              throw new Error("Must provide a destAsset for a payment operation");
            case !this.isValidAmount(r.destAmount):
              throw new TypeError(this.constructAmountRequirementsError("destAmount"));
          }
          var m = {};
          m.sendAsset = r.sendAsset.toXDRObject(), m.sendMax = this._toXDRAmount(r.sendMax);
          try {
            m.destination = (0, f.decodeAddressToMuxedAccount)(r.destination);
          } catch {
            throw new Error("destination is invalid");
          }
          m.destAsset = r.destAsset.toXDRObject(), m.destAmount = this._toXDRAmount(r.destAmount);
          var g = r.path ? r.path : [];
          m.path = g.map(function(d) {
            return d.toXDRObject();
          });
          var a = new h.default.PathPaymentStrictReceiveOp(m), l = {};
          return l.body = h.default.OperationBody.pathPaymentStrictReceive(a), this.setSourceAccount(l, r), new h.default.Operation(l);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6160);
      }, 2115: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.createAccount = function(m) {
          if (!r.StrKey.isValidEd25519PublicKey(m.destination)) throw new Error("destination is invalid");
          if (!this.isValidAmount(m.startingBalance, true)) throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
          var g = {};
          g.destination = f.Keypair.fromPublicKey(m.destination).xdrAccountId(), g.startingBalance = this._toXDRAmount(m.startingBalance);
          var a = new h.default.CreateAccountOp(g), l = {};
          return l.body = h.default.OperationBody.createAccount(a), this.setSourceAccount(l, m), new h.default.Operation(l);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6691), r = u(7120);
      }, 2135: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Account = void 0;
        var c, h = (c = u(1242)) && c.__esModule ? c : { default: c }, f = u(7120);
        function r(a) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
            return typeof l;
          } : function(l) {
            return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
          }, r(a);
        }
        function m(a, l) {
          for (var d = 0; d < l.length; d++) {
            var b = l[d];
            b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, g(b.key), b);
          }
        }
        function g(a) {
          var l = function(d, b) {
            if (r(d) != "object" || !d) return d;
            var S = d[Symbol.toPrimitive];
            if (S !== void 0) {
              var E = S.call(d, b);
              if (r(E) != "object") return E;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(d);
          }(a, "string");
          return r(l) == "symbol" ? l : l + "";
        }
        o.Account = function() {
          return function(a, l, d) {
            return l && m(a.prototype, l), Object.defineProperty(a, "prototype", { writable: false }), a;
          }(function a(l, d) {
            if (function(b, S) {
              if (!(b instanceof S)) throw new TypeError("Cannot call a class as a function");
            }(this, a), f.StrKey.isValidMed25519PublicKey(l)) throw new Error("accountId is an M-address; use MuxedAccount instead");
            if (!f.StrKey.isValidEd25519PublicKey(l)) throw new Error("accountId is invalid");
            if (typeof d != "string") throw new Error("sequence must be of type string");
            this._accountId = l, this.sequence = new h.default(d);
          }, [{ key: "accountId", value: function() {
            return this._accountId;
          } }, { key: "sequenceNumber", value: function() {
            return this.sequence.toString();
          } }, { key: "incrementSequenceNumber", value: function() {
            this.sequence = this.sequence.plus(1);
          } }]);
        }();
      }, 2203: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.clawbackClaimableBalance = function() {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          (0, f.validateClaimableBalanceId)(r.balanceId);
          var m = { balanceId: h.default.ClaimableBalanceId.fromXDR(r.balanceId, "hex") }, g = { body: h.default.OperationBody.clawbackClaimableBalance(new h.default.ClawbackClaimableBalanceOp(m)) };
          return this.setSourceAccount(g, r), new h.default.Operation(g);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(7239);
      }, 2205: (t, o, u) => {
        var c = u(6743), h = u(1002), f = u(3144);
        t.exports = function() {
          return f(c, h, arguments);
        };
      }, 2243: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.MuxedAccount = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(2135), r = u(7120), m = u(6160);
        function g(d) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, g(d);
        }
        function a(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, l(E.key), E);
          }
        }
        function l(d) {
          var b = function(S, E) {
            if (g(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (g(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return g(b) == "symbol" ? b : b + "";
        }
        o.MuxedAccount = function() {
          function d(b, S) {
            (function(R, k) {
              if (!(R instanceof k)) throw new TypeError("Cannot call a class as a function");
            })(this, d);
            var E = b.accountId();
            if (!r.StrKey.isValidEd25519PublicKey(E)) throw new Error("accountId is invalid");
            this.account = b, this._muxedXdr = (0, m.encodeMuxedAccount)(E, S), this._mAddress = (0, m.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = S;
          }
          return function(b, S, E) {
            return S && a(b.prototype, S), E && a(b, E), Object.defineProperty(b, "prototype", { writable: false }), b;
          }(d, [{ key: "baseAccount", value: function() {
            return this.account;
          } }, { key: "accountId", value: function() {
            return this._mAddress;
          } }, { key: "id", value: function() {
            return this._id;
          } }, { key: "setId", value: function(b) {
            if (typeof b != "string") throw new Error("id should be a string representing a number (uint64)");
            return this._muxedXdr.med25519().id(h.default.Uint64.fromString(b)), this._mAddress = (0, m.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = b, this;
          } }, { key: "sequenceNumber", value: function() {
            return this.account.sequenceNumber();
          } }, { key: "incrementSequenceNumber", value: function() {
            return this.account.incrementSequenceNumber();
          } }, { key: "toXDRObject", value: function() {
            return this._muxedXdr;
          } }, { key: "equals", value: function(b) {
            return this.accountId() === b.accountId();
          } }], [{ key: "fromAddress", value: function(b, S) {
            var E = (0, m.decodeAddressToMuxedAccount)(b), R = (0, m.extractBaseAddress)(b), k = E.med25519().id().toString();
            return new d(new f.Account(R, S), k);
          } }]);
        }();
      }, 2262: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.LiquidityPoolAsset = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(1764), r = u(5578);
        function m(S) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          }, m(S);
        }
        function g(S, E) {
          var R = Object.keys(S);
          if (Object.getOwnPropertySymbols) {
            var k = Object.getOwnPropertySymbols(S);
            E && (k = k.filter(function(w) {
              return Object.getOwnPropertyDescriptor(S, w).enumerable;
            })), R.push.apply(R, k);
          }
          return R;
        }
        function a(S) {
          for (var E = 1; E < arguments.length; E++) {
            var R = arguments[E] != null ? arguments[E] : {};
            E % 2 ? g(Object(R), true).forEach(function(k) {
              l(S, k, R[k]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(S, Object.getOwnPropertyDescriptors(R)) : g(Object(R)).forEach(function(k) {
              Object.defineProperty(S, k, Object.getOwnPropertyDescriptor(R, k));
            });
          }
          return S;
        }
        function l(S, E, R) {
          return (E = b(E)) in S ? Object.defineProperty(S, E, { value: R, enumerable: true, configurable: true, writable: true }) : S[E] = R, S;
        }
        function d(S, E) {
          for (var R = 0; R < E.length; R++) {
            var k = E[R];
            k.enumerable = k.enumerable || false, k.configurable = true, "value" in k && (k.writable = true), Object.defineProperty(S, b(k.key), k);
          }
        }
        function b(S) {
          var E = function(R, k) {
            if (m(R) != "object" || !R) return R;
            var w = R[Symbol.toPrimitive];
            if (w !== void 0) {
              var F = w.call(R, k);
              if (m(F) != "object") return F;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(R);
          }(S, "string");
          return m(E) == "symbol" ? E : E + "";
        }
        o.LiquidityPoolAsset = function() {
          return function(S, E, R) {
            return E && d(S.prototype, E), R && d(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          }(function S(E, R, k) {
            if (function(w, F) {
              if (!(w instanceof F)) throw new TypeError("Cannot call a class as a function");
            }(this, S), !(E && E instanceof f.Asset)) throw new Error("assetA is invalid");
            if (!(R && R instanceof f.Asset)) throw new Error("assetB is invalid");
            if (f.Asset.compare(E, R) !== -1) throw new Error("Assets are not in lexicographic order");
            if (!k || k !== r.LiquidityPoolFeeV18) throw new Error("fee is invalid");
            this.assetA = E, this.assetB = R, this.fee = k;
          }, [{ key: "toXDRObject", value: function() {
            var S = new h.default.LiquidityPoolConstantProductParameters({ assetA: this.assetA.toXDRObject(), assetB: this.assetB.toXDRObject(), fee: this.fee }), E = new h.default.LiquidityPoolParameters("liquidityPoolConstantProduct", S);
            return new h.default.ChangeTrustAsset("assetTypePoolShare", E);
          } }, { key: "getLiquidityPoolParameters", value: function() {
            return a(a({}, this), {}, { assetA: this.assetA, assetB: this.assetB, fee: this.fee });
          } }, { key: "getAssetType", value: function() {
            return "liquidity_pool_shares";
          } }, { key: "equals", value: function(S) {
            return this.assetA.equals(S.assetA) && this.assetB.equals(S.assetB) && this.fee === S.fee;
          } }, { key: "toString", value: function() {
            var S = (0, r.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
            return "liquidity_pool:".concat(S);
          } }], [{ key: "fromOperation", value: function(S) {
            var E = S.switch();
            if (E === h.default.AssetType.assetTypePoolShare()) {
              var R = S.liquidityPool().constantProduct();
              return new this(f.Asset.fromOperation(R.assetA()), f.Asset.fromOperation(R.assetB()), R.fee());
            }
            throw new Error("Invalid asset type: ".concat(E.name));
          } }]);
        }();
      }, 2271: (t, o, u) => {
        var c = u(453), h = u(6556), f = u(8859), r = u(507), m = u(9675), g = c("%WeakMap%", true), a = h("WeakMap.prototype.get", true), l = h("WeakMap.prototype.set", true), d = h("WeakMap.prototype.has", true), b = h("WeakMap.prototype.delete", true);
        t.exports = g ? function() {
          var S, E, R = { assert: function(k) {
            if (!R.has(k)) throw new m("Side channel does not contain " + f(k));
          }, delete: function(k) {
            if (g && k && (typeof k == "object" || typeof k == "function")) {
              if (S) return b(S, k);
            } else if (r && E) return E.delete(k);
            return false;
          }, get: function(k) {
            return g && k && (typeof k == "object" || typeof k == "function") && S ? a(S, k) : E && E.get(k);
          }, has: function(k) {
            return g && k && (typeof k == "object" || typeof k == "function") && S ? d(S, k) : !!E && E.has(k);
          }, set: function(k, w) {
            g && k && (typeof k == "object" || typeof k == "function") ? (S || (S = new g()), l(S, k, w)) : r && (E || (E = r()), E.set(k, w));
          } };
          return R;
        } : r;
      }, 2634: () => {
      }, 2642: (t, o, u) => {
        var c = u(7720), h = Object.prototype.hasOwnProperty, f = Array.isArray, r = { allowDots: false, allowEmptyArrays: false, allowPrototypes: false, allowSparse: false, arrayLimit: 20, charset: "utf-8", charsetSentinel: false, comma: false, decodeDotInKeys: false, decoder: c.decode, delimiter: "&", depth: 5, duplicates: "combine", ignoreQueryPrefix: false, interpretNumericEntities: false, parameterLimit: 1e3, parseArrays: true, plainObjects: false, strictDepth: false, strictNullHandling: false, throwOnLimitExceeded: false }, m = function(l) {
          return l.replace(/&#(\d+);/g, function(d, b) {
            return String.fromCharCode(parseInt(b, 10));
          });
        }, g = function(l, d, b) {
          if (l && typeof l == "string" && d.comma && l.indexOf(",") > -1) return l.split(",");
          if (d.throwOnLimitExceeded && b >= d.arrayLimit) throw new RangeError("Array limit exceeded. Only " + d.arrayLimit + " element" + (d.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
          return l;
        }, a = function(l, d, b, S) {
          if (l) {
            var E = b.allowDots ? l.replace(/\.([^.[]+)/g, "[$1]") : l, R = /(\[[^[\]]*])/g, k = b.depth > 0 && /(\[[^[\]]*])/.exec(E), w = k ? E.slice(0, k.index) : E, F = [];
            if (w) {
              if (!b.plainObjects && h.call(Object.prototype, w) && !b.allowPrototypes) return;
              F.push(w);
            }
            for (var I = 0; b.depth > 0 && (k = R.exec(E)) !== null && I < b.depth; ) {
              if (I += 1, !b.plainObjects && h.call(Object.prototype, k[1].slice(1, -1)) && !b.allowPrototypes) return;
              F.push(k[1]);
            }
            if (k) {
              if (b.strictDepth === true) throw new RangeError("Input depth exceeded depth option of " + b.depth + " and strictDepth is true");
              F.push("[" + E.slice(k.index) + "]");
            }
            return function(q, D, H, _) {
              var T = 0;
              if (q.length > 0 && q[q.length - 1] === "[]") {
                var L = q.slice(0, -1).join("");
                T = Array.isArray(D) && D[L] ? D[L].length : 0;
              }
              for (var j = _ ? D : g(D, H, T), z = q.length - 1; z >= 0; --z) {
                var Y, te = q[z];
                if (te === "[]" && H.parseArrays) Y = H.allowEmptyArrays && (j === "" || H.strictNullHandling && j === null) ? [] : c.combine([], j);
                else {
                  Y = H.plainObjects ? { __proto__: null } : {};
                  var G = te.charAt(0) === "[" && te.charAt(te.length - 1) === "]" ? te.slice(1, -1) : te, K = H.decodeDotInKeys ? G.replace(/%2E/g, ".") : G, J = parseInt(K, 10);
                  H.parseArrays || K !== "" ? !isNaN(J) && te !== K && String(J) === K && J >= 0 && H.parseArrays && J <= H.arrayLimit ? (Y = [])[J] = j : K !== "__proto__" && (Y[K] = j) : Y = { 0: j };
                }
                j = Y;
              }
              return j;
            }(F, d, b, S);
          }
        };
        t.exports = function(l, d) {
          var b = function(I) {
            if (!I) return r;
            if (I.allowEmptyArrays !== void 0 && typeof I.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
            if (I.decodeDotInKeys !== void 0 && typeof I.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
            if (I.decoder !== null && I.decoder !== void 0 && typeof I.decoder != "function") throw new TypeError("Decoder has to be a function.");
            if (I.charset !== void 0 && I.charset !== "utf-8" && I.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            if (I.throwOnLimitExceeded !== void 0 && typeof I.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
            var q = I.charset === void 0 ? r.charset : I.charset, D = I.duplicates === void 0 ? r.duplicates : I.duplicates;
            if (D !== "combine" && D !== "first" && D !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
            return { allowDots: I.allowDots === void 0 ? I.decodeDotInKeys === true || r.allowDots : !!I.allowDots, allowEmptyArrays: typeof I.allowEmptyArrays == "boolean" ? !!I.allowEmptyArrays : r.allowEmptyArrays, allowPrototypes: typeof I.allowPrototypes == "boolean" ? I.allowPrototypes : r.allowPrototypes, allowSparse: typeof I.allowSparse == "boolean" ? I.allowSparse : r.allowSparse, arrayLimit: typeof I.arrayLimit == "number" ? I.arrayLimit : r.arrayLimit, charset: q, charsetSentinel: typeof I.charsetSentinel == "boolean" ? I.charsetSentinel : r.charsetSentinel, comma: typeof I.comma == "boolean" ? I.comma : r.comma, decodeDotInKeys: typeof I.decodeDotInKeys == "boolean" ? I.decodeDotInKeys : r.decodeDotInKeys, decoder: typeof I.decoder == "function" ? I.decoder : r.decoder, delimiter: typeof I.delimiter == "string" || c.isRegExp(I.delimiter) ? I.delimiter : r.delimiter, depth: typeof I.depth == "number" || I.depth === false ? +I.depth : r.depth, duplicates: D, ignoreQueryPrefix: I.ignoreQueryPrefix === true, interpretNumericEntities: typeof I.interpretNumericEntities == "boolean" ? I.interpretNumericEntities : r.interpretNumericEntities, parameterLimit: typeof I.parameterLimit == "number" ? I.parameterLimit : r.parameterLimit, parseArrays: I.parseArrays !== false, plainObjects: typeof I.plainObjects == "boolean" ? I.plainObjects : r.plainObjects, strictDepth: typeof I.strictDepth == "boolean" ? !!I.strictDepth : r.strictDepth, strictNullHandling: typeof I.strictNullHandling == "boolean" ? I.strictNullHandling : r.strictNullHandling, throwOnLimitExceeded: typeof I.throwOnLimitExceeded == "boolean" && I.throwOnLimitExceeded };
          }(d);
          if (l === "" || l == null) return b.plainObjects ? { __proto__: null } : {};
          for (var S = typeof l == "string" ? function(I, q) {
            var D = { __proto__: null }, H = q.ignoreQueryPrefix ? I.replace(/^\?/, "") : I;
            H = H.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
            var _ = q.parameterLimit === 1 / 0 ? void 0 : q.parameterLimit, T = H.split(q.delimiter, q.throwOnLimitExceeded ? _ + 1 : _);
            if (q.throwOnLimitExceeded && T.length > _) throw new RangeError("Parameter limit exceeded. Only " + _ + " parameter" + (_ === 1 ? "" : "s") + " allowed.");
            var L, j = -1, z = q.charset;
            if (q.charsetSentinel) for (L = 0; L < T.length; ++L) T[L].indexOf("utf8=") === 0 && (T[L] === "utf8=%E2%9C%93" ? z = "utf-8" : T[L] === "utf8=%26%2310003%3B" && (z = "iso-8859-1"), j = L, L = T.length);
            for (L = 0; L < T.length; ++L) if (L !== j) {
              var Y, te, G = T[L], K = G.indexOf("]="), J = K === -1 ? G.indexOf("=") : K + 1;
              J === -1 ? (Y = q.decoder(G, r.decoder, z, "key"), te = q.strictNullHandling ? null : "") : (Y = q.decoder(G.slice(0, J), r.decoder, z, "key"), te = c.maybeMap(g(G.slice(J + 1), q, f(D[Y]) ? D[Y].length : 0), function(Z) {
                return q.decoder(Z, r.decoder, z, "value");
              })), te && q.interpretNumericEntities && z === "iso-8859-1" && (te = m(String(te))), G.indexOf("[]=") > -1 && (te = f(te) ? [te] : te);
              var B = h.call(D, Y);
              B && q.duplicates === "combine" ? D[Y] = c.combine(D[Y], te) : B && q.duplicates !== "last" || (D[Y] = te);
            }
            return D;
          }(l, b) : l, E = b.plainObjects ? { __proto__: null } : {}, R = Object.keys(S), k = 0; k < R.length; ++k) {
            var w = R[k], F = a(w, S[w], b, typeof l == "string");
            E = c.merge(E, F, b);
          }
          return b.allowSparse === true ? E : c.compact(E);
        };
      }, 2682: (t, o, u) => {
        var c = u(9600), h = Object.prototype.toString, f = Object.prototype.hasOwnProperty;
        t.exports = function(r, m, g) {
          if (!c(m)) throw new TypeError("iterator must be a function");
          var a, l;
          arguments.length >= 3 && (a = g), l = r, h.call(l) === "[object Array]" ? function(d, b, S) {
            for (var E = 0, R = d.length; E < R; E++) f.call(d, E) && (S == null ? b(d[E], E, d) : b.call(S, d[E], E, d));
          }(r, m, a) : typeof r == "string" ? function(d, b, S) {
            for (var E = 0, R = d.length; E < R; E++) S == null ? b(d.charAt(E), E, d) : b.call(S, d.charAt(E), E, d);
          }(r, m, a) : function(d, b, S) {
            for (var E in d) f.call(d, E) && (S == null ? b(d[E], E, d) : b.call(S, d[E], E, d));
          }(r, m, a);
        };
      }, 2708: (t) => {
        t.exports = { compile: function(o) {
          var u = [], c = [], h = "", f = /* @__PURE__ */ Object.create(null), r = f;
          return function(k) {
            for (var w, F = 0; F < k.length; F++) switch ((w = k[F]).type) {
              case "Assign":
                g(w);
                break;
              case "ObjectPath":
                b(w);
                break;
              case "ArrayPath":
                S(w);
            }
            return f;
          }(o);
          function m(k, w, F) {
            var I = new Error(k);
            throw I.line = w, I.column = F, I;
          }
          function g(k) {
            var w, F = k.key, I = k.value, q = k.line, D = k.column;
            w = h ? h + "." + F : F, r[F] !== void 0 && m("Cannot redefine existing key '" + w + "'.", q, D), r[F] = l(I), a(w) || (u.push(w), c.push(w));
          }
          function a(k) {
            return u.indexOf(k) !== -1;
          }
          function l(k) {
            return k.type === "Array" ? function(w) {
              for (var F = null, I = 0; I < w.length; I++) {
                var q = w[I];
                F === null ? F = q.type : q.type !== F && m("Cannot add value of type " + q.type + " to array of type " + F + ".", q.line, q.column);
              }
              return w.map(l);
            }(k.value) : k.type === "InlineTable" ? d(k.value) : k.value;
          }
          function d(k) {
            for (var w = /* @__PURE__ */ Object.create(null), F = 0; F < k.length; F++) {
              var I = k[F];
              I.value.type === "InlineTable" ? w[I.key] = d(I.value.value) : I.type === "InlineTableValue" && (w[I.key] = l(I.value));
            }
            return w;
          }
          function b(k) {
            var w = k.value, F = w.map(R).join("."), I = k.line, q = k.column;
            a(F) && m("Cannot redefine existing key '" + w + "'.", I, q), u.push(F), r = E(f, w, /* @__PURE__ */ Object.create(null), I, q), h = w;
          }
          function S(k) {
            var w = k.value, F = w.map(R).join("."), I = k.line, q = k.column;
            if (a(F) || u.push(F), (u = u.filter(function(H) {
              return H.indexOf(F) !== 0;
            })).push(F), r = E(f, w, [], I, q), h = F, r instanceof Array) {
              var D = /* @__PURE__ */ Object.create(null);
              r.push(D), r = D;
            } else m("Cannot redefine existing key '" + w + "'.", I, q);
          }
          function E(k, w, F, I, q) {
            for (var D = [], H = "", _ = (w.join("."), k), T = 0; T < w.length; T++) {
              var L = w[T];
              D.push(L), H = D.join("."), _[L] === void 0 ? T === w.length - 1 ? _[L] = F : _[L] = /* @__PURE__ */ Object.create(null) : T !== w.length - 1 && c.indexOf(H) > -1 && m("Cannot redefine existing key '" + H + "'.", I, q), (_ = _[L]) instanceof Array && _.length && T < w.length - 1 && (_ = _[_.length - 1]);
            }
            return _;
          }
          function R(k) {
            return k.indexOf(".") > -1 ? '"' + k + '"' : k;
          }
        } };
      }, 2726: (t, o, u) => {
        function c(d, b) {
          var S = Object.keys(d);
          if (Object.getOwnPropertySymbols) {
            var E = Object.getOwnPropertySymbols(d);
            b && (E = E.filter(function(R) {
              return Object.getOwnPropertyDescriptor(d, R).enumerable;
            })), S.push.apply(S, E);
          }
          return S;
        }
        function h(d) {
          for (var b = 1; b < arguments.length; b++) {
            var S = arguments[b] != null ? arguments[b] : {};
            b % 2 ? c(Object(S), true).forEach(function(E) {
              f(d, E, S[E]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(S)) : c(Object(S)).forEach(function(E) {
              Object.defineProperty(d, E, Object.getOwnPropertyDescriptor(S, E));
            });
          }
          return d;
        }
        function f(d, b, S) {
          return (b = m(b)) in d ? Object.defineProperty(d, b, { value: S, enumerable: true, configurable: true, writable: true }) : d[b] = S, d;
        }
        function r(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, m(E.key), E);
          }
        }
        function m(d) {
          var b = function(S, E) {
            if (typeof S != "object" || S === null) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (typeof k != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (E === "string" ? String : Number)(S);
          }(d, "string");
          return typeof b == "symbol" ? b : String(b);
        }
        var g = u(8287).Buffer, a = u(5340).inspect, l = a && a.custom || "inspect";
        t.exports = function() {
          function d() {
            (function(E, R) {
              if (!(E instanceof R)) throw new TypeError("Cannot call a class as a function");
            })(this, d), this.head = null, this.tail = null, this.length = 0;
          }
          var b, S;
          return b = d, (S = [{ key: "push", value: function(E) {
            var R = { data: E, next: null };
            this.length > 0 ? this.tail.next = R : this.head = R, this.tail = R, ++this.length;
          } }, { key: "unshift", value: function(E) {
            var R = { data: E, next: this.head };
            this.length === 0 && (this.tail = R), this.head = R, ++this.length;
          } }, { key: "shift", value: function() {
            if (this.length !== 0) {
              var E = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, E;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(E) {
            if (this.length === 0) return "";
            for (var R = this.head, k = "" + R.data; R = R.next; ) k += E + R.data;
            return k;
          } }, { key: "concat", value: function(E) {
            if (this.length === 0) return g.alloc(0);
            for (var R, k, w, F = g.allocUnsafe(E >>> 0), I = this.head, q = 0; I; ) R = I.data, k = F, w = q, g.prototype.copy.call(R, k, w), q += I.data.length, I = I.next;
            return F;
          } }, { key: "consume", value: function(E, R) {
            var k;
            return E < this.head.data.length ? (k = this.head.data.slice(0, E), this.head.data = this.head.data.slice(E)) : k = E === this.head.data.length ? this.shift() : R ? this._getString(E) : this._getBuffer(E), k;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(E) {
            var R = this.head, k = 1, w = R.data;
            for (E -= w.length; R = R.next; ) {
              var F = R.data, I = E > F.length ? F.length : E;
              if (I === F.length ? w += F : w += F.slice(0, E), (E -= I) == 0) {
                I === F.length ? (++k, R.next ? this.head = R.next : this.head = this.tail = null) : (this.head = R, R.data = F.slice(I));
                break;
              }
              ++k;
            }
            return this.length -= k, w;
          } }, { key: "_getBuffer", value: function(E) {
            var R = g.allocUnsafe(E), k = this.head, w = 1;
            for (k.data.copy(R), E -= k.data.length; k = k.next; ) {
              var F = k.data, I = E > F.length ? F.length : E;
              if (F.copy(R, R.length - E, 0, I), (E -= I) == 0) {
                I === F.length ? (++w, k.next ? this.head = k.next : this.head = this.tail = null) : (this.head = k, k.data = F.slice(I));
                break;
              }
              ++w;
            }
            return this.length -= w, R;
          } }, { key: l, value: function(E, R) {
            return a(this, h(h({}, R), {}, { depth: 0, customInspect: false }));
          } }]) && r(b.prototype, S), Object.defineProperty(b, "prototype", { writable: false }), d;
        }();
      }, 2802: (t, o, u) => {
        var c = t.exports = function(h) {
          h = h.toLowerCase();
          var f = c[h];
          if (!f) throw new Error(h + " is not supported (we accept pull requests)");
          return new f();
        };
        c.sha = u(7816), c.sha1 = u(3737), c.sha224 = u(6710), c.sha256 = u(4107), c.sha384 = u(2827), c.sha512 = u(2890);
      }, 2810: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.changeTrust = function(l) {
          var d = {};
          if (l.asset instanceof r.Asset) d.line = l.asset.toChangeTrustXDRObject();
          else {
            if (!(l.asset instanceof m.LiquidityPoolAsset)) throw new TypeError("asset must be Asset or LiquidityPoolAsset");
            d.line = l.asset.toXDRObject();
          }
          if (l.limit !== void 0 && !this.isValidAmount(l.limit, true)) throw new TypeError(this.constructAmountRequirementsError("limit"));
          l.limit ? d.limit = this._toXDRAmount(l.limit) : d.limit = c.Hyper.fromString(new h.default(a).toString()), l.source && (d.source = l.source.masterKeypair);
          var b = new f.default.ChangeTrustOp(d), S = {};
          return S.body = f.default.OperationBody.changeTrust(b), this.setSourceAccount(S, l), new f.default.Operation(S);
        };
        var c = u(3740), h = g(u(1242)), f = g(u(1918)), r = u(1764), m = u(2262);
        function g(l) {
          return l && l.__esModule ? l : { default: l };
        }
        var a = "9223372036854775807";
      }, 2827: (t, o, u) => {
        var c = u(6698), h = u(2890), f = u(392), r = u(2861).Buffer, m = new Array(160);
        function g() {
          this.init(), this._w = m, f.call(this, 128, 112);
        }
        c(g, h), g.prototype.init = function() {
          return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
        }, g.prototype._hash = function() {
          var a = r.allocUnsafe(48);
          function l(d, b, S) {
            a.writeInt32BE(d, S), a.writeInt32BE(b, S + 4);
          }
          return l(this._ah, this._al, 0), l(this._bh, this._bl, 8), l(this._ch, this._cl, 16), l(this._dh, this._dl, 24), l(this._eh, this._el, 32), l(this._fh, this._fl, 40), a;
        }, t.exports = g;
      }, 2861: (t, o, u) => {
        var c = u(8287), h = c.Buffer;
        function f(m, g) {
          for (var a in m) g[a] = m[a];
        }
        function r(m, g, a) {
          return h(m, g, a);
        }
        h.from && h.alloc && h.allocUnsafe && h.allocUnsafeSlow ? t.exports = c : (f(c, o), o.Buffer = r), r.prototype = Object.create(h.prototype), f(h, r), r.from = function(m, g, a) {
          if (typeof m == "number") throw new TypeError("Argument must not be a number");
          return h(m, g, a);
        }, r.alloc = function(m, g, a) {
          if (typeof m != "number") throw new TypeError("Argument must be a number");
          var l = h(m);
          return g !== void 0 ? typeof a == "string" ? l.fill(g, a) : l.fill(g) : l.fill(0), l;
        }, r.allocUnsafe = function(m) {
          if (typeof m != "number") throw new TypeError("Argument must be a number");
          return h(m);
        }, r.allocUnsafeSlow = function(m) {
          if (typeof m != "number") throw new TypeError("Argument must be a number");
          return c.SlowBuffer(m);
        };
      }, 2890: (t, o, u) => {
        var c = u(6698), h = u(392), f = u(2861).Buffer, r = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], m = new Array(160);
        function g() {
          this.init(), this._w = m, h.call(this, 128, 112);
        }
        function a(F, I, q) {
          return q ^ F & (I ^ q);
        }
        function l(F, I, q) {
          return F & I | q & (F | I);
        }
        function d(F, I) {
          return (F >>> 28 | I << 4) ^ (I >>> 2 | F << 30) ^ (I >>> 7 | F << 25);
        }
        function b(F, I) {
          return (F >>> 14 | I << 18) ^ (F >>> 18 | I << 14) ^ (I >>> 9 | F << 23);
        }
        function S(F, I) {
          return (F >>> 1 | I << 31) ^ (F >>> 8 | I << 24) ^ F >>> 7;
        }
        function E(F, I) {
          return (F >>> 1 | I << 31) ^ (F >>> 8 | I << 24) ^ (F >>> 7 | I << 25);
        }
        function R(F, I) {
          return (F >>> 19 | I << 13) ^ (I >>> 29 | F << 3) ^ F >>> 6;
        }
        function k(F, I) {
          return (F >>> 19 | I << 13) ^ (I >>> 29 | F << 3) ^ (F >>> 6 | I << 26);
        }
        function w(F, I) {
          return F >>> 0 < I >>> 0 ? 1 : 0;
        }
        c(g, h), g.prototype.init = function() {
          return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
        }, g.prototype._update = function(F) {
          for (var I = this._w, q = 0 | this._ah, D = 0 | this._bh, H = 0 | this._ch, _ = 0 | this._dh, T = 0 | this._eh, L = 0 | this._fh, j = 0 | this._gh, z = 0 | this._hh, Y = 0 | this._al, te = 0 | this._bl, G = 0 | this._cl, K = 0 | this._dl, J = 0 | this._el, B = 0 | this._fl, Z = 0 | this._gl, ie = 0 | this._hl, $ = 0; $ < 32; $ += 2) I[$] = F.readInt32BE(4 * $), I[$ + 1] = F.readInt32BE(4 * $ + 4);
          for (; $ < 160; $ += 2) {
            var oe = I[$ - 30], ce = I[$ - 30 + 1], ye = S(oe, ce), ae = E(ce, oe), ue = R(oe = I[$ - 4], ce = I[$ - 4 + 1]), ne = k(ce, oe), ge = I[$ - 14], Te = I[$ - 14 + 1], pe = I[$ - 32], Oe = I[$ - 32 + 1], xe = ae + Te | 0, Ve = ye + ge + w(xe, ae) | 0;
            Ve = (Ve = Ve + ue + w(xe = xe + ne | 0, ne) | 0) + pe + w(xe = xe + Oe | 0, Oe) | 0, I[$] = Ve, I[$ + 1] = xe;
          }
          for (var _e = 0; _e < 160; _e += 2) {
            Ve = I[_e], xe = I[_e + 1];
            var Be = l(q, D, H), Qe = l(Y, te, G), ee = d(q, Y), P = d(Y, q), x = b(T, J), O = b(J, T), V = r[_e], N = r[_e + 1], C = a(T, L, j), p = a(J, B, Z), A = ie + O | 0, U = z + x + w(A, ie) | 0;
            U = (U = (U = U + C + w(A = A + p | 0, p) | 0) + V + w(A = A + N | 0, N) | 0) + Ve + w(A = A + xe | 0, xe) | 0;
            var Q = P + Qe | 0, se = ee + Be + w(Q, P) | 0;
            z = j, ie = Z, j = L, Z = B, L = T, B = J, T = _ + U + w(J = K + A | 0, K) | 0, _ = H, K = G, H = D, G = te, D = q, te = Y, q = U + se + w(Y = A + Q | 0, A) | 0;
          }
          this._al = this._al + Y | 0, this._bl = this._bl + te | 0, this._cl = this._cl + G | 0, this._dl = this._dl + K | 0, this._el = this._el + J | 0, this._fl = this._fl + B | 0, this._gl = this._gl + Z | 0, this._hl = this._hl + ie | 0, this._ah = this._ah + q + w(this._al, Y) | 0, this._bh = this._bh + D + w(this._bl, te) | 0, this._ch = this._ch + H + w(this._cl, G) | 0, this._dh = this._dh + _ + w(this._dl, K) | 0, this._eh = this._eh + T + w(this._el, J) | 0, this._fh = this._fh + L + w(this._fl, B) | 0, this._gh = this._gh + j + w(this._gl, Z) | 0, this._hh = this._hh + z + w(this._hl, ie) | 0;
        }, g.prototype._hash = function() {
          var F = f.allocUnsafe(64);
          function I(q, D, H) {
            F.writeInt32BE(q, H), F.writeInt32BE(D, H + 4);
          }
          return I(this._ah, this._al, 0), I(this._bh, this._bl, 8), I(this._ch, this._cl, 16), I(this._dh, this._dl, 24), I(this._eh, this._el, 32), I(this._fh, this._fl, 40), I(this._gh, this._gl, 48), I(this._hh, this._hl, 56), F;
        }, t.exports = g;
      }, 2894: () => {
      }, 2955: (t, o, u) => {
        var c;
        function h(F, I, q) {
          return (I = function(D) {
            var H = function(_, T) {
              if (typeof _ != "object" || _ === null) return _;
              var L = _[Symbol.toPrimitive];
              if (L !== void 0) {
                var j = L.call(_, T);
                if (typeof j != "object") return j;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (T === "string" ? String : Number)(_);
            }(D, "string");
            return typeof H == "symbol" ? H : String(H);
          }(I)) in F ? Object.defineProperty(F, I, { value: q, enumerable: true, configurable: true, writable: true }) : F[I] = q, F;
        }
        var f = u(6238), r = Symbol("lastResolve"), m = Symbol("lastReject"), g = Symbol("error"), a = Symbol("ended"), l = Symbol("lastPromise"), d = Symbol("handlePromise"), b = Symbol("stream");
        function S(F, I) {
          return { value: F, done: I };
        }
        function E(F) {
          var I = F[r];
          if (I !== null) {
            var q = F[b].read();
            q !== null && (F[l] = null, F[r] = null, F[m] = null, I(S(q, false)));
          }
        }
        function R(F) {
          process.nextTick(E, F);
        }
        var k = Object.getPrototypeOf(function() {
        }), w = Object.setPrototypeOf((h(c = { get stream() {
          return this[b];
        }, next: function() {
          var F = this, I = this[g];
          if (I !== null) return Promise.reject(I);
          if (this[a]) return Promise.resolve(S(void 0, true));
          if (this[b].destroyed) return new Promise(function(_, T) {
            process.nextTick(function() {
              F[g] ? T(F[g]) : _(S(void 0, true));
            });
          });
          var q, D = this[l];
          if (D) q = new Promise(/* @__PURE__ */ function(_, T) {
            return function(L, j) {
              _.then(function() {
                T[a] ? L(S(void 0, true)) : T[d](L, j);
              }, j);
            };
          }(D, this));
          else {
            var H = this[b].read();
            if (H !== null) return Promise.resolve(S(H, false));
            q = new Promise(this[d]);
          }
          return this[l] = q, q;
        } }, Symbol.asyncIterator, function() {
          return this;
        }), h(c, "return", function() {
          var F = this;
          return new Promise(function(I, q) {
            F[b].destroy(null, function(D) {
              D ? q(D) : I(S(void 0, true));
            });
          });
        }), c), k);
        t.exports = function(F) {
          var I, q = Object.create(w, (h(I = {}, b, { value: F, writable: true }), h(I, r, { value: null, writable: true }), h(I, m, { value: null, writable: true }), h(I, g, { value: null, writable: true }), h(I, a, { value: F._readableState.endEmitted, writable: true }), h(I, d, { value: function(D, H) {
            var _ = q[b].read();
            _ ? (q[l] = null, q[r] = null, q[m] = null, D(S(_, false))) : (q[r] = D, q[m] = H);
          }, writable: true }), I));
          return q[l] = null, f(F, function(D) {
            if (D && D.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var H = q[m];
              return H !== null && (q[l] = null, q[r] = null, q[m] = null, H(D)), void (q[g] = D);
            }
            var _ = q[r];
            _ !== null && (q[l] = null, q[r] = null, q[m] = null, _(S(void 0, true))), q[a] = true;
          }), F.on("readable", R.bind(null, q)), q;
        };
      }, 3093: (t, o, u) => {
        var c = u(4459);
        t.exports = function(h) {
          return c(h) || h === 0 ? h : h < 0 ? -1 : 1;
        };
      }, 3121: (t, o, u) => {
        function c(l) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, c(l);
        }
        function h(l, d) {
          for (var b = 0; b < d.length; b++) {
            var S = d[b];
            S.enumerable = S.enumerable || false, S.configurable = true, "value" in S && (S.writable = true), Object.defineProperty(l, f(S.key), S);
          }
        }
        function f(l) {
          var d = function(b, S) {
            if (c(b) != "object" || !b) return b;
            var E = b[Symbol.toPrimitive];
            if (E !== void 0) {
              var R = E.call(b, S);
              if (c(R) != "object") return R;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(b);
          }(l, "string");
          return c(d) == "symbol" ? d : d + "";
        }
        u.d(o, { A: () => a });
        var r, m, g, a = (r = function l() {
          (function(d, b) {
            if (!(d instanceof b)) throw new TypeError("Cannot call a class as a function");
          })(this, l);
        }, g = [{ key: "validateTimebounds", value: function(l) {
          var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!l.timeBounds) return false;
          var b = Math.floor(Date.now() / 1e3), S = l.timeBounds, E = S.minTime, R = S.maxTime;
          return b >= Number.parseInt(E, 10) - d && b <= Number.parseInt(R, 10) + d;
        } }, { key: "sleep", value: function(l) {
          return new Promise(function(d) {
            return setTimeout(d, l);
          });
        } }], (m = null) && h(r.prototype, m), g && h(r, g), Object.defineProperty(r, "prototype", { writable: false }), r);
      }, 3126: (t, o, u) => {
        var c = u(6743), h = u(9675), f = u(76), r = u(3144);
        t.exports = function(m) {
          if (m.length < 1 || typeof m[0] != "function") throw new h("a function is required");
          return r(c, f, m);
        };
      }, 3141: (t, o, u) => {
        var c = u(2861).Buffer, h = c.isEncoding || function(E) {
          switch ((E = "" + E) && E.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function f(E) {
          var R;
          switch (this.encoding = function(k) {
            var w = function(F) {
              if (!F) return "utf8";
              for (var I; ; ) switch (F) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return F;
                default:
                  if (I) return;
                  F = ("" + F).toLowerCase(), I = true;
              }
            }(k);
            if (typeof w != "string" && (c.isEncoding === h || !h(k))) throw new Error("Unknown encoding: " + k);
            return w || k;
          }(E), this.encoding) {
            case "utf16le":
              this.text = g, this.end = a, R = 4;
              break;
            case "utf8":
              this.fillLast = m, R = 4;
              break;
            case "base64":
              this.text = l, this.end = d, R = 3;
              break;
            default:
              return this.write = b, void (this.end = S);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = c.allocUnsafe(R);
        }
        function r(E) {
          return E <= 127 ? 0 : E >> 5 == 6 ? 2 : E >> 4 == 14 ? 3 : E >> 3 == 30 ? 4 : E >> 6 == 2 ? -1 : -2;
        }
        function m(E) {
          var R = this.lastTotal - this.lastNeed, k = function(w, F) {
            if ((192 & F[0]) != 128) return w.lastNeed = 0, "\uFFFD";
            if (w.lastNeed > 1 && F.length > 1) {
              if ((192 & F[1]) != 128) return w.lastNeed = 1, "\uFFFD";
              if (w.lastNeed > 2 && F.length > 2 && (192 & F[2]) != 128) return w.lastNeed = 2, "\uFFFD";
            }
          }(this, E);
          return k !== void 0 ? k : this.lastNeed <= E.length ? (E.copy(this.lastChar, R, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (E.copy(this.lastChar, R, 0, E.length), void (this.lastNeed -= E.length));
        }
        function g(E, R) {
          if ((E.length - R) % 2 == 0) {
            var k = E.toString("utf16le", R);
            if (k) {
              var w = k.charCodeAt(k.length - 1);
              if (w >= 55296 && w <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1], k.slice(0, -1);
            }
            return k;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = E[E.length - 1], E.toString("utf16le", R, E.length - 1);
        }
        function a(E) {
          var R = E && E.length ? this.write(E) : "";
          if (this.lastNeed) {
            var k = this.lastTotal - this.lastNeed;
            return R + this.lastChar.toString("utf16le", 0, k);
          }
          return R;
        }
        function l(E, R) {
          var k = (E.length - R) % 3;
          return k === 0 ? E.toString("base64", R) : (this.lastNeed = 3 - k, this.lastTotal = 3, k === 1 ? this.lastChar[0] = E[E.length - 1] : (this.lastChar[0] = E[E.length - 2], this.lastChar[1] = E[E.length - 1]), E.toString("base64", R, E.length - k));
        }
        function d(E) {
          var R = E && E.length ? this.write(E) : "";
          return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R;
        }
        function b(E) {
          return E.toString(this.encoding);
        }
        function S(E) {
          return E && E.length ? this.write(E) : "";
        }
        o.I = f, f.prototype.write = function(E) {
          if (E.length === 0) return "";
          var R, k;
          if (this.lastNeed) {
            if ((R = this.fillLast(E)) === void 0) return "";
            k = this.lastNeed, this.lastNeed = 0;
          } else k = 0;
          return k < E.length ? R ? R + this.text(E, k) : this.text(E, k) : R || "";
        }, f.prototype.end = function(E) {
          var R = E && E.length ? this.write(E) : "";
          return this.lastNeed ? R + "\uFFFD" : R;
        }, f.prototype.text = function(E, R) {
          var k = function(F, I, q) {
            var D = I.length - 1;
            if (D < q) return 0;
            var H = r(I[D]);
            return H >= 0 ? (H > 0 && (F.lastNeed = H - 1), H) : --D < q || H === -2 ? 0 : (H = r(I[D]), H >= 0 ? (H > 0 && (F.lastNeed = H - 2), H) : --D < q || H === -2 ? 0 : (H = r(I[D]), H >= 0 ? (H > 0 && (H === 2 ? H = 0 : F.lastNeed = H - 3), H) : 0));
          }(this, E, R);
          if (!this.lastNeed) return E.toString("utf8", R);
          this.lastTotal = k;
          var w = E.length - (k - this.lastNeed);
          return E.copy(this.lastChar, 0, w), E.toString("utf8", R, w);
        }, f.prototype.fillLast = function(E) {
          if (this.lastNeed <= E.length) return E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          E.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, E.length), this.lastNeed -= E.length;
        };
      }, 3144: (t, o, u) => {
        var c = u(6743), h = u(1002), f = u(76), r = u(7119);
        t.exports = r || c.call(f, h);
      }, 3209: (t, o, u) => {
        var c = 65536, h = 4294967295, f = u(2861).Buffer, r = u.g.crypto || u.g.msCrypto;
        r && r.getRandomValues ? t.exports = function(m, g) {
          if (m > h) throw new RangeError("requested too many random bytes");
          var a = f.allocUnsafe(m);
          if (m > 0) if (m > c) for (var l = 0; l < m; l += c) r.getRandomValues(a.slice(l, l + c));
          else r.getRandomValues(a);
          return typeof g == "function" ? process.nextTick(function() {
            g(null, a);
          }) : a;
        } : t.exports = function() {
          throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
        };
      }, 3317: (t, o, u) => {
        function c(d) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, c(d);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.ScInt = void 0;
        var h = u(7429);
        function f(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, r(E.key), E);
          }
        }
        function r(d) {
          var b = function(S, E) {
            if (c(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (c(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return c(b) == "symbol" ? b : b + "";
        }
        function m(d, b, S) {
          return b = a(b), function(E, R) {
            if (R && (c(R) == "object" || typeof R == "function")) return R;
            if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(k) {
              if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return k;
            }(E);
          }(d, g() ? Reflect.construct(b, S || [], a(d).constructor) : b.apply(d, S));
        }
        function g() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!d;
          })();
        }
        function a(d) {
          return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, a(d);
        }
        function l(d, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, E) {
            return S.__proto__ = E, S;
          }, l(d, b);
        }
        o.ScInt = function(d) {
          function b(k, w) {
            var F;
            (function(H, _) {
              if (!(H instanceof _)) throw new TypeError("Cannot call a class as a function");
            })(this, b);
            var I = k < 0, q = (F = w == null ? void 0 : w.type) !== null && F !== void 0 ? F : "";
            if (q.startsWith("u") && I) throw TypeError("specified type ".concat(w.type, " yet negative (").concat(k, ")"));
            if (q === "") {
              q = I ? "i" : "u";
              var D = function(H) {
                var _, T = H.toString(2).length;
                return (_ = [64, 128, 256].find(function(L) {
                  return T <= L;
                })) !== null && _ !== void 0 ? _ : T;
              }(k);
              switch (D) {
                case 64:
                case 128:
                case 256:
                  q += D.toString();
                  break;
                default:
                  throw RangeError("expected 64/128/256 bits for input (".concat(k, "), got ").concat(D));
              }
            }
            return m(this, b, [q, k]);
          }
          return function(k, w) {
            if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
            k.prototype = Object.create(w && w.prototype, { constructor: { value: k, writable: true, configurable: true } }), Object.defineProperty(k, "prototype", { writable: false }), w && l(k, w);
          }(b, d), S = b, E && f(S.prototype, E), R && f(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }(h.XdrLargeInt);
      }, 3335: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.default = void 0;
        var c = u(3740), h = { XdrWriter: c.XdrWriter, XdrReader: c.XdrReader };
        o.default = h;
      }, 3496: (t, o, u) => {
        u.r(o), u.d(o, { Api: () => c.j, AxiosClient: () => m, BasicSleepStrategy: () => z, Durability: () => j, LinearSleepStrategy: () => Y, Server: () => N, assembleTransaction: () => S.X, default: () => C, parseRawEvents: () => E.fG, parseRawSimulation: () => E.jr });
        var c = u(4076), h = u(4193), f = u.n(h), r = u(356);
        const m = (0, u(9983).vt)({ headers: { "X-Client-Name": "js-soroban-client", "X-Client-Version": "13.2.0" } });
        function g(p) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
            return typeof A;
          } : function(A) {
            return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
          }, g(p);
        }
        function a() {
          a = function() {
            return A;
          };
          var p, A = {}, U = Object.prototype, Q = U.hasOwnProperty, se = Object.defineProperty || function(st, ct, yt) {
            st[ct] = yt.value;
          }, X = typeof Symbol == "function" ? Symbol : {}, de = X.iterator || "@@iterator", tt = X.asyncIterator || "@@asyncIterator", Ne = X.toStringTag || "@@toStringTag";
          function ut(st, ct, yt) {
            return Object.defineProperty(st, ct, { value: yt, enumerable: true, configurable: true, writable: true }), st[ct];
          }
          try {
            ut({}, "");
          } catch {
            ut = function(ct, yt, Zt) {
              return ct[yt] = Zt;
            };
          }
          function Ze(st, ct, yt, Zt) {
            var Ct = ct && ct.prototype instanceof qe ? ct : qe, Lt = Object.create(Ct.prototype), Wt = new ft(Zt || []);
            return se(Lt, "_invoke", { value: le(st, yt, Wt) }), Lt;
          }
          function Et(st, ct, yt) {
            try {
              return { type: "normal", arg: st.call(ct, yt) };
            } catch (Zt) {
              return { type: "throw", arg: Zt };
            }
          }
          A.wrap = Ze;
          var rr = "suspendedStart", je = "suspendedYield", Ge = "executing", at = "completed", Ae = {};
          function qe() {
          }
          function Ft() {
          }
          function Dt() {
          }
          var wr = {};
          ut(wr, de, function() {
            return this;
          });
          var Nt = Object.getPrototypeOf, yr = Nt && Nt(Nt(zt([])));
          yr && yr !== U && Q.call(yr, de) && (wr = yr);
          var Ur = Dt.prototype = qe.prototype = Object.create(wr);
          function Pe(st) {
            ["next", "throw", "return"].forEach(function(ct) {
              ut(st, ct, function(yt) {
                return this._invoke(ct, yt);
              });
            });
          }
          function $e(st, ct) {
            function yt(Ct, Lt, Wt, vr) {
              var ar = Et(st[Ct], st, Lt);
              if (ar.type !== "throw") {
                var sr = ar.arg, gr = sr.value;
                return gr && g(gr) == "object" && Q.call(gr, "__await") ? ct.resolve(gr.__await).then(function(Tr) {
                  yt("next", Tr, Wt, vr);
                }, function(Tr) {
                  yt("throw", Tr, Wt, vr);
                }) : ct.resolve(gr).then(function(Tr) {
                  sr.value = Tr, Wt(sr);
                }, function(Tr) {
                  return yt("throw", Tr, Wt, vr);
                });
              }
              vr(ar.arg);
            }
            var Zt;
            se(this, "_invoke", { value: function(Ct, Lt) {
              function Wt() {
                return new ct(function(vr, ar) {
                  yt(Ct, Lt, vr, ar);
                });
              }
              return Zt = Zt ? Zt.then(Wt, Wt) : Wt();
            } });
          }
          function le(st, ct, yt) {
            var Zt = rr;
            return function(Ct, Lt) {
              if (Zt === Ge) throw Error("Generator is already running");
              if (Zt === at) {
                if (Ct === "throw") throw Lt;
                return { value: p, done: true };
              }
              for (yt.method = Ct, yt.arg = Lt; ; ) {
                var Wt = yt.delegate;
                if (Wt) {
                  var vr = re(Wt, yt);
                  if (vr) {
                    if (vr === Ae) continue;
                    return vr;
                  }
                }
                if (yt.method === "next") yt.sent = yt._sent = yt.arg;
                else if (yt.method === "throw") {
                  if (Zt === rr) throw Zt = at, yt.arg;
                  yt.dispatchException(yt.arg);
                } else yt.method === "return" && yt.abrupt("return", yt.arg);
                Zt = Ge;
                var ar = Et(st, ct, yt);
                if (ar.type === "normal") {
                  if (Zt = yt.done ? at : je, ar.arg === Ae) continue;
                  return { value: ar.arg, done: yt.done };
                }
                ar.type === "throw" && (Zt = at, yt.method = "throw", yt.arg = ar.arg);
              }
            };
          }
          function re(st, ct) {
            var yt = ct.method, Zt = st.iterator[yt];
            if (Zt === p) return ct.delegate = null, yt === "throw" && st.iterator.return && (ct.method = "return", ct.arg = p, re(st, ct), ct.method === "throw") || yt !== "return" && (ct.method = "throw", ct.arg = new TypeError("The iterator does not provide a '" + yt + "' method")), Ae;
            var Ct = Et(Zt, st.iterator, ct.arg);
            if (Ct.type === "throw") return ct.method = "throw", ct.arg = Ct.arg, ct.delegate = null, Ae;
            var Lt = Ct.arg;
            return Lt ? Lt.done ? (ct[st.resultName] = Lt.value, ct.next = st.nextLoc, ct.method !== "return" && (ct.method = "next", ct.arg = p), ct.delegate = null, Ae) : Lt : (ct.method = "throw", ct.arg = new TypeError("iterator result is not an object"), ct.delegate = null, Ae);
          }
          function Le(st) {
            var ct = { tryLoc: st[0] };
            1 in st && (ct.catchLoc = st[1]), 2 in st && (ct.finallyLoc = st[2], ct.afterLoc = st[3]), this.tryEntries.push(ct);
          }
          function nt(st) {
            var ct = st.completion || {};
            ct.type = "normal", delete ct.arg, st.completion = ct;
          }
          function ft(st) {
            this.tryEntries = [{ tryLoc: "root" }], st.forEach(Le, this), this.reset(true);
          }
          function zt(st) {
            if (st || st === "") {
              var ct = st[de];
              if (ct) return ct.call(st);
              if (typeof st.next == "function") return st;
              if (!isNaN(st.length)) {
                var yt = -1, Zt = function Ct() {
                  for (; ++yt < st.length; ) if (Q.call(st, yt)) return Ct.value = st[yt], Ct.done = false, Ct;
                  return Ct.value = p, Ct.done = true, Ct;
                };
                return Zt.next = Zt;
              }
            }
            throw new TypeError(g(st) + " is not iterable");
          }
          return Ft.prototype = Dt, se(Ur, "constructor", { value: Dt, configurable: true }), se(Dt, "constructor", { value: Ft, configurable: true }), Ft.displayName = ut(Dt, Ne, "GeneratorFunction"), A.isGeneratorFunction = function(st) {
            var ct = typeof st == "function" && st.constructor;
            return !!ct && (ct === Ft || (ct.displayName || ct.name) === "GeneratorFunction");
          }, A.mark = function(st) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(st, Dt) : (st.__proto__ = Dt, ut(st, Ne, "GeneratorFunction")), st.prototype = Object.create(Ur), st;
          }, A.awrap = function(st) {
            return { __await: st };
          }, Pe($e.prototype), ut($e.prototype, tt, function() {
            return this;
          }), A.AsyncIterator = $e, A.async = function(st, ct, yt, Zt, Ct) {
            Ct === void 0 && (Ct = Promise);
            var Lt = new $e(Ze(st, ct, yt, Zt), Ct);
            return A.isGeneratorFunction(ct) ? Lt : Lt.next().then(function(Wt) {
              return Wt.done ? Wt.value : Lt.next();
            });
          }, Pe(Ur), ut(Ur, Ne, "Generator"), ut(Ur, de, function() {
            return this;
          }), ut(Ur, "toString", function() {
            return "[object Generator]";
          }), A.keys = function(st) {
            var ct = Object(st), yt = [];
            for (var Zt in ct) yt.push(Zt);
            return yt.reverse(), function Ct() {
              for (; yt.length; ) {
                var Lt = yt.pop();
                if (Lt in ct) return Ct.value = Lt, Ct.done = false, Ct;
              }
              return Ct.done = true, Ct;
            };
          }, A.values = zt, ft.prototype = { constructor: ft, reset: function(st) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = p, this.done = false, this.delegate = null, this.method = "next", this.arg = p, this.tryEntries.forEach(nt), !st) for (var ct in this) ct.charAt(0) === "t" && Q.call(this, ct) && !isNaN(+ct.slice(1)) && (this[ct] = p);
          }, stop: function() {
            this.done = true;
            var st = this.tryEntries[0].completion;
            if (st.type === "throw") throw st.arg;
            return this.rval;
          }, dispatchException: function(st) {
            if (this.done) throw st;
            var ct = this;
            function yt(ar, sr) {
              return Lt.type = "throw", Lt.arg = st, ct.next = ar, sr && (ct.method = "next", ct.arg = p), !!sr;
            }
            for (var Zt = this.tryEntries.length - 1; Zt >= 0; --Zt) {
              var Ct = this.tryEntries[Zt], Lt = Ct.completion;
              if (Ct.tryLoc === "root") return yt("end");
              if (Ct.tryLoc <= this.prev) {
                var Wt = Q.call(Ct, "catchLoc"), vr = Q.call(Ct, "finallyLoc");
                if (Wt && vr) {
                  if (this.prev < Ct.catchLoc) return yt(Ct.catchLoc, true);
                  if (this.prev < Ct.finallyLoc) return yt(Ct.finallyLoc);
                } else if (Wt) {
                  if (this.prev < Ct.catchLoc) return yt(Ct.catchLoc, true);
                } else {
                  if (!vr) throw Error("try statement without catch or finally");
                  if (this.prev < Ct.finallyLoc) return yt(Ct.finallyLoc);
                }
              }
            }
          }, abrupt: function(st, ct) {
            for (var yt = this.tryEntries.length - 1; yt >= 0; --yt) {
              var Zt = this.tryEntries[yt];
              if (Zt.tryLoc <= this.prev && Q.call(Zt, "finallyLoc") && this.prev < Zt.finallyLoc) {
                var Ct = Zt;
                break;
              }
            }
            Ct && (st === "break" || st === "continue") && Ct.tryLoc <= ct && ct <= Ct.finallyLoc && (Ct = null);
            var Lt = Ct ? Ct.completion : {};
            return Lt.type = st, Lt.arg = ct, Ct ? (this.method = "next", this.next = Ct.finallyLoc, Ae) : this.complete(Lt);
          }, complete: function(st, ct) {
            if (st.type === "throw") throw st.arg;
            return st.type === "break" || st.type === "continue" ? this.next = st.arg : st.type === "return" ? (this.rval = this.arg = st.arg, this.method = "return", this.next = "end") : st.type === "normal" && ct && (this.next = ct), Ae;
          }, finish: function(st) {
            for (var ct = this.tryEntries.length - 1; ct >= 0; --ct) {
              var yt = this.tryEntries[ct];
              if (yt.finallyLoc === st) return this.complete(yt.completion, yt.afterLoc), nt(yt), Ae;
            }
          }, catch: function(st) {
            for (var ct = this.tryEntries.length - 1; ct >= 0; --ct) {
              var yt = this.tryEntries[ct];
              if (yt.tryLoc === st) {
                var Zt = yt.completion;
                if (Zt.type === "throw") {
                  var Ct = Zt.arg;
                  nt(yt);
                }
                return Ct;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(st, ct, yt) {
            return this.delegate = { iterator: zt(st), resultName: ct, nextLoc: yt }, this.method === "next" && (this.arg = p), Ae;
          } }, A;
        }
        function l(p, A, U, Q, se, X, de) {
          try {
            var tt = p[X](de), Ne = tt.value;
          } catch (ut) {
            return void U(ut);
          }
          tt.done ? A(Ne) : Promise.resolve(Ne).then(Q, se);
        }
        function d(p, A) {
          return b.apply(this, arguments);
        }
        function b() {
          var p;
          return p = a().mark(function A(U, Q) {
            var se, X, de, tt = arguments;
            return a().wrap(function(Ne) {
              for (; ; ) switch (Ne.prev = Ne.next) {
                case 0:
                  return se = tt.length > 2 && tt[2] !== void 0 ? tt[2] : null, Ne.next = 3, m.post(U, { jsonrpc: "2.0", id: 1, method: Q, params: se });
                case 3:
                  if (X = Ne.sent, ut = X.data, Ze = "error", !ut.hasOwnProperty(Ze)) {
                    Ne.next = 8;
                    break;
                  }
                  throw X.data.error;
                case 8:
                  return Ne.abrupt("return", (de = X.data) === null || de === void 0 ? void 0 : de.result);
                case 9:
                case "end":
                  return Ne.stop();
              }
              var ut, Ze;
            }, A);
          }), b = function() {
            var A = this, U = arguments;
            return new Promise(function(Q, se) {
              var X = p.apply(A, U);
              function de(Ne) {
                l(X, Q, se, de, tt, "next", Ne);
              }
              function tt(Ne) {
                l(X, Q, se, de, tt, "throw", Ne);
              }
              de(void 0);
            });
          }, b.apply(this, arguments);
        }
        var S = u(8680), E = u(784), R = u(3121), k = u(8287).Buffer;
        function w(p) {
          return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
            return typeof A;
          } : function(A) {
            return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
          }, w(p);
        }
        function F(p, A) {
          var U = Object.keys(p);
          if (Object.getOwnPropertySymbols) {
            var Q = Object.getOwnPropertySymbols(p);
            A && (Q = Q.filter(function(se) {
              return Object.getOwnPropertyDescriptor(p, se).enumerable;
            })), U.push.apply(U, Q);
          }
          return U;
        }
        function I(p) {
          for (var A = 1; A < arguments.length; A++) {
            var U = arguments[A] != null ? arguments[A] : {};
            A % 2 ? F(Object(U), true).forEach(function(Q) {
              q(p, Q, U[Q]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(p, Object.getOwnPropertyDescriptors(U)) : F(Object(U)).forEach(function(Q) {
              Object.defineProperty(p, Q, Object.getOwnPropertyDescriptor(U, Q));
            });
          }
          return p;
        }
        function q(p, A, U) {
          return (A = L(A)) in p ? Object.defineProperty(p, A, { value: U, enumerable: true, configurable: true, writable: true }) : p[A] = U, p;
        }
        function D() {
          D = function() {
            return A;
          };
          var p, A = {}, U = Object.prototype, Q = U.hasOwnProperty, se = Object.defineProperty || function(st, ct, yt) {
            st[ct] = yt.value;
          }, X = typeof Symbol == "function" ? Symbol : {}, de = X.iterator || "@@iterator", tt = X.asyncIterator || "@@asyncIterator", Ne = X.toStringTag || "@@toStringTag";
          function ut(st, ct, yt) {
            return Object.defineProperty(st, ct, { value: yt, enumerable: true, configurable: true, writable: true }), st[ct];
          }
          try {
            ut({}, "");
          } catch {
            ut = function(ct, yt, Zt) {
              return ct[yt] = Zt;
            };
          }
          function Ze(st, ct, yt, Zt) {
            var Ct = ct && ct.prototype instanceof qe ? ct : qe, Lt = Object.create(Ct.prototype), Wt = new ft(Zt || []);
            return se(Lt, "_invoke", { value: le(st, yt, Wt) }), Lt;
          }
          function Et(st, ct, yt) {
            try {
              return { type: "normal", arg: st.call(ct, yt) };
            } catch (Zt) {
              return { type: "throw", arg: Zt };
            }
          }
          A.wrap = Ze;
          var rr = "suspendedStart", je = "suspendedYield", Ge = "executing", at = "completed", Ae = {};
          function qe() {
          }
          function Ft() {
          }
          function Dt() {
          }
          var wr = {};
          ut(wr, de, function() {
            return this;
          });
          var Nt = Object.getPrototypeOf, yr = Nt && Nt(Nt(zt([])));
          yr && yr !== U && Q.call(yr, de) && (wr = yr);
          var Ur = Dt.prototype = qe.prototype = Object.create(wr);
          function Pe(st) {
            ["next", "throw", "return"].forEach(function(ct) {
              ut(st, ct, function(yt) {
                return this._invoke(ct, yt);
              });
            });
          }
          function $e(st, ct) {
            function yt(Ct, Lt, Wt, vr) {
              var ar = Et(st[Ct], st, Lt);
              if (ar.type !== "throw") {
                var sr = ar.arg, gr = sr.value;
                return gr && w(gr) == "object" && Q.call(gr, "__await") ? ct.resolve(gr.__await).then(function(Tr) {
                  yt("next", Tr, Wt, vr);
                }, function(Tr) {
                  yt("throw", Tr, Wt, vr);
                }) : ct.resolve(gr).then(function(Tr) {
                  sr.value = Tr, Wt(sr);
                }, function(Tr) {
                  return yt("throw", Tr, Wt, vr);
                });
              }
              vr(ar.arg);
            }
            var Zt;
            se(this, "_invoke", { value: function(Ct, Lt) {
              function Wt() {
                return new ct(function(vr, ar) {
                  yt(Ct, Lt, vr, ar);
                });
              }
              return Zt = Zt ? Zt.then(Wt, Wt) : Wt();
            } });
          }
          function le(st, ct, yt) {
            var Zt = rr;
            return function(Ct, Lt) {
              if (Zt === Ge) throw Error("Generator is already running");
              if (Zt === at) {
                if (Ct === "throw") throw Lt;
                return { value: p, done: true };
              }
              for (yt.method = Ct, yt.arg = Lt; ; ) {
                var Wt = yt.delegate;
                if (Wt) {
                  var vr = re(Wt, yt);
                  if (vr) {
                    if (vr === Ae) continue;
                    return vr;
                  }
                }
                if (yt.method === "next") yt.sent = yt._sent = yt.arg;
                else if (yt.method === "throw") {
                  if (Zt === rr) throw Zt = at, yt.arg;
                  yt.dispatchException(yt.arg);
                } else yt.method === "return" && yt.abrupt("return", yt.arg);
                Zt = Ge;
                var ar = Et(st, ct, yt);
                if (ar.type === "normal") {
                  if (Zt = yt.done ? at : je, ar.arg === Ae) continue;
                  return { value: ar.arg, done: yt.done };
                }
                ar.type === "throw" && (Zt = at, yt.method = "throw", yt.arg = ar.arg);
              }
            };
          }
          function re(st, ct) {
            var yt = ct.method, Zt = st.iterator[yt];
            if (Zt === p) return ct.delegate = null, yt === "throw" && st.iterator.return && (ct.method = "return", ct.arg = p, re(st, ct), ct.method === "throw") || yt !== "return" && (ct.method = "throw", ct.arg = new TypeError("The iterator does not provide a '" + yt + "' method")), Ae;
            var Ct = Et(Zt, st.iterator, ct.arg);
            if (Ct.type === "throw") return ct.method = "throw", ct.arg = Ct.arg, ct.delegate = null, Ae;
            var Lt = Ct.arg;
            return Lt ? Lt.done ? (ct[st.resultName] = Lt.value, ct.next = st.nextLoc, ct.method !== "return" && (ct.method = "next", ct.arg = p), ct.delegate = null, Ae) : Lt : (ct.method = "throw", ct.arg = new TypeError("iterator result is not an object"), ct.delegate = null, Ae);
          }
          function Le(st) {
            var ct = { tryLoc: st[0] };
            1 in st && (ct.catchLoc = st[1]), 2 in st && (ct.finallyLoc = st[2], ct.afterLoc = st[3]), this.tryEntries.push(ct);
          }
          function nt(st) {
            var ct = st.completion || {};
            ct.type = "normal", delete ct.arg, st.completion = ct;
          }
          function ft(st) {
            this.tryEntries = [{ tryLoc: "root" }], st.forEach(Le, this), this.reset(true);
          }
          function zt(st) {
            if (st || st === "") {
              var ct = st[de];
              if (ct) return ct.call(st);
              if (typeof st.next == "function") return st;
              if (!isNaN(st.length)) {
                var yt = -1, Zt = function Ct() {
                  for (; ++yt < st.length; ) if (Q.call(st, yt)) return Ct.value = st[yt], Ct.done = false, Ct;
                  return Ct.value = p, Ct.done = true, Ct;
                };
                return Zt.next = Zt;
              }
            }
            throw new TypeError(w(st) + " is not iterable");
          }
          return Ft.prototype = Dt, se(Ur, "constructor", { value: Dt, configurable: true }), se(Dt, "constructor", { value: Ft, configurable: true }), Ft.displayName = ut(Dt, Ne, "GeneratorFunction"), A.isGeneratorFunction = function(st) {
            var ct = typeof st == "function" && st.constructor;
            return !!ct && (ct === Ft || (ct.displayName || ct.name) === "GeneratorFunction");
          }, A.mark = function(st) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(st, Dt) : (st.__proto__ = Dt, ut(st, Ne, "GeneratorFunction")), st.prototype = Object.create(Ur), st;
          }, A.awrap = function(st) {
            return { __await: st };
          }, Pe($e.prototype), ut($e.prototype, tt, function() {
            return this;
          }), A.AsyncIterator = $e, A.async = function(st, ct, yt, Zt, Ct) {
            Ct === void 0 && (Ct = Promise);
            var Lt = new $e(Ze(st, ct, yt, Zt), Ct);
            return A.isGeneratorFunction(ct) ? Lt : Lt.next().then(function(Wt) {
              return Wt.done ? Wt.value : Lt.next();
            });
          }, Pe(Ur), ut(Ur, Ne, "Generator"), ut(Ur, de, function() {
            return this;
          }), ut(Ur, "toString", function() {
            return "[object Generator]";
          }), A.keys = function(st) {
            var ct = Object(st), yt = [];
            for (var Zt in ct) yt.push(Zt);
            return yt.reverse(), function Ct() {
              for (; yt.length; ) {
                var Lt = yt.pop();
                if (Lt in ct) return Ct.value = Lt, Ct.done = false, Ct;
              }
              return Ct.done = true, Ct;
            };
          }, A.values = zt, ft.prototype = { constructor: ft, reset: function(st) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = p, this.done = false, this.delegate = null, this.method = "next", this.arg = p, this.tryEntries.forEach(nt), !st) for (var ct in this) ct.charAt(0) === "t" && Q.call(this, ct) && !isNaN(+ct.slice(1)) && (this[ct] = p);
          }, stop: function() {
            this.done = true;
            var st = this.tryEntries[0].completion;
            if (st.type === "throw") throw st.arg;
            return this.rval;
          }, dispatchException: function(st) {
            if (this.done) throw st;
            var ct = this;
            function yt(ar, sr) {
              return Lt.type = "throw", Lt.arg = st, ct.next = ar, sr && (ct.method = "next", ct.arg = p), !!sr;
            }
            for (var Zt = this.tryEntries.length - 1; Zt >= 0; --Zt) {
              var Ct = this.tryEntries[Zt], Lt = Ct.completion;
              if (Ct.tryLoc === "root") return yt("end");
              if (Ct.tryLoc <= this.prev) {
                var Wt = Q.call(Ct, "catchLoc"), vr = Q.call(Ct, "finallyLoc");
                if (Wt && vr) {
                  if (this.prev < Ct.catchLoc) return yt(Ct.catchLoc, true);
                  if (this.prev < Ct.finallyLoc) return yt(Ct.finallyLoc);
                } else if (Wt) {
                  if (this.prev < Ct.catchLoc) return yt(Ct.catchLoc, true);
                } else {
                  if (!vr) throw Error("try statement without catch or finally");
                  if (this.prev < Ct.finallyLoc) return yt(Ct.finallyLoc);
                }
              }
            }
          }, abrupt: function(st, ct) {
            for (var yt = this.tryEntries.length - 1; yt >= 0; --yt) {
              var Zt = this.tryEntries[yt];
              if (Zt.tryLoc <= this.prev && Q.call(Zt, "finallyLoc") && this.prev < Zt.finallyLoc) {
                var Ct = Zt;
                break;
              }
            }
            Ct && (st === "break" || st === "continue") && Ct.tryLoc <= ct && ct <= Ct.finallyLoc && (Ct = null);
            var Lt = Ct ? Ct.completion : {};
            return Lt.type = st, Lt.arg = ct, Ct ? (this.method = "next", this.next = Ct.finallyLoc, Ae) : this.complete(Lt);
          }, complete: function(st, ct) {
            if (st.type === "throw") throw st.arg;
            return st.type === "break" || st.type === "continue" ? this.next = st.arg : st.type === "return" ? (this.rval = this.arg = st.arg, this.method = "return", this.next = "end") : st.type === "normal" && ct && (this.next = ct), Ae;
          }, finish: function(st) {
            for (var ct = this.tryEntries.length - 1; ct >= 0; --ct) {
              var yt = this.tryEntries[ct];
              if (yt.finallyLoc === st) return this.complete(yt.completion, yt.afterLoc), nt(yt), Ae;
            }
          }, catch: function(st) {
            for (var ct = this.tryEntries.length - 1; ct >= 0; --ct) {
              var yt = this.tryEntries[ct];
              if (yt.tryLoc === st) {
                var Zt = yt.completion;
                if (Zt.type === "throw") {
                  var Ct = Zt.arg;
                  nt(yt);
                }
                return Ct;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(st, ct, yt) {
            return this.delegate = { iterator: zt(st), resultName: ct, nextLoc: yt }, this.method === "next" && (this.arg = p), Ae;
          } }, A;
        }
        function H(p, A, U, Q, se, X, de) {
          try {
            var tt = p[X](de), Ne = tt.value;
          } catch (ut) {
            return void U(ut);
          }
          tt.done ? A(Ne) : Promise.resolve(Ne).then(Q, se);
        }
        function _(p) {
          return function() {
            var A = this, U = arguments;
            return new Promise(function(Q, se) {
              var X = p.apply(A, U);
              function de(Ne) {
                H(X, Q, se, de, tt, "next", Ne);
              }
              function tt(Ne) {
                H(X, Q, se, de, tt, "throw", Ne);
              }
              de(void 0);
            });
          };
        }
        function T(p, A) {
          for (var U = 0; U < A.length; U++) {
            var Q = A[U];
            Q.enumerable = Q.enumerable || false, Q.configurable = true, "value" in Q && (Q.writable = true), Object.defineProperty(p, L(Q.key), Q);
          }
        }
        function L(p) {
          var A = function(U, Q) {
            if (w(U) != "object" || !U) return U;
            var se = U[Symbol.toPrimitive];
            if (se !== void 0) {
              var X = se.call(U, Q);
              if (w(X) != "object") return X;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (Q === "string" ? String : Number)(U);
          }(p, "string");
          return w(A) == "symbol" ? A : A + "";
        }
        var j = function(p) {
          return p.Temporary = "temporary", p.Persistent = "persistent", p;
        }({}), z = function(p) {
          return 1e3;
        }, Y = function(p) {
          return 1e3 * p;
        };
        function te(p) {
          var A, U = [];
          switch (p.switch()) {
            case 0:
              U = p.operations();
              break;
            case 1:
            case 2:
            case 3:
              U = p.value().operations();
              break;
            default:
              throw new Error("Unexpected transaction meta switch value");
          }
          var Q = (A = U.flatMap(function(se) {
            return se.changes();
          }).find(function(se) {
            return se.switch() === r.xdr.LedgerEntryChangeType.ledgerEntryCreated() && se.created().data().switch() === r.xdr.LedgerEntryType.account();
          })) === null || A === void 0 || (A = A.created()) === null || A === void 0 || (A = A.data()) === null || A === void 0 || (A = A.account()) === null || A === void 0 || (A = A.seqNum()) === null || A === void 0 ? void 0 : A.toString();
          if (Q) return Q;
          throw new Error("No account created in transaction");
        }
        var G, K, J, B, Z, ie, $, oe, ce, ye, ae, ue, ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P, x, O, V, N = (G = function p(A) {
          var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (function(Q, se) {
            if (!(Q instanceof se)) throw new TypeError("Cannot call a class as a function");
          }(this, p), this.serverURL = f()(A), U.headers && Object.keys(U.headers).length !== 0 && m.interceptors.request.use(function(Q) {
            return Q.headers = Object.assign(Q.headers, U.headers), Q;
          }), this.serverURL.protocol() !== "https" && !U.allowHttp) throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }, K = [{ key: "getAccount", value: (V = _(D().mark(function p(A) {
          var U, Q, se;
          return D().wrap(function(X) {
            for (; ; ) switch (X.prev = X.next) {
              case 0:
                return U = r.xdr.LedgerKey.account(new r.xdr.LedgerKeyAccount({ accountId: r.Keypair.fromPublicKey(A).xdrPublicKey() })), X.next = 3, this.getLedgerEntries(U);
              case 3:
                if ((Q = X.sent).entries.length !== 0) {
                  X.next = 6;
                  break;
                }
                return X.abrupt("return", Promise.reject({ code: 404, message: "Account not found: ".concat(A) }));
              case 6:
                return se = Q.entries[0].val.account(), X.abrupt("return", new r.Account(A, se.seqNum().toString()));
              case 8:
              case "end":
                return X.stop();
            }
          }, p, this);
        })), function(p) {
          return V.apply(this, arguments);
        }) }, { key: "getHealth", value: (O = _(D().mark(function p() {
          return D().wrap(function(A) {
            for (; ; ) switch (A.prev = A.next) {
              case 0:
                return A.abrupt("return", d(this.serverURL.toString(), "getHealth"));
              case 1:
              case "end":
                return A.stop();
            }
          }, p, this);
        })), function() {
          return O.apply(this, arguments);
        }) }, { key: "getContractData", value: (x = _(D().mark(function p(A, U) {
          var Q, se, X, de, tt = arguments;
          return D().wrap(function(Ne) {
            for (; ; ) switch (Ne.prev = Ne.next) {
              case 0:
                if (Q = tt.length > 2 && tt[2] !== void 0 ? tt[2] : j.Persistent, typeof A != "string") {
                  Ne.next = 5;
                  break;
                }
                se = new r.Contract(A).address().toScAddress(), Ne.next = 14;
                break;
              case 5:
                if (!(A instanceof r.Address)) {
                  Ne.next = 9;
                  break;
                }
                se = A.toScAddress(), Ne.next = 14;
                break;
              case 9:
                if (!(A instanceof r.Contract)) {
                  Ne.next = 13;
                  break;
                }
                se = A.address().toScAddress(), Ne.next = 14;
                break;
              case 13:
                throw new TypeError("unknown contract type: ".concat(A));
              case 14:
                Ne.t0 = Q, Ne.next = Ne.t0 === j.Temporary ? 17 : Ne.t0 === j.Persistent ? 19 : 21;
                break;
              case 17:
                return X = r.xdr.ContractDataDurability.temporary(), Ne.abrupt("break", 22);
              case 19:
                return X = r.xdr.ContractDataDurability.persistent(), Ne.abrupt("break", 22);
              case 21:
                throw new TypeError("invalid durability: ".concat(Q));
              case 22:
                return de = r.xdr.LedgerKey.contractData(new r.xdr.LedgerKeyContractData({ key: U, contract: se, durability: X })), Ne.abrupt("return", this.getLedgerEntries(de).then(function(ut) {
                  return ut.entries.length === 0 ? Promise.reject({ code: 404, message: "Contract data not found. Contract: ".concat(r.Address.fromScAddress(se).toString(), ", Key: ").concat(U.toXDR("base64"), ", Durability: ").concat(Q) }) : ut.entries[0];
                }));
              case 24:
              case "end":
                return Ne.stop();
            }
          }, p, this);
        })), function(p, A) {
          return x.apply(this, arguments);
        }) }, { key: "getContractWasmByContractId", value: (P = _(D().mark(function p(A) {
          var U, Q, se, X;
          return D().wrap(function(de) {
            for (; ; ) switch (de.prev = de.next) {
              case 0:
                return Q = new r.Contract(A).getFootprint(), de.next = 3, this.getLedgerEntries(Q);
              case 3:
                if ((se = de.sent).entries.length && (U = se.entries[0]) !== null && U !== void 0 && U.val) {
                  de.next = 6;
                  break;
                }
                return de.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract hash from server" }));
              case 6:
                return X = se.entries[0].val.contractData().val().instance().executable().wasmHash(), de.abrupt("return", this.getContractWasmByHash(X));
              case 8:
              case "end":
                return de.stop();
            }
          }, p, this);
        })), function(p) {
          return P.apply(this, arguments);
        }) }, { key: "getContractWasmByHash", value: (ee = _(D().mark(function p(A) {
          var U, Q, se, X, de, tt, Ne = arguments;
          return D().wrap(function(ut) {
            for (; ; ) switch (ut.prev = ut.next) {
              case 0:
                return Q = Ne.length > 1 && Ne[1] !== void 0 ? Ne[1] : void 0, se = typeof A == "string" ? k.from(A, Q) : A, X = r.xdr.LedgerKey.contractCode(new r.xdr.LedgerKeyContractCode({ hash: se })), ut.next = 5, this.getLedgerEntries(X);
              case 5:
                if ((de = ut.sent).entries.length && (U = de.entries[0]) !== null && U !== void 0 && U.val) {
                  ut.next = 8;
                  break;
                }
                return ut.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract wasm from server" }));
              case 8:
                return tt = de.entries[0].val.contractCode().code(), ut.abrupt("return", tt);
              case 10:
              case "end":
                return ut.stop();
            }
          }, p, this);
        })), function(p) {
          return ee.apply(this, arguments);
        }) }, { key: "getLedgerEntries", value: (Qe = _(D().mark(function p() {
          var A = arguments;
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", this._getLedgerEntries.apply(this, A).then(E.$D));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function() {
          return Qe.apply(this, arguments);
        }) }, { key: "_getLedgerEntries", value: (Be = _(D().mark(function p() {
          var A, U, Q, se = arguments;
          return D().wrap(function(X) {
            for (; ; ) switch (X.prev = X.next) {
              case 0:
                for (A = se.length, U = new Array(A), Q = 0; Q < A; Q++) U[Q] = se[Q];
                return X.abrupt("return", d(this.serverURL.toString(), "getLedgerEntries", { keys: U.map(function(de) {
                  return de.toXDR("base64");
                }) }));
              case 2:
              case "end":
                return X.stop();
            }
          }, p, this);
        })), function() {
          return Be.apply(this, arguments);
        }) }, { key: "pollTransaction", value: (_e = _(D().mark(function p(A, U) {
          var Q, se, X, de, tt, Ne;
          return D().wrap(function(ut) {
            for (; ; ) switch (ut.prev = ut.next) {
              case 0:
                X = ((Q = U == null ? void 0 : U.attempts) !== null && Q !== void 0 ? Q : 0) < 1 ? 30 : (se = U == null ? void 0 : U.attempts) !== null && se !== void 0 ? se : 30, tt = 1;
              case 2:
                if (!(tt < X)) {
                  ut.next = 13;
                  break;
                }
                return ut.next = 5, this.getTransaction(A);
              case 5:
                if ((de = ut.sent).status === c.j.GetTransactionStatus.NOT_FOUND) {
                  ut.next = 8;
                  break;
                }
                return ut.abrupt("return", de);
              case 8:
                return ut.next = 10, R.A.sleep(((Ne = U == null ? void 0 : U.sleepStrategy) !== null && Ne !== void 0 ? Ne : z)(tt));
              case 10:
                tt++, ut.next = 2;
                break;
              case 13:
                return ut.abrupt("return", de);
              case 14:
              case "end":
                return ut.stop();
            }
          }, p, this);
        })), function(p, A) {
          return _e.apply(this, arguments);
        }) }, { key: "getTransaction", value: (Ve = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", this._getTransaction(A).then(function(Q) {
                  var se = {};
                  return Q.status !== c.j.GetTransactionStatus.NOT_FOUND && Object.assign(se, (0, E.WC)(Q)), I({ status: Q.status, txHash: A, latestLedger: Q.latestLedger, latestLedgerCloseTime: Q.latestLedgerCloseTime, oldestLedger: Q.oldestLedger, oldestLedgerCloseTime: Q.oldestLedgerCloseTime }, se);
                }));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return Ve.apply(this, arguments);
        }) }, { key: "_getTransaction", value: (xe = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", d(this.serverURL.toString(), "getTransaction", { hash: A }));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return xe.apply(this, arguments);
        }) }, { key: "getTransactions", value: (Oe = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", this._getTransactions(A).then(function(Q) {
                  return { transactions: Q.transactions.map(E.tR), latestLedger: Q.latestLedger, latestLedgerCloseTimestamp: Q.latestLedgerCloseTimestamp, oldestLedger: Q.oldestLedger, oldestLedgerCloseTimestamp: Q.oldestLedgerCloseTimestamp, cursor: Q.cursor };
                }));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return Oe.apply(this, arguments);
        }) }, { key: "_getTransactions", value: (pe = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", d(this.serverURL.toString(), "getTransactions", A));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return pe.apply(this, arguments);
        }) }, { key: "getEvents", value: (Te = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", this._getEvents(A).then(E.fG));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return Te.apply(this, arguments);
        }) }, { key: "_getEvents", value: (ge = _(D().mark(function p(A) {
          var U;
          return D().wrap(function(Q) {
            for (; ; ) switch (Q.prev = Q.next) {
              case 0:
                return Q.abrupt("return", d(this.serverURL.toString(), "getEvents", I(I({ filters: (U = A.filters) !== null && U !== void 0 ? U : [], pagination: I(I({}, A.cursor && { cursor: A.cursor }), A.limit && { limit: A.limit }) }, A.startLedger && { startLedger: A.startLedger }), A.endLedger && { endLedger: A.endLedger })));
              case 1:
              case "end":
                return Q.stop();
            }
          }, p, this);
        })), function(p) {
          return ge.apply(this, arguments);
        }) }, { key: "getNetwork", value: (ne = _(D().mark(function p() {
          return D().wrap(function(A) {
            for (; ; ) switch (A.prev = A.next) {
              case 0:
                return A.abrupt("return", d(this.serverURL.toString(), "getNetwork"));
              case 1:
              case "end":
                return A.stop();
            }
          }, p, this);
        })), function() {
          return ne.apply(this, arguments);
        }) }, { key: "getLatestLedger", value: (ue = _(D().mark(function p() {
          return D().wrap(function(A) {
            for (; ; ) switch (A.prev = A.next) {
              case 0:
                return A.abrupt("return", d(this.serverURL.toString(), "getLatestLedger"));
              case 1:
              case "end":
                return A.stop();
            }
          }, p, this);
        })), function() {
          return ue.apply(this, arguments);
        }) }, { key: "simulateTransaction", value: (ae = _(D().mark(function p(A, U) {
          return D().wrap(function(Q) {
            for (; ; ) switch (Q.prev = Q.next) {
              case 0:
                return Q.abrupt("return", this._simulateTransaction(A, U).then(E.jr));
              case 1:
              case "end":
                return Q.stop();
            }
          }, p, this);
        })), function(p, A) {
          return ae.apply(this, arguments);
        }) }, { key: "_simulateTransaction", value: (ye = _(D().mark(function p(A, U) {
          return D().wrap(function(Q) {
            for (; ; ) switch (Q.prev = Q.next) {
              case 0:
                return Q.abrupt("return", d(this.serverURL.toString(), "simulateTransaction", I({ transaction: A.toXDR() }, U !== void 0 && { resourceConfig: { instructionLeeway: U.cpuInstructions } })));
              case 1:
              case "end":
                return Q.stop();
            }
          }, p, this);
        })), function(p, A) {
          return ye.apply(this, arguments);
        }) }, { key: "prepareTransaction", value: (ce = _(D().mark(function p(A) {
          var U;
          return D().wrap(function(Q) {
            for (; ; ) switch (Q.prev = Q.next) {
              case 0:
                return Q.next = 2, this.simulateTransaction(A);
              case 2:
                if (U = Q.sent, !c.j.isSimulationError(U)) {
                  Q.next = 5;
                  break;
                }
                throw new Error(U.error);
              case 5:
                return Q.abrupt("return", (0, S.X)(A, U).build());
              case 6:
              case "end":
                return Q.stop();
            }
          }, p, this);
        })), function(p) {
          return ce.apply(this, arguments);
        }) }, { key: "sendTransaction", value: (oe = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", this._sendTransaction(A).then(E.Af));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return oe.apply(this, arguments);
        }) }, { key: "_sendTransaction", value: ($ = _(D().mark(function p(A) {
          return D().wrap(function(U) {
            for (; ; ) switch (U.prev = U.next) {
              case 0:
                return U.abrupt("return", d(this.serverURL.toString(), "sendTransaction", { transaction: A.toXDR() }));
              case 1:
              case "end":
                return U.stop();
            }
          }, p, this);
        })), function(p) {
          return $.apply(this, arguments);
        }) }, { key: "requestAirdrop", value: (ie = _(D().mark(function p(A, U) {
          var Q, se, X, de, tt, Ne, ut;
          return D().wrap(function(Ze) {
            for (; ; ) switch (Ze.prev = Ze.next) {
              case 0:
                if (Q = typeof A == "string" ? A : A.accountId(), Ze.t0 = U, Ze.t0) {
                  Ze.next = 6;
                  break;
                }
                return Ze.next = 5, this.getNetwork();
              case 5:
                Ze.t0 = Ze.sent.friendbotUrl;
              case 6:
                if (U = Ze.t0) {
                  Ze.next = 9;
                  break;
                }
                throw new Error("No friendbot URL configured for current network");
              case 9:
                return Ze.prev = 9, Ze.next = 12, m.post("".concat(U, "?addr=").concat(encodeURIComponent(Q)));
              case 12:
                if ((se = Ze.sent).data.result_meta_xdr) {
                  Ze.next = 22;
                  break;
                }
                return Ze.next = 16, this.getTransaction(se.data.hash);
              case 16:
                if ((de = Ze.sent).status === c.j.GetTransactionStatus.SUCCESS) {
                  Ze.next = 19;
                  break;
                }
                throw new Error("Funding account ".concat(A, " failed"));
              case 19:
                X = de.resultMetaXdr, Ze.next = 23;
                break;
              case 22:
                X = r.xdr.TransactionMeta.fromXDR(se.data.result_meta_xdr, "base64");
              case 23:
                return tt = te(X), Ze.abrupt("return", new r.Account(Q, tt));
              case 27:
                if (Ze.prev = 27, Ze.t1 = Ze.catch(9), ((Ne = Ze.t1.response) === null || Ne === void 0 ? void 0 : Ne.status) !== 400) {
                  Ze.next = 32;
                  break;
                }
                if ((ut = Ze.t1.response.detail) === null || ut === void 0 || !ut.includes("createAccountAlreadyExist")) {
                  Ze.next = 32;
                  break;
                }
                return Ze.abrupt("return", this.getAccount(Q));
              case 32:
                throw Ze.t1;
              case 33:
              case "end":
                return Ze.stop();
            }
          }, p, this, [[9, 27]]);
        })), function(p, A) {
          return ie.apply(this, arguments);
        }) }, { key: "getFeeStats", value: (Z = _(D().mark(function p() {
          return D().wrap(function(A) {
            for (; ; ) switch (A.prev = A.next) {
              case 0:
                return A.abrupt("return", d(this.serverURL.toString(), "getFeeStats"));
              case 1:
              case "end":
                return A.stop();
            }
          }, p, this);
        })), function() {
          return Z.apply(this, arguments);
        }) }, { key: "getVersionInfo", value: (B = _(D().mark(function p() {
          return D().wrap(function(A) {
            for (; ; ) switch (A.prev = A.next) {
              case 0:
                return A.abrupt("return", d(this.serverURL.toString(), "getVersionInfo"));
              case 1:
              case "end":
                return A.stop();
            }
          }, p, this);
        })), function() {
          return B.apply(this, arguments);
        }) }, { key: "getSACBalance", value: (J = _(D().mark(function p(A, U, Q) {
          var se, X, de, tt, Ne, ut, Ze, Et, rr, je;
          return D().wrap(function(Ge) {
            for (; ; ) switch (Ge.prev = Ge.next) {
              case 0:
                if (r.StrKey.isValidContract(A)) {
                  Ge.next = 2;
                  break;
                }
                throw new TypeError("expected contract ID, got ".concat(A));
              case 2:
                if (Q == null) {
                  Ge.next = 6;
                  break;
                }
                Ge.t0 = Q, Ge.next = 9;
                break;
              case 6:
                return Ge.next = 8, this.getNetwork().then(function(at) {
                  return at.passphrase;
                });
              case 8:
                Ge.t0 = Ge.sent;
              case 9:
                return se = Ge.t0, X = U.contractId(se), de = r.xdr.ScVal.scvVec([(0, r.nativeToScVal)("Balance", { type: "symbol" }), (0, r.nativeToScVal)(A, { type: "address" })]), tt = r.xdr.LedgerKey.contractData(new r.xdr.LedgerKeyContractData({ contract: new r.Address(X).toScAddress(), durability: r.xdr.ContractDataDurability.persistent(), key: de })), Ge.next = 15, this.getLedgerEntries(tt);
              case 15:
                if ((Ne = Ge.sent).entries.length !== 0) {
                  Ge.next = 18;
                  break;
                }
                return Ge.abrupt("return", { latestLedger: Ne.latestLedger });
              case 18:
                if (ut = Ne.entries[0], Ze = ut.lastModifiedLedgerSeq, Et = ut.liveUntilLedgerSeq, (rr = ut.val).switch().value === r.xdr.LedgerEntryType.contractData().value) {
                  Ge.next = 21;
                  break;
                }
                return Ge.abrupt("return", { latestLedger: Ne.latestLedger });
              case 21:
                return je = (0, r.scValToNative)(rr.contractData().val()), Ge.abrupt("return", { latestLedger: Ne.latestLedger, balanceEntry: { liveUntilLedgerSeq: Et, lastModifiedLedgerSeq: Ze, amount: je.amount.toString(), authorized: je.authorized, clawback: je.clawback } });
              case 23:
              case "end":
                return Ge.stop();
            }
          }, p, this);
        })), function(p, A, U) {
          return J.apply(this, arguments);
        }) }], K && T(G.prototype, K), Object.defineProperty(G, "prototype", { writable: false }), G);
        const C = (t = u.hmd(t)).exports;
      }, 3533: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.payment = function(r) {
          if (!r.asset) throw new Error("Must provide an asset for a payment operation");
          if (!this.isValidAmount(r.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          var m = {};
          try {
            m.destination = (0, f.decodeAddressToMuxedAccount)(r.destination);
          } catch {
            throw new Error("destination is invalid");
          }
          m.asset = r.asset.toXDRObject(), m.amount = this._toXDRAmount(r.amount);
          var g = new h.default.PaymentOp(m), a = {};
          return a.body = h.default.OperationBody.payment(g), this.setSourceAccount(a, r), new h.default.Operation(a);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6160);
      }, 3564: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.buildInvocationTree = function l(d) {
          var b = d.function(), S = {}, E = b.value();
          switch (b.switch().value) {
            case 0:
              S.type = "execute", S.args = { source: h.Address.fromScAddress(E.contractAddress()).toString(), function: E.functionName(), args: E.args().map(function(q) {
                return (0, f.scValToNative)(q);
              }) };
              break;
            case 1:
            case 2:
              var R = b.switch().value === 2;
              S.type = "create", S.args = {};
              var k = [E.executable(), E.contractIdPreimage()], w = k[0], F = k[1];
              if (!!w.switch().value != !!F.switch().value) throw new Error("creation function appears invalid: ".concat(JSON.stringify(E), " (should be wasm+address or token+asset)"));
              switch (w.switch().value) {
                case 0:
                  var I = F.fromAddress();
                  S.args.type = "wasm", S.args.wasm = function(q) {
                    for (var D = 1; D < arguments.length; D++) {
                      var H = arguments[D] != null ? arguments[D] : {};
                      D % 2 ? m(Object(H), true).forEach(function(_) {
                        g(q, _, H[_]);
                      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(H)) : m(Object(H)).forEach(function(_) {
                        Object.defineProperty(q, _, Object.getOwnPropertyDescriptor(H, _));
                      });
                    }
                    return q;
                  }({ salt: I.salt().toString("hex"), hash: w.wasmHash().toString("hex"), address: h.Address.fromScAddress(I.address()).toString() }, R && { constructorArgs: E.constructorArgs().map(function(q) {
                    return (0, f.scValToNative)(q);
                  }) });
                  break;
                case 1:
                  S.args.type = "sac", S.args.asset = c.Asset.fromOperation(F.fromAsset()).toString();
                  break;
                default:
                  throw new Error("unknown creation type: ".concat(JSON.stringify(w)));
              }
              break;
            default:
              throw new Error("unknown invocation type (".concat(b.switch(), "): ").concat(JSON.stringify(b)));
          }
          return S.invocations = d.subInvocations().map(function(q) {
            return l(q);
          }), S;
        }, o.walkInvocationTree = function(l, d) {
          a(l, 1, d);
        };
        var c = u(1764), h = u(1180), f = u(7177);
        function r(l) {
          return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, r(l);
        }
        function m(l, d) {
          var b = Object.keys(l);
          if (Object.getOwnPropertySymbols) {
            var S = Object.getOwnPropertySymbols(l);
            d && (S = S.filter(function(E) {
              return Object.getOwnPropertyDescriptor(l, E).enumerable;
            })), b.push.apply(b, S);
          }
          return b;
        }
        function g(l, d, b) {
          return (d = function(S) {
            var E = function(R, k) {
              if (r(R) != "object" || !R) return R;
              var w = R[Symbol.toPrimitive];
              if (w !== void 0) {
                var F = w.call(R, k);
                if (r(F) != "object") return F;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (k === "string" ? String : Number)(R);
            }(S, "string");
            return r(E) == "symbol" ? E : E + "";
          }(d)) in l ? Object.defineProperty(l, d, { value: b, enumerable: true, configurable: true, writable: true }) : l[d] = b, l;
        }
        function a(l, d, b, S) {
          b(l, d, S) !== false && l.subInvocations().forEach(function(E) {
            return a(E, d + 1, b, l);
          });
        }
      }, 3600: (t, o, u) => {
        t.exports = h;
        var c = u(4610);
        function h(f) {
          if (!(this instanceof h)) return new h(f);
          c.call(this, f);
        }
        u(6698)(h, c), h.prototype._transform = function(f, r, m) {
          m(null, f);
        };
      }, 3628: (t, o, u) => {
        var c = u(8648), h = u(1064), f = u(7176);
        t.exports = c ? function(r) {
          return c(r);
        } : h ? function(r) {
          if (!r || typeof r != "object" && typeof r != "function") throw new TypeError("getProto: not an object");
          return h(r);
        } : f ? function(r) {
          return f(r);
        } : null;
      }, 3683: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.allowTrust = function(m) {
          if (!r.StrKey.isValidEd25519PublicKey(m.trustor)) throw new Error("trustor is invalid");
          var g = {};
          if (g.trustor = f.Keypair.fromPublicKey(m.trustor).xdrAccountId(), m.assetCode.length <= 4) {
            var a = m.assetCode.padEnd(4, "\0");
            g.asset = h.default.AssetCode.assetTypeCreditAlphanum4(a);
          } else {
            if (!(m.assetCode.length <= 12)) throw new Error("Asset code must be 12 characters at max.");
            var l = m.assetCode.padEnd(12, "\0");
            g.asset = h.default.AssetCode.assetTypeCreditAlphanum12(l);
          }
          typeof m.authorize == "boolean" ? m.authorize ? g.authorize = h.default.TrustLineFlags.authorizedFlag().value : g.authorize = 0 : g.authorize = m.authorize;
          var d = new h.default.AllowTrustOp(g), b = {};
          return b.body = h.default.OperationBody.allowTrust(d), this.setSourceAccount(b, m), new h.default.Operation(b);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6691), r = u(7120);
      }, 3737: (t, o, u) => {
        var c = u(6698), h = u(392), f = u(2861).Buffer, r = [1518500249, 1859775393, -1894007588, -899497514], m = new Array(80);
        function g() {
          this.init(), this._w = m, h.call(this, 64, 56);
        }
        function a(b) {
          return b << 5 | b >>> 27;
        }
        function l(b) {
          return b << 30 | b >>> 2;
        }
        function d(b, S, E, R) {
          return b === 0 ? S & E | ~S & R : b === 2 ? S & E | S & R | E & R : S ^ E ^ R;
        }
        c(g, h), g.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, g.prototype._update = function(b) {
          for (var S, E = this._w, R = 0 | this._a, k = 0 | this._b, w = 0 | this._c, F = 0 | this._d, I = 0 | this._e, q = 0; q < 16; ++q) E[q] = b.readInt32BE(4 * q);
          for (; q < 80; ++q) E[q] = (S = E[q - 3] ^ E[q - 8] ^ E[q - 14] ^ E[q - 16]) << 1 | S >>> 31;
          for (var D = 0; D < 80; ++D) {
            var H = ~~(D / 20), _ = a(R) + d(H, k, w, F) + I + E[D] + r[H] | 0;
            I = F, F = w, w = l(k), k = R, R = _;
          }
          this._a = R + this._a | 0, this._b = k + this._b | 0, this._c = w + this._c | 0, this._d = F + this._d | 0, this._e = I + this._e | 0;
        }, g.prototype._hash = function() {
          var b = f.allocUnsafe(20);
          return b.writeInt32BE(0 | this._a, 0), b.writeInt32BE(0 | this._b, 4), b.writeInt32BE(0 | this._c, 8), b.writeInt32BE(0 | this._d, 12), b.writeInt32BE(0 | this._e, 16), b;
        }, t.exports = g;
      }, 3740: function(t) {
        var o;
        o = () => (() => {
          var u = { 616: (f, r, m) => {
            m.d(r, { A: () => a });
            var g = m(287);
            g.hp.alloc(1).subarray(0, 1) instanceof g.hp || (g.hp.prototype.subarray = function(l, d) {
              const b = Uint8Array.prototype.subarray.call(this, l, d);
              return Object.setPrototypeOf(b, g.hp.prototype), b;
            });
            const a = g.hp;
          }, 281: (f, r, m) => {
            const g = m(164);
            f.exports = g;
          }, 164: (f, r, m) => {
            m.r(r), m.d(r, { Array: () => pe, Bool: () => ce, Double: () => $, Enum: () => _e, Float: () => ie, Hyper: () => K, Int: () => z, LargeInt: () => G, Opaque: () => ne, Option: () => xe, Quadruple: () => oe, Reference: () => Be, String: () => ae, Struct: () => Qe, Union: () => P, UnsignedHyper: () => Z, UnsignedInt: () => B, VarArray: () => Oe, VarOpaque: () => Te, Void: () => Ve, XdrReader: () => S, XdrWriter: () => k, config: () => Q });
            class g extends TypeError {
              constructor(X) {
                super(`XDR Write Error: ${X}`);
              }
            }
            class a extends TypeError {
              constructor(X) {
                super(`XDR Read Error: ${X}`);
              }
            }
            class l extends TypeError {
              constructor(X) {
                super(`XDR Type Definition Error: ${X}`);
              }
            }
            class d extends l {
              constructor() {
                super("method not implemented, it should be overloaded in the descendant class.");
              }
            }
            var b = m(616).A;
            class S {
              constructor(X) {
                __publicField(this, "_buffer");
                __publicField(this, "_length");
                __publicField(this, "_index");
                if (!b.isBuffer(X)) {
                  if (!(X instanceof Array || Array.isArray(X) || ArrayBuffer.isView(X))) throw new a(`source invalid: ${X}`);
                  X = b.from(X);
                }
                this._buffer = X, this._length = X.length, this._index = 0;
              }
              get eof() {
                return this._index === this._length;
              }
              advance(X) {
                const de = this._index;
                if (this._index += X, this._length < this._index) throw new a("attempt to read outside the boundary of the buffer");
                const tt = 4 - (X % 4 || 4);
                if (tt > 0) {
                  for (let Ne = 0; Ne < tt; Ne++) if (this._buffer[this._index + Ne] !== 0) throw new a("invalid padding");
                  this._index += tt;
                }
                return de;
              }
              rewind() {
                this._index = 0;
              }
              read(X) {
                const de = this.advance(X);
                return this._buffer.subarray(de, de + X);
              }
              readInt32BE() {
                return this._buffer.readInt32BE(this.advance(4));
              }
              readUInt32BE() {
                return this._buffer.readUInt32BE(this.advance(4));
              }
              readBigInt64BE() {
                return this._buffer.readBigInt64BE(this.advance(8));
              }
              readBigUInt64BE() {
                return this._buffer.readBigUInt64BE(this.advance(8));
              }
              readFloatBE() {
                return this._buffer.readFloatBE(this.advance(4));
              }
              readDoubleBE() {
                return this._buffer.readDoubleBE(this.advance(8));
              }
              ensureInputConsumed() {
                if (this._index !== this._length) throw new a("invalid XDR contract typecast - source buffer not entirely consumed");
              }
            }
            var E = m(616).A;
            const R = 8192;
            class k {
              constructor(X) {
                __publicField(this, "_buffer");
                __publicField(this, "_length");
                __publicField(this, "_index", 0);
                typeof X == "number" ? X = E.allocUnsafe(X) : X instanceof E || (X = E.allocUnsafe(R)), this._buffer = X, this._length = X.length;
              }
              alloc(X) {
                const de = this._index;
                return this._index += X, this._length < this._index && this.resize(this._index), de;
              }
              resize(X) {
                const de = Math.ceil(X / R) * R, tt = E.allocUnsafe(de);
                this._buffer.copy(tt, 0, 0, this._length), this._buffer = tt, this._length = de;
              }
              finalize() {
                return this._buffer.subarray(0, this._index);
              }
              toArray() {
                return [...this.finalize()];
              }
              write(X, de) {
                if (typeof X == "string") {
                  const Ne = this.alloc(de);
                  this._buffer.write(X, Ne, "utf8");
                } else {
                  X instanceof E || (X = E.from(X));
                  const Ne = this.alloc(de);
                  X.copy(this._buffer, Ne, 0, de);
                }
                const tt = 4 - (de % 4 || 4);
                if (tt > 0) {
                  const Ne = this.alloc(tt);
                  this._buffer.fill(0, Ne, this._index);
                }
              }
              writeInt32BE(X) {
                const de = this.alloc(4);
                this._buffer.writeInt32BE(X, de);
              }
              writeUInt32BE(X) {
                const de = this.alloc(4);
                this._buffer.writeUInt32BE(X, de);
              }
              writeBigInt64BE(X) {
                const de = this.alloc(8);
                this._buffer.writeBigInt64BE(X, de);
              }
              writeBigUInt64BE(X) {
                const de = this.alloc(8);
                this._buffer.writeBigUInt64BE(X, de);
              }
              writeFloatBE(X) {
                const de = this.alloc(4);
                this._buffer.writeFloatBE(X, de);
              }
              writeDoubleBE(X) {
                const de = this.alloc(8);
                this._buffer.writeDoubleBE(X, de);
              }
            }
            __publicField(k, "bufferChunkSize", R);
            var w = m(616).A;
            class F {
              toXDR(X = "raw") {
                if (!this.write) return this.constructor.toXDR(this, X);
                const de = new k();
                return this.write(this, de), H(de.finalize(), X);
              }
              fromXDR(X, de = "raw") {
                if (!this.read) return this.constructor.fromXDR(X, de);
                const tt = new S(_(X, de)), Ne = this.read(tt);
                return tt.ensureInputConsumed(), Ne;
              }
              validateXDR(X, de = "raw") {
                try {
                  return this.fromXDR(X, de), true;
                } catch {
                  return false;
                }
              }
              static toXDR(X, de = "raw") {
                const tt = new k();
                return this.write(X, tt), H(tt.finalize(), de);
              }
              static fromXDR(X, de = "raw") {
                const tt = new S(_(X, de)), Ne = this.read(tt);
                return tt.ensureInputConsumed(), Ne;
              }
              static validateXDR(X, de = "raw") {
                try {
                  return this.fromXDR(X, de), true;
                } catch {
                  return false;
                }
              }
            }
            class I extends F {
              static read(X) {
                throw new d();
              }
              static write(X, de) {
                throw new d();
              }
              static isValid(X) {
                return false;
              }
            }
            class q extends F {
              isValid(X) {
                return false;
              }
            }
            class D extends TypeError {
              constructor(X) {
                super(`Invalid format ${X}, must be one of "raw", "hex", "base64"`);
              }
            }
            function H(se, X) {
              switch (X) {
                case "raw":
                  return se;
                case "hex":
                  return se.toString("hex");
                case "base64":
                  return se.toString("base64");
                default:
                  throw new D(X);
              }
            }
            function _(se, X) {
              switch (X) {
                case "raw":
                  return se;
                case "hex":
                  return w.from(se, "hex");
                case "base64":
                  return w.from(se, "base64");
                default:
                  throw new D(X);
              }
            }
            function T(se, X) {
              return se != null && (se instanceof X || L(se, X) && typeof se.constructor.read == "function" && typeof se.constructor.write == "function" && L(se, "XdrType"));
            }
            function L(se, X) {
              do
                if (se.constructor.name === X) return true;
              while (se = Object.getPrototypeOf(se));
              return false;
            }
            const j = 2147483647;
            class z extends I {
              static read(X) {
                return X.readInt32BE();
              }
              static write(X, de) {
                if (typeof X != "number") throw new g("not a number");
                if ((0 | X) !== X) throw new g("invalid i32 value");
                de.writeInt32BE(X);
              }
              static isValid(X) {
                return typeof X == "number" && (0 | X) === X && X >= -2147483648 && X <= j;
              }
            }
            function Y(se, X, de) {
              if (typeof se != "bigint") throw new TypeError("Expected bigint 'value', got " + typeof se);
              const tt = X / de;
              if (tt === 1) return [se];
              if (de < 32 || de > 128 || tt !== 2 && tt !== 4 && tt !== 8) throw new TypeError(`invalid bigint (${se}) and slice size (${X} -> ${de}) combination`);
              const Ne = BigInt(de), ut = new Array(tt);
              for (let Ze = 0; Ze < tt; Ze++) ut[Ze] = BigInt.asIntN(de, se), se >>= Ne;
              return ut;
            }
            function te(se, X) {
              if (X) return [0n, (1n << BigInt(se)) - 1n];
              const de = 1n << BigInt(se - 1);
              return [0n - de, de - 1n];
            }
            z.MAX_VALUE = j, z.MIN_VALUE = 2147483648;
            class G extends I {
              constructor(X) {
                super(), this._value = function(de, tt, Ne) {
                  de instanceof Array ? de.length && de[0] instanceof Array && (de = de[0]) : de = [de];
                  const ut = tt / de.length;
                  switch (ut) {
                    case 32:
                    case 64:
                    case 128:
                    case 256:
                      break;
                    default:
                      throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${de}`);
                  }
                  try {
                    for (let je = 0; je < de.length; je++) typeof de[je] != "bigint" && (de[je] = BigInt(de[je].valueOf()));
                  } catch (je) {
                    throw new TypeError(`expected bigint-like values, got: ${de} (${je})`);
                  }
                  if (Ne && de.length === 1 && de[0] < 0n) throw new RangeError(`expected a positive value, got: ${de}`);
                  let Ze = BigInt.asUintN(ut, de[0]);
                  for (let je = 1; je < de.length; je++) Ze |= BigInt.asUintN(ut, de[je]) << BigInt(je * ut);
                  Ne || (Ze = BigInt.asIntN(tt, Ze));
                  const [Et, rr] = te(tt, Ne);
                  if (Ze >= Et && Ze <= rr) return Ze;
                  throw new TypeError(`bigint values [${de}] for ${function(je, Ge) {
                    return `${Ge ? "u" : "i"}${je}`;
                  }(tt, Ne)} out of range [${Et}, ${rr}]: ${Ze}`);
                }(X, this.size, this.unsigned);
              }
              get unsigned() {
                throw new d();
              }
              get size() {
                throw new d();
              }
              slice(X) {
                return Y(this._value, this.size, X);
              }
              toString() {
                return this._value.toString();
              }
              toJSON() {
                return { _value: this._value.toString() };
              }
              toBigInt() {
                return BigInt(this._value);
              }
              static read(X) {
                const { size: de } = this.prototype;
                return de === 64 ? new this(X.readBigUInt64BE()) : new this(...Array.from({ length: de / 64 }, () => X.readBigUInt64BE()).reverse());
              }
              static write(X, de) {
                if (X instanceof this) X = X._value;
                else if (typeof X != "bigint" || X > this.MAX_VALUE || X < this.MIN_VALUE) throw new g(`${X} is not a ${this.name}`);
                const { unsigned: tt, size: Ne } = this.prototype;
                if (Ne === 64) tt ? de.writeBigUInt64BE(X) : de.writeBigInt64BE(X);
                else for (const ut of Y(X, Ne, 64).reverse()) tt ? de.writeBigUInt64BE(ut) : de.writeBigInt64BE(ut);
              }
              static isValid(X) {
                return typeof X == "bigint" || X instanceof this;
              }
              static fromString(X) {
                return new this(X);
              }
              static defineIntBoundaries() {
                const [X, de] = te(this.prototype.size, this.prototype.unsigned);
                this.MIN_VALUE = X, this.MAX_VALUE = de;
              }
            }
            __publicField(G, "MAX_VALUE", 0n);
            __publicField(G, "MIN_VALUE", 0n);
            class K extends G {
              constructor(...X) {
                super(X);
              }
              get low() {
                return 0 | Number(0xffffffffn & this._value);
              }
              get high() {
                return 0 | Number(this._value >> 32n);
              }
              get size() {
                return 64;
              }
              get unsigned() {
                return false;
              }
              static fromBits(X, de) {
                return new this(X, de);
              }
            }
            K.defineIntBoundaries();
            const J = 4294967295;
            class B extends I {
              static read(X) {
                return X.readUInt32BE();
              }
              static write(X, de) {
                if (typeof X != "number" || !(X >= 0 && X <= J) || X % 1 != 0) throw new g("invalid u32 value");
                de.writeUInt32BE(X);
              }
              static isValid(X) {
                return typeof X == "number" && X % 1 == 0 && X >= 0 && X <= J;
              }
            }
            B.MAX_VALUE = J, B.MIN_VALUE = 0;
            class Z extends G {
              constructor(...X) {
                super(X);
              }
              get low() {
                return 0 | Number(0xffffffffn & this._value);
              }
              get high() {
                return 0 | Number(this._value >> 32n);
              }
              get size() {
                return 64;
              }
              get unsigned() {
                return true;
              }
              static fromBits(X, de) {
                return new this(X, de);
              }
            }
            Z.defineIntBoundaries();
            class ie extends I {
              static read(X) {
                return X.readFloatBE();
              }
              static write(X, de) {
                if (typeof X != "number") throw new g("not a number");
                de.writeFloatBE(X);
              }
              static isValid(X) {
                return typeof X == "number";
              }
            }
            class $ extends I {
              static read(X) {
                return X.readDoubleBE();
              }
              static write(X, de) {
                if (typeof X != "number") throw new g("not a number");
                de.writeDoubleBE(X);
              }
              static isValid(X) {
                return typeof X == "number";
              }
            }
            class oe extends I {
              static read() {
                throw new l("quadruple not supported");
              }
              static write() {
                throw new l("quadruple not supported");
              }
              static isValid() {
                return false;
              }
            }
            class ce extends I {
              static read(X) {
                const de = z.read(X);
                switch (de) {
                  case 0:
                    return false;
                  case 1:
                    return true;
                  default:
                    throw new a(`got ${de} when trying to read a bool`);
                }
              }
              static write(X, de) {
                const tt = X ? 1 : 0;
                z.write(tt, de);
              }
              static isValid(X) {
                return typeof X == "boolean";
              }
            }
            var ye = m(616).A;
            class ae extends q {
              constructor(X = B.MAX_VALUE) {
                super(), this._maxLength = X;
              }
              read(X) {
                const de = B.read(X);
                if (de > this._maxLength) throw new a(`saw ${de} length String, max allowed is ${this._maxLength}`);
                return X.read(de);
              }
              readString(X) {
                return this.read(X).toString("utf8");
              }
              write(X, de) {
                const tt = typeof X == "string" ? ye.byteLength(X, "utf8") : X.length;
                if (tt > this._maxLength) throw new g(`got ${X.length} bytes, max allowed is ${this._maxLength}`);
                B.write(tt, de), de.write(X, tt);
              }
              isValid(X) {
                return typeof X == "string" ? ye.byteLength(X, "utf8") <= this._maxLength : !!(X instanceof Array || ye.isBuffer(X)) && X.length <= this._maxLength;
              }
            }
            var ue = m(616).A;
            class ne extends q {
              constructor(X) {
                super(), this._length = X;
              }
              read(X) {
                return X.read(this._length);
              }
              write(X, de) {
                const { length: tt } = X;
                if (tt !== this._length) throw new g(`got ${X.length} bytes, expected ${this._length}`);
                de.write(X, tt);
              }
              isValid(X) {
                return ue.isBuffer(X) && X.length === this._length;
              }
            }
            var ge = m(616).A;
            class Te extends q {
              constructor(X = B.MAX_VALUE) {
                super(), this._maxLength = X;
              }
              read(X) {
                const de = B.read(X);
                if (de > this._maxLength) throw new a(`saw ${de} length VarOpaque, max allowed is ${this._maxLength}`);
                return X.read(de);
              }
              write(X, de) {
                const { length: tt } = X;
                if (X.length > this._maxLength) throw new g(`got ${X.length} bytes, max allowed is ${this._maxLength}`);
                B.write(tt, de), de.write(X, tt);
              }
              isValid(X) {
                return ge.isBuffer(X) && X.length <= this._maxLength;
              }
            }
            class pe extends q {
              constructor(X, de) {
                super(), this._childType = X, this._length = de;
              }
              read(X) {
                const de = new m.g.Array(this._length);
                for (let tt = 0; tt < this._length; tt++) de[tt] = this._childType.read(X);
                return de;
              }
              write(X, de) {
                if (!m.g.Array.isArray(X)) throw new g("value is not array");
                if (X.length !== this._length) throw new g(`got array of size ${X.length}, expected ${this._length}`);
                for (const tt of X) this._childType.write(tt, de);
              }
              isValid(X) {
                if (!(X instanceof m.g.Array) || X.length !== this._length) return false;
                for (const de of X) if (!this._childType.isValid(de)) return false;
                return true;
              }
            }
            class Oe extends q {
              constructor(X, de = B.MAX_VALUE) {
                super(), this._childType = X, this._maxLength = de;
              }
              read(X) {
                const de = B.read(X);
                if (de > this._maxLength) throw new a(`saw ${de} length VarArray, max allowed is ${this._maxLength}`);
                const tt = new Array(de);
                for (let Ne = 0; Ne < de; Ne++) tt[Ne] = this._childType.read(X);
                return tt;
              }
              write(X, de) {
                if (!(X instanceof Array)) throw new g("value is not array");
                if (X.length > this._maxLength) throw new g(`got array of size ${X.length}, max allowed is ${this._maxLength}`);
                B.write(X.length, de);
                for (const tt of X) this._childType.write(tt, de);
              }
              isValid(X) {
                if (!(X instanceof Array) || X.length > this._maxLength) return false;
                for (const de of X) if (!this._childType.isValid(de)) return false;
                return true;
              }
            }
            class xe extends I {
              constructor(X) {
                super(), this._childType = X;
              }
              read(X) {
                if (ce.read(X)) return this._childType.read(X);
              }
              write(X, de) {
                const tt = X != null;
                ce.write(tt, de), tt && this._childType.write(X, de);
              }
              isValid(X) {
                return X == null || this._childType.isValid(X);
              }
            }
            class Ve extends I {
              static read() {
              }
              static write(X) {
                if (X !== void 0) throw new g("trying to write value to a void slot");
              }
              static isValid(X) {
                return X === void 0;
              }
            }
            class _e extends I {
              constructor(X, de) {
                super(), this.name = X, this.value = de;
              }
              static read(X) {
                const de = z.read(X), tt = this._byValue[de];
                if (tt === void 0) throw new a(`unknown ${this.enumName} member for value ${de}`);
                return tt;
              }
              static write(X, de) {
                if (!this.isValid(X)) throw new g(`${X} has enum name ${X == null ? void 0 : X.enumName}, not ${this.enumName}: ${JSON.stringify(X)}`);
                z.write(X.value, de);
              }
              static isValid(X) {
                var _a2;
                return ((_a2 = X == null ? void 0 : X.constructor) == null ? void 0 : _a2.enumName) === this.enumName || T(X, this);
              }
              static members() {
                return this._members;
              }
              static values() {
                return Object.values(this._members);
              }
              static fromName(X) {
                const de = this._members[X];
                if (!de) throw new TypeError(`${X} is not a member of ${this.enumName}`);
                return de;
              }
              static fromValue(X) {
                const de = this._byValue[X];
                if (de === void 0) throw new TypeError(`${X} is not a value of any member of ${this.enumName}`);
                return de;
              }
              static create(X, de, tt) {
                const Ne = class extends _e {
                };
                Ne.enumName = de, X.results[de] = Ne, Ne._members = {}, Ne._byValue = {};
                for (const [ut, Ze] of Object.entries(tt)) {
                  const Et = new Ne(ut, Ze);
                  Ne._members[ut] = Et, Ne._byValue[Ze] = Et, Ne[ut] = () => Et;
                }
                return Ne;
              }
            }
            class Be extends I {
              resolve() {
                throw new l('"resolve" method should be implemented in the descendant class');
              }
            }
            class Qe extends q {
              constructor(X) {
                super(), this._attributes = X || {};
              }
              static read(X) {
                const de = {};
                for (const [tt, Ne] of this._fields) de[tt] = Ne.read(X);
                return new this(de);
              }
              static write(X, de) {
                var _a2;
                if (!this.isValid(X)) throw new g(`${X} has struct name ${(_a2 = X == null ? void 0 : X.constructor) == null ? void 0 : _a2.structName}, not ${this.structName}: ${JSON.stringify(X)}`);
                for (const [tt, Ne] of this._fields) {
                  const ut = X._attributes[tt];
                  Ne.write(ut, de);
                }
              }
              static isValid(X) {
                var _a2;
                return ((_a2 = X == null ? void 0 : X.constructor) == null ? void 0 : _a2.structName) === this.structName || T(X, this);
              }
              static create(X, de, tt) {
                const Ne = class extends Qe {
                };
                Ne.structName = de, X.results[de] = Ne;
                const ut = new Array(tt.length);
                for (let Ze = 0; Ze < tt.length; Ze++) {
                  const Et = tt[Ze], rr = Et[0];
                  let je = Et[1];
                  je instanceof Be && (je = je.resolve(X)), ut[Ze] = [rr, je], Ne.prototype[rr] = ee(rr);
                }
                return Ne._fields = ut, Ne;
              }
            }
            function ee(se) {
              return function(X) {
                return X !== void 0 && (this._attributes[se] = X), this._attributes[se];
              };
            }
            class P extends q {
              constructor(X, de) {
                super(), this.set(X, de);
              }
              set(X, de) {
                typeof X == "string" && (X = this.constructor._switchOn.fromName(X)), this._switch = X;
                const tt = this.constructor.armForSwitch(this._switch);
                this._arm = tt, this._armType = tt === Ve ? Ve : this.constructor._arms[tt], this._value = de;
              }
              get(X = this._arm) {
                if (this._arm !== Ve && this._arm !== X) throw new TypeError(`${X} not set`);
                return this._value;
              }
              switch() {
                return this._switch;
              }
              arm() {
                return this._arm;
              }
              armType() {
                return this._armType;
              }
              value() {
                return this._value;
              }
              static armForSwitch(X) {
                const de = this._switches.get(X);
                if (de !== void 0) return de;
                if (this._defaultArm) return this._defaultArm;
                throw new TypeError(`Bad union switch: ${X}`);
              }
              static armTypeForArm(X) {
                return X === Ve ? Ve : this._arms[X];
              }
              static read(X) {
                const de = this._switchOn.read(X), tt = this.armForSwitch(de), Ne = tt === Ve ? Ve : this._arms[tt];
                let ut;
                return ut = Ne !== void 0 ? Ne.read(X) : tt.read(X), new this(de, ut);
              }
              static write(X, de) {
                if (!this.isValid(X)) throw new g(`${X} has union name ${X == null ? void 0 : X.unionName}, not ${this.unionName}: ${JSON.stringify(X)}`);
                this._switchOn.write(X.switch(), de), X.armType().write(X.value(), de);
              }
              static isValid(X) {
                var _a2;
                return ((_a2 = X == null ? void 0 : X.constructor) == null ? void 0 : _a2.unionName) === this.unionName || T(X, this);
              }
              static create(X, de, tt) {
                const Ne = class extends P {
                };
                Ne.unionName = de, X.results[de] = Ne, tt.switchOn instanceof Be ? Ne._switchOn = tt.switchOn.resolve(X) : Ne._switchOn = tt.switchOn, Ne._switches = /* @__PURE__ */ new Map(), Ne._arms = {};
                let ut = tt.defaultArm;
                ut instanceof Be && (ut = ut.resolve(X)), Ne._defaultArm = ut;
                for (const [Ze, Et] of tt.switches) {
                  const rr = typeof Ze == "string" ? Ne._switchOn.fromName(Ze) : Ze;
                  Ne._switches.set(rr, Et);
                }
                if (Ne._switchOn.values !== void 0) for (const Ze of Ne._switchOn.values()) Ne[Ze.name] = function(Et) {
                  return new Ne(Ze, Et);
                }, Ne.prototype[Ze.name] = function(Et) {
                  return this.set(Ze, Et);
                };
                if (tt.arms) for (const [Ze, Et] of Object.entries(tt.arms)) Ne._arms[Ze] = Et instanceof Be ? Et.resolve(X) : Et, Et !== Ve && (Ne.prototype[Ze] = function() {
                  return this.get(Ze);
                });
                return Ne;
              }
            }
            class x extends Be {
              constructor(X) {
                super(), this.name = X;
              }
              resolve(X) {
                return X.definitions[this.name].resolve(X);
              }
            }
            class O extends Be {
              constructor(X, de, tt = false) {
                super(), this.childReference = X, this.length = de, this.variable = tt;
              }
              resolve(X) {
                let de = this.childReference, tt = this.length;
                return de instanceof Be && (de = de.resolve(X)), tt instanceof Be && (tt = tt.resolve(X)), this.variable ? new Oe(de, tt) : new pe(de, tt);
              }
            }
            class V extends Be {
              constructor(X) {
                super(), this.childReference = X, this.name = X.name;
              }
              resolve(X) {
                let de = this.childReference;
                return de instanceof Be && (de = de.resolve(X)), new xe(de);
              }
            }
            class N extends Be {
              constructor(X, de) {
                super(), this.sizedType = X, this.length = de;
              }
              resolve(X) {
                let de = this.length;
                return de instanceof Be && (de = de.resolve(X)), new this.sizedType(de);
              }
            }
            class C {
              constructor(X, de, tt) {
                this.constructor = X, this.name = de, this.config = tt;
              }
              resolve(X) {
                return this.name in X.results ? X.results[this.name] : this.constructor(X, this.name, this.config);
              }
            }
            function p(se, X, de) {
              return de instanceof Be && (de = de.resolve(se)), se.results[X] = de, de;
            }
            function A(se, X, de) {
              return se.results[X] = de, de;
            }
            class U {
              constructor(X) {
                this._destination = X, this._definitions = {};
              }
              enum(X, de) {
                const tt = new C(_e.create, X, de);
                this.define(X, tt);
              }
              struct(X, de) {
                const tt = new C(Qe.create, X, de);
                this.define(X, tt);
              }
              union(X, de) {
                const tt = new C(P.create, X, de);
                this.define(X, tt);
              }
              typedef(X, de) {
                const tt = new C(p, X, de);
                this.define(X, tt);
              }
              const(X, de) {
                const tt = new C(A, X, de);
                this.define(X, tt);
              }
              void() {
                return Ve;
              }
              bool() {
                return ce;
              }
              int() {
                return z;
              }
              hyper() {
                return K;
              }
              uint() {
                return B;
              }
              uhyper() {
                return Z;
              }
              float() {
                return ie;
              }
              double() {
                return $;
              }
              quadruple() {
                return oe;
              }
              string(X) {
                return new N(ae, X);
              }
              opaque(X) {
                return new N(ne, X);
              }
              varOpaque(X) {
                return new N(Te, X);
              }
              array(X, de) {
                return new O(X, de);
              }
              varArray(X, de) {
                return new O(X, de, true);
              }
              option(X) {
                return new V(X);
              }
              define(X, de) {
                if (this._destination[X] !== void 0) throw new l(`${X} is already defined`);
                this._definitions[X] = de;
              }
              lookup(X) {
                return new x(X);
              }
              resolve() {
                for (const X of Object.values(this._definitions)) X.resolve({ definitions: this._definitions, results: this._destination });
              }
            }
            function Q(se, X = {}) {
              if (se) {
                const de = new U(X);
                se(de), de.resolve();
              }
              return X;
            }
          }, 526: (f, r) => {
            r.byteLength = function(E) {
              var R = b(E), k = R[0], w = R[1];
              return 3 * (k + w) / 4 - w;
            }, r.toByteArray = function(E) {
              var R, k, w = b(E), F = w[0], I = w[1], q = new a(function(_, T, L) {
                return 3 * (T + L) / 4 - L;
              }(0, F, I)), D = 0, H = I > 0 ? F - 4 : F;
              for (k = 0; k < H; k += 4) R = g[E.charCodeAt(k)] << 18 | g[E.charCodeAt(k + 1)] << 12 | g[E.charCodeAt(k + 2)] << 6 | g[E.charCodeAt(k + 3)], q[D++] = R >> 16 & 255, q[D++] = R >> 8 & 255, q[D++] = 255 & R;
              return I === 2 && (R = g[E.charCodeAt(k)] << 2 | g[E.charCodeAt(k + 1)] >> 4, q[D++] = 255 & R), I === 1 && (R = g[E.charCodeAt(k)] << 10 | g[E.charCodeAt(k + 1)] << 4 | g[E.charCodeAt(k + 2)] >> 2, q[D++] = R >> 8 & 255, q[D++] = 255 & R), q;
            }, r.fromByteArray = function(E) {
              for (var R, k = E.length, w = k % 3, F = [], I = 16383, q = 0, D = k - w; q < D; q += I) F.push(S(E, q, q + I > D ? D : q + I));
              return w === 1 ? (R = E[k - 1], F.push(m[R >> 2] + m[R << 4 & 63] + "==")) : w === 2 && (R = (E[k - 2] << 8) + E[k - 1], F.push(m[R >> 10] + m[R >> 4 & 63] + m[R << 2 & 63] + "=")), F.join("");
            };
            for (var m = [], g = [], a = typeof Uint8Array < "u" ? Uint8Array : Array, l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", d = 0; d < 64; ++d) m[d] = l[d], g[l.charCodeAt(d)] = d;
            function b(E) {
              var R = E.length;
              if (R % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
              var k = E.indexOf("=");
              return k === -1 && (k = R), [k, k === R ? 0 : 4 - k % 4];
            }
            function S(E, R, k) {
              for (var w, F, I = [], q = R; q < k; q += 3) w = (E[q] << 16 & 16711680) + (E[q + 1] << 8 & 65280) + (255 & E[q + 2]), I.push(m[(F = w) >> 18 & 63] + m[F >> 12 & 63] + m[F >> 6 & 63] + m[63 & F]);
              return I.join("");
            }
            g[45] = 62, g[95] = 63;
          }, 287: (f, r, m) => {
            const g = m(526), a = m(251), l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.hp = S, r.IS = 50;
            const d = 2147483647;
            function b(p) {
              if (p > d) throw new RangeError('The value "' + p + '" is invalid for option "size"');
              const A = new Uint8Array(p);
              return Object.setPrototypeOf(A, S.prototype), A;
            }
            function S(p, A, U) {
              if (typeof p == "number") {
                if (typeof A == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
                return k(p);
              }
              return E(p, A, U);
            }
            function E(p, A, U) {
              if (typeof p == "string") return function(X, de) {
                if (typeof de == "string" && de !== "" || (de = "utf8"), !S.isEncoding(de)) throw new TypeError("Unknown encoding: " + de);
                const tt = 0 | q(X, de);
                let Ne = b(tt);
                const ut = Ne.write(X, de);
                return ut !== tt && (Ne = Ne.slice(0, ut)), Ne;
              }(p, A);
              if (ArrayBuffer.isView(p)) return function(X) {
                if (x(X, Uint8Array)) {
                  const de = new Uint8Array(X);
                  return F(de.buffer, de.byteOffset, de.byteLength);
                }
                return w(X);
              }(p);
              if (p == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p);
              if (x(p, ArrayBuffer) || p && x(p.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (x(p, SharedArrayBuffer) || p && x(p.buffer, SharedArrayBuffer))) return F(p, A, U);
              if (typeof p == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
              const Q = p.valueOf && p.valueOf();
              if (Q != null && Q !== p) return S.from(Q, A, U);
              const se = function(X) {
                if (S.isBuffer(X)) {
                  const de = 0 | I(X.length), tt = b(de);
                  return tt.length === 0 || X.copy(tt, 0, 0, de), tt;
                }
                return X.length !== void 0 ? typeof X.length != "number" || O(X.length) ? b(0) : w(X) : X.type === "Buffer" && Array.isArray(X.data) ? w(X.data) : void 0;
              }(p);
              if (se) return se;
              if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof p[Symbol.toPrimitive] == "function") return S.from(p[Symbol.toPrimitive]("string"), A, U);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof p);
            }
            function R(p) {
              if (typeof p != "number") throw new TypeError('"size" argument must be of type number');
              if (p < 0) throw new RangeError('The value "' + p + '" is invalid for option "size"');
            }
            function k(p) {
              return R(p), b(p < 0 ? 0 : 0 | I(p));
            }
            function w(p) {
              const A = p.length < 0 ? 0 : 0 | I(p.length), U = b(A);
              for (let Q = 0; Q < A; Q += 1) U[Q] = 255 & p[Q];
              return U;
            }
            function F(p, A, U) {
              if (A < 0 || p.byteLength < A) throw new RangeError('"offset" is outside of buffer bounds');
              if (p.byteLength < A + (U || 0)) throw new RangeError('"length" is outside of buffer bounds');
              let Q;
              return Q = A === void 0 && U === void 0 ? new Uint8Array(p) : U === void 0 ? new Uint8Array(p, A) : new Uint8Array(p, A, U), Object.setPrototypeOf(Q, S.prototype), Q;
            }
            function I(p) {
              if (p >= d) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + d.toString(16) + " bytes");
              return 0 | p;
            }
            function q(p, A) {
              if (S.isBuffer(p)) return p.length;
              if (ArrayBuffer.isView(p) || x(p, ArrayBuffer)) return p.byteLength;
              if (typeof p != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof p);
              const U = p.length, Q = arguments.length > 2 && arguments[2] === true;
              if (!Q && U === 0) return 0;
              let se = false;
              for (; ; ) switch (A) {
                case "ascii":
                case "latin1":
                case "binary":
                  return U;
                case "utf8":
                case "utf-8":
                  return Qe(p).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * U;
                case "hex":
                  return U >>> 1;
                case "base64":
                  return ee(p).length;
                default:
                  if (se) return Q ? -1 : Qe(p).length;
                  A = ("" + A).toLowerCase(), se = true;
              }
            }
            function D(p, A, U) {
              let Q = false;
              if ((A === void 0 || A < 0) && (A = 0), A > this.length || ((U === void 0 || U > this.length) && (U = this.length), U <= 0) || (U >>>= 0) <= (A >>>= 0)) return "";
              for (p || (p = "utf8"); ; ) switch (p) {
                case "hex":
                  return ie(this, A, U);
                case "utf8":
                case "utf-8":
                  return K(this, A, U);
                case "ascii":
                  return B(this, A, U);
                case "latin1":
                case "binary":
                  return Z(this, A, U);
                case "base64":
                  return G(this, A, U);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return $(this, A, U);
                default:
                  if (Q) throw new TypeError("Unknown encoding: " + p);
                  p = (p + "").toLowerCase(), Q = true;
              }
            }
            function H(p, A, U) {
              const Q = p[A];
              p[A] = p[U], p[U] = Q;
            }
            function _(p, A, U, Q, se) {
              if (p.length === 0) return -1;
              if (typeof U == "string" ? (Q = U, U = 0) : U > 2147483647 ? U = 2147483647 : U < -2147483648 && (U = -2147483648), O(U = +U) && (U = se ? 0 : p.length - 1), U < 0 && (U = p.length + U), U >= p.length) {
                if (se) return -1;
                U = p.length - 1;
              } else if (U < 0) {
                if (!se) return -1;
                U = 0;
              }
              if (typeof A == "string" && (A = S.from(A, Q)), S.isBuffer(A)) return A.length === 0 ? -1 : T(p, A, U, Q, se);
              if (typeof A == "number") return A &= 255, typeof Uint8Array.prototype.indexOf == "function" ? se ? Uint8Array.prototype.indexOf.call(p, A, U) : Uint8Array.prototype.lastIndexOf.call(p, A, U) : T(p, [A], U, Q, se);
              throw new TypeError("val must be string, number or Buffer");
            }
            function T(p, A, U, Q, se) {
              let X, de = 1, tt = p.length, Ne = A.length;
              if (Q !== void 0 && ((Q = String(Q).toLowerCase()) === "ucs2" || Q === "ucs-2" || Q === "utf16le" || Q === "utf-16le")) {
                if (p.length < 2 || A.length < 2) return -1;
                de = 2, tt /= 2, Ne /= 2, U /= 2;
              }
              function ut(Ze, Et) {
                return de === 1 ? Ze[Et] : Ze.readUInt16BE(Et * de);
              }
              if (se) {
                let Ze = -1;
                for (X = U; X < tt; X++) if (ut(p, X) === ut(A, Ze === -1 ? 0 : X - Ze)) {
                  if (Ze === -1 && (Ze = X), X - Ze + 1 === Ne) return Ze * de;
                } else Ze !== -1 && (X -= X - Ze), Ze = -1;
              } else for (U + Ne > tt && (U = tt - Ne), X = U; X >= 0; X--) {
                let Ze = true;
                for (let Et = 0; Et < Ne; Et++) if (ut(p, X + Et) !== ut(A, Et)) {
                  Ze = false;
                  break;
                }
                if (Ze) return X;
              }
              return -1;
            }
            function L(p, A, U, Q) {
              U = Number(U) || 0;
              const se = p.length - U;
              Q ? (Q = Number(Q)) > se && (Q = se) : Q = se;
              const X = A.length;
              let de;
              for (Q > X / 2 && (Q = X / 2), de = 0; de < Q; ++de) {
                const tt = parseInt(A.substr(2 * de, 2), 16);
                if (O(tt)) return de;
                p[U + de] = tt;
              }
              return de;
            }
            function j(p, A, U, Q) {
              return P(Qe(A, p.length - U), p, U, Q);
            }
            function z(p, A, U, Q) {
              return P(function(se) {
                const X = [];
                for (let de = 0; de < se.length; ++de) X.push(255 & se.charCodeAt(de));
                return X;
              }(A), p, U, Q);
            }
            function Y(p, A, U, Q) {
              return P(ee(A), p, U, Q);
            }
            function te(p, A, U, Q) {
              return P(function(se, X) {
                let de, tt, Ne;
                const ut = [];
                for (let Ze = 0; Ze < se.length && !((X -= 2) < 0); ++Ze) de = se.charCodeAt(Ze), tt = de >> 8, Ne = de % 256, ut.push(Ne), ut.push(tt);
                return ut;
              }(A, p.length - U), p, U, Q);
            }
            function G(p, A, U) {
              return A === 0 && U === p.length ? g.fromByteArray(p) : g.fromByteArray(p.slice(A, U));
            }
            function K(p, A, U) {
              U = Math.min(p.length, U);
              const Q = [];
              let se = A;
              for (; se < U; ) {
                const X = p[se];
                let de = null, tt = X > 239 ? 4 : X > 223 ? 3 : X > 191 ? 2 : 1;
                if (se + tt <= U) {
                  let Ne, ut, Ze, Et;
                  switch (tt) {
                    case 1:
                      X < 128 && (de = X);
                      break;
                    case 2:
                      Ne = p[se + 1], (192 & Ne) == 128 && (Et = (31 & X) << 6 | 63 & Ne, Et > 127 && (de = Et));
                      break;
                    case 3:
                      Ne = p[se + 1], ut = p[se + 2], (192 & Ne) == 128 && (192 & ut) == 128 && (Et = (15 & X) << 12 | (63 & Ne) << 6 | 63 & ut, Et > 2047 && (Et < 55296 || Et > 57343) && (de = Et));
                      break;
                    case 4:
                      Ne = p[se + 1], ut = p[se + 2], Ze = p[se + 3], (192 & Ne) == 128 && (192 & ut) == 128 && (192 & Ze) == 128 && (Et = (15 & X) << 18 | (63 & Ne) << 12 | (63 & ut) << 6 | 63 & Ze, Et > 65535 && Et < 1114112 && (de = Et));
                  }
                }
                de === null ? (de = 65533, tt = 1) : de > 65535 && (de -= 65536, Q.push(de >>> 10 & 1023 | 55296), de = 56320 | 1023 & de), Q.push(de), se += tt;
              }
              return function(X) {
                const de = X.length;
                if (de <= J) return String.fromCharCode.apply(String, X);
                let tt = "", Ne = 0;
                for (; Ne < de; ) tt += String.fromCharCode.apply(String, X.slice(Ne, Ne += J));
                return tt;
              }(Q);
            }
            S.TYPED_ARRAY_SUPPORT = function() {
              try {
                const p = new Uint8Array(1), A = { foo: function() {
                  return 42;
                } };
                return Object.setPrototypeOf(A, Uint8Array.prototype), Object.setPrototypeOf(p, A), p.foo() === 42;
              } catch {
                return false;
              }
            }(), S.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(S.prototype, "parent", { enumerable: true, get: function() {
              if (S.isBuffer(this)) return this.buffer;
            } }), Object.defineProperty(S.prototype, "offset", { enumerable: true, get: function() {
              if (S.isBuffer(this)) return this.byteOffset;
            } }), S.poolSize = 8192, S.from = function(p, A, U) {
              return E(p, A, U);
            }, Object.setPrototypeOf(S.prototype, Uint8Array.prototype), Object.setPrototypeOf(S, Uint8Array), S.alloc = function(p, A, U) {
              return function(Q, se, X) {
                return R(Q), Q <= 0 ? b(Q) : se !== void 0 ? typeof X == "string" ? b(Q).fill(se, X) : b(Q).fill(se) : b(Q);
              }(p, A, U);
            }, S.allocUnsafe = function(p) {
              return k(p);
            }, S.allocUnsafeSlow = function(p) {
              return k(p);
            }, S.isBuffer = function(p) {
              return p != null && p._isBuffer === true && p !== S.prototype;
            }, S.compare = function(p, A) {
              if (x(p, Uint8Array) && (p = S.from(p, p.offset, p.byteLength)), x(A, Uint8Array) && (A = S.from(A, A.offset, A.byteLength)), !S.isBuffer(p) || !S.isBuffer(A)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (p === A) return 0;
              let U = p.length, Q = A.length;
              for (let se = 0, X = Math.min(U, Q); se < X; ++se) if (p[se] !== A[se]) {
                U = p[se], Q = A[se];
                break;
              }
              return U < Q ? -1 : Q < U ? 1 : 0;
            }, S.isEncoding = function(p) {
              switch (String(p).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, S.concat = function(p, A) {
              if (!Array.isArray(p)) throw new TypeError('"list" argument must be an Array of Buffers');
              if (p.length === 0) return S.alloc(0);
              let U;
              if (A === void 0) for (A = 0, U = 0; U < p.length; ++U) A += p[U].length;
              const Q = S.allocUnsafe(A);
              let se = 0;
              for (U = 0; U < p.length; ++U) {
                let X = p[U];
                if (x(X, Uint8Array)) se + X.length > Q.length ? (S.isBuffer(X) || (X = S.from(X)), X.copy(Q, se)) : Uint8Array.prototype.set.call(Q, X, se);
                else {
                  if (!S.isBuffer(X)) throw new TypeError('"list" argument must be an Array of Buffers');
                  X.copy(Q, se);
                }
                se += X.length;
              }
              return Q;
            }, S.byteLength = q, S.prototype._isBuffer = true, S.prototype.swap16 = function() {
              const p = this.length;
              if (p % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (let A = 0; A < p; A += 2) H(this, A, A + 1);
              return this;
            }, S.prototype.swap32 = function() {
              const p = this.length;
              if (p % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (let A = 0; A < p; A += 4) H(this, A, A + 3), H(this, A + 1, A + 2);
              return this;
            }, S.prototype.swap64 = function() {
              const p = this.length;
              if (p % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (let A = 0; A < p; A += 8) H(this, A, A + 7), H(this, A + 1, A + 6), H(this, A + 2, A + 5), H(this, A + 3, A + 4);
              return this;
            }, S.prototype.toString = function() {
              const p = this.length;
              return p === 0 ? "" : arguments.length === 0 ? K(this, 0, p) : D.apply(this, arguments);
            }, S.prototype.toLocaleString = S.prototype.toString, S.prototype.equals = function(p) {
              if (!S.isBuffer(p)) throw new TypeError("Argument must be a Buffer");
              return this === p || S.compare(this, p) === 0;
            }, S.prototype.inspect = function() {
              let p = "";
              const A = r.IS;
              return p = this.toString("hex", 0, A).replace(/(.{2})/g, "$1 ").trim(), this.length > A && (p += " ... "), "<Buffer " + p + ">";
            }, l && (S.prototype[l] = S.prototype.inspect), S.prototype.compare = function(p, A, U, Q, se) {
              if (x(p, Uint8Array) && (p = S.from(p, p.offset, p.byteLength)), !S.isBuffer(p)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof p);
              if (A === void 0 && (A = 0), U === void 0 && (U = p ? p.length : 0), Q === void 0 && (Q = 0), se === void 0 && (se = this.length), A < 0 || U > p.length || Q < 0 || se > this.length) throw new RangeError("out of range index");
              if (Q >= se && A >= U) return 0;
              if (Q >= se) return -1;
              if (A >= U) return 1;
              if (this === p) return 0;
              let X = (se >>>= 0) - (Q >>>= 0), de = (U >>>= 0) - (A >>>= 0);
              const tt = Math.min(X, de), Ne = this.slice(Q, se), ut = p.slice(A, U);
              for (let Ze = 0; Ze < tt; ++Ze) if (Ne[Ze] !== ut[Ze]) {
                X = Ne[Ze], de = ut[Ze];
                break;
              }
              return X < de ? -1 : de < X ? 1 : 0;
            }, S.prototype.includes = function(p, A, U) {
              return this.indexOf(p, A, U) !== -1;
            }, S.prototype.indexOf = function(p, A, U) {
              return _(this, p, A, U, true);
            }, S.prototype.lastIndexOf = function(p, A, U) {
              return _(this, p, A, U, false);
            }, S.prototype.write = function(p, A, U, Q) {
              if (A === void 0) Q = "utf8", U = this.length, A = 0;
              else if (U === void 0 && typeof A == "string") Q = A, U = this.length, A = 0;
              else {
                if (!isFinite(A)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                A >>>= 0, isFinite(U) ? (U >>>= 0, Q === void 0 && (Q = "utf8")) : (Q = U, U = void 0);
              }
              const se = this.length - A;
              if ((U === void 0 || U > se) && (U = se), p.length > 0 && (U < 0 || A < 0) || A > this.length) throw new RangeError("Attempt to write outside buffer bounds");
              Q || (Q = "utf8");
              let X = false;
              for (; ; ) switch (Q) {
                case "hex":
                  return L(this, p, A, U);
                case "utf8":
                case "utf-8":
                  return j(this, p, A, U);
                case "ascii":
                case "latin1":
                case "binary":
                  return z(this, p, A, U);
                case "base64":
                  return Y(this, p, A, U);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return te(this, p, A, U);
                default:
                  if (X) throw new TypeError("Unknown encoding: " + Q);
                  Q = ("" + Q).toLowerCase(), X = true;
              }
            }, S.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            const J = 4096;
            function B(p, A, U) {
              let Q = "";
              U = Math.min(p.length, U);
              for (let se = A; se < U; ++se) Q += String.fromCharCode(127 & p[se]);
              return Q;
            }
            function Z(p, A, U) {
              let Q = "";
              U = Math.min(p.length, U);
              for (let se = A; se < U; ++se) Q += String.fromCharCode(p[se]);
              return Q;
            }
            function ie(p, A, U) {
              const Q = p.length;
              (!A || A < 0) && (A = 0), (!U || U < 0 || U > Q) && (U = Q);
              let se = "";
              for (let X = A; X < U; ++X) se += V[p[X]];
              return se;
            }
            function $(p, A, U) {
              const Q = p.slice(A, U);
              let se = "";
              for (let X = 0; X < Q.length - 1; X += 2) se += String.fromCharCode(Q[X] + 256 * Q[X + 1]);
              return se;
            }
            function oe(p, A, U) {
              if (p % 1 != 0 || p < 0) throw new RangeError("offset is not uint");
              if (p + A > U) throw new RangeError("Trying to access beyond buffer length");
            }
            function ce(p, A, U, Q, se, X) {
              if (!S.isBuffer(p)) throw new TypeError('"buffer" argument must be a Buffer instance');
              if (A > se || A < X) throw new RangeError('"value" argument is out of bounds');
              if (U + Q > p.length) throw new RangeError("Index out of range");
            }
            function ye(p, A, U, Q, se) {
              xe(A, Q, se, p, U, 7);
              let X = Number(A & BigInt(4294967295));
              p[U++] = X, X >>= 8, p[U++] = X, X >>= 8, p[U++] = X, X >>= 8, p[U++] = X;
              let de = Number(A >> BigInt(32) & BigInt(4294967295));
              return p[U++] = de, de >>= 8, p[U++] = de, de >>= 8, p[U++] = de, de >>= 8, p[U++] = de, U;
            }
            function ae(p, A, U, Q, se) {
              xe(A, Q, se, p, U, 7);
              let X = Number(A & BigInt(4294967295));
              p[U + 7] = X, X >>= 8, p[U + 6] = X, X >>= 8, p[U + 5] = X, X >>= 8, p[U + 4] = X;
              let de = Number(A >> BigInt(32) & BigInt(4294967295));
              return p[U + 3] = de, de >>= 8, p[U + 2] = de, de >>= 8, p[U + 1] = de, de >>= 8, p[U] = de, U + 8;
            }
            function ue(p, A, U, Q, se, X) {
              if (U + Q > p.length) throw new RangeError("Index out of range");
              if (U < 0) throw new RangeError("Index out of range");
            }
            function ne(p, A, U, Q, se) {
              return A = +A, U >>>= 0, se || ue(p, 0, U, 4), a.write(p, A, U, Q, 23, 4), U + 4;
            }
            function ge(p, A, U, Q, se) {
              return A = +A, U >>>= 0, se || ue(p, 0, U, 8), a.write(p, A, U, Q, 52, 8), U + 8;
            }
            S.prototype.slice = function(p, A) {
              const U = this.length;
              (p = ~~p) < 0 ? (p += U) < 0 && (p = 0) : p > U && (p = U), (A = A === void 0 ? U : ~~A) < 0 ? (A += U) < 0 && (A = 0) : A > U && (A = U), A < p && (A = p);
              const Q = this.subarray(p, A);
              return Object.setPrototypeOf(Q, S.prototype), Q;
            }, S.prototype.readUintLE = S.prototype.readUIntLE = function(p, A, U) {
              p >>>= 0, A >>>= 0, U || oe(p, A, this.length);
              let Q = this[p], se = 1, X = 0;
              for (; ++X < A && (se *= 256); ) Q += this[p + X] * se;
              return Q;
            }, S.prototype.readUintBE = S.prototype.readUIntBE = function(p, A, U) {
              p >>>= 0, A >>>= 0, U || oe(p, A, this.length);
              let Q = this[p + --A], se = 1;
              for (; A > 0 && (se *= 256); ) Q += this[p + --A] * se;
              return Q;
            }, S.prototype.readUint8 = S.prototype.readUInt8 = function(p, A) {
              return p >>>= 0, A || oe(p, 1, this.length), this[p];
            }, S.prototype.readUint16LE = S.prototype.readUInt16LE = function(p, A) {
              return p >>>= 0, A || oe(p, 2, this.length), this[p] | this[p + 1] << 8;
            }, S.prototype.readUint16BE = S.prototype.readUInt16BE = function(p, A) {
              return p >>>= 0, A || oe(p, 2, this.length), this[p] << 8 | this[p + 1];
            }, S.prototype.readUint32LE = S.prototype.readUInt32LE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), (this[p] | this[p + 1] << 8 | this[p + 2] << 16) + 16777216 * this[p + 3];
            }, S.prototype.readUint32BE = S.prototype.readUInt32BE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), 16777216 * this[p] + (this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3]);
            }, S.prototype.readBigUInt64LE = N(function(p) {
              Ve(p >>>= 0, "offset");
              const A = this[p], U = this[p + 7];
              A !== void 0 && U !== void 0 || _e(p, this.length - 8);
              const Q = A + 256 * this[++p] + 65536 * this[++p] + this[++p] * 2 ** 24, se = this[++p] + 256 * this[++p] + 65536 * this[++p] + U * 2 ** 24;
              return BigInt(Q) + (BigInt(se) << BigInt(32));
            }), S.prototype.readBigUInt64BE = N(function(p) {
              Ve(p >>>= 0, "offset");
              const A = this[p], U = this[p + 7];
              A !== void 0 && U !== void 0 || _e(p, this.length - 8);
              const Q = A * 2 ** 24 + 65536 * this[++p] + 256 * this[++p] + this[++p], se = this[++p] * 2 ** 24 + 65536 * this[++p] + 256 * this[++p] + U;
              return (BigInt(Q) << BigInt(32)) + BigInt(se);
            }), S.prototype.readIntLE = function(p, A, U) {
              p >>>= 0, A >>>= 0, U || oe(p, A, this.length);
              let Q = this[p], se = 1, X = 0;
              for (; ++X < A && (se *= 256); ) Q += this[p + X] * se;
              return se *= 128, Q >= se && (Q -= Math.pow(2, 8 * A)), Q;
            }, S.prototype.readIntBE = function(p, A, U) {
              p >>>= 0, A >>>= 0, U || oe(p, A, this.length);
              let Q = A, se = 1, X = this[p + --Q];
              for (; Q > 0 && (se *= 256); ) X += this[p + --Q] * se;
              return se *= 128, X >= se && (X -= Math.pow(2, 8 * A)), X;
            }, S.prototype.readInt8 = function(p, A) {
              return p >>>= 0, A || oe(p, 1, this.length), 128 & this[p] ? -1 * (255 - this[p] + 1) : this[p];
            }, S.prototype.readInt16LE = function(p, A) {
              p >>>= 0, A || oe(p, 2, this.length);
              const U = this[p] | this[p + 1] << 8;
              return 32768 & U ? 4294901760 | U : U;
            }, S.prototype.readInt16BE = function(p, A) {
              p >>>= 0, A || oe(p, 2, this.length);
              const U = this[p + 1] | this[p] << 8;
              return 32768 & U ? 4294901760 | U : U;
            }, S.prototype.readInt32LE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), this[p] | this[p + 1] << 8 | this[p + 2] << 16 | this[p + 3] << 24;
            }, S.prototype.readInt32BE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), this[p] << 24 | this[p + 1] << 16 | this[p + 2] << 8 | this[p + 3];
            }, S.prototype.readBigInt64LE = N(function(p) {
              Ve(p >>>= 0, "offset");
              const A = this[p], U = this[p + 7];
              A !== void 0 && U !== void 0 || _e(p, this.length - 8);
              const Q = this[p + 4] + 256 * this[p + 5] + 65536 * this[p + 6] + (U << 24);
              return (BigInt(Q) << BigInt(32)) + BigInt(A + 256 * this[++p] + 65536 * this[++p] + this[++p] * 16777216);
            }), S.prototype.readBigInt64BE = N(function(p) {
              Ve(p >>>= 0, "offset");
              const A = this[p], U = this[p + 7];
              A !== void 0 && U !== void 0 || _e(p, this.length - 8);
              const Q = (A << 24) + 65536 * this[++p] + 256 * this[++p] + this[++p];
              return (BigInt(Q) << BigInt(32)) + BigInt(this[++p] * 16777216 + 65536 * this[++p] + 256 * this[++p] + U);
            }), S.prototype.readFloatLE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), a.read(this, p, true, 23, 4);
            }, S.prototype.readFloatBE = function(p, A) {
              return p >>>= 0, A || oe(p, 4, this.length), a.read(this, p, false, 23, 4);
            }, S.prototype.readDoubleLE = function(p, A) {
              return p >>>= 0, A || oe(p, 8, this.length), a.read(this, p, true, 52, 8);
            }, S.prototype.readDoubleBE = function(p, A) {
              return p >>>= 0, A || oe(p, 8, this.length), a.read(this, p, false, 52, 8);
            }, S.prototype.writeUintLE = S.prototype.writeUIntLE = function(p, A, U, Q) {
              p = +p, A >>>= 0, U >>>= 0, Q || ce(this, p, A, U, Math.pow(2, 8 * U) - 1, 0);
              let se = 1, X = 0;
              for (this[A] = 255 & p; ++X < U && (se *= 256); ) this[A + X] = p / se & 255;
              return A + U;
            }, S.prototype.writeUintBE = S.prototype.writeUIntBE = function(p, A, U, Q) {
              p = +p, A >>>= 0, U >>>= 0, Q || ce(this, p, A, U, Math.pow(2, 8 * U) - 1, 0);
              let se = U - 1, X = 1;
              for (this[A + se] = 255 & p; --se >= 0 && (X *= 256); ) this[A + se] = p / X & 255;
              return A + U;
            }, S.prototype.writeUint8 = S.prototype.writeUInt8 = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 1, 255, 0), this[A] = 255 & p, A + 1;
            }, S.prototype.writeUint16LE = S.prototype.writeUInt16LE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 2, 65535, 0), this[A] = 255 & p, this[A + 1] = p >>> 8, A + 2;
            }, S.prototype.writeUint16BE = S.prototype.writeUInt16BE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 2, 65535, 0), this[A] = p >>> 8, this[A + 1] = 255 & p, A + 2;
            }, S.prototype.writeUint32LE = S.prototype.writeUInt32LE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 4, 4294967295, 0), this[A + 3] = p >>> 24, this[A + 2] = p >>> 16, this[A + 1] = p >>> 8, this[A] = 255 & p, A + 4;
            }, S.prototype.writeUint32BE = S.prototype.writeUInt32BE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 4, 4294967295, 0), this[A] = p >>> 24, this[A + 1] = p >>> 16, this[A + 2] = p >>> 8, this[A + 3] = 255 & p, A + 4;
            }, S.prototype.writeBigUInt64LE = N(function(p, A = 0) {
              return ye(this, p, A, BigInt(0), BigInt("0xffffffffffffffff"));
            }), S.prototype.writeBigUInt64BE = N(function(p, A = 0) {
              return ae(this, p, A, BigInt(0), BigInt("0xffffffffffffffff"));
            }), S.prototype.writeIntLE = function(p, A, U, Q) {
              if (p = +p, A >>>= 0, !Q) {
                const tt = Math.pow(2, 8 * U - 1);
                ce(this, p, A, U, tt - 1, -tt);
              }
              let se = 0, X = 1, de = 0;
              for (this[A] = 255 & p; ++se < U && (X *= 256); ) p < 0 && de === 0 && this[A + se - 1] !== 0 && (de = 1), this[A + se] = (p / X | 0) - de & 255;
              return A + U;
            }, S.prototype.writeIntBE = function(p, A, U, Q) {
              if (p = +p, A >>>= 0, !Q) {
                const tt = Math.pow(2, 8 * U - 1);
                ce(this, p, A, U, tt - 1, -tt);
              }
              let se = U - 1, X = 1, de = 0;
              for (this[A + se] = 255 & p; --se >= 0 && (X *= 256); ) p < 0 && de === 0 && this[A + se + 1] !== 0 && (de = 1), this[A + se] = (p / X | 0) - de & 255;
              return A + U;
            }, S.prototype.writeInt8 = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 1, 127, -128), p < 0 && (p = 255 + p + 1), this[A] = 255 & p, A + 1;
            }, S.prototype.writeInt16LE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 2, 32767, -32768), this[A] = 255 & p, this[A + 1] = p >>> 8, A + 2;
            }, S.prototype.writeInt16BE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 2, 32767, -32768), this[A] = p >>> 8, this[A + 1] = 255 & p, A + 2;
            }, S.prototype.writeInt32LE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 4, 2147483647, -2147483648), this[A] = 255 & p, this[A + 1] = p >>> 8, this[A + 2] = p >>> 16, this[A + 3] = p >>> 24, A + 4;
            }, S.prototype.writeInt32BE = function(p, A, U) {
              return p = +p, A >>>= 0, U || ce(this, p, A, 4, 2147483647, -2147483648), p < 0 && (p = 4294967295 + p + 1), this[A] = p >>> 24, this[A + 1] = p >>> 16, this[A + 2] = p >>> 8, this[A + 3] = 255 & p, A + 4;
            }, S.prototype.writeBigInt64LE = N(function(p, A = 0) {
              return ye(this, p, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), S.prototype.writeBigInt64BE = N(function(p, A = 0) {
              return ae(this, p, A, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), S.prototype.writeFloatLE = function(p, A, U) {
              return ne(this, p, A, true, U);
            }, S.prototype.writeFloatBE = function(p, A, U) {
              return ne(this, p, A, false, U);
            }, S.prototype.writeDoubleLE = function(p, A, U) {
              return ge(this, p, A, true, U);
            }, S.prototype.writeDoubleBE = function(p, A, U) {
              return ge(this, p, A, false, U);
            }, S.prototype.copy = function(p, A, U, Q) {
              if (!S.isBuffer(p)) throw new TypeError("argument should be a Buffer");
              if (U || (U = 0), Q || Q === 0 || (Q = this.length), A >= p.length && (A = p.length), A || (A = 0), Q > 0 && Q < U && (Q = U), Q === U || p.length === 0 || this.length === 0) return 0;
              if (A < 0) throw new RangeError("targetStart out of bounds");
              if (U < 0 || U >= this.length) throw new RangeError("Index out of range");
              if (Q < 0) throw new RangeError("sourceEnd out of bounds");
              Q > this.length && (Q = this.length), p.length - A < Q - U && (Q = p.length - A + U);
              const se = Q - U;
              return this === p && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(A, U, Q) : Uint8Array.prototype.set.call(p, this.subarray(U, Q), A), se;
            }, S.prototype.fill = function(p, A, U, Q) {
              if (typeof p == "string") {
                if (typeof A == "string" ? (Q = A, A = 0, U = this.length) : typeof U == "string" && (Q = U, U = this.length), Q !== void 0 && typeof Q != "string") throw new TypeError("encoding must be a string");
                if (typeof Q == "string" && !S.isEncoding(Q)) throw new TypeError("Unknown encoding: " + Q);
                if (p.length === 1) {
                  const X = p.charCodeAt(0);
                  (Q === "utf8" && X < 128 || Q === "latin1") && (p = X);
                }
              } else typeof p == "number" ? p &= 255 : typeof p == "boolean" && (p = Number(p));
              if (A < 0 || this.length < A || this.length < U) throw new RangeError("Out of range index");
              if (U <= A) return this;
              let se;
              if (A >>>= 0, U = U === void 0 ? this.length : U >>> 0, p || (p = 0), typeof p == "number") for (se = A; se < U; ++se) this[se] = p;
              else {
                const X = S.isBuffer(p) ? p : S.from(p, Q), de = X.length;
                if (de === 0) throw new TypeError('The value "' + p + '" is invalid for argument "value"');
                for (se = 0; se < U - A; ++se) this[se + A] = X[se % de];
              }
              return this;
            };
            const Te = {};
            function pe(p, A, U) {
              Te[p] = class extends U {
                constructor() {
                  super(), Object.defineProperty(this, "message", { value: A.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${p}]`, this.stack, delete this.name;
                }
                get code() {
                  return p;
                }
                set code(Q) {
                  Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: Q, writable: true });
                }
                toString() {
                  return `${this.name} [${p}]: ${this.message}`;
                }
              };
            }
            function Oe(p) {
              let A = "", U = p.length;
              const Q = p[0] === "-" ? 1 : 0;
              for (; U >= Q + 4; U -= 3) A = `_${p.slice(U - 3, U)}${A}`;
              return `${p.slice(0, U)}${A}`;
            }
            function xe(p, A, U, Q, se, X) {
              if (p > U || p < A) {
                const de = typeof A == "bigint" ? "n" : "";
                let tt;
                throw tt = A === 0 || A === BigInt(0) ? `>= 0${de} and < 2${de} ** ${8 * (X + 1)}${de}` : `>= -(2${de} ** ${8 * (X + 1) - 1}${de}) and < 2 ** ${8 * (X + 1) - 1}${de}`, new Te.ERR_OUT_OF_RANGE("value", tt, p);
              }
              (function(de, tt, Ne) {
                Ve(tt, "offset"), de[tt] !== void 0 && de[tt + Ne] !== void 0 || _e(tt, de.length - (Ne + 1));
              })(Q, se, X);
            }
            function Ve(p, A) {
              if (typeof p != "number") throw new Te.ERR_INVALID_ARG_TYPE(A, "number", p);
            }
            function _e(p, A, U) {
              throw Math.floor(p) !== p ? (Ve(p, U), new Te.ERR_OUT_OF_RANGE("offset", "an integer", p)) : A < 0 ? new Te.ERR_BUFFER_OUT_OF_BOUNDS() : new Te.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${A}`, p);
            }
            pe("ERR_BUFFER_OUT_OF_BOUNDS", function(p) {
              return p ? `${p} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
            }, RangeError), pe("ERR_INVALID_ARG_TYPE", function(p, A) {
              return `The "${p}" argument must be of type number. Received type ${typeof A}`;
            }, TypeError), pe("ERR_OUT_OF_RANGE", function(p, A, U) {
              let Q = `The value of "${p}" is out of range.`, se = U;
              return Number.isInteger(U) && Math.abs(U) > 4294967296 ? se = Oe(String(U)) : typeof U == "bigint" && (se = String(U), (U > BigInt(2) ** BigInt(32) || U < -(BigInt(2) ** BigInt(32))) && (se = Oe(se)), se += "n"), Q += ` It must be ${A}. Received ${se}`, Q;
            }, RangeError);
            const Be = /[^+/0-9A-Za-z-_]/g;
            function Qe(p, A) {
              let U;
              A = A || 1 / 0;
              const Q = p.length;
              let se = null;
              const X = [];
              for (let de = 0; de < Q; ++de) {
                if (U = p.charCodeAt(de), U > 55295 && U < 57344) {
                  if (!se) {
                    if (U > 56319) {
                      (A -= 3) > -1 && X.push(239, 191, 189);
                      continue;
                    }
                    if (de + 1 === Q) {
                      (A -= 3) > -1 && X.push(239, 191, 189);
                      continue;
                    }
                    se = U;
                    continue;
                  }
                  if (U < 56320) {
                    (A -= 3) > -1 && X.push(239, 191, 189), se = U;
                    continue;
                  }
                  U = 65536 + (se - 55296 << 10 | U - 56320);
                } else se && (A -= 3) > -1 && X.push(239, 191, 189);
                if (se = null, U < 128) {
                  if ((A -= 1) < 0) break;
                  X.push(U);
                } else if (U < 2048) {
                  if ((A -= 2) < 0) break;
                  X.push(U >> 6 | 192, 63 & U | 128);
                } else if (U < 65536) {
                  if ((A -= 3) < 0) break;
                  X.push(U >> 12 | 224, U >> 6 & 63 | 128, 63 & U | 128);
                } else {
                  if (!(U < 1114112)) throw new Error("Invalid code point");
                  if ((A -= 4) < 0) break;
                  X.push(U >> 18 | 240, U >> 12 & 63 | 128, U >> 6 & 63 | 128, 63 & U | 128);
                }
              }
              return X;
            }
            function ee(p) {
              return g.toByteArray(function(A) {
                if ((A = (A = A.split("=")[0]).trim().replace(Be, "")).length < 2) return "";
                for (; A.length % 4 != 0; ) A += "=";
                return A;
              }(p));
            }
            function P(p, A, U, Q) {
              let se;
              for (se = 0; se < Q && !(se + U >= A.length || se >= p.length); ++se) A[se + U] = p[se];
              return se;
            }
            function x(p, A) {
              return p instanceof A || p != null && p.constructor != null && p.constructor.name != null && p.constructor.name === A.name;
            }
            function O(p) {
              return p != p;
            }
            const V = function() {
              const p = "0123456789abcdef", A = new Array(256);
              for (let U = 0; U < 16; ++U) {
                const Q = 16 * U;
                for (let se = 0; se < 16; ++se) A[Q + se] = p[U] + p[se];
              }
              return A;
            }();
            function N(p) {
              return typeof BigInt > "u" ? C : p;
            }
            function C() {
              throw new Error("BigInt not supported");
            }
          }, 251: (f, r) => {
            r.read = function(m, g, a, l, d) {
              var b, S, E = 8 * d - l - 1, R = (1 << E) - 1, k = R >> 1, w = -7, F = a ? d - 1 : 0, I = a ? -1 : 1, q = m[g + F];
              for (F += I, b = q & (1 << -w) - 1, q >>= -w, w += E; w > 0; b = 256 * b + m[g + F], F += I, w -= 8) ;
              for (S = b & (1 << -w) - 1, b >>= -w, w += l; w > 0; S = 256 * S + m[g + F], F += I, w -= 8) ;
              if (b === 0) b = 1 - k;
              else {
                if (b === R) return S ? NaN : 1 / 0 * (q ? -1 : 1);
                S += Math.pow(2, l), b -= k;
              }
              return (q ? -1 : 1) * S * Math.pow(2, b - l);
            }, r.write = function(m, g, a, l, d, b) {
              var S, E, R, k = 8 * b - d - 1, w = (1 << k) - 1, F = w >> 1, I = d === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = l ? 0 : b - 1, D = l ? 1 : -1, H = g < 0 || g === 0 && 1 / g < 0 ? 1 : 0;
              for (g = Math.abs(g), isNaN(g) || g === 1 / 0 ? (E = isNaN(g) ? 1 : 0, S = w) : (S = Math.floor(Math.log(g) / Math.LN2), g * (R = Math.pow(2, -S)) < 1 && (S--, R *= 2), (g += S + F >= 1 ? I / R : I * Math.pow(2, 1 - F)) * R >= 2 && (S++, R /= 2), S + F >= w ? (E = 0, S = w) : S + F >= 1 ? (E = (g * R - 1) * Math.pow(2, d), S += F) : (E = g * Math.pow(2, F - 1) * Math.pow(2, d), S = 0)); d >= 8; m[a + q] = 255 & E, q += D, E /= 256, d -= 8) ;
              for (S = S << d | E, k += d; k > 0; m[a + q] = 255 & S, q += D, S /= 256, k -= 8) ;
              m[a + q - D] |= 128 * H;
            };
          } }, c = {};
          function h(f) {
            var r = c[f];
            if (r !== void 0) return r.exports;
            var m = c[f] = { exports: {} };
            return u[f](m, m.exports, h), m.exports;
          }
          return h.d = (f, r) => {
            for (var m in r) h.o(r, m) && !h.o(f, m) && Object.defineProperty(f, m, { enumerable: true, get: r[m] });
          }, h.g = function() {
            if (typeof globalThis == "object") return globalThis;
            try {
              return this || new Function("return this")();
            } catch {
              if (typeof window == "object") return window;
            }
          }(), h.o = (f, r) => Object.prototype.hasOwnProperty.call(f, r), h.r = (f) => {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(f, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(f, "__esModule", { value: true });
          }, h(281);
        })(), t.exports = o();
      }, 3758: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.TransactionBase = void 0;
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(9152), m = u(6691);
        function g(d) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, g(d);
        }
        function a(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, l(E.key), E);
          }
        }
        function l(d) {
          var b = function(S, E) {
            if (g(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (g(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return g(b) == "symbol" ? b : b + "";
        }
        o.TransactionBase = function() {
          return function(d, b, S) {
            return b && a(d.prototype, b), Object.defineProperty(d, "prototype", { writable: false }), d;
          }(function d(b, S, E, R) {
            if (function(k, w) {
              if (!(k instanceof w)) throw new TypeError("Cannot call a class as a function");
            }(this, d), typeof R != "string") throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(g(R)));
            this._networkPassphrase = R, this._tx = b, this._signatures = S, this._fee = E;
          }, [{ key: "signatures", get: function() {
            return this._signatures;
          }, set: function(d) {
            throw new Error("Transaction is immutable");
          } }, { key: "tx", get: function() {
            return this._tx;
          }, set: function(d) {
            throw new Error("Transaction is immutable");
          } }, { key: "fee", get: function() {
            return this._fee;
          }, set: function(d) {
            throw new Error("Transaction is immutable");
          } }, { key: "networkPassphrase", get: function() {
            return this._networkPassphrase;
          }, set: function(d) {
            this._networkPassphrase = d;
          } }, { key: "sign", value: function() {
            for (var d = this, b = this.hash(), S = arguments.length, E = new Array(S), R = 0; R < S; R++) E[R] = arguments[R];
            E.forEach(function(k) {
              var w = k.signDecorated(b);
              d.signatures.push(w);
            });
          } }, { key: "getKeypairSignature", value: function(d) {
            return d.sign(this.hash()).toString("base64");
          } }, { key: "addSignature", value: function() {
            var d, b, S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
            if (!E || typeof E != "string") throw new Error("Invalid signature");
            if (!S || typeof S != "string") throw new Error("Invalid publicKey");
            var R = c.from(E, "base64");
            try {
              b = (d = m.Keypair.fromPublicKey(S)).signatureHint();
            } catch {
              throw new Error("Invalid publicKey");
            }
            if (!d.verify(this.hash(), R)) throw new Error("Invalid signature");
            this.signatures.push(new f.default.DecoratedSignature({ hint: b, signature: R }));
          } }, { key: "addDecoratedSignature", value: function(d) {
            this.signatures.push(d);
          } }, { key: "signHashX", value: function(d) {
            if (typeof d == "string" && (d = c.from(d, "hex")), d.length > 64) throw new Error("preimage cannnot be longer than 64 bytes");
            var b = d, S = (0, r.hash)(d), E = S.slice(S.length - 4);
            this.signatures.push(new f.default.DecoratedSignature({ hint: E, signature: b }));
          } }, { key: "hash", value: function() {
            return (0, r.hash)(this.signatureBase());
          } }, { key: "signatureBase", value: function() {
            throw new Error("Implement in subclass");
          } }, { key: "toEnvelope", value: function() {
            throw new Error("Implement in subclass");
          } }, { key: "toXDR", value: function() {
            return this.toEnvelope().toXDR().toString("base64");
          } }]);
        }();
      }, 3874: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.pathPaymentStrictSend = function(r) {
          switch (true) {
            case !r.sendAsset:
              throw new Error("Must specify a send asset");
            case !this.isValidAmount(r.sendAmount):
              throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
            case !r.destAsset:
              throw new Error("Must provide a destAsset for a payment operation");
            case !this.isValidAmount(r.destMin):
              throw new TypeError(this.constructAmountRequirementsError("destMin"));
          }
          var m = {};
          m.sendAsset = r.sendAsset.toXDRObject(), m.sendAmount = this._toXDRAmount(r.sendAmount);
          try {
            m.destination = (0, f.decodeAddressToMuxedAccount)(r.destination);
          } catch {
            throw new Error("destination is invalid");
          }
          m.destAsset = r.destAsset.toXDRObject(), m.destMin = this._toXDRAmount(r.destMin);
          var g = r.path ? r.path : [];
          m.path = g.map(function(d) {
            return d.toXDRObject();
          });
          var a = new h.default.PathPaymentStrictSendOp(m), l = {};
          return l.body = h.default.OperationBody.pathPaymentStrictSend(a), this.setSourceAccount(l, r), new h.default.Operation(l);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6160);
      }, 3898: (t, o, u) => {
        u.r(o), u.d(o, { Api: () => {
        }, Resolver: () => I, STELLAR_TOML_MAX_SIZE: () => w });
        var c = u(1293), h = u.n(c), f = u(9983), r = u(8732);
        function m(q) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
            return typeof D;
          } : function(D) {
            return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
          }, m(q);
        }
        function g() {
          g = function() {
            return D;
          };
          var q, D = {}, H = Object.prototype, _ = H.hasOwnProperty, T = Object.defineProperty || function(ee, P, x) {
            ee[P] = x.value;
          }, L = typeof Symbol == "function" ? Symbol : {}, j = L.iterator || "@@iterator", z = L.asyncIterator || "@@asyncIterator", Y = L.toStringTag || "@@toStringTag";
          function te(ee, P, x) {
            return Object.defineProperty(ee, P, { value: x, enumerable: true, configurable: true, writable: true }), ee[P];
          }
          try {
            te({}, "");
          } catch {
            te = function(P, x, O) {
              return P[x] = O;
            };
          }
          function G(ee, P, x, O) {
            var V = P && P.prototype instanceof oe ? P : oe, N = Object.create(V.prototype), C = new Be(O || []);
            return T(N, "_invoke", { value: Oe(ee, x, C) }), N;
          }
          function K(ee, P, x) {
            try {
              return { type: "normal", arg: ee.call(P, x) };
            } catch (O) {
              return { type: "throw", arg: O };
            }
          }
          D.wrap = G;
          var J = "suspendedStart", B = "suspendedYield", Z = "executing", ie = "completed", $ = {};
          function oe() {
          }
          function ce() {
          }
          function ye() {
          }
          var ae = {};
          te(ae, j, function() {
            return this;
          });
          var ue = Object.getPrototypeOf, ne = ue && ue(ue(Qe([])));
          ne && ne !== H && _.call(ne, j) && (ae = ne);
          var ge = ye.prototype = oe.prototype = Object.create(ae);
          function Te(ee) {
            ["next", "throw", "return"].forEach(function(P) {
              te(ee, P, function(x) {
                return this._invoke(P, x);
              });
            });
          }
          function pe(ee, P) {
            function x(V, N, C, p) {
              var A = K(ee[V], ee, N);
              if (A.type !== "throw") {
                var U = A.arg, Q = U.value;
                return Q && m(Q) == "object" && _.call(Q, "__await") ? P.resolve(Q.__await).then(function(se) {
                  x("next", se, C, p);
                }, function(se) {
                  x("throw", se, C, p);
                }) : P.resolve(Q).then(function(se) {
                  U.value = se, C(U);
                }, function(se) {
                  return x("throw", se, C, p);
                });
              }
              p(A.arg);
            }
            var O;
            T(this, "_invoke", { value: function(V, N) {
              function C() {
                return new P(function(p, A) {
                  x(V, N, p, A);
                });
              }
              return O = O ? O.then(C, C) : C();
            } });
          }
          function Oe(ee, P, x) {
            var O = J;
            return function(V, N) {
              if (O === Z) throw Error("Generator is already running");
              if (O === ie) {
                if (V === "throw") throw N;
                return { value: q, done: true };
              }
              for (x.method = V, x.arg = N; ; ) {
                var C = x.delegate;
                if (C) {
                  var p = xe(C, x);
                  if (p) {
                    if (p === $) continue;
                    return p;
                  }
                }
                if (x.method === "next") x.sent = x._sent = x.arg;
                else if (x.method === "throw") {
                  if (O === J) throw O = ie, x.arg;
                  x.dispatchException(x.arg);
                } else x.method === "return" && x.abrupt("return", x.arg);
                O = Z;
                var A = K(ee, P, x);
                if (A.type === "normal") {
                  if (O = x.done ? ie : B, A.arg === $) continue;
                  return { value: A.arg, done: x.done };
                }
                A.type === "throw" && (O = ie, x.method = "throw", x.arg = A.arg);
              }
            };
          }
          function xe(ee, P) {
            var x = P.method, O = ee.iterator[x];
            if (O === q) return P.delegate = null, x === "throw" && ee.iterator.return && (P.method = "return", P.arg = q, xe(ee, P), P.method === "throw") || x !== "return" && (P.method = "throw", P.arg = new TypeError("The iterator does not provide a '" + x + "' method")), $;
            var V = K(O, ee.iterator, P.arg);
            if (V.type === "throw") return P.method = "throw", P.arg = V.arg, P.delegate = null, $;
            var N = V.arg;
            return N ? N.done ? (P[ee.resultName] = N.value, P.next = ee.nextLoc, P.method !== "return" && (P.method = "next", P.arg = q), P.delegate = null, $) : N : (P.method = "throw", P.arg = new TypeError("iterator result is not an object"), P.delegate = null, $);
          }
          function Ve(ee) {
            var P = { tryLoc: ee[0] };
            1 in ee && (P.catchLoc = ee[1]), 2 in ee && (P.finallyLoc = ee[2], P.afterLoc = ee[3]), this.tryEntries.push(P);
          }
          function _e(ee) {
            var P = ee.completion || {};
            P.type = "normal", delete P.arg, ee.completion = P;
          }
          function Be(ee) {
            this.tryEntries = [{ tryLoc: "root" }], ee.forEach(Ve, this), this.reset(true);
          }
          function Qe(ee) {
            if (ee || ee === "") {
              var P = ee[j];
              if (P) return P.call(ee);
              if (typeof ee.next == "function") return ee;
              if (!isNaN(ee.length)) {
                var x = -1, O = function V() {
                  for (; ++x < ee.length; ) if (_.call(ee, x)) return V.value = ee[x], V.done = false, V;
                  return V.value = q, V.done = true, V;
                };
                return O.next = O;
              }
            }
            throw new TypeError(m(ee) + " is not iterable");
          }
          return ce.prototype = ye, T(ge, "constructor", { value: ye, configurable: true }), T(ye, "constructor", { value: ce, configurable: true }), ce.displayName = te(ye, Y, "GeneratorFunction"), D.isGeneratorFunction = function(ee) {
            var P = typeof ee == "function" && ee.constructor;
            return !!P && (P === ce || (P.displayName || P.name) === "GeneratorFunction");
          }, D.mark = function(ee) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(ee, ye) : (ee.__proto__ = ye, te(ee, Y, "GeneratorFunction")), ee.prototype = Object.create(ge), ee;
          }, D.awrap = function(ee) {
            return { __await: ee };
          }, Te(pe.prototype), te(pe.prototype, z, function() {
            return this;
          }), D.AsyncIterator = pe, D.async = function(ee, P, x, O, V) {
            V === void 0 && (V = Promise);
            var N = new pe(G(ee, P, x, O), V);
            return D.isGeneratorFunction(P) ? N : N.next().then(function(C) {
              return C.done ? C.value : N.next();
            });
          }, Te(ge), te(ge, Y, "Generator"), te(ge, j, function() {
            return this;
          }), te(ge, "toString", function() {
            return "[object Generator]";
          }), D.keys = function(ee) {
            var P = Object(ee), x = [];
            for (var O in P) x.push(O);
            return x.reverse(), function V() {
              for (; x.length; ) {
                var N = x.pop();
                if (N in P) return V.value = N, V.done = false, V;
              }
              return V.done = true, V;
            };
          }, D.values = Qe, Be.prototype = { constructor: Be, reset: function(ee) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = q, this.done = false, this.delegate = null, this.method = "next", this.arg = q, this.tryEntries.forEach(_e), !ee) for (var P in this) P.charAt(0) === "t" && _.call(this, P) && !isNaN(+P.slice(1)) && (this[P] = q);
          }, stop: function() {
            this.done = true;
            var ee = this.tryEntries[0].completion;
            if (ee.type === "throw") throw ee.arg;
            return this.rval;
          }, dispatchException: function(ee) {
            if (this.done) throw ee;
            var P = this;
            function x(A, U) {
              return N.type = "throw", N.arg = ee, P.next = A, U && (P.method = "next", P.arg = q), !!U;
            }
            for (var O = this.tryEntries.length - 1; O >= 0; --O) {
              var V = this.tryEntries[O], N = V.completion;
              if (V.tryLoc === "root") return x("end");
              if (V.tryLoc <= this.prev) {
                var C = _.call(V, "catchLoc"), p = _.call(V, "finallyLoc");
                if (C && p) {
                  if (this.prev < V.catchLoc) return x(V.catchLoc, true);
                  if (this.prev < V.finallyLoc) return x(V.finallyLoc);
                } else if (C) {
                  if (this.prev < V.catchLoc) return x(V.catchLoc, true);
                } else {
                  if (!p) throw Error("try statement without catch or finally");
                  if (this.prev < V.finallyLoc) return x(V.finallyLoc);
                }
              }
            }
          }, abrupt: function(ee, P) {
            for (var x = this.tryEntries.length - 1; x >= 0; --x) {
              var O = this.tryEntries[x];
              if (O.tryLoc <= this.prev && _.call(O, "finallyLoc") && this.prev < O.finallyLoc) {
                var V = O;
                break;
              }
            }
            V && (ee === "break" || ee === "continue") && V.tryLoc <= P && P <= V.finallyLoc && (V = null);
            var N = V ? V.completion : {};
            return N.type = ee, N.arg = P, V ? (this.method = "next", this.next = V.finallyLoc, $) : this.complete(N);
          }, complete: function(ee, P) {
            if (ee.type === "throw") throw ee.arg;
            return ee.type === "break" || ee.type === "continue" ? this.next = ee.arg : ee.type === "return" ? (this.rval = this.arg = ee.arg, this.method = "return", this.next = "end") : ee.type === "normal" && P && (this.next = P), $;
          }, finish: function(ee) {
            for (var P = this.tryEntries.length - 1; P >= 0; --P) {
              var x = this.tryEntries[P];
              if (x.finallyLoc === ee) return this.complete(x.completion, x.afterLoc), _e(x), $;
            }
          }, catch: function(ee) {
            for (var P = this.tryEntries.length - 1; P >= 0; --P) {
              var x = this.tryEntries[P];
              if (x.tryLoc === ee) {
                var O = x.completion;
                if (O.type === "throw") {
                  var V = O.arg;
                  _e(x);
                }
                return V;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(ee, P, x) {
            return this.delegate = { iterator: Qe(ee), resultName: P, nextLoc: x }, this.method === "next" && (this.arg = q), $;
          } }, D;
        }
        function a(q, D, H, _, T, L, j) {
          try {
            var z = q[L](j), Y = z.value;
          } catch (te) {
            return void H(te);
          }
          z.done ? D(Y) : Promise.resolve(Y).then(_, T);
        }
        function l(q, D) {
          for (var H = 0; H < D.length; H++) {
            var _ = D[H];
            _.enumerable = _.enumerable || false, _.configurable = true, "value" in _ && (_.writable = true), Object.defineProperty(q, d(_.key), _);
          }
        }
        function d(q) {
          var D = function(H, _) {
            if (m(H) != "object" || !H) return H;
            var T = H[Symbol.toPrimitive];
            if (T !== void 0) {
              var L = T.call(H, _);
              if (m(L) != "object") return L;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(H);
          }(q, "string");
          return m(D) == "symbol" ? D : D + "";
        }
        var b, S, E, R, k, w = 102400, F = f.ok.CancelToken, I = (b = function q() {
          (function(D, H) {
            if (!(D instanceof H)) throw new TypeError("Cannot call a class as a function");
          })(this, q);
        }, S = null, E = [{ key: "resolve", value: (R = g().mark(function q(D) {
          var H, _, T, L, j, z = arguments;
          return g().wrap(function(Y) {
            for (; ; ) switch (Y.prev = Y.next) {
              case 0:
                return T = (_ = z.length > 1 && z[1] !== void 0 ? z[1] : {}).allowHttp === void 0 ? r.T.isAllowHttp() : _.allowHttp, L = _.timeout === void 0 ? r.T.getTimeout() : _.timeout, j = T ? "http" : "https", Y.abrupt("return", f.ok.get("".concat(j, "://").concat(D, "/.well-known/stellar.toml"), { maxRedirects: (H = _.allowedRedirects) !== null && H !== void 0 ? H : 0, maxContentLength: w, cancelToken: L ? new F(function(te) {
                  return setTimeout(function() {
                    return te("timeout of ".concat(L, "ms exceeded"));
                  }, L);
                }) : void 0, timeout: L }).then(function(te) {
                  try {
                    var G = h().parse(te.data);
                    return Promise.resolve(G);
                  } catch (K) {
                    return Promise.reject(new Error("stellar.toml is invalid - Parsing error on line ".concat(K.line, ", column ").concat(K.column, ": ").concat(K.message)));
                  }
                }).catch(function(te) {
                  throw te.message.match(/^maxContentLength size/) ? new Error("stellar.toml file exceeds allowed size of ".concat(w)) : te;
                }));
              case 5:
              case "end":
                return Y.stop();
            }
          }, q);
        }), k = function() {
          var q = this, D = arguments;
          return new Promise(function(H, _) {
            var T = R.apply(q, D);
            function L(z) {
              a(T, H, _, L, j, "next", z);
            }
            function j(z) {
              a(T, H, _, L, j, "throw", z);
            }
            L(void 0);
          });
        }, function(q) {
          return k.apply(this, arguments);
        }) }], S && l(b.prototype, S), E && l(b, E), Object.defineProperty(b, "prototype", { writable: false }), b);
      }, 3919: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.humanizeEvents = function(l) {
          return l.map(function(d) {
            return d.inSuccessfulContractCall ? a(d.event()) : a(d);
          });
        };
        var c = u(7120), h = u(7177);
        function f(l) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
            return typeof d;
          } : function(d) {
            return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
          }, f(l);
        }
        function r(l, d) {
          var b = Object.keys(l);
          if (Object.getOwnPropertySymbols) {
            var S = Object.getOwnPropertySymbols(l);
            d && (S = S.filter(function(E) {
              return Object.getOwnPropertyDescriptor(l, E).enumerable;
            })), b.push.apply(b, S);
          }
          return b;
        }
        function m(l) {
          for (var d = 1; d < arguments.length; d++) {
            var b = arguments[d] != null ? arguments[d] : {};
            d % 2 ? r(Object(b), true).forEach(function(S) {
              g(l, S, b[S]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(l, Object.getOwnPropertyDescriptors(b)) : r(Object(b)).forEach(function(S) {
              Object.defineProperty(l, S, Object.getOwnPropertyDescriptor(b, S));
            });
          }
          return l;
        }
        function g(l, d, b) {
          return (d = function(S) {
            var E = function(R, k) {
              if (f(R) != "object" || !R) return R;
              var w = R[Symbol.toPrimitive];
              if (w !== void 0) {
                var F = w.call(R, k);
                if (f(F) != "object") return F;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return (k === "string" ? String : Number)(R);
            }(S, "string");
            return f(E) == "symbol" ? E : E + "";
          }(d)) in l ? Object.defineProperty(l, d, { value: b, enumerable: true, configurable: true, writable: true }) : l[d] = b, l;
        }
        function a(l) {
          return m(m({}, typeof l.contractId == "function" && l.contractId() != null && { contractId: c.StrKey.encodeContract(l.contractId()) }), {}, { type: l.type().name, topics: l.body().value().topics().map(function(d) {
            return (0, h.scValToNative)(d);
          }), data: (0, h.scValToNative)(l.body().value().data()) });
        }
      }, 4035: (t, o, u) => {
        var c, h = u(6556), f = u(9092)(), r = u(9957), m = u(5795);
        if (f) {
          var g = h("RegExp.prototype.exec"), a = {}, l = function() {
            throw a;
          }, d = { toString: l, valueOf: l };
          typeof Symbol.toPrimitive == "symbol" && (d[Symbol.toPrimitive] = l), c = function(S) {
            if (!S || typeof S != "object") return false;
            var E = m(S, "lastIndex");
            if (!(E && r(E, "value"))) return false;
            try {
              g(S, d);
            } catch (R) {
              return R === a;
            }
          };
        } else {
          var b = h("Object.prototype.toString");
          c = function(S) {
            return !(!S || typeof S != "object" && typeof S != "function") && b(S) === "[object RegExp]";
          };
        }
        t.exports = c;
      }, 4039: (t, o, u) => {
        var c = typeof Symbol < "u" && Symbol, h = u(1333);
        t.exports = function() {
          return typeof c == "function" && typeof Symbol == "function" && typeof c("foo") == "symbol" && typeof Symbol("bar") == "symbol" && h();
        };
      }, 4062: (t, o) => {
        function u(m) {
          return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
            return typeof g;
          } : function(g) {
            return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
          }, u(m);
        }
        function c(m) {
          return function(g) {
            if (Array.isArray(g)) return g;
          }(m) || function(g) {
            if (typeof Symbol < "u" && g[Symbol.iterator] != null || g["@@iterator"] != null) return Array.from(g);
          }(m) || function(g, a) {
            if (g) {
              if (typeof g == "string") return h(g, a);
              var l = {}.toString.call(g).slice(8, -1);
              return l === "Object" && g.constructor && (l = g.constructor.name), l === "Map" || l === "Set" ? Array.from(g) : l === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l) ? h(g, a) : void 0;
            }
          }(m) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function h(m, g) {
          (g == null || g > m.length) && (g = m.length);
          for (var a = 0, l = Array(g); a < g; a++) l[a] = m[a];
          return l;
        }
        function f(m, g) {
          for (var a = 0; a < g.length; a++) {
            var l = g[a];
            l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(m, r(l.key), l);
          }
        }
        function r(m) {
          var g = function(a, l) {
            if (u(a) != "object" || !a) return a;
            var d = a[Symbol.toPrimitive];
            if (d !== void 0) {
              var b = d.call(a, l);
              if (u(b) != "object") return b;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(a);
          }(m, "string");
          return u(g) == "symbol" ? g : g + "";
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Soroban = void 0, o.Soroban = function() {
          return m = function l() {
            (function(d, b) {
              if (!(d instanceof b)) throw new TypeError("Cannot call a class as a function");
            })(this, l);
          }, a = [{ key: "formatTokenAmount", value: function(l, d) {
            if (l.includes(".")) throw new TypeError("No decimals are allowed");
            var b = l;
            return d > 0 && (b = d > b.length ? ["0", b.toString().padStart(d, "0")].join(".") : [b.slice(0, -d), b.slice(-d)].join(".")), b.replace(/(\.\d*?)0+$/, "$1");
          } }, { key: "parseTokenAmount", value: function(l, d) {
            var b, S = c(l.split(".").slice()), E = S[0], R = S[1];
            if (S.slice(2).length) throw new Error("Invalid decimal value: ".concat(l));
            return BigInt(E + ((b = R == null ? void 0 : R.padEnd(d, "0")) !== null && b !== void 0 ? b : "0".repeat(d))).toString();
          } }], (g = null) && f(m.prototype, g), a && f(m, a), Object.defineProperty(m, "prototype", { writable: false }), m;
          var m, g, a;
        }();
      }, 4063: (t, o, u) => {
        function c(d) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, c(d);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Int256 = void 0;
        var h = u(3740);
        function f(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, r(E.key), E);
          }
        }
        function r(d) {
          var b = function(S, E) {
            if (c(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (c(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return c(b) == "symbol" ? b : b + "";
        }
        function m(d, b, S) {
          return b = a(b), function(E, R) {
            if (R && (c(R) == "object" || typeof R == "function")) return R;
            if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(k) {
              if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return k;
            }(E);
          }(d, g() ? Reflect.construct(b, S || [], a(d).constructor) : b.apply(d, S));
        }
        function g() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!d;
          })();
        }
        function a(d) {
          return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, a(d);
        }
        function l(d, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, E) {
            return S.__proto__ = E, S;
          }, l(d, b);
        }
        (o.Int256 = function(d) {
          function b() {
            (function(I, q) {
              if (!(I instanceof q)) throw new TypeError("Cannot call a class as a function");
            })(this, b);
            for (var k = arguments.length, w = new Array(k), F = 0; F < k; F++) w[F] = arguments[F];
            return m(this, b, [w]);
          }
          return function(k, w) {
            if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
            k.prototype = Object.create(w && w.prototype, { constructor: { value: k, writable: true, configurable: true } }), Object.defineProperty(k, "prototype", { writable: false }), w && l(k, w);
          }(b, d), S = b, (E = [{ key: "unsigned", get: function() {
            return false;
          } }, { key: "size", get: function() {
            return 256;
          } }]) && f(S.prototype, E), R && f(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }(h.LargeInt)).defineIntBoundaries();
      }, 4076: (t, o, u) => {
        var c;
        u.d(o, { j: () => c }), function(h) {
          var f = function(m) {
            return m.SUCCESS = "SUCCESS", m.NOT_FOUND = "NOT_FOUND", m.FAILED = "FAILED", m;
          }({});
          function r(m) {
            return "transactionData" in m;
          }
          h.GetTransactionStatus = f, h.isSimulationError = function(m) {
            return "error" in m;
          }, h.isSimulationSuccess = r, h.isSimulationRestore = function(m) {
            return r(m) && "restorePreamble" in m && !!m.restorePreamble.transactionData;
          }, h.isSimulationRaw = function(m) {
            return !m._parsed;
          };
        }(c || (c = {}));
      }, 4107: (t, o, u) => {
        var c = u(6698), h = u(392), f = u(2861).Buffer, r = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], m = new Array(64);
        function g() {
          this.init(), this._w = m, h.call(this, 64, 56);
        }
        function a(E, R, k) {
          return k ^ E & (R ^ k);
        }
        function l(E, R, k) {
          return E & R | k & (E | R);
        }
        function d(E) {
          return (E >>> 2 | E << 30) ^ (E >>> 13 | E << 19) ^ (E >>> 22 | E << 10);
        }
        function b(E) {
          return (E >>> 6 | E << 26) ^ (E >>> 11 | E << 21) ^ (E >>> 25 | E << 7);
        }
        function S(E) {
          return (E >>> 7 | E << 25) ^ (E >>> 18 | E << 14) ^ E >>> 3;
        }
        c(g, h), g.prototype.init = function() {
          return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
        }, g.prototype._update = function(E) {
          for (var R, k = this._w, w = 0 | this._a, F = 0 | this._b, I = 0 | this._c, q = 0 | this._d, D = 0 | this._e, H = 0 | this._f, _ = 0 | this._g, T = 0 | this._h, L = 0; L < 16; ++L) k[L] = E.readInt32BE(4 * L);
          for (; L < 64; ++L) k[L] = 0 | (((R = k[L - 2]) >>> 17 | R << 15) ^ (R >>> 19 | R << 13) ^ R >>> 10) + k[L - 7] + S(k[L - 15]) + k[L - 16];
          for (var j = 0; j < 64; ++j) {
            var z = T + b(D) + a(D, H, _) + r[j] + k[j] | 0, Y = d(w) + l(w, F, I) | 0;
            T = _, _ = H, H = D, D = q + z | 0, q = I, I = F, F = w, w = z + Y | 0;
          }
          this._a = w + this._a | 0, this._b = F + this._b | 0, this._c = I + this._c | 0, this._d = q + this._d | 0, this._e = D + this._e | 0, this._f = H + this._f | 0, this._g = _ + this._g | 0, this._h = T + this._h | 0;
        }, g.prototype._hash = function() {
          var E = f.allocUnsafe(32);
          return E.writeInt32BE(this._a, 0), E.writeInt32BE(this._b, 4), E.writeInt32BE(this._c, 8), E.writeInt32BE(this._d, 12), E.writeInt32BE(this._e, 16), E.writeInt32BE(this._f, 20), E.writeInt32BE(this._g, 24), E.writeInt32BE(this._h, 28), E;
        }, t.exports = g;
      }, 4151: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.best_r = function(m) {
          for (var g, a, l = new h.default(m), d = [[new h.default(0), new h.default(1)], [new h.default(1), new h.default(0)]], b = 2; !l.gt(r); ) {
            g = l.integerValue(h.default.ROUND_FLOOR), a = l.minus(g);
            var S = g.times(d[b - 1][0]).plus(d[b - 2][0]), E = g.times(d[b - 1][1]).plus(d[b - 2][1]);
            if (S.gt(r) || E.gt(r) || (d.push([S, E]), a.eq(0))) break;
            l = new h.default(1).div(a), b += 1;
          }
          var R = (F = d[d.length - 1], I = 2, function(q) {
            if (Array.isArray(q)) return q;
          }(F) || function(q, D) {
            var H = q == null ? null : typeof Symbol < "u" && q[Symbol.iterator] || q["@@iterator"];
            if (H != null) {
              var _, T, L, j, z = [], Y = true, te = false;
              try {
                if (L = (H = H.call(q)).next, D === 0) {
                  if (Object(H) !== H) return;
                  Y = false;
                } else for (; !(Y = (_ = L.call(H)).done) && (z.push(_.value), z.length !== D); Y = true) ;
              } catch (G) {
                te = true, T = G;
              } finally {
                try {
                  if (!Y && H.return != null && (j = H.return(), Object(j) !== j)) return;
                } finally {
                  if (te) throw T;
                }
              }
              return z;
            }
          }(F, I) || function(q, D) {
            if (q) {
              if (typeof q == "string") return f(q, D);
              var H = {}.toString.call(q).slice(8, -1);
              return H === "Object" && q.constructor && (H = q.constructor.name), H === "Map" || H === "Set" ? Array.from(q) : H === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(H) ? f(q, D) : void 0;
            }
          }(F, I) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }()), k = R[0], w = R[1], F, I;
          if (k.isZero() || w.isZero()) throw new Error("Couldn't find approximation");
          return [k.toNumber(), w.toNumber()];
        };
        var c, h = (c = u(1242)) && c.__esModule ? c : { default: c };
        function f(m, g) {
          (g == null || g > m.length) && (g = m.length);
          for (var a = 0, l = Array(g); a < g; a++) l[a] = m[a];
          return l;
        }
        var r = 2147483647;
      }, 4172: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.MemoText = o.MemoReturn = o.MemoNone = o.MemoID = o.MemoHash = o.Memo = void 0;
        var h = u(3740), f = m(u(1242)), r = m(u(1918));
        function m(k) {
          return k && k.__esModule ? k : { default: k };
        }
        function g(k) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, g(k);
        }
        function a(k, w) {
          for (var F = 0; F < w.length; F++) {
            var I = w[F];
            I.enumerable = I.enumerable || false, I.configurable = true, "value" in I && (I.writable = true), Object.defineProperty(k, l(I.key), I);
          }
        }
        function l(k) {
          var w = function(F, I) {
            if (g(F) != "object" || !F) return F;
            var q = F[Symbol.toPrimitive];
            if (q !== void 0) {
              var D = q.call(F, I);
              if (g(D) != "object") return D;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(F);
          }(k, "string");
          return g(w) == "symbol" ? w : w + "";
        }
        var d = o.MemoNone = "none", b = o.MemoID = "id", S = o.MemoText = "text", E = o.MemoHash = "hash", R = o.MemoReturn = "return";
        o.Memo = function() {
          function k(q) {
            var D = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            switch (function(H, _) {
              if (!(H instanceof _)) throw new TypeError("Cannot call a class as a function");
            }(this, k), this._type = q, this._value = D, this._type) {
              case d:
                break;
              case b:
                k._validateIdValue(D);
                break;
              case S:
                k._validateTextValue(D);
                break;
              case E:
              case R:
                k._validateHashValue(D), typeof D == "string" && (this._value = c.from(D, "hex"));
                break;
              default:
                throw new Error("Invalid memo type");
            }
          }
          return w = k, I = [{ key: "_validateIdValue", value: function(q) {
            var D, H = new Error("Expects a int64 as a string. Got ".concat(q));
            if (typeof q != "string") throw H;
            try {
              D = new f.default(q);
            } catch {
              throw H;
            }
            if (!D.isFinite() || D.isNaN()) throw H;
          } }, { key: "_validateTextValue", value: function(q) {
            if (!r.default.Memo.armTypeForArm("text").isValid(q)) throw new Error("Expects string, array or buffer, max 28 bytes");
          } }, { key: "_validateHashValue", value: function(q) {
            var D, H = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(q));
            if (q == null) throw H;
            if (typeof q == "string") {
              if (!/^[0-9A-Fa-f]{64}$/g.test(q)) throw H;
              D = c.from(q, "hex");
            } else {
              if (!c.isBuffer(q)) throw H;
              D = c.from(q);
            }
            if (!D.length || D.length !== 32) throw H;
          } }, { key: "none", value: function() {
            return new k(d);
          } }, { key: "text", value: function(q) {
            return new k(S, q);
          } }, { key: "id", value: function(q) {
            return new k(b, q);
          } }, { key: "hash", value: function(q) {
            return new k(E, q);
          } }, { key: "return", value: function(q) {
            return new k(R, q);
          } }, { key: "fromXDRObject", value: function(q) {
            switch (q.arm()) {
              case "id":
                return k.id(q.value().toString());
              case "text":
                return k.text(q.value());
              case "hash":
                return k.hash(q.value());
              case "retHash":
                return k.return(q.value());
            }
            if (q.value() === void 0) return k.none();
            throw new Error("Unknown type");
          } }], (F = [{ key: "type", get: function() {
            return this._type;
          }, set: function(q) {
            throw new Error("Memo is immutable");
          } }, { key: "value", get: function() {
            switch (this._type) {
              case d:
                return null;
              case b:
              case S:
                return this._value;
              case E:
              case R:
                return c.from(this._value);
              default:
                throw new Error("Invalid memo type");
            }
          }, set: function(q) {
            throw new Error("Memo is immutable");
          } }, { key: "toXDRObject", value: function() {
            switch (this._type) {
              case d:
                return r.default.Memo.memoNone();
              case b:
                return r.default.Memo.memoId(h.UnsignedHyper.fromString(this._value));
              case S:
                return r.default.Memo.memoText(this._value);
              case E:
                return r.default.Memo.memoHash(this._value);
              case R:
                return r.default.Memo.memoReturn(this._value);
              default:
                return null;
            }
          } }]) && a(w.prototype, F), I && a(w, I), Object.defineProperty(w, "prototype", { writable: false }), w;
          var w, F, I;
        }();
      }, 4193: function(t, o, u) {
        var c, h, f;
        (function(r, m) {
          t.exports ? t.exports = m(u(9340), u(1430), u(4704)) : (h = [u(9340), u(1430), u(4704)], (f = typeof (c = m) == "function" ? c.apply(o, h) : c) === void 0 || (t.exports = f));
        })(0, function(r, m, g, a) {
          var l = a && a.URI;
          function d(B, Z) {
            var ie = arguments.length >= 1;
            if (!(this instanceof d)) return ie ? arguments.length >= 2 ? new d(B, Z) : new d(B) : new d();
            if (B === void 0) {
              if (ie) throw new TypeError("undefined is not a valid argument for URI");
              B = typeof location < "u" ? location.href + "" : "";
            }
            if (B === null && ie) throw new TypeError("null is not a valid argument for URI");
            return this.href(B), Z !== void 0 ? this.absoluteTo(Z) : this;
          }
          d.version = "1.19.11";
          var b = d.prototype, S = Object.prototype.hasOwnProperty;
          function E(B) {
            return B.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
          }
          function R(B) {
            return B === void 0 ? "Undefined" : String(Object.prototype.toString.call(B)).slice(8, -1);
          }
          function k(B) {
            return R(B) === "Array";
          }
          function w(B, Z) {
            var ie, $, oe = {};
            if (R(Z) === "RegExp") oe = null;
            else if (k(Z)) for (ie = 0, $ = Z.length; ie < $; ie++) oe[Z[ie]] = true;
            else oe[Z] = true;
            for (ie = 0, $ = B.length; ie < $; ie++) (oe && oe[B[ie]] !== void 0 || !oe && Z.test(B[ie])) && (B.splice(ie, 1), $--, ie--);
            return B;
          }
          function F(B, Z) {
            var ie, $;
            if (k(Z)) {
              for (ie = 0, $ = Z.length; ie < $; ie++) if (!F(B, Z[ie])) return false;
              return true;
            }
            var oe = R(Z);
            for (ie = 0, $ = B.length; ie < $; ie++) if (oe === "RegExp") {
              if (typeof B[ie] == "string" && B[ie].match(Z)) return true;
            } else if (B[ie] === Z) return true;
            return false;
          }
          function I(B, Z) {
            if (!k(B) || !k(Z) || B.length !== Z.length) return false;
            B.sort(), Z.sort();
            for (var ie = 0, $ = B.length; ie < $; ie++) if (B[ie] !== Z[ie]) return false;
            return true;
          }
          function q(B) {
            return B.replace(/^\/+|\/+$/g, "");
          }
          function D(B) {
            return escape(B);
          }
          function H(B) {
            return encodeURIComponent(B).replace(/[!'()*]/g, D).replace(/\*/g, "%2A");
          }
          d._parts = function() {
            return { protocol: null, username: null, password: null, hostname: null, urn: null, port: null, path: null, query: null, fragment: null, preventInvalidHostname: d.preventInvalidHostname, duplicateQueryParameters: d.duplicateQueryParameters, escapeQuerySpace: d.escapeQuerySpace };
          }, d.preventInvalidHostname = false, d.duplicateQueryParameters = false, d.escapeQuerySpace = true, d.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, d.idn_expression = /[^a-z0-9\._-]/i, d.punycode_expression = /(xn--)/i, d.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, d.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, d.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?\xab\xbb\u201c\u201d\u2018\u2019]))/gi, d.findUri = { start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi, end: /[\s\r\n]|$/, trim: /[`!()\[\]{};:'".,<>?\xab\xbb\u201c\u201d\u201e\u2018\u2019]+$/, parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g }, d.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, d.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, d.defaultPorts = { http: "80", https: "443", ftp: "21", gopher: "70", ws: "80", wss: "443" }, d.hostProtocols = ["http", "https"], d.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, d.domAttributes = { a: "href", blockquote: "cite", link: "href", base: "href", script: "src", form: "action", img: "src", area: "href", iframe: "src", embed: "src", source: "src", track: "src", input: "src", audio: "src", video: "src" }, d.getDomAttribute = function(B) {
            if (B && B.nodeName) {
              var Z = B.nodeName.toLowerCase();
              if (Z !== "input" || B.type === "image") return d.domAttributes[Z];
            }
          }, d.encode = H, d.decode = decodeURIComponent, d.iso8859 = function() {
            d.encode = escape, d.decode = unescape;
          }, d.unicode = function() {
            d.encode = H, d.decode = decodeURIComponent;
          }, d.characters = { pathname: { encode: { expression: /%(24|26|2B|2C|3B|3D|3A|40)/gi, map: { "%24": "$", "%26": "&", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%3A": ":", "%40": "@" } }, decode: { expression: /[\/\?#]/g, map: { "/": "%2F", "?": "%3F", "#": "%23" } } }, reserved: { encode: { expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi, map: { "%3A": ":", "%2F": "/", "%3F": "?", "%23": "#", "%5B": "[", "%5D": "]", "%40": "@", "%21": "!", "%24": "$", "%26": "&", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=" } } }, urnpath: { encode: { expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi, map: { "%21": "!", "%24": "$", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%40": "@" } }, decode: { expression: /[\/\?#:]/g, map: { "/": "%2F", "?": "%3F", "#": "%23", ":": "%3A" } } } }, d.encodeQuery = function(B, Z) {
            var ie = d.encode(B + "");
            return Z === void 0 && (Z = d.escapeQuerySpace), Z ? ie.replace(/%20/g, "+") : ie;
          }, d.decodeQuery = function(B, Z) {
            B += "", Z === void 0 && (Z = d.escapeQuerySpace);
            try {
              return d.decode(Z ? B.replace(/\+/g, "%20") : B);
            } catch {
              return B;
            }
          };
          var _, T = { encode: "encode", decode: "decode" }, L = function(B, Z) {
            return function(ie) {
              try {
                return d[Z](ie + "").replace(d.characters[B][Z].expression, function($) {
                  return d.characters[B][Z].map[$];
                });
              } catch {
                return ie;
              }
            };
          };
          for (_ in T) d[_ + "PathSegment"] = L("pathname", T[_]), d[_ + "UrnPathSegment"] = L("urnpath", T[_]);
          var j = function(B, Z, ie) {
            return function($) {
              var oe;
              oe = ie ? function(ue) {
                return d[Z](d[ie](ue));
              } : d[Z];
              for (var ce = ($ + "").split(B), ye = 0, ae = ce.length; ye < ae; ye++) ce[ye] = oe(ce[ye]);
              return ce.join(B);
            };
          };
          function z(B) {
            return function(Z, ie) {
              return Z === void 0 ? this._parts[B] || "" : (this._parts[B] = Z || null, this.build(!ie), this);
            };
          }
          function Y(B, Z) {
            return function(ie, $) {
              return ie === void 0 ? this._parts[B] || "" : (ie !== null && (ie += "").charAt(0) === Z && (ie = ie.substring(1)), this._parts[B] = ie, this.build(!$), this);
            };
          }
          d.decodePath = j("/", "decodePathSegment"), d.decodeUrnPath = j(":", "decodeUrnPathSegment"), d.recodePath = j("/", "encodePathSegment", "decode"), d.recodeUrnPath = j(":", "encodeUrnPathSegment", "decode"), d.encodeReserved = L("reserved", "encode"), d.parse = function(B, Z) {
            var ie;
            return Z || (Z = { preventInvalidHostname: d.preventInvalidHostname }), (ie = (B = (B = B.replace(d.leading_whitespace_expression, "")).replace(d.ascii_tab_whitespace, "")).indexOf("#")) > -1 && (Z.fragment = B.substring(ie + 1) || null, B = B.substring(0, ie)), (ie = B.indexOf("?")) > -1 && (Z.query = B.substring(ie + 1) || null, B = B.substring(0, ie)), (B = (B = B.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://")).replace(/^[/\\]{2,}/i, "//")).substring(0, 2) === "//" ? (Z.protocol = null, B = B.substring(2), B = d.parseAuthority(B, Z)) : (ie = B.indexOf(":")) > -1 && (Z.protocol = B.substring(0, ie) || null, Z.protocol && !Z.protocol.match(d.protocol_expression) ? Z.protocol = void 0 : B.substring(ie + 1, ie + 3).replace(/\\/g, "/") === "//" ? (B = B.substring(ie + 3), B = d.parseAuthority(B, Z)) : (B = B.substring(ie + 1), Z.urn = true)), Z.path = B, Z;
          }, d.parseHost = function(B, Z) {
            B || (B = "");
            var ie, $, oe = (B = B.replace(/\\/g, "/")).indexOf("/");
            if (oe === -1 && (oe = B.length), B.charAt(0) === "[") ie = B.indexOf("]"), Z.hostname = B.substring(1, ie) || null, Z.port = B.substring(ie + 2, oe) || null, Z.port === "/" && (Z.port = null);
            else {
              var ce = B.indexOf(":"), ye = B.indexOf("/"), ae = B.indexOf(":", ce + 1);
              ae !== -1 && (ye === -1 || ae < ye) ? (Z.hostname = B.substring(0, oe) || null, Z.port = null) : ($ = B.substring(0, oe).split(":"), Z.hostname = $[0] || null, Z.port = $[1] || null);
            }
            return Z.hostname && B.substring(oe).charAt(0) !== "/" && (oe++, B = "/" + B), Z.preventInvalidHostname && d.ensureValidHostname(Z.hostname, Z.protocol), Z.port && d.ensureValidPort(Z.port), B.substring(oe) || "/";
          }, d.parseAuthority = function(B, Z) {
            return B = d.parseUserinfo(B, Z), d.parseHost(B, Z);
          }, d.parseUserinfo = function(B, Z) {
            var ie = B;
            B.indexOf("\\") !== -1 && (B = B.replace(/\\/g, "/"));
            var $, oe = B.indexOf("/"), ce = B.lastIndexOf("@", oe > -1 ? oe : B.length - 1);
            return ce > -1 && (oe === -1 || ce < oe) ? ($ = B.substring(0, ce).split(":"), Z.username = $[0] ? d.decode($[0]) : null, $.shift(), Z.password = $[0] ? d.decode($.join(":")) : null, B = ie.substring(ce + 1)) : (Z.username = null, Z.password = null), B;
          }, d.parseQuery = function(B, Z) {
            if (!B) return {};
            if (!(B = B.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""))) return {};
            for (var ie, $, oe, ce = {}, ye = B.split("&"), ae = ye.length, ue = 0; ue < ae; ue++) ie = ye[ue].split("="), $ = d.decodeQuery(ie.shift(), Z), oe = ie.length ? d.decodeQuery(ie.join("="), Z) : null, $ !== "__proto__" && (S.call(ce, $) ? (typeof ce[$] != "string" && ce[$] !== null || (ce[$] = [ce[$]]), ce[$].push(oe)) : ce[$] = oe);
            return ce;
          }, d.build = function(B) {
            var Z = "", ie = false;
            return B.protocol && (Z += B.protocol + ":"), B.urn || !Z && !B.hostname || (Z += "//", ie = true), Z += d.buildAuthority(B) || "", typeof B.path == "string" && (B.path.charAt(0) !== "/" && ie && (Z += "/"), Z += B.path), typeof B.query == "string" && B.query && (Z += "?" + B.query), typeof B.fragment == "string" && B.fragment && (Z += "#" + B.fragment), Z;
          }, d.buildHost = function(B) {
            var Z = "";
            return B.hostname ? (d.ip6_expression.test(B.hostname) ? Z += "[" + B.hostname + "]" : Z += B.hostname, B.port && (Z += ":" + B.port), Z) : "";
          }, d.buildAuthority = function(B) {
            return d.buildUserinfo(B) + d.buildHost(B);
          }, d.buildUserinfo = function(B) {
            var Z = "";
            return B.username && (Z += d.encode(B.username)), B.password && (Z += ":" + d.encode(B.password)), Z && (Z += "@"), Z;
          }, d.buildQuery = function(B, Z, ie) {
            var $, oe, ce, ye, ae = "";
            for (oe in B) if (oe !== "__proto__" && S.call(B, oe)) if (k(B[oe])) for ($ = {}, ce = 0, ye = B[oe].length; ce < ye; ce++) B[oe][ce] !== void 0 && $[B[oe][ce] + ""] === void 0 && (ae += "&" + d.buildQueryParameter(oe, B[oe][ce], ie), Z !== true && ($[B[oe][ce] + ""] = true));
            else B[oe] !== void 0 && (ae += "&" + d.buildQueryParameter(oe, B[oe], ie));
            return ae.substring(1);
          }, d.buildQueryParameter = function(B, Z, ie) {
            return d.encodeQuery(B, ie) + (Z !== null ? "=" + d.encodeQuery(Z, ie) : "");
          }, d.addQuery = function(B, Z, ie) {
            if (typeof Z == "object") for (var $ in Z) S.call(Z, $) && d.addQuery(B, $, Z[$]);
            else {
              if (typeof Z != "string") throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
              if (B[Z] === void 0) return void (B[Z] = ie);
              typeof B[Z] == "string" && (B[Z] = [B[Z]]), k(ie) || (ie = [ie]), B[Z] = (B[Z] || []).concat(ie);
            }
          }, d.setQuery = function(B, Z, ie) {
            if (typeof Z == "object") for (var $ in Z) S.call(Z, $) && d.setQuery(B, $, Z[$]);
            else {
              if (typeof Z != "string") throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
              B[Z] = ie === void 0 ? null : ie;
            }
          }, d.removeQuery = function(B, Z, ie) {
            var $, oe, ce;
            if (k(Z)) for ($ = 0, oe = Z.length; $ < oe; $++) B[Z[$]] = void 0;
            else if (R(Z) === "RegExp") for (ce in B) Z.test(ce) && (B[ce] = void 0);
            else if (typeof Z == "object") for (ce in Z) S.call(Z, ce) && d.removeQuery(B, ce, Z[ce]);
            else {
              if (typeof Z != "string") throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
              ie !== void 0 ? R(ie) === "RegExp" ? !k(B[Z]) && ie.test(B[Z]) ? B[Z] = void 0 : B[Z] = w(B[Z], ie) : B[Z] !== String(ie) || k(ie) && ie.length !== 1 ? k(B[Z]) && (B[Z] = w(B[Z], ie)) : B[Z] = void 0 : B[Z] = void 0;
            }
          }, d.hasQuery = function(B, Z, ie, $) {
            switch (R(Z)) {
              case "String":
                break;
              case "RegExp":
                for (var oe in B) if (S.call(B, oe) && Z.test(oe) && (ie === void 0 || d.hasQuery(B, oe, ie))) return true;
                return false;
              case "Object":
                for (var ce in Z) if (S.call(Z, ce) && !d.hasQuery(B, ce, Z[ce])) return false;
                return true;
              default:
                throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
            }
            switch (R(ie)) {
              case "Undefined":
                return Z in B;
              case "Boolean":
                return ie === !!(k(B[Z]) ? B[Z].length : B[Z]);
              case "Function":
                return !!ie(B[Z], Z, B);
              case "Array":
                return !!k(B[Z]) && ($ ? F : I)(B[Z], ie);
              case "RegExp":
                return k(B[Z]) ? !!$ && F(B[Z], ie) : !!(B[Z] && B[Z].match(ie));
              case "Number":
                ie = String(ie);
              case "String":
                return k(B[Z]) ? !!$ && F(B[Z], ie) : B[Z] === ie;
              default:
                throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
            }
          }, d.joinPaths = function() {
            for (var B = [], Z = [], ie = 0, $ = 0; $ < arguments.length; $++) {
              var oe = new d(arguments[$]);
              B.push(oe);
              for (var ce = oe.segment(), ye = 0; ye < ce.length; ye++) typeof ce[ye] == "string" && Z.push(ce[ye]), ce[ye] && ie++;
            }
            if (!Z.length || !ie) return new d("");
            var ae = new d("").segment(Z);
            return B[0].path() !== "" && B[0].path().slice(0, 1) !== "/" || ae.path("/" + ae.path()), ae.normalize();
          }, d.commonPath = function(B, Z) {
            var ie, $ = Math.min(B.length, Z.length);
            for (ie = 0; ie < $; ie++) if (B.charAt(ie) !== Z.charAt(ie)) {
              ie--;
              break;
            }
            return ie < 1 ? B.charAt(0) === Z.charAt(0) && B.charAt(0) === "/" ? "/" : "" : (B.charAt(ie) === "/" && Z.charAt(ie) === "/" || (ie = B.substring(0, ie).lastIndexOf("/")), B.substring(0, ie + 1));
          }, d.withinString = function(B, Z, ie) {
            ie || (ie = {});
            var $ = ie.start || d.findUri.start, oe = ie.end || d.findUri.end, ce = ie.trim || d.findUri.trim, ye = ie.parens || d.findUri.parens, ae = /[a-z0-9-]=["']?$/i;
            for ($.lastIndex = 0; ; ) {
              var ue = $.exec(B);
              if (!ue) break;
              var ne = ue.index;
              if (ie.ignoreHtml) {
                var ge = B.slice(Math.max(ne - 3, 0), ne);
                if (ge && ae.test(ge)) continue;
              }
              for (var Te = ne + B.slice(ne).search(oe), pe = B.slice(ne, Te), Oe = -1; ; ) {
                var xe = ye.exec(pe);
                if (!xe) break;
                var Ve = xe.index + xe[0].length;
                Oe = Math.max(Oe, Ve);
              }
              if (!((pe = Oe > -1 ? pe.slice(0, Oe) + pe.slice(Oe).replace(ce, "") : pe.replace(ce, "")).length <= ue[0].length || ie.ignore && ie.ignore.test(pe))) {
                var _e = Z(pe, ne, Te = ne + pe.length, B);
                _e !== void 0 ? (_e = String(_e), B = B.slice(0, ne) + _e + B.slice(Te), $.lastIndex = ne + _e.length) : $.lastIndex = Te;
              }
            }
            return $.lastIndex = 0, B;
          }, d.ensureValidHostname = function(B, Z) {
            var ie = !!B, $ = false;
            if (Z && ($ = F(d.hostProtocols, Z)), $ && !ie) throw new TypeError("Hostname cannot be empty, if protocol is " + Z);
            if (B && B.match(d.invalid_hostname_characters)) {
              if (!r) throw new TypeError('Hostname "' + B + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
              if (r.toASCII(B).match(d.invalid_hostname_characters)) throw new TypeError('Hostname "' + B + '" contains characters other than [A-Z0-9.-:_]');
            }
          }, d.ensureValidPort = function(B) {
            if (B) {
              var Z = Number(B);
              if (!(/^[0-9]+$/.test(Z) && Z > 0 && Z < 65536)) throw new TypeError('Port "' + B + '" is not a valid port');
            }
          }, d.noConflict = function(B) {
            if (B) {
              var Z = { URI: this.noConflict() };
              return a.URITemplate && typeof a.URITemplate.noConflict == "function" && (Z.URITemplate = a.URITemplate.noConflict()), a.IPv6 && typeof a.IPv6.noConflict == "function" && (Z.IPv6 = a.IPv6.noConflict()), a.SecondLevelDomains && typeof a.SecondLevelDomains.noConflict == "function" && (Z.SecondLevelDomains = a.SecondLevelDomains.noConflict()), Z;
            }
            return a.URI === this && (a.URI = l), this;
          }, b.build = function(B) {
            return B === true ? this._deferred_build = true : (B === void 0 || this._deferred_build) && (this._string = d.build(this._parts), this._deferred_build = false), this;
          }, b.clone = function() {
            return new d(this);
          }, b.valueOf = b.toString = function() {
            return this.build(false)._string;
          }, b.protocol = z("protocol"), b.username = z("username"), b.password = z("password"), b.hostname = z("hostname"), b.port = z("port"), b.query = Y("query", "?"), b.fragment = Y("fragment", "#"), b.search = function(B, Z) {
            var ie = this.query(B, Z);
            return typeof ie == "string" && ie.length ? "?" + ie : ie;
          }, b.hash = function(B, Z) {
            var ie = this.fragment(B, Z);
            return typeof ie == "string" && ie.length ? "#" + ie : ie;
          }, b.pathname = function(B, Z) {
            if (B === void 0 || B === true) {
              var ie = this._parts.path || (this._parts.hostname ? "/" : "");
              return B ? (this._parts.urn ? d.decodeUrnPath : d.decodePath)(ie) : ie;
            }
            return this._parts.urn ? this._parts.path = B ? d.recodeUrnPath(B) : "" : this._parts.path = B ? d.recodePath(B) : "/", this.build(!Z), this;
          }, b.path = b.pathname, b.href = function(B, Z) {
            var ie;
            if (B === void 0) return this.toString();
            this._string = "", this._parts = d._parts();
            var $ = B instanceof d, oe = typeof B == "object" && (B.hostname || B.path || B.pathname);
            if (B.nodeName && (B = B[d.getDomAttribute(B)] || "", oe = false), !$ && oe && B.pathname !== void 0 && (B = B.toString()), typeof B == "string" || B instanceof String) this._parts = d.parse(String(B), this._parts);
            else {
              if (!$ && !oe) throw new TypeError("invalid input");
              var ce = $ ? B._parts : B;
              for (ie in ce) ie !== "query" && S.call(this._parts, ie) && (this._parts[ie] = ce[ie]);
              ce.query && this.query(ce.query, false);
            }
            return this.build(!Z), this;
          }, b.is = function(B) {
            var Z = false, ie = false, $ = false, oe = false, ce = false, ye = false, ae = false, ue = !this._parts.urn;
            switch (this._parts.hostname && (ue = false, ie = d.ip4_expression.test(this._parts.hostname), $ = d.ip6_expression.test(this._parts.hostname), ce = (oe = !(Z = ie || $)) && g && g.has(this._parts.hostname), ye = oe && d.idn_expression.test(this._parts.hostname), ae = oe && d.punycode_expression.test(this._parts.hostname)), B.toLowerCase()) {
              case "relative":
                return ue;
              case "absolute":
                return !ue;
              case "domain":
              case "name":
                return oe;
              case "sld":
                return ce;
              case "ip":
                return Z;
              case "ip4":
              case "ipv4":
              case "inet4":
                return ie;
              case "ip6":
              case "ipv6":
              case "inet6":
                return $;
              case "idn":
                return ye;
              case "url":
                return !this._parts.urn;
              case "urn":
                return !!this._parts.urn;
              case "punycode":
                return ae;
            }
            return null;
          };
          var te = b.protocol, G = b.port, K = b.hostname;
          b.protocol = function(B, Z) {
            if (B && !(B = B.replace(/:(\/\/)?$/, "")).match(d.protocol_expression)) throw new TypeError('Protocol "' + B + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
            return te.call(this, B, Z);
          }, b.scheme = b.protocol, b.port = function(B, Z) {
            return this._parts.urn ? B === void 0 ? "" : this : (B !== void 0 && (B === 0 && (B = null), B && ((B += "").charAt(0) === ":" && (B = B.substring(1)), d.ensureValidPort(B))), G.call(this, B, Z));
          }, b.hostname = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B !== void 0) {
              var ie = { preventInvalidHostname: this._parts.preventInvalidHostname };
              if (d.parseHost(B, ie) !== "/") throw new TypeError('Hostname "' + B + '" contains characters other than [A-Z0-9.-]');
              B = ie.hostname, this._parts.preventInvalidHostname && d.ensureValidHostname(B, this._parts.protocol);
            }
            return K.call(this, B, Z);
          }, b.origin = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0) {
              var ie = this.protocol();
              return this.authority() ? (ie ? ie + "://" : "") + this.authority() : "";
            }
            var $ = d(B);
            return this.protocol($.protocol()).authority($.authority()).build(!Z), this;
          }, b.host = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0) return this._parts.hostname ? d.buildHost(this._parts) : "";
            if (d.parseHost(B, this._parts) !== "/") throw new TypeError('Hostname "' + B + '" contains characters other than [A-Z0-9.-]');
            return this.build(!Z), this;
          }, b.authority = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0) return this._parts.hostname ? d.buildAuthority(this._parts) : "";
            if (d.parseAuthority(B, this._parts) !== "/") throw new TypeError('Hostname "' + B + '" contains characters other than [A-Z0-9.-]');
            return this.build(!Z), this;
          }, b.userinfo = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0) {
              var ie = d.buildUserinfo(this._parts);
              return ie && ie.substring(0, ie.length - 1);
            }
            return B[B.length - 1] !== "@" && (B += "@"), d.parseUserinfo(B, this._parts), this.build(!Z), this;
          }, b.resource = function(B, Z) {
            var ie;
            return B === void 0 ? this.path() + this.search() + this.hash() : (ie = d.parse(B), this._parts.path = ie.path, this._parts.query = ie.query, this._parts.fragment = ie.fragment, this.build(!Z), this);
          }, b.subdomain = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var ie = this._parts.hostname.length - this.domain().length - 1;
              return this._parts.hostname.substring(0, ie) || "";
            }
            var $ = this._parts.hostname.length - this.domain().length, oe = this._parts.hostname.substring(0, $), ce = new RegExp("^" + E(oe));
            if (B && B.charAt(B.length - 1) !== "." && (B += "."), B.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
            return B && d.ensureValidHostname(B, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(ce, B), this.build(!Z), this;
          }, b.domain = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (typeof B == "boolean" && (Z = B, B = void 0), B === void 0) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var ie = this._parts.hostname.match(/\./g);
              if (ie && ie.length < 2) return this._parts.hostname;
              var $ = this._parts.hostname.length - this.tld(Z).length - 1;
              return $ = this._parts.hostname.lastIndexOf(".", $ - 1) + 1, this._parts.hostname.substring($) || "";
            }
            if (!B) throw new TypeError("cannot set domain empty");
            if (B.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
            if (d.ensureValidHostname(B, this._parts.protocol), !this._parts.hostname || this.is("IP")) this._parts.hostname = B;
            else {
              var oe = new RegExp(E(this.domain()) + "$");
              this._parts.hostname = this._parts.hostname.replace(oe, B);
            }
            return this.build(!Z), this;
          }, b.tld = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (typeof B == "boolean" && (Z = B, B = void 0), B === void 0) {
              if (!this._parts.hostname || this.is("IP")) return "";
              var ie = this._parts.hostname.lastIndexOf("."), $ = this._parts.hostname.substring(ie + 1);
              return Z !== true && g && g.list[$.toLowerCase()] && g.get(this._parts.hostname) || $;
            }
            var oe;
            if (!B) throw new TypeError("cannot set TLD empty");
            if (B.match(/[^a-zA-Z0-9-]/)) {
              if (!g || !g.is(B)) throw new TypeError('TLD "' + B + '" contains characters other than [A-Z0-9]');
              oe = new RegExp(E(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(oe, B);
            } else {
              if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host");
              oe = new RegExp(E(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(oe, B);
            }
            return this.build(!Z), this;
          }, b.directory = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0 || B === true) {
              if (!this._parts.path && !this._parts.hostname) return "";
              if (this._parts.path === "/") return "/";
              var ie = this._parts.path.length - this.filename().length - 1, $ = this._parts.path.substring(0, ie) || (this._parts.hostname ? "/" : "");
              return B ? d.decodePath($) : $;
            }
            var oe = this._parts.path.length - this.filename().length, ce = this._parts.path.substring(0, oe), ye = new RegExp("^" + E(ce));
            return this.is("relative") || (B || (B = "/"), B.charAt(0) !== "/" && (B = "/" + B)), B && B.charAt(B.length - 1) !== "/" && (B += "/"), B = d.recodePath(B), this._parts.path = this._parts.path.replace(ye, B), this.build(!Z), this;
          }, b.filename = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (typeof B != "string") {
              if (!this._parts.path || this._parts.path === "/") return "";
              var ie = this._parts.path.lastIndexOf("/"), $ = this._parts.path.substring(ie + 1);
              return B ? d.decodePathSegment($) : $;
            }
            var oe = false;
            B.charAt(0) === "/" && (B = B.substring(1)), B.match(/\.?\//) && (oe = true);
            var ce = new RegExp(E(this.filename()) + "$");
            return B = d.recodePath(B), this._parts.path = this._parts.path.replace(ce, B), oe ? this.normalizePath(Z) : this.build(!Z), this;
          }, b.suffix = function(B, Z) {
            if (this._parts.urn) return B === void 0 ? "" : this;
            if (B === void 0 || B === true) {
              if (!this._parts.path || this._parts.path === "/") return "";
              var ie, $, oe = this.filename(), ce = oe.lastIndexOf(".");
              return ce === -1 ? "" : (ie = oe.substring(ce + 1), $ = /^[a-z0-9%]+$/i.test(ie) ? ie : "", B ? d.decodePathSegment($) : $);
            }
            B.charAt(0) === "." && (B = B.substring(1));
            var ye, ae = this.suffix();
            if (ae) ye = B ? new RegExp(E(ae) + "$") : new RegExp(E("." + ae) + "$");
            else {
              if (!B) return this;
              this._parts.path += "." + d.recodePath(B);
            }
            return ye && (B = d.recodePath(B), this._parts.path = this._parts.path.replace(ye, B)), this.build(!Z), this;
          }, b.segment = function(B, Z, ie) {
            var $ = this._parts.urn ? ":" : "/", oe = this.path(), ce = oe.substring(0, 1) === "/", ye = oe.split($);
            if (B !== void 0 && typeof B != "number" && (ie = Z, Z = B, B = void 0), B !== void 0 && typeof B != "number") throw new Error('Bad segment "' + B + '", must be 0-based integer');
            if (ce && ye.shift(), B < 0 && (B = Math.max(ye.length + B, 0)), Z === void 0) return B === void 0 ? ye : ye[B];
            if (B === null || ye[B] === void 0) if (k(Z)) {
              ye = [];
              for (var ae = 0, ue = Z.length; ae < ue; ae++) (Z[ae].length || ye.length && ye[ye.length - 1].length) && (ye.length && !ye[ye.length - 1].length && ye.pop(), ye.push(q(Z[ae])));
            } else (Z || typeof Z == "string") && (Z = q(Z), ye[ye.length - 1] === "" ? ye[ye.length - 1] = Z : ye.push(Z));
            else Z ? ye[B] = q(Z) : ye.splice(B, 1);
            return ce && ye.unshift(""), this.path(ye.join($), ie);
          }, b.segmentCoded = function(B, Z, ie) {
            var $, oe, ce;
            if (typeof B != "number" && (ie = Z, Z = B, B = void 0), Z === void 0) {
              if (k($ = this.segment(B, Z, ie))) for (oe = 0, ce = $.length; oe < ce; oe++) $[oe] = d.decode($[oe]);
              else $ = $ !== void 0 ? d.decode($) : void 0;
              return $;
            }
            if (k(Z)) for (oe = 0, ce = Z.length; oe < ce; oe++) Z[oe] = d.encode(Z[oe]);
            else Z = typeof Z == "string" || Z instanceof String ? d.encode(Z) : Z;
            return this.segment(B, Z, ie);
          };
          var J = b.query;
          return b.query = function(B, Z) {
            if (B === true) return d.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if (typeof B == "function") {
              var ie = d.parseQuery(this._parts.query, this._parts.escapeQuerySpace), $ = B.call(this, ie);
              return this._parts.query = d.buildQuery($ || ie, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!Z), this;
            }
            return B !== void 0 && typeof B != "string" ? (this._parts.query = d.buildQuery(B, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!Z), this) : J.call(this, B, Z);
          }, b.setQuery = function(B, Z, ie) {
            var $ = d.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            if (typeof B == "string" || B instanceof String) $[B] = Z !== void 0 ? Z : null;
            else {
              if (typeof B != "object") throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
              for (var oe in B) S.call(B, oe) && ($[oe] = B[oe]);
            }
            return this._parts.query = d.buildQuery($, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof B != "string" && (ie = Z), this.build(!ie), this;
          }, b.addQuery = function(B, Z, ie) {
            var $ = d.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return d.addQuery($, B, Z === void 0 ? null : Z), this._parts.query = d.buildQuery($, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof B != "string" && (ie = Z), this.build(!ie), this;
          }, b.removeQuery = function(B, Z, ie) {
            var $ = d.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return d.removeQuery($, B, Z), this._parts.query = d.buildQuery($, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof B != "string" && (ie = Z), this.build(!ie), this;
          }, b.hasQuery = function(B, Z, ie) {
            var $ = d.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
            return d.hasQuery($, B, Z, ie);
          }, b.setSearch = b.setQuery, b.addSearch = b.addQuery, b.removeSearch = b.removeQuery, b.hasSearch = b.hasQuery, b.normalize = function() {
            return this._parts.urn ? this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build() : this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
          }, b.normalizeProtocol = function(B) {
            return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!B)), this;
          }, b.normalizeHostname = function(B) {
            return this._parts.hostname && (this.is("IDN") && r ? this._parts.hostname = r.toASCII(this._parts.hostname) : this.is("IPv6") && m && (this._parts.hostname = m.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!B)), this;
          }, b.normalizePort = function(B) {
            return typeof this._parts.protocol == "string" && this._parts.port === d.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!B)), this;
          }, b.normalizePath = function(B) {
            var Z, ie = this._parts.path;
            if (!ie) return this;
            if (this._parts.urn) return this._parts.path = d.recodeUrnPath(this._parts.path), this.build(!B), this;
            if (this._parts.path === "/") return this;
            var $, oe, ce = "";
            for ((ie = d.recodePath(ie)).charAt(0) !== "/" && (Z = true, ie = "/" + ie), ie.slice(-3) !== "/.." && ie.slice(-2) !== "/." || (ie += "/"), ie = ie.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), Z && (ce = ie.substring(1).match(/^(\.\.\/)+/) || "") && (ce = ce[0]); ($ = ie.search(/\/\.\.(\/|$)/)) !== -1; ) $ !== 0 ? ((oe = ie.substring(0, $).lastIndexOf("/")) === -1 && (oe = $), ie = ie.substring(0, oe) + ie.substring($ + 3)) : ie = ie.substring(3);
            return Z && this.is("relative") && (ie = ce + ie.substring(1)), this._parts.path = ie, this.build(!B), this;
          }, b.normalizePathname = b.normalizePath, b.normalizeQuery = function(B) {
            return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(d.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!B)), this;
          }, b.normalizeFragment = function(B) {
            return this._parts.fragment || (this._parts.fragment = null, this.build(!B)), this;
          }, b.normalizeSearch = b.normalizeQuery, b.normalizeHash = b.normalizeFragment, b.iso8859 = function() {
            var B = d.encode, Z = d.decode;
            d.encode = escape, d.decode = decodeURIComponent;
            try {
              this.normalize();
            } finally {
              d.encode = B, d.decode = Z;
            }
            return this;
          }, b.unicode = function() {
            var B = d.encode, Z = d.decode;
            d.encode = H, d.decode = unescape;
            try {
              this.normalize();
            } finally {
              d.encode = B, d.decode = Z;
            }
            return this;
          }, b.readable = function() {
            var B = this.clone();
            B.username("").password("").normalize();
            var Z = "";
            if (B._parts.protocol && (Z += B._parts.protocol + "://"), B._parts.hostname && (B.is("punycode") && r ? (Z += r.toUnicode(B._parts.hostname), B._parts.port && (Z += ":" + B._parts.port)) : Z += B.host()), B._parts.hostname && B._parts.path && B._parts.path.charAt(0) !== "/" && (Z += "/"), Z += B.path(true), B._parts.query) {
              for (var ie = "", $ = 0, oe = B._parts.query.split("&"), ce = oe.length; $ < ce; $++) {
                var ye = (oe[$] || "").split("=");
                ie += "&" + d.decodeQuery(ye[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), ye[1] !== void 0 && (ie += "=" + d.decodeQuery(ye[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
              }
              Z += "?" + ie.substring(1);
            }
            return Z += d.decodeQuery(B.hash(), true);
          }, b.absoluteTo = function(B) {
            var Z, ie, $, oe = this.clone(), ce = ["protocol", "username", "password", "hostname", "port"];
            if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            if (B instanceof d || (B = new d(B)), oe._parts.protocol || (oe._parts.protocol = B._parts.protocol, this._parts.hostname)) return oe;
            for (ie = 0; $ = ce[ie]; ie++) oe._parts[$] = B._parts[$];
            return oe._parts.path ? (oe._parts.path.substring(-2) === ".." && (oe._parts.path += "/"), oe.path().charAt(0) !== "/" && (Z = (Z = B.directory()) || (B.path().indexOf("/") === 0 ? "/" : ""), oe._parts.path = (Z ? Z + "/" : "") + oe._parts.path, oe.normalizePath())) : (oe._parts.path = B._parts.path, oe._parts.query || (oe._parts.query = B._parts.query)), oe.build(), oe;
          }, b.relativeTo = function(B) {
            var Z, ie, $, oe, ce, ye = this.clone().normalize();
            if (ye._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
            if (B = new d(B).normalize(), Z = ye._parts, ie = B._parts, oe = ye.path(), ce = B.path(), oe.charAt(0) !== "/") throw new Error("URI is already relative");
            if (ce.charAt(0) !== "/") throw new Error("Cannot calculate a URI relative to another relative URI");
            if (Z.protocol === ie.protocol && (Z.protocol = null), Z.username !== ie.username || Z.password !== ie.password || Z.protocol !== null || Z.username !== null || Z.password !== null || Z.hostname !== ie.hostname || Z.port !== ie.port) return ye.build();
            if (Z.hostname = null, Z.port = null, oe === ce) return Z.path = "", ye.build();
            if (!($ = d.commonPath(oe, ce))) return ye.build();
            var ae = ie.path.substring($.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
            return Z.path = ae + Z.path.substring($.length) || "./", ye.build();
          }, b.equals = function(B) {
            var Z, ie, $, oe, ce, ye = this.clone(), ae = new d(B), ue = {};
            if (ye.normalize(), ae.normalize(), ye.toString() === ae.toString()) return true;
            if ($ = ye.query(), oe = ae.query(), ye.query(""), ae.query(""), ye.toString() !== ae.toString() || $.length !== oe.length) return false;
            for (ce in Z = d.parseQuery($, this._parts.escapeQuerySpace), ie = d.parseQuery(oe, this._parts.escapeQuerySpace), Z) if (S.call(Z, ce)) {
              if (k(Z[ce])) {
                if (!I(Z[ce], ie[ce])) return false;
              } else if (Z[ce] !== ie[ce]) return false;
              ue[ce] = true;
            }
            for (ce in ie) if (S.call(ie, ce) && !ue[ce]) return false;
            return true;
          }, b.preventInvalidHostname = function(B) {
            return this._parts.preventInvalidHostname = !!B, this;
          }, b.duplicateQueryParameters = function(B) {
            return this._parts.duplicateQueryParameters = !!B, this;
          }, b.escapeQuerySpace = function(B) {
            return this._parts.escapeQuerySpace = !!B, this;
          }, d;
        });
      }, 4295: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.accountMerge = function(r) {
          var m = {};
          try {
            m.body = h.default.OperationBody.accountMerge((0, f.decodeAddressToMuxedAccount)(r.destination));
          } catch {
            throw new Error("destination is invalid");
          }
          return this.setSourceAccount(m, r), new h.default.Operation(m);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6160);
      }, 4356: (t, o, u) => {
        u.r(o), u.d(o, { AccountRequiresMemoError: () => c.Cu, BadRequestError: () => c.v7, BadResponseError: () => c.nS, Config: () => h.T, Federation: () => m, Friendbot: () => a, Horizon: () => l, NetworkError: () => c.Dr, NotFoundError: () => c.m_, StellarToml: () => r, Utils: () => f.A, WebAuth: () => g, contract: () => b, default: () => R, rpc: () => d });
        var c = u(5976), h = u(8732), f = u(3121), r = u(3898), m = u(7600), g = u(5479), a = u(8242), l = u(8733), d = u(3496), b = u(6299), S = u(356), E = {};
        for (const k in S) ["default", "Config", "Utils", "StellarToml", "Federation", "WebAuth", "Friendbot", "Horizon", "rpc", "contract", "AccountRequiresMemoError", "BadRequestError", "BadResponseError", "NetworkError", "NotFoundError"].indexOf(k) < 0 && (E[k] = () => S[k]);
        u.d(o, E);
        const R = (t = u.hmd(t)).exports;
        u.g.__USE_AXIOS__ === void 0 && (u.g.__USE_AXIOS__ = true), u.g.__USE_EVENTSOURCE__ === void 0 && (u.g.__USE_EVENTSOURCE__ = false);
      }, 4403: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.createCustomContract = function(l) {
          var d, b = c.from(l.salt || r.Keypair.random().xdrPublicKey().value());
          if (!l.wasmHash || l.wasmHash.length !== 32) throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(l.wasmHash));
          if (b.length !== 32) throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(l.wasmHash));
          return this.invokeHostFunction({ source: l.source, auth: l.auth, func: f.default.HostFunction.hostFunctionTypeCreateContractV2(new f.default.CreateContractArgsV2({ executable: f.default.ContractExecutable.contractExecutableWasm(c.from(l.wasmHash)), contractIdPreimage: f.default.ContractIdPreimage.contractIdPreimageFromAddress(new f.default.ContractIdPreimageFromAddress({ address: l.address.toScAddress(), salt: b })), constructorArgs: (d = l.constructorArgs) !== null && d !== void 0 ? d : [] })) });
        }, o.createStellarAssetContract = function(l) {
          var d = l.asset;
          if (typeof d == "string") {
            var b = d.split(":"), S = (w = 2, function(F) {
              if (Array.isArray(F)) return F;
            }(k = b) || function(F, I) {
              var q = F == null ? null : typeof Symbol < "u" && F[Symbol.iterator] || F["@@iterator"];
              if (q != null) {
                var D, H, _, T, L = [], j = true, z = false;
                try {
                  if (_ = (q = q.call(F)).next, I === 0) {
                    if (Object(q) !== q) return;
                    j = false;
                  } else for (; !(j = (D = _.call(q)).done) && (L.push(D.value), L.length !== I); j = true) ;
                } catch (Y) {
                  z = true, H = Y;
                } finally {
                  try {
                    if (!j && q.return != null && (T = q.return(), Object(T) !== T)) return;
                  } finally {
                    if (z) throw H;
                  }
                }
                return L;
              }
            }(k, w) || function(F, I) {
              if (F) {
                if (typeof F == "string") return a(F, I);
                var q = {}.toString.call(F).slice(8, -1);
                return q === "Object" && F.constructor && (q = F.constructor.name), q === "Map" || q === "Set" ? Array.from(F) : q === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(q) ? a(F, I) : void 0;
              }
            }(k, w) || function() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }()), E = S[0], R = S[1];
            d = new g.Asset(E, R);
          }
          var k, w;
          if (!(d instanceof g.Asset)) throw new TypeError("expected Asset in 'opts.asset', got ".concat(d));
          return this.invokeHostFunction({ source: l.source, auth: l.auth, func: f.default.HostFunction.hostFunctionTypeCreateContract(new f.default.CreateContractArgs({ executable: f.default.ContractExecutable.contractExecutableStellarAsset(), contractIdPreimage: f.default.ContractIdPreimage.contractIdPreimageFromAsset(d.toXDRObject()) })) });
        }, o.invokeContractFunction = function(l) {
          var d = new m.Address(l.contract);
          if (d._type !== "contract") throw new TypeError("expected contract strkey instance, got ".concat(d));
          return this.invokeHostFunction({ source: l.source, auth: l.auth, func: f.default.HostFunction.hostFunctionTypeInvokeContract(new f.default.InvokeContractArgs({ contractAddress: d.toScAddress(), functionName: l.function, args: l.args })) });
        }, o.invokeHostFunction = function(l) {
          if (!l.func) throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(l), ")"));
          var d = new f.default.InvokeHostFunctionOp({ hostFunction: l.func, auth: l.auth || [] }), b = { body: f.default.OperationBody.invokeHostFunction(d) };
          return this.setSourceAccount(b, l), new f.default.Operation(b);
        }, o.uploadContractWasm = function(l) {
          return this.invokeHostFunction({ source: l.source, auth: l.auth, func: f.default.HostFunction.hostFunctionTypeUploadContractWasm(c.from(l.wasm)) });
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(6691), m = u(1180), g = u(1764);
        function a(l, d) {
          (d == null || d > l.length) && (d = l.length);
          for (var b = 0, S = Array(d); b < d; b++) S[b] = l[b];
          return S;
        }
      }, 4459: (t) => {
        t.exports = Number.isNaN || function(o) {
          return o != o;
        };
      }, 4610: (t, o, u) => {
        t.exports = l;
        var c = u(6048).F, h = c.ERR_METHOD_NOT_IMPLEMENTED, f = c.ERR_MULTIPLE_CALLBACK, r = c.ERR_TRANSFORM_ALREADY_TRANSFORMING, m = c.ERR_TRANSFORM_WITH_LENGTH_0, g = u(5382);
        function a(S, E) {
          var R = this._transformState;
          R.transforming = false;
          var k = R.writecb;
          if (k === null) return this.emit("error", new f());
          R.writechunk = null, R.writecb = null, E != null && this.push(E), k(S);
          var w = this._readableState;
          w.reading = false, (w.needReadable || w.length < w.highWaterMark) && this._read(w.highWaterMark);
        }
        function l(S) {
          if (!(this instanceof l)) return new l(S);
          g.call(this, S), this._transformState = { afterTransform: a.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, S && (typeof S.transform == "function" && (this._transform = S.transform), typeof S.flush == "function" && (this._flush = S.flush)), this.on("prefinish", d);
        }
        function d() {
          var S = this;
          typeof this._flush != "function" || this._readableState.destroyed ? b(this, null, null) : this._flush(function(E, R) {
            b(S, E, R);
          });
        }
        function b(S, E, R) {
          if (E) return S.emit("error", E);
          if (R != null && S.push(R), S._writableState.length) throw new m();
          if (S._transformState.transforming) throw new r();
          return S.push(null);
        }
        u(6698)(l, g), l.prototype.push = function(S, E) {
          return this._transformState.needTransform = false, g.prototype.push.call(this, S, E);
        }, l.prototype._transform = function(S, E, R) {
          R(new h("_transform()"));
        }, l.prototype._write = function(S, E, R) {
          var k = this._transformState;
          if (k.writecb = R, k.writechunk = S, k.writeencoding = E, !k.transforming) {
            var w = this._readableState;
            (k.needTransform || w.needReadable || w.length < w.highWaterMark) && this._read(w.highWaterMark);
          }
        }, l.prototype._read = function(S) {
          var E = this._transformState;
          E.writechunk === null || E.transforming ? E.needTransform = true : (E.transforming = true, this._transform(E.writechunk, E.writeencoding, E.afterTransform));
        }, l.prototype._destroy = function(S, E) {
          g.prototype._destroy.call(this, S, function(R) {
            E(R);
          });
        };
      }, 4643: (t, o, u) => {
        function c(h) {
          try {
            if (!u.g.localStorage) return false;
          } catch {
            return false;
          }
          var f = u.g.localStorage[h];
          return f != null && String(f).toLowerCase() === "true";
        }
        t.exports = function(h, f) {
          if (c("noDeprecation")) return h;
          var r = false;
          return function() {
            if (!r) {
              if (c("throwDeprecation")) throw new Error(f);
              c("traceDeprecation") ? console.trace(f) : console.warn(f), r = true;
            }
            return h.apply(this, arguments);
          };
        };
      }, 4704: function(t, o, u) {
        var c, h;
        (function(f, r) {
          t.exports ? t.exports = r() : (h = typeof (c = r) == "function" ? c.call(o, u, o, t) : c) === void 0 || (t.exports = h);
        })(0, function(f) {
          var r = f && f.SecondLevelDomains, m = { list: { ac: " com gov mil net org ", ae: " ac co gov mil name net org pro sch ", af: " com edu gov net org ", al: " com edu gov mil net org ", ao: " co ed gv it og pb ", ar: " com edu gob gov int mil net org tur ", at: " ac co gv or ", au: " asn com csiro edu gov id net org ", ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ", bb: " biz co com edu gov info net org store tv ", bh: " biz cc com edu gov info net org ", bn: " com edu gov net org ", bo: " com edu gob gov int mil net org tv ", br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ", bs: " com edu gov net org ", bz: " du et om ov rg ", ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ", ck: " biz co edu gen gov info net org ", cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ", co: " com edu gov mil net nom org ", cr: " ac c co ed fi go or sa ", cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ", do: " art com edu gob gov mil net org sld web ", dz: " art asso com edu gov net org pol ", ec: " com edu fin gov info med mil net org pro ", eg: " com edu eun gov mil name net org sci ", er: " com edu gov ind mil net org rochest w ", es: " com edu gob nom org ", et: " biz com edu gov info name net org ", fj: " ac biz com info mil name net org pro ", fk: " ac co gov net nom org ", fr: " asso com f gouv nom prd presse tm ", gg: " co net org ", gh: " com edu gov mil org ", gn: " ac com gov net org ", gr: " com edu gov mil net org ", gt: " com edu gob ind mil net org ", gu: " com edu gov net org ", hk: " com edu gov idv net org ", hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ", id: " ac co go mil net or sch web ", il: " ac co gov idf k12 muni net org ", in: " ac co edu ernet firm gen gov i ind mil net nic org res ", iq: " com edu gov i mil net org ", ir: " ac co dnssec gov i id net org sch ", it: " edu gov ", je: " co net org ", jo: " com edu gov mil name net org sch ", jp: " ac ad co ed go gr lg ne or ", ke: " ac co go info me mobi ne or sc ", kh: " com edu gov mil net org per ", ki: " biz com de edu gov info mob net org tel ", km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ", kn: " edu gov net org ", kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ", kw: " com edu gov net org ", ky: " com edu gov net org ", kz: " com edu gov mil net org ", lb: " com edu gov net org ", lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ", lr: " com edu gov net org ", lv: " asn com conf edu gov id mil net org ", ly: " com edu gov id med net org plc sch ", ma: " ac co gov m net org press ", mc: " asso tm ", me: " ac co edu gov its net org priv ", mg: " com edu gov mil nom org prd tm ", mk: " com edu gov inf name net org pro ", ml: " com edu gov net org presse ", mn: " edu gov org ", mo: " com edu gov net org ", mt: " com edu gov net org ", mv: " aero biz com coop edu gov info int mil museum name net org pro ", mw: " ac co com coop edu gov int museum net org ", mx: " com edu gob net org ", my: " com edu gov mil name net org sch ", nf: " arts com firm info net other per rec store web ", ng: " biz com edu gov mil mobi name net org sch ", ni: " ac co com edu gob mil net nom org ", np: " com edu gov mil net org ", nr: " biz com edu gov info net org ", om: " ac biz co com edu gov med mil museum net org pro sch ", pe: " com edu gob mil net nom org sld ", ph: " com edu gov i mil net ngo org ", pk: " biz com edu fam gob gok gon gop gos gov net org web ", pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ", pr: " ac biz com edu est gov info isla name net org pro prof ", ps: " com edu gov net org plo sec ", pw: " belau co ed go ne or ", ro: " arts com firm info nom nt org rec store tm www ", rs: " ac co edu gov in org ", sb: " com edu gov net org ", sc: " com edu gov net org ", sh: " co com edu gov net nom org ", sl: " com edu gov net org ", st: " co com consulado edu embaixada gov mil net org principe saotome store ", sv: " com edu gob org red ", sz: " ac co org ", tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ", tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ", tw: " club com ebiz edu game gov idv mil net org ", mu: " ac co com gov net or org ", mz: " ac co edu gov org ", na: " co com ", nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ", pa: " abo ac com edu gob ing med net nom org sld ", pt: " com edu gov int net nome org publ ", py: " com edu gov mil net org ", qa: " com edu gov mil net org ", re: " asso com nom ", ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ", rw: " ac co com edu gouv gov int mil net ", sa: " com edu gov med net org pub sch ", sd: " com edu gov info med net org tv ", se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ", sg: " com edu gov idn net org per ", sn: " art com edu gouv org perso univ ", sy: " com edu gov mil net news org ", th: " ac co go in mi net or ", tj: " ac biz co com edu go gov info int mil name net nic org test web ", tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ", tz: " ac co go ne or ", ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ", ug: " ac co go ne or org sc ", uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ", us: " dni fed isa kids nsn ", uy: " com edu gub mil net org ", ve: " co com edu gob info mil net org web ", vi: " co com k12 net org ", vn: " ac biz com edu gov health info int name net org pro ", ye: " co com gov ltd me net org plc ", yu: " ac co edu gov org ", za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ", zm: " ac co com edu gov net org sch ", com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ", net: "gb jp se uk ", org: "ae", de: "com " }, has: function(g) {
            var a = g.lastIndexOf(".");
            if (a <= 0 || a >= g.length - 1) return false;
            var l = g.lastIndexOf(".", a - 1);
            if (l <= 0 || l >= a - 1) return false;
            var d = m.list[g.slice(a + 1)];
            return !!d && d.indexOf(" " + g.slice(l + 1, a) + " ") >= 0;
          }, is: function(g) {
            var a = g.lastIndexOf(".");
            if (a <= 0 || a >= g.length - 1 || g.lastIndexOf(".", a - 1) >= 0) return false;
            var l = m.list[g.slice(a + 1)];
            return !!l && l.indexOf(" " + g.slice(0, a) + " ") >= 0;
          }, get: function(g) {
            var a = g.lastIndexOf(".");
            if (a <= 0 || a >= g.length - 1) return null;
            var l = g.lastIndexOf(".", a - 1);
            if (l <= 0 || l >= a - 1) return null;
            var d = m.list[g.slice(a + 1)];
            return d ? d.indexOf(" " + g.slice(l + 1, a) + " ") < 0 ? null : g.slice(l + 1) : null;
          }, noConflict: function() {
            return f.SecondLevelDomains === this && (f.SecondLevelDomains = r), this;
          } };
          return m;
        });
      }, 4737: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.liquidityPoolWithdraw = function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = {};
          if (!f.liquidityPoolId) throw new TypeError("liquidityPoolId argument is required");
          if (r.liquidityPoolId = h.default.PoolId.fromXDR(f.liquidityPoolId, "hex"), !this.isValidAmount(f.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (r.amount = this._toXDRAmount(f.amount), !this.isValidAmount(f.minAmountA, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
          if (r.minAmountA = this._toXDRAmount(f.minAmountA), !this.isValidAmount(f.minAmountB, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
          r.minAmountB = this._toXDRAmount(f.minAmountB);
          var m = new h.default.LiquidityPoolWithdrawOp(r), g = { body: h.default.OperationBody.liquidityPoolWithdraw(m) };
          return this.setSourceAccount(g, f), new h.default.Operation(g);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 4765: (t) => {
        var o = String.prototype.replace, u = /%20/g, c = "RFC1738", h = "RFC3986";
        t.exports = { default: h, formatters: { RFC1738: function(f) {
          return o.call(f, u, "+");
        }, RFC3986: function(f) {
          return String(f);
        } }, RFC1738: c, RFC3986: h };
      }, 4803: (t, o, u) => {
        var c = u(8859), h = u(9675), f = function(r, m, g) {
          for (var a, l = r; (a = l.next) != null; l = a) if (a.key === m) return l.next = a.next, g || (a.next = r.next, r.next = a), a;
        };
        t.exports = function() {
          var r, m = { assert: function(g) {
            if (!m.has(g)) throw new h("Side channel does not contain " + c(g));
          }, delete: function(g) {
            var a = r && r.next, l = function(d, b) {
              if (d) return f(d, b, true);
            }(r, g);
            return l && a && a === l && (r = void 0), !!l;
          }, get: function(g) {
            return function(a, l) {
              if (a) {
                var d = f(a, l);
                return d && d.value;
              }
            }(r, g);
          }, has: function(g) {
            return function(a, l) {
              return !!a && !!f(a, l);
            }(r, g);
          }, set: function(g, a) {
            r || (r = { next: void 0 }), function(l, d, b) {
              var S = f(l, d);
              S ? S.value = b : l.next = { key: d, next: l.next, value: b };
            }(r, g, a);
          } };
          return m;
        };
      }, 4831: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.createClaimableBalance = function(r) {
          if (!(r.asset instanceof f.Asset)) throw new Error("must provide an asset for create claimable balance operation");
          if (!this.isValidAmount(r.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (!Array.isArray(r.claimants) || r.claimants.length === 0) throw new Error("must provide at least one claimant");
          var m = {};
          m.asset = r.asset.toXDRObject(), m.amount = this._toXDRAmount(r.amount), m.claimants = Object.values(r.claimants).map(function(l) {
            return l.toXDRObject();
          });
          var g = new h.default.CreateClaimableBalanceOp(m), a = {};
          return a.body = h.default.OperationBody.createClaimableBalance(g), this.setSourceAccount(a, r), new h.default.Operation(a);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(1764);
      }, 4842: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.SorobanDataBuilder = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
        function f(g) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
            return typeof a;
          } : function(a) {
            return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
          }, f(g);
        }
        function r(g, a) {
          for (var l = 0; l < a.length; l++) {
            var d = a[l];
            d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(g, m(d.key), d);
          }
        }
        function m(g) {
          var a = function(l, d) {
            if (f(l) != "object" || !l) return l;
            var b = l[Symbol.toPrimitive];
            if (b !== void 0) {
              var S = b.call(l, d);
              if (f(S) != "object") return S;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (d === "string" ? String : Number)(l);
          }(g, "string");
          return f(a) == "symbol" ? a : a + "";
        }
        o.SorobanDataBuilder = function() {
          return function(g, a, l) {
            return a && r(g.prototype, a), l && r(g, l), Object.defineProperty(g, "prototype", { writable: false }), g;
          }(function g(a) {
            var l;
            (function(d, b) {
              if (!(d instanceof b)) throw new TypeError("Cannot call a class as a function");
            })(this, g), function(d, b, S) {
              (b = m(b)) in d ? Object.defineProperty(d, b, { value: S, enumerable: true, configurable: true, writable: true }) : d[b] = S;
            }(this, "_data", void 0), l = a ? typeof a == "string" || ArrayBuffer.isView(a) ? g.fromXDR(a) : g.fromXDR(a.toXDR()) : new h.default.SorobanTransactionData({ resources: new h.default.SorobanResources({ footprint: new h.default.LedgerFootprint({ readOnly: [], readWrite: [] }), instructions: 0, readBytes: 0, writeBytes: 0 }), ext: new h.default.ExtensionPoint(0), resourceFee: new h.default.Int64(0) }), this._data = l;
          }, [{ key: "setResourceFee", value: function(g) {
            return this._data.resourceFee(new h.default.Int64(g)), this;
          } }, { key: "setResources", value: function(g, a, l) {
            return this._data.resources().instructions(g), this._data.resources().readBytes(a), this._data.resources().writeBytes(l), this;
          } }, { key: "appendFootprint", value: function(g, a) {
            return this.setFootprint(this.getReadOnly().concat(g), this.getReadWrite().concat(a));
          } }, { key: "setFootprint", value: function(g, a) {
            return g !== null && this.setReadOnly(g), a !== null && this.setReadWrite(a), this;
          } }, { key: "setReadOnly", value: function(g) {
            return this._data.resources().footprint().readOnly(g ?? []), this;
          } }, { key: "setReadWrite", value: function(g) {
            return this._data.resources().footprint().readWrite(g ?? []), this;
          } }, { key: "build", value: function() {
            return h.default.SorobanTransactionData.fromXDR(this._data.toXDR());
          } }, { key: "getReadOnly", value: function() {
            return this.getFootprint().readOnly();
          } }, { key: "getReadWrite", value: function() {
            return this.getFootprint().readWrite();
          } }, { key: "getFootprint", value: function() {
            return this._data.resources().footprint();
          } }], [{ key: "fromXDR", value: function(g) {
            return h.default.SorobanTransactionData.fromXDR(g, typeof g == "string" ? "base64" : "raw");
          } }]);
        }();
      }, 4940: (t, o, u) => {
        (function(c) {
          var h = function(je) {
            var Ge, at = new Float64Array(16);
            if (je) for (Ge = 0; Ge < je.length; Ge++) at[Ge] = je[Ge];
            return at;
          }, f = function() {
            throw new Error("no PRNG");
          }, r = new Uint8Array(16), m = new Uint8Array(32);
          m[0] = 9;
          var g = h(), a = h([1]), l = h([56129, 1]), d = h([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), b = h([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), S = h([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), E = h([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), R = h([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
          function k(je, Ge, at, Ae) {
            je[Ge] = at >> 24 & 255, je[Ge + 1] = at >> 16 & 255, je[Ge + 2] = at >> 8 & 255, je[Ge + 3] = 255 & at, je[Ge + 4] = Ae >> 24 & 255, je[Ge + 5] = Ae >> 16 & 255, je[Ge + 6] = Ae >> 8 & 255, je[Ge + 7] = 255 & Ae;
          }
          function w(je, Ge, at, Ae, qe) {
            var Ft, Dt = 0;
            for (Ft = 0; Ft < qe; Ft++) Dt |= je[Ge + Ft] ^ at[Ae + Ft];
            return (1 & Dt - 1 >>> 8) - 1;
          }
          function F(je, Ge, at, Ae) {
            return w(je, Ge, at, Ae, 16);
          }
          function I(je, Ge, at, Ae) {
            return w(je, Ge, at, Ae, 32);
          }
          function q(je, Ge, at, Ae) {
            (function(qe, Ft, Dt, wr) {
              for (var Nt, yr = 255 & wr[0] | (255 & wr[1]) << 8 | (255 & wr[2]) << 16 | (255 & wr[3]) << 24, Ur = 255 & Dt[0] | (255 & Dt[1]) << 8 | (255 & Dt[2]) << 16 | (255 & Dt[3]) << 24, Pe = 255 & Dt[4] | (255 & Dt[5]) << 8 | (255 & Dt[6]) << 16 | (255 & Dt[7]) << 24, $e = 255 & Dt[8] | (255 & Dt[9]) << 8 | (255 & Dt[10]) << 16 | (255 & Dt[11]) << 24, le = 255 & Dt[12] | (255 & Dt[13]) << 8 | (255 & Dt[14]) << 16 | (255 & Dt[15]) << 24, re = 255 & wr[4] | (255 & wr[5]) << 8 | (255 & wr[6]) << 16 | (255 & wr[7]) << 24, Le = 255 & Ft[0] | (255 & Ft[1]) << 8 | (255 & Ft[2]) << 16 | (255 & Ft[3]) << 24, nt = 255 & Ft[4] | (255 & Ft[5]) << 8 | (255 & Ft[6]) << 16 | (255 & Ft[7]) << 24, ft = 255 & Ft[8] | (255 & Ft[9]) << 8 | (255 & Ft[10]) << 16 | (255 & Ft[11]) << 24, zt = 255 & Ft[12] | (255 & Ft[13]) << 8 | (255 & Ft[14]) << 16 | (255 & Ft[15]) << 24, st = 255 & wr[8] | (255 & wr[9]) << 8 | (255 & wr[10]) << 16 | (255 & wr[11]) << 24, ct = 255 & Dt[16] | (255 & Dt[17]) << 8 | (255 & Dt[18]) << 16 | (255 & Dt[19]) << 24, yt = 255 & Dt[20] | (255 & Dt[21]) << 8 | (255 & Dt[22]) << 16 | (255 & Dt[23]) << 24, Zt = 255 & Dt[24] | (255 & Dt[25]) << 8 | (255 & Dt[26]) << 16 | (255 & Dt[27]) << 24, Ct = 255 & Dt[28] | (255 & Dt[29]) << 8 | (255 & Dt[30]) << 16 | (255 & Dt[31]) << 24, Lt = 255 & wr[12] | (255 & wr[13]) << 8 | (255 & wr[14]) << 16 | (255 & wr[15]) << 24, Wt = yr, vr = Ur, ar = Pe, sr = $e, gr = le, Tr = re, Mr = Le, Nr = nt, Lr = ft, jr = zt, Hr = st, kr = ct, Xt = yt, Qt = Zt, br = Ct, we = Lt, me = 0; me < 20; me += 2) Wt ^= (Nt = (Xt ^= (Nt = (Lr ^= (Nt = (gr ^= (Nt = Wt + Xt | 0) << 7 | Nt >>> 25) + Wt | 0) << 9 | Nt >>> 23) + gr | 0) << 13 | Nt >>> 19) + Lr | 0) << 18 | Nt >>> 14, Tr ^= (Nt = (vr ^= (Nt = (Qt ^= (Nt = (jr ^= (Nt = Tr + vr | 0) << 7 | Nt >>> 25) + Tr | 0) << 9 | Nt >>> 23) + jr | 0) << 13 | Nt >>> 19) + Qt | 0) << 18 | Nt >>> 14, Hr ^= (Nt = (Mr ^= (Nt = (ar ^= (Nt = (br ^= (Nt = Hr + Mr | 0) << 7 | Nt >>> 25) + Hr | 0) << 9 | Nt >>> 23) + br | 0) << 13 | Nt >>> 19) + ar | 0) << 18 | Nt >>> 14, we ^= (Nt = (kr ^= (Nt = (Nr ^= (Nt = (sr ^= (Nt = we + kr | 0) << 7 | Nt >>> 25) + we | 0) << 9 | Nt >>> 23) + sr | 0) << 13 | Nt >>> 19) + Nr | 0) << 18 | Nt >>> 14, Wt ^= (Nt = (sr ^= (Nt = (ar ^= (Nt = (vr ^= (Nt = Wt + sr | 0) << 7 | Nt >>> 25) + Wt | 0) << 9 | Nt >>> 23) + vr | 0) << 13 | Nt >>> 19) + ar | 0) << 18 | Nt >>> 14, Tr ^= (Nt = (gr ^= (Nt = (Nr ^= (Nt = (Mr ^= (Nt = Tr + gr | 0) << 7 | Nt >>> 25) + Tr | 0) << 9 | Nt >>> 23) + Mr | 0) << 13 | Nt >>> 19) + Nr | 0) << 18 | Nt >>> 14, Hr ^= (Nt = (jr ^= (Nt = (Lr ^= (Nt = (kr ^= (Nt = Hr + jr | 0) << 7 | Nt >>> 25) + Hr | 0) << 9 | Nt >>> 23) + kr | 0) << 13 | Nt >>> 19) + Lr | 0) << 18 | Nt >>> 14, we ^= (Nt = (br ^= (Nt = (Qt ^= (Nt = (Xt ^= (Nt = we + br | 0) << 7 | Nt >>> 25) + we | 0) << 9 | Nt >>> 23) + Xt | 0) << 13 | Nt >>> 19) + Qt | 0) << 18 | Nt >>> 14;
              Wt = Wt + yr | 0, vr = vr + Ur | 0, ar = ar + Pe | 0, sr = sr + $e | 0, gr = gr + le | 0, Tr = Tr + re | 0, Mr = Mr + Le | 0, Nr = Nr + nt | 0, Lr = Lr + ft | 0, jr = jr + zt | 0, Hr = Hr + st | 0, kr = kr + ct | 0, Xt = Xt + yt | 0, Qt = Qt + Zt | 0, br = br + Ct | 0, we = we + Lt | 0, qe[0] = Wt >>> 0 & 255, qe[1] = Wt >>> 8 & 255, qe[2] = Wt >>> 16 & 255, qe[3] = Wt >>> 24 & 255, qe[4] = vr >>> 0 & 255, qe[5] = vr >>> 8 & 255, qe[6] = vr >>> 16 & 255, qe[7] = vr >>> 24 & 255, qe[8] = ar >>> 0 & 255, qe[9] = ar >>> 8 & 255, qe[10] = ar >>> 16 & 255, qe[11] = ar >>> 24 & 255, qe[12] = sr >>> 0 & 255, qe[13] = sr >>> 8 & 255, qe[14] = sr >>> 16 & 255, qe[15] = sr >>> 24 & 255, qe[16] = gr >>> 0 & 255, qe[17] = gr >>> 8 & 255, qe[18] = gr >>> 16 & 255, qe[19] = gr >>> 24 & 255, qe[20] = Tr >>> 0 & 255, qe[21] = Tr >>> 8 & 255, qe[22] = Tr >>> 16 & 255, qe[23] = Tr >>> 24 & 255, qe[24] = Mr >>> 0 & 255, qe[25] = Mr >>> 8 & 255, qe[26] = Mr >>> 16 & 255, qe[27] = Mr >>> 24 & 255, qe[28] = Nr >>> 0 & 255, qe[29] = Nr >>> 8 & 255, qe[30] = Nr >>> 16 & 255, qe[31] = Nr >>> 24 & 255, qe[32] = Lr >>> 0 & 255, qe[33] = Lr >>> 8 & 255, qe[34] = Lr >>> 16 & 255, qe[35] = Lr >>> 24 & 255, qe[36] = jr >>> 0 & 255, qe[37] = jr >>> 8 & 255, qe[38] = jr >>> 16 & 255, qe[39] = jr >>> 24 & 255, qe[40] = Hr >>> 0 & 255, qe[41] = Hr >>> 8 & 255, qe[42] = Hr >>> 16 & 255, qe[43] = Hr >>> 24 & 255, qe[44] = kr >>> 0 & 255, qe[45] = kr >>> 8 & 255, qe[46] = kr >>> 16 & 255, qe[47] = kr >>> 24 & 255, qe[48] = Xt >>> 0 & 255, qe[49] = Xt >>> 8 & 255, qe[50] = Xt >>> 16 & 255, qe[51] = Xt >>> 24 & 255, qe[52] = Qt >>> 0 & 255, qe[53] = Qt >>> 8 & 255, qe[54] = Qt >>> 16 & 255, qe[55] = Qt >>> 24 & 255, qe[56] = br >>> 0 & 255, qe[57] = br >>> 8 & 255, qe[58] = br >>> 16 & 255, qe[59] = br >>> 24 & 255, qe[60] = we >>> 0 & 255, qe[61] = we >>> 8 & 255, qe[62] = we >>> 16 & 255, qe[63] = we >>> 24 & 255;
            })(je, Ge, at, Ae);
          }
          function D(je, Ge, at, Ae) {
            (function(qe, Ft, Dt, wr) {
              for (var Nt, yr = 255 & wr[0] | (255 & wr[1]) << 8 | (255 & wr[2]) << 16 | (255 & wr[3]) << 24, Ur = 255 & Dt[0] | (255 & Dt[1]) << 8 | (255 & Dt[2]) << 16 | (255 & Dt[3]) << 24, Pe = 255 & Dt[4] | (255 & Dt[5]) << 8 | (255 & Dt[6]) << 16 | (255 & Dt[7]) << 24, $e = 255 & Dt[8] | (255 & Dt[9]) << 8 | (255 & Dt[10]) << 16 | (255 & Dt[11]) << 24, le = 255 & Dt[12] | (255 & Dt[13]) << 8 | (255 & Dt[14]) << 16 | (255 & Dt[15]) << 24, re = 255 & wr[4] | (255 & wr[5]) << 8 | (255 & wr[6]) << 16 | (255 & wr[7]) << 24, Le = 255 & Ft[0] | (255 & Ft[1]) << 8 | (255 & Ft[2]) << 16 | (255 & Ft[3]) << 24, nt = 255 & Ft[4] | (255 & Ft[5]) << 8 | (255 & Ft[6]) << 16 | (255 & Ft[7]) << 24, ft = 255 & Ft[8] | (255 & Ft[9]) << 8 | (255 & Ft[10]) << 16 | (255 & Ft[11]) << 24, zt = 255 & Ft[12] | (255 & Ft[13]) << 8 | (255 & Ft[14]) << 16 | (255 & Ft[15]) << 24, st = 255 & wr[8] | (255 & wr[9]) << 8 | (255 & wr[10]) << 16 | (255 & wr[11]) << 24, ct = 255 & Dt[16] | (255 & Dt[17]) << 8 | (255 & Dt[18]) << 16 | (255 & Dt[19]) << 24, yt = 255 & Dt[20] | (255 & Dt[21]) << 8 | (255 & Dt[22]) << 16 | (255 & Dt[23]) << 24, Zt = 255 & Dt[24] | (255 & Dt[25]) << 8 | (255 & Dt[26]) << 16 | (255 & Dt[27]) << 24, Ct = 255 & Dt[28] | (255 & Dt[29]) << 8 | (255 & Dt[30]) << 16 | (255 & Dt[31]) << 24, Lt = 255 & wr[12] | (255 & wr[13]) << 8 | (255 & wr[14]) << 16 | (255 & wr[15]) << 24, Wt = 0; Wt < 20; Wt += 2) yr ^= (Nt = (yt ^= (Nt = (ft ^= (Nt = (le ^= (Nt = yr + yt | 0) << 7 | Nt >>> 25) + yr | 0) << 9 | Nt >>> 23) + le | 0) << 13 | Nt >>> 19) + ft | 0) << 18 | Nt >>> 14, re ^= (Nt = (Ur ^= (Nt = (Zt ^= (Nt = (zt ^= (Nt = re + Ur | 0) << 7 | Nt >>> 25) + re | 0) << 9 | Nt >>> 23) + zt | 0) << 13 | Nt >>> 19) + Zt | 0) << 18 | Nt >>> 14, st ^= (Nt = (Le ^= (Nt = (Pe ^= (Nt = (Ct ^= (Nt = st + Le | 0) << 7 | Nt >>> 25) + st | 0) << 9 | Nt >>> 23) + Ct | 0) << 13 | Nt >>> 19) + Pe | 0) << 18 | Nt >>> 14, Lt ^= (Nt = (ct ^= (Nt = (nt ^= (Nt = ($e ^= (Nt = Lt + ct | 0) << 7 | Nt >>> 25) + Lt | 0) << 9 | Nt >>> 23) + $e | 0) << 13 | Nt >>> 19) + nt | 0) << 18 | Nt >>> 14, yr ^= (Nt = ($e ^= (Nt = (Pe ^= (Nt = (Ur ^= (Nt = yr + $e | 0) << 7 | Nt >>> 25) + yr | 0) << 9 | Nt >>> 23) + Ur | 0) << 13 | Nt >>> 19) + Pe | 0) << 18 | Nt >>> 14, re ^= (Nt = (le ^= (Nt = (nt ^= (Nt = (Le ^= (Nt = re + le | 0) << 7 | Nt >>> 25) + re | 0) << 9 | Nt >>> 23) + Le | 0) << 13 | Nt >>> 19) + nt | 0) << 18 | Nt >>> 14, st ^= (Nt = (zt ^= (Nt = (ft ^= (Nt = (ct ^= (Nt = st + zt | 0) << 7 | Nt >>> 25) + st | 0) << 9 | Nt >>> 23) + ct | 0) << 13 | Nt >>> 19) + ft | 0) << 18 | Nt >>> 14, Lt ^= (Nt = (Ct ^= (Nt = (Zt ^= (Nt = (yt ^= (Nt = Lt + Ct | 0) << 7 | Nt >>> 25) + Lt | 0) << 9 | Nt >>> 23) + yt | 0) << 13 | Nt >>> 19) + Zt | 0) << 18 | Nt >>> 14;
              qe[0] = yr >>> 0 & 255, qe[1] = yr >>> 8 & 255, qe[2] = yr >>> 16 & 255, qe[3] = yr >>> 24 & 255, qe[4] = re >>> 0 & 255, qe[5] = re >>> 8 & 255, qe[6] = re >>> 16 & 255, qe[7] = re >>> 24 & 255, qe[8] = st >>> 0 & 255, qe[9] = st >>> 8 & 255, qe[10] = st >>> 16 & 255, qe[11] = st >>> 24 & 255, qe[12] = Lt >>> 0 & 255, qe[13] = Lt >>> 8 & 255, qe[14] = Lt >>> 16 & 255, qe[15] = Lt >>> 24 & 255, qe[16] = Le >>> 0 & 255, qe[17] = Le >>> 8 & 255, qe[18] = Le >>> 16 & 255, qe[19] = Le >>> 24 & 255, qe[20] = nt >>> 0 & 255, qe[21] = nt >>> 8 & 255, qe[22] = nt >>> 16 & 255, qe[23] = nt >>> 24 & 255, qe[24] = ft >>> 0 & 255, qe[25] = ft >>> 8 & 255, qe[26] = ft >>> 16 & 255, qe[27] = ft >>> 24 & 255, qe[28] = zt >>> 0 & 255, qe[29] = zt >>> 8 & 255, qe[30] = zt >>> 16 & 255, qe[31] = zt >>> 24 & 255;
            })(je, Ge, at, Ae);
          }
          var H = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
          function _(je, Ge, at, Ae, qe, Ft, Dt) {
            var wr, Nt, yr = new Uint8Array(16), Ur = new Uint8Array(64);
            for (Nt = 0; Nt < 16; Nt++) yr[Nt] = 0;
            for (Nt = 0; Nt < 8; Nt++) yr[Nt] = Ft[Nt];
            for (; qe >= 64; ) {
              for (q(Ur, yr, Dt, H), Nt = 0; Nt < 64; Nt++) je[Ge + Nt] = at[Ae + Nt] ^ Ur[Nt];
              for (wr = 1, Nt = 8; Nt < 16; Nt++) wr = wr + (255 & yr[Nt]) | 0, yr[Nt] = 255 & wr, wr >>>= 8;
              qe -= 64, Ge += 64, Ae += 64;
            }
            if (qe > 0) for (q(Ur, yr, Dt, H), Nt = 0; Nt < qe; Nt++) je[Ge + Nt] = at[Ae + Nt] ^ Ur[Nt];
            return 0;
          }
          function T(je, Ge, at, Ae, qe) {
            var Ft, Dt, wr = new Uint8Array(16), Nt = new Uint8Array(64);
            for (Dt = 0; Dt < 16; Dt++) wr[Dt] = 0;
            for (Dt = 0; Dt < 8; Dt++) wr[Dt] = Ae[Dt];
            for (; at >= 64; ) {
              for (q(Nt, wr, qe, H), Dt = 0; Dt < 64; Dt++) je[Ge + Dt] = Nt[Dt];
              for (Ft = 1, Dt = 8; Dt < 16; Dt++) Ft = Ft + (255 & wr[Dt]) | 0, wr[Dt] = 255 & Ft, Ft >>>= 8;
              at -= 64, Ge += 64;
            }
            if (at > 0) for (q(Nt, wr, qe, H), Dt = 0; Dt < at; Dt++) je[Ge + Dt] = Nt[Dt];
            return 0;
          }
          function L(je, Ge, at, Ae, qe) {
            var Ft = new Uint8Array(32);
            D(Ft, Ae, qe, H);
            for (var Dt = new Uint8Array(8), wr = 0; wr < 8; wr++) Dt[wr] = Ae[wr + 16];
            return T(je, Ge, at, Dt, Ft);
          }
          function j(je, Ge, at, Ae, qe, Ft, Dt) {
            var wr = new Uint8Array(32);
            D(wr, Ft, Dt, H);
            for (var Nt = new Uint8Array(8), yr = 0; yr < 8; yr++) Nt[yr] = Ft[yr + 16];
            return _(je, Ge, at, Ae, qe, Nt, wr);
          }
          var z = function(je) {
            var Ge, at, Ae, qe, Ft, Dt, wr, Nt;
            this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, Ge = 255 & je[0] | (255 & je[1]) << 8, this.r[0] = 8191 & Ge, at = 255 & je[2] | (255 & je[3]) << 8, this.r[1] = 8191 & (Ge >>> 13 | at << 3), Ae = 255 & je[4] | (255 & je[5]) << 8, this.r[2] = 7939 & (at >>> 10 | Ae << 6), qe = 255 & je[6] | (255 & je[7]) << 8, this.r[3] = 8191 & (Ae >>> 7 | qe << 9), Ft = 255 & je[8] | (255 & je[9]) << 8, this.r[4] = 255 & (qe >>> 4 | Ft << 12), this.r[5] = Ft >>> 1 & 8190, Dt = 255 & je[10] | (255 & je[11]) << 8, this.r[6] = 8191 & (Ft >>> 14 | Dt << 2), wr = 255 & je[12] | (255 & je[13]) << 8, this.r[7] = 8065 & (Dt >>> 11 | wr << 5), Nt = 255 & je[14] | (255 & je[15]) << 8, this.r[8] = 8191 & (wr >>> 8 | Nt << 8), this.r[9] = Nt >>> 5 & 127, this.pad[0] = 255 & je[16] | (255 & je[17]) << 8, this.pad[1] = 255 & je[18] | (255 & je[19]) << 8, this.pad[2] = 255 & je[20] | (255 & je[21]) << 8, this.pad[3] = 255 & je[22] | (255 & je[23]) << 8, this.pad[4] = 255 & je[24] | (255 & je[25]) << 8, this.pad[5] = 255 & je[26] | (255 & je[27]) << 8, this.pad[6] = 255 & je[28] | (255 & je[29]) << 8, this.pad[7] = 255 & je[30] | (255 & je[31]) << 8;
          };
          function Y(je, Ge, at, Ae, qe, Ft) {
            var Dt = new z(Ft);
            return Dt.update(at, Ae, qe), Dt.finish(je, Ge), 0;
          }
          function te(je, Ge, at, Ae, qe, Ft) {
            var Dt = new Uint8Array(16);
            return Y(Dt, 0, at, Ae, qe, Ft), F(je, Ge, Dt, 0);
          }
          function G(je, Ge, at, Ae, qe) {
            var Ft;
            if (at < 32) return -1;
            for (j(je, 0, Ge, 0, at, Ae, qe), Y(je, 16, je, 32, at - 32, je), Ft = 0; Ft < 16; Ft++) je[Ft] = 0;
            return 0;
          }
          function K(je, Ge, at, Ae, qe) {
            var Ft, Dt = new Uint8Array(32);
            if (at < 32 || (L(Dt, 0, 32, Ae, qe), te(Ge, 16, Ge, 32, at - 32, Dt) !== 0)) return -1;
            for (j(je, 0, Ge, 0, at, Ae, qe), Ft = 0; Ft < 32; Ft++) je[Ft] = 0;
            return 0;
          }
          function J(je, Ge) {
            var at;
            for (at = 0; at < 16; at++) je[at] = 0 | Ge[at];
          }
          function B(je) {
            var Ge, at, Ae = 1;
            for (Ge = 0; Ge < 16; Ge++) at = je[Ge] + Ae + 65535, Ae = Math.floor(at / 65536), je[Ge] = at - 65536 * Ae;
            je[0] += Ae - 1 + 37 * (Ae - 1);
          }
          function Z(je, Ge, at) {
            for (var Ae, qe = ~(at - 1), Ft = 0; Ft < 16; Ft++) Ae = qe & (je[Ft] ^ Ge[Ft]), je[Ft] ^= Ae, Ge[Ft] ^= Ae;
          }
          function ie(je, Ge) {
            var at, Ae, qe, Ft = h(), Dt = h();
            for (at = 0; at < 16; at++) Dt[at] = Ge[at];
            for (B(Dt), B(Dt), B(Dt), Ae = 0; Ae < 2; Ae++) {
              for (Ft[0] = Dt[0] - 65517, at = 1; at < 15; at++) Ft[at] = Dt[at] - 65535 - (Ft[at - 1] >> 16 & 1), Ft[at - 1] &= 65535;
              Ft[15] = Dt[15] - 32767 - (Ft[14] >> 16 & 1), qe = Ft[15] >> 16 & 1, Ft[14] &= 65535, Z(Dt, Ft, 1 - qe);
            }
            for (at = 0; at < 16; at++) je[2 * at] = 255 & Dt[at], je[2 * at + 1] = Dt[at] >> 8;
          }
          function $(je, Ge) {
            var at = new Uint8Array(32), Ae = new Uint8Array(32);
            return ie(at, je), ie(Ae, Ge), I(at, 0, Ae, 0);
          }
          function oe(je) {
            var Ge = new Uint8Array(32);
            return ie(Ge, je), 1 & Ge[0];
          }
          function ce(je, Ge) {
            var at;
            for (at = 0; at < 16; at++) je[at] = Ge[2 * at] + (Ge[2 * at + 1] << 8);
            je[15] &= 32767;
          }
          function ye(je, Ge, at) {
            for (var Ae = 0; Ae < 16; Ae++) je[Ae] = Ge[Ae] + at[Ae];
          }
          function ae(je, Ge, at) {
            for (var Ae = 0; Ae < 16; Ae++) je[Ae] = Ge[Ae] - at[Ae];
          }
          function ue(je, Ge, at) {
            var Ae, qe, Ft = 0, Dt = 0, wr = 0, Nt = 0, yr = 0, Ur = 0, Pe = 0, $e = 0, le = 0, re = 0, Le = 0, nt = 0, ft = 0, zt = 0, st = 0, ct = 0, yt = 0, Zt = 0, Ct = 0, Lt = 0, Wt = 0, vr = 0, ar = 0, sr = 0, gr = 0, Tr = 0, Mr = 0, Nr = 0, Lr = 0, jr = 0, Hr = 0, kr = at[0], Xt = at[1], Qt = at[2], br = at[3], we = at[4], me = at[5], ze = at[6], rt = at[7], Tt = at[8], Ot = at[9], It = at[10], We = at[11], mt = at[12], Gt = at[13], ir = at[14], dr = at[15];
            Ft += (Ae = Ge[0]) * kr, Dt += Ae * Xt, wr += Ae * Qt, Nt += Ae * br, yr += Ae * we, Ur += Ae * me, Pe += Ae * ze, $e += Ae * rt, le += Ae * Tt, re += Ae * Ot, Le += Ae * It, nt += Ae * We, ft += Ae * mt, zt += Ae * Gt, st += Ae * ir, ct += Ae * dr, Dt += (Ae = Ge[1]) * kr, wr += Ae * Xt, Nt += Ae * Qt, yr += Ae * br, Ur += Ae * we, Pe += Ae * me, $e += Ae * ze, le += Ae * rt, re += Ae * Tt, Le += Ae * Ot, nt += Ae * It, ft += Ae * We, zt += Ae * mt, st += Ae * Gt, ct += Ae * ir, yt += Ae * dr, wr += (Ae = Ge[2]) * kr, Nt += Ae * Xt, yr += Ae * Qt, Ur += Ae * br, Pe += Ae * we, $e += Ae * me, le += Ae * ze, re += Ae * rt, Le += Ae * Tt, nt += Ae * Ot, ft += Ae * It, zt += Ae * We, st += Ae * mt, ct += Ae * Gt, yt += Ae * ir, Zt += Ae * dr, Nt += (Ae = Ge[3]) * kr, yr += Ae * Xt, Ur += Ae * Qt, Pe += Ae * br, $e += Ae * we, le += Ae * me, re += Ae * ze, Le += Ae * rt, nt += Ae * Tt, ft += Ae * Ot, zt += Ae * It, st += Ae * We, ct += Ae * mt, yt += Ae * Gt, Zt += Ae * ir, Ct += Ae * dr, yr += (Ae = Ge[4]) * kr, Ur += Ae * Xt, Pe += Ae * Qt, $e += Ae * br, le += Ae * we, re += Ae * me, Le += Ae * ze, nt += Ae * rt, ft += Ae * Tt, zt += Ae * Ot, st += Ae * It, ct += Ae * We, yt += Ae * mt, Zt += Ae * Gt, Ct += Ae * ir, Lt += Ae * dr, Ur += (Ae = Ge[5]) * kr, Pe += Ae * Xt, $e += Ae * Qt, le += Ae * br, re += Ae * we, Le += Ae * me, nt += Ae * ze, ft += Ae * rt, zt += Ae * Tt, st += Ae * Ot, ct += Ae * It, yt += Ae * We, Zt += Ae * mt, Ct += Ae * Gt, Lt += Ae * ir, Wt += Ae * dr, Pe += (Ae = Ge[6]) * kr, $e += Ae * Xt, le += Ae * Qt, re += Ae * br, Le += Ae * we, nt += Ae * me, ft += Ae * ze, zt += Ae * rt, st += Ae * Tt, ct += Ae * Ot, yt += Ae * It, Zt += Ae * We, Ct += Ae * mt, Lt += Ae * Gt, Wt += Ae * ir, vr += Ae * dr, $e += (Ae = Ge[7]) * kr, le += Ae * Xt, re += Ae * Qt, Le += Ae * br, nt += Ae * we, ft += Ae * me, zt += Ae * ze, st += Ae * rt, ct += Ae * Tt, yt += Ae * Ot, Zt += Ae * It, Ct += Ae * We, Lt += Ae * mt, Wt += Ae * Gt, vr += Ae * ir, ar += Ae * dr, le += (Ae = Ge[8]) * kr, re += Ae * Xt, Le += Ae * Qt, nt += Ae * br, ft += Ae * we, zt += Ae * me, st += Ae * ze, ct += Ae * rt, yt += Ae * Tt, Zt += Ae * Ot, Ct += Ae * It, Lt += Ae * We, Wt += Ae * mt, vr += Ae * Gt, ar += Ae * ir, sr += Ae * dr, re += (Ae = Ge[9]) * kr, Le += Ae * Xt, nt += Ae * Qt, ft += Ae * br, zt += Ae * we, st += Ae * me, ct += Ae * ze, yt += Ae * rt, Zt += Ae * Tt, Ct += Ae * Ot, Lt += Ae * It, Wt += Ae * We, vr += Ae * mt, ar += Ae * Gt, sr += Ae * ir, gr += Ae * dr, Le += (Ae = Ge[10]) * kr, nt += Ae * Xt, ft += Ae * Qt, zt += Ae * br, st += Ae * we, ct += Ae * me, yt += Ae * ze, Zt += Ae * rt, Ct += Ae * Tt, Lt += Ae * Ot, Wt += Ae * It, vr += Ae * We, ar += Ae * mt, sr += Ae * Gt, gr += Ae * ir, Tr += Ae * dr, nt += (Ae = Ge[11]) * kr, ft += Ae * Xt, zt += Ae * Qt, st += Ae * br, ct += Ae * we, yt += Ae * me, Zt += Ae * ze, Ct += Ae * rt, Lt += Ae * Tt, Wt += Ae * Ot, vr += Ae * It, ar += Ae * We, sr += Ae * mt, gr += Ae * Gt, Tr += Ae * ir, Mr += Ae * dr, ft += (Ae = Ge[12]) * kr, zt += Ae * Xt, st += Ae * Qt, ct += Ae * br, yt += Ae * we, Zt += Ae * me, Ct += Ae * ze, Lt += Ae * rt, Wt += Ae * Tt, vr += Ae * Ot, ar += Ae * It, sr += Ae * We, gr += Ae * mt, Tr += Ae * Gt, Mr += Ae * ir, Nr += Ae * dr, zt += (Ae = Ge[13]) * kr, st += Ae * Xt, ct += Ae * Qt, yt += Ae * br, Zt += Ae * we, Ct += Ae * me, Lt += Ae * ze, Wt += Ae * rt, vr += Ae * Tt, ar += Ae * Ot, sr += Ae * It, gr += Ae * We, Tr += Ae * mt, Mr += Ae * Gt, Nr += Ae * ir, Lr += Ae * dr, st += (Ae = Ge[14]) * kr, ct += Ae * Xt, yt += Ae * Qt, Zt += Ae * br, Ct += Ae * we, Lt += Ae * me, Wt += Ae * ze, vr += Ae * rt, ar += Ae * Tt, sr += Ae * Ot, gr += Ae * It, Tr += Ae * We, Mr += Ae * mt, Nr += Ae * Gt, Lr += Ae * ir, jr += Ae * dr, ct += (Ae = Ge[15]) * kr, Dt += 38 * (Zt += Ae * Qt), wr += 38 * (Ct += Ae * br), Nt += 38 * (Lt += Ae * we), yr += 38 * (Wt += Ae * me), Ur += 38 * (vr += Ae * ze), Pe += 38 * (ar += Ae * rt), $e += 38 * (sr += Ae * Tt), le += 38 * (gr += Ae * Ot), re += 38 * (Tr += Ae * It), Le += 38 * (Mr += Ae * We), nt += 38 * (Nr += Ae * mt), ft += 38 * (Lr += Ae * Gt), zt += 38 * (jr += Ae * ir), st += 38 * (Hr += Ae * dr), Ft = (Ae = (Ft += 38 * (yt += Ae * Xt)) + (qe = 1) + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Dt = (Ae = Dt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), wr = (Ae = wr + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Nt = (Ae = Nt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), yr = (Ae = yr + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Ur = (Ae = Ur + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Pe = (Ae = Pe + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), $e = (Ae = $e + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), le = (Ae = le + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), re = (Ae = re + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Le = (Ae = Le + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), nt = (Ae = nt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), ft = (Ae = ft + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), zt = (Ae = zt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), st = (Ae = st + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), ct = (Ae = ct + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Ft = (Ae = (Ft += qe - 1 + 37 * (qe - 1)) + (qe = 1) + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Dt = (Ae = Dt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), wr = (Ae = wr + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Nt = (Ae = Nt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), yr = (Ae = yr + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Ur = (Ae = Ur + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Pe = (Ae = Pe + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), $e = (Ae = $e + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), le = (Ae = le + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), re = (Ae = re + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Le = (Ae = Le + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), nt = (Ae = nt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), ft = (Ae = ft + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), zt = (Ae = zt + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), st = (Ae = st + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), ct = (Ae = ct + qe + 65535) - 65536 * (qe = Math.floor(Ae / 65536)), Ft += qe - 1 + 37 * (qe - 1), je[0] = Ft, je[1] = Dt, je[2] = wr, je[3] = Nt, je[4] = yr, je[5] = Ur, je[6] = Pe, je[7] = $e, je[8] = le, je[9] = re, je[10] = Le, je[11] = nt, je[12] = ft, je[13] = zt, je[14] = st, je[15] = ct;
          }
          function ne(je, Ge) {
            ue(je, Ge, Ge);
          }
          function ge(je, Ge) {
            var at, Ae = h();
            for (at = 0; at < 16; at++) Ae[at] = Ge[at];
            for (at = 253; at >= 0; at--) ne(Ae, Ae), at !== 2 && at !== 4 && ue(Ae, Ae, Ge);
            for (at = 0; at < 16; at++) je[at] = Ae[at];
          }
          function Te(je, Ge) {
            var at, Ae = h();
            for (at = 0; at < 16; at++) Ae[at] = Ge[at];
            for (at = 250; at >= 0; at--) ne(Ae, Ae), at !== 1 && ue(Ae, Ae, Ge);
            for (at = 0; at < 16; at++) je[at] = Ae[at];
          }
          function pe(je, Ge, at) {
            var Ae, qe, Ft = new Uint8Array(32), Dt = new Float64Array(80), wr = h(), Nt = h(), yr = h(), Ur = h(), Pe = h(), $e = h();
            for (qe = 0; qe < 31; qe++) Ft[qe] = Ge[qe];
            for (Ft[31] = 127 & Ge[31] | 64, Ft[0] &= 248, ce(Dt, at), qe = 0; qe < 16; qe++) Nt[qe] = Dt[qe], Ur[qe] = wr[qe] = yr[qe] = 0;
            for (wr[0] = Ur[0] = 1, qe = 254; qe >= 0; --qe) Z(wr, Nt, Ae = Ft[qe >>> 3] >>> (7 & qe) & 1), Z(yr, Ur, Ae), ye(Pe, wr, yr), ae(wr, wr, yr), ye(yr, Nt, Ur), ae(Nt, Nt, Ur), ne(Ur, Pe), ne($e, wr), ue(wr, yr, wr), ue(yr, Nt, Pe), ye(Pe, wr, yr), ae(wr, wr, yr), ne(Nt, wr), ae(yr, Ur, $e), ue(wr, yr, l), ye(wr, wr, Ur), ue(yr, yr, wr), ue(wr, Ur, $e), ue(Ur, Nt, Dt), ne(Nt, Pe), Z(wr, Nt, Ae), Z(yr, Ur, Ae);
            for (qe = 0; qe < 16; qe++) Dt[qe + 16] = wr[qe], Dt[qe + 32] = yr[qe], Dt[qe + 48] = Nt[qe], Dt[qe + 64] = Ur[qe];
            var le = Dt.subarray(32), re = Dt.subarray(16);
            return ge(le, le), ue(re, re, le), ie(je, re), 0;
          }
          function Oe(je, Ge) {
            return pe(je, Ge, m);
          }
          function xe(je, Ge) {
            return f(Ge, 32), Oe(je, Ge);
          }
          function Ve(je, Ge, at) {
            var Ae = new Uint8Array(32);
            return pe(Ae, at, Ge), D(je, r, Ae, H);
          }
          z.prototype.blocks = function(je, Ge, at) {
            for (var Ae, qe, Ft, Dt, wr, Nt, yr, Ur, Pe, $e, le, re, Le, nt, ft, zt, st, ct, yt, Zt = this.fin ? 0 : 2048, Ct = this.h[0], Lt = this.h[1], Wt = this.h[2], vr = this.h[3], ar = this.h[4], sr = this.h[5], gr = this.h[6], Tr = this.h[7], Mr = this.h[8], Nr = this.h[9], Lr = this.r[0], jr = this.r[1], Hr = this.r[2], kr = this.r[3], Xt = this.r[4], Qt = this.r[5], br = this.r[6], we = this.r[7], me = this.r[8], ze = this.r[9]; at >= 16; ) $e = Pe = 0, $e += (Ct += 8191 & (Ae = 255 & je[Ge + 0] | (255 & je[Ge + 1]) << 8)) * Lr, $e += (Lt += 8191 & (Ae >>> 13 | (qe = 255 & je[Ge + 2] | (255 & je[Ge + 3]) << 8) << 3)) * (5 * ze), $e += (Wt += 8191 & (qe >>> 10 | (Ft = 255 & je[Ge + 4] | (255 & je[Ge + 5]) << 8) << 6)) * (5 * me), $e += (vr += 8191 & (Ft >>> 7 | (Dt = 255 & je[Ge + 6] | (255 & je[Ge + 7]) << 8) << 9)) * (5 * we), Pe = ($e += (ar += 8191 & (Dt >>> 4 | (wr = 255 & je[Ge + 8] | (255 & je[Ge + 9]) << 8) << 12)) * (5 * br)) >>> 13, $e &= 8191, $e += (sr += wr >>> 1 & 8191) * (5 * Qt), $e += (gr += 8191 & (wr >>> 14 | (Nt = 255 & je[Ge + 10] | (255 & je[Ge + 11]) << 8) << 2)) * (5 * Xt), $e += (Tr += 8191 & (Nt >>> 11 | (yr = 255 & je[Ge + 12] | (255 & je[Ge + 13]) << 8) << 5)) * (5 * kr), $e += (Mr += 8191 & (yr >>> 8 | (Ur = 255 & je[Ge + 14] | (255 & je[Ge + 15]) << 8) << 8)) * (5 * Hr), le = Pe += ($e += (Nr += Ur >>> 5 | Zt) * (5 * jr)) >>> 13, le += Ct * jr, le += Lt * Lr, le += Wt * (5 * ze), le += vr * (5 * me), Pe = (le += ar * (5 * we)) >>> 13, le &= 8191, le += sr * (5 * br), le += gr * (5 * Qt), le += Tr * (5 * Xt), le += Mr * (5 * kr), Pe += (le += Nr * (5 * Hr)) >>> 13, le &= 8191, re = Pe, re += Ct * Hr, re += Lt * jr, re += Wt * Lr, re += vr * (5 * ze), Pe = (re += ar * (5 * me)) >>> 13, re &= 8191, re += sr * (5 * we), re += gr * (5 * br), re += Tr * (5 * Qt), re += Mr * (5 * Xt), Le = Pe += (re += Nr * (5 * kr)) >>> 13, Le += Ct * kr, Le += Lt * Hr, Le += Wt * jr, Le += vr * Lr, Pe = (Le += ar * (5 * ze)) >>> 13, Le &= 8191, Le += sr * (5 * me), Le += gr * (5 * we), Le += Tr * (5 * br), Le += Mr * (5 * Qt), nt = Pe += (Le += Nr * (5 * Xt)) >>> 13, nt += Ct * Xt, nt += Lt * kr, nt += Wt * Hr, nt += vr * jr, Pe = (nt += ar * Lr) >>> 13, nt &= 8191, nt += sr * (5 * ze), nt += gr * (5 * me), nt += Tr * (5 * we), nt += Mr * (5 * br), ft = Pe += (nt += Nr * (5 * Qt)) >>> 13, ft += Ct * Qt, ft += Lt * Xt, ft += Wt * kr, ft += vr * Hr, Pe = (ft += ar * jr) >>> 13, ft &= 8191, ft += sr * Lr, ft += gr * (5 * ze), ft += Tr * (5 * me), ft += Mr * (5 * we), zt = Pe += (ft += Nr * (5 * br)) >>> 13, zt += Ct * br, zt += Lt * Qt, zt += Wt * Xt, zt += vr * kr, Pe = (zt += ar * Hr) >>> 13, zt &= 8191, zt += sr * jr, zt += gr * Lr, zt += Tr * (5 * ze), zt += Mr * (5 * me), st = Pe += (zt += Nr * (5 * we)) >>> 13, st += Ct * we, st += Lt * br, st += Wt * Qt, st += vr * Xt, Pe = (st += ar * kr) >>> 13, st &= 8191, st += sr * Hr, st += gr * jr, st += Tr * Lr, st += Mr * (5 * ze), ct = Pe += (st += Nr * (5 * me)) >>> 13, ct += Ct * me, ct += Lt * we, ct += Wt * br, ct += vr * Qt, Pe = (ct += ar * Xt) >>> 13, ct &= 8191, ct += sr * kr, ct += gr * Hr, ct += Tr * jr, ct += Mr * Lr, yt = Pe += (ct += Nr * (5 * ze)) >>> 13, yt += Ct * ze, yt += Lt * me, yt += Wt * we, yt += vr * br, Pe = (yt += ar * Qt) >>> 13, yt &= 8191, yt += sr * Xt, yt += gr * kr, yt += Tr * Hr, yt += Mr * jr, Ct = $e = 8191 & (Pe = (Pe = ((Pe += (yt += Nr * Lr) >>> 13) << 2) + Pe | 0) + ($e &= 8191) | 0), Lt = le += Pe >>>= 13, Wt = re &= 8191, vr = Le &= 8191, ar = nt &= 8191, sr = ft &= 8191, gr = zt &= 8191, Tr = st &= 8191, Mr = ct &= 8191, Nr = yt &= 8191, Ge += 16, at -= 16;
            this.h[0] = Ct, this.h[1] = Lt, this.h[2] = Wt, this.h[3] = vr, this.h[4] = ar, this.h[5] = sr, this.h[6] = gr, this.h[7] = Tr, this.h[8] = Mr, this.h[9] = Nr;
          }, z.prototype.finish = function(je, Ge) {
            var at, Ae, qe, Ft, Dt = new Uint16Array(10);
            if (this.leftover) {
              for (Ft = this.leftover, this.buffer[Ft++] = 1; Ft < 16; Ft++) this.buffer[Ft] = 0;
              this.fin = 1, this.blocks(this.buffer, 0, 16);
            }
            for (at = this.h[1] >>> 13, this.h[1] &= 8191, Ft = 2; Ft < 10; Ft++) this.h[Ft] += at, at = this.h[Ft] >>> 13, this.h[Ft] &= 8191;
            for (this.h[0] += 5 * at, at = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += at, at = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += at, Dt[0] = this.h[0] + 5, at = Dt[0] >>> 13, Dt[0] &= 8191, Ft = 1; Ft < 10; Ft++) Dt[Ft] = this.h[Ft] + at, at = Dt[Ft] >>> 13, Dt[Ft] &= 8191;
            for (Dt[9] -= 8192, Ae = (1 ^ at) - 1, Ft = 0; Ft < 10; Ft++) Dt[Ft] &= Ae;
            for (Ae = ~Ae, Ft = 0; Ft < 10; Ft++) this.h[Ft] = this.h[Ft] & Ae | Dt[Ft];
            for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), qe = this.h[0] + this.pad[0], this.h[0] = 65535 & qe, Ft = 1; Ft < 8; Ft++) qe = (this.h[Ft] + this.pad[Ft] | 0) + (qe >>> 16) | 0, this.h[Ft] = 65535 & qe;
            je[Ge + 0] = this.h[0] >>> 0 & 255, je[Ge + 1] = this.h[0] >>> 8 & 255, je[Ge + 2] = this.h[1] >>> 0 & 255, je[Ge + 3] = this.h[1] >>> 8 & 255, je[Ge + 4] = this.h[2] >>> 0 & 255, je[Ge + 5] = this.h[2] >>> 8 & 255, je[Ge + 6] = this.h[3] >>> 0 & 255, je[Ge + 7] = this.h[3] >>> 8 & 255, je[Ge + 8] = this.h[4] >>> 0 & 255, je[Ge + 9] = this.h[4] >>> 8 & 255, je[Ge + 10] = this.h[5] >>> 0 & 255, je[Ge + 11] = this.h[5] >>> 8 & 255, je[Ge + 12] = this.h[6] >>> 0 & 255, je[Ge + 13] = this.h[6] >>> 8 & 255, je[Ge + 14] = this.h[7] >>> 0 & 255, je[Ge + 15] = this.h[7] >>> 8 & 255;
          }, z.prototype.update = function(je, Ge, at) {
            var Ae, qe;
            if (this.leftover) {
              for ((qe = 16 - this.leftover) > at && (qe = at), Ae = 0; Ae < qe; Ae++) this.buffer[this.leftover + Ae] = je[Ge + Ae];
              if (at -= qe, Ge += qe, this.leftover += qe, this.leftover < 16) return;
              this.blocks(this.buffer, 0, 16), this.leftover = 0;
            }
            if (at >= 16 && (qe = at - at % 16, this.blocks(je, Ge, qe), Ge += qe, at -= qe), at) {
              for (Ae = 0; Ae < at; Ae++) this.buffer[this.leftover + Ae] = je[Ge + Ae];
              this.leftover += at;
            }
          };
          var _e = G, Be = K, Qe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
          function ee(je, Ge, at, Ae) {
            for (var qe, Ft, Dt, wr, Nt, yr, Ur, Pe, $e, le, re, Le, nt, ft, zt, st, ct, yt, Zt, Ct, Lt, Wt, vr, ar, sr, gr, Tr = new Int32Array(16), Mr = new Int32Array(16), Nr = je[0], Lr = je[1], jr = je[2], Hr = je[3], kr = je[4], Xt = je[5], Qt = je[6], br = je[7], we = Ge[0], me = Ge[1], ze = Ge[2], rt = Ge[3], Tt = Ge[4], Ot = Ge[5], It = Ge[6], We = Ge[7], mt = 0; Ae >= 128; ) {
              for (Zt = 0; Zt < 16; Zt++) Ct = 8 * Zt + mt, Tr[Zt] = at[Ct + 0] << 24 | at[Ct + 1] << 16 | at[Ct + 2] << 8 | at[Ct + 3], Mr[Zt] = at[Ct + 4] << 24 | at[Ct + 5] << 16 | at[Ct + 6] << 8 | at[Ct + 7];
              for (Zt = 0; Zt < 80; Zt++) if (qe = Nr, Ft = Lr, Dt = jr, wr = Hr, Nt = kr, yr = Xt, Ur = Qt, $e = we, le = me, re = ze, Le = rt, nt = Tt, ft = Ot, zt = It, vr = 65535 & (Wt = We), ar = Wt >>> 16, sr = 65535 & (Lt = br), gr = Lt >>> 16, vr += 65535 & (Wt = (Tt >>> 14 | kr << 18) ^ (Tt >>> 18 | kr << 14) ^ (kr >>> 9 | Tt << 23)), ar += Wt >>> 16, sr += 65535 & (Lt = (kr >>> 14 | Tt << 18) ^ (kr >>> 18 | Tt << 14) ^ (Tt >>> 9 | kr << 23)), gr += Lt >>> 16, vr += 65535 & (Wt = Tt & Ot ^ ~Tt & It), ar += Wt >>> 16, sr += 65535 & (Lt = kr & Xt ^ ~kr & Qt), gr += Lt >>> 16, vr += 65535 & (Wt = Qe[2 * Zt + 1]), ar += Wt >>> 16, sr += 65535 & (Lt = Qe[2 * Zt]), gr += Lt >>> 16, Lt = Tr[Zt % 16], ar += (Wt = Mr[Zt % 16]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16, vr = 65535 & (Wt = yt = 65535 & vr | ar << 16), ar = Wt >>> 16, sr = 65535 & (Lt = ct = 65535 & sr | (gr += sr >>> 16) << 16), gr = Lt >>> 16, vr += 65535 & (Wt = (we >>> 28 | Nr << 4) ^ (Nr >>> 2 | we << 30) ^ (Nr >>> 7 | we << 25)), ar += Wt >>> 16, sr += 65535 & (Lt = (Nr >>> 28 | we << 4) ^ (we >>> 2 | Nr << 30) ^ (we >>> 7 | Nr << 25)), gr += Lt >>> 16, ar += (Wt = we & me ^ we & ze ^ me & ze) >>> 16, sr += 65535 & (Lt = Nr & Lr ^ Nr & jr ^ Lr & jr), gr += Lt >>> 16, Pe = 65535 & (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) | (gr += sr >>> 16) << 16, st = 65535 & vr | ar << 16, vr = 65535 & (Wt = Le), ar = Wt >>> 16, sr = 65535 & (Lt = wr), gr = Lt >>> 16, ar += (Wt = yt) >>> 16, sr += 65535 & (Lt = ct), gr += Lt >>> 16, Lr = qe, jr = Ft, Hr = Dt, kr = wr = 65535 & (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) | (gr += sr >>> 16) << 16, Xt = Nt, Qt = yr, br = Ur, Nr = Pe, me = $e, ze = le, rt = re, Tt = Le = 65535 & vr | ar << 16, Ot = nt, It = ft, We = zt, we = st, Zt % 16 == 15) for (Ct = 0; Ct < 16; Ct++) Lt = Tr[Ct], vr = 65535 & (Wt = Mr[Ct]), ar = Wt >>> 16, sr = 65535 & Lt, gr = Lt >>> 16, Lt = Tr[(Ct + 9) % 16], vr += 65535 & (Wt = Mr[(Ct + 9) % 16]), ar += Wt >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, ct = Tr[(Ct + 1) % 16], vr += 65535 & (Wt = ((yt = Mr[(Ct + 1) % 16]) >>> 1 | ct << 31) ^ (yt >>> 8 | ct << 24) ^ (yt >>> 7 | ct << 25)), ar += Wt >>> 16, sr += 65535 & (Lt = (ct >>> 1 | yt << 31) ^ (ct >>> 8 | yt << 24) ^ ct >>> 7), gr += Lt >>> 16, ct = Tr[(Ct + 14) % 16], ar += (Wt = ((yt = Mr[(Ct + 14) % 16]) >>> 19 | ct << 13) ^ (ct >>> 29 | yt << 3) ^ (yt >>> 6 | ct << 26)) >>> 16, sr += 65535 & (Lt = (ct >>> 19 | yt << 13) ^ (yt >>> 29 | ct << 3) ^ ct >>> 6), gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, Tr[Ct] = 65535 & sr | gr << 16, Mr[Ct] = 65535 & vr | ar << 16;
              vr = 65535 & (Wt = we), ar = Wt >>> 16, sr = 65535 & (Lt = Nr), gr = Lt >>> 16, Lt = je[0], ar += (Wt = Ge[0]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[0] = Nr = 65535 & sr | gr << 16, Ge[0] = we = 65535 & vr | ar << 16, vr = 65535 & (Wt = me), ar = Wt >>> 16, sr = 65535 & (Lt = Lr), gr = Lt >>> 16, Lt = je[1], ar += (Wt = Ge[1]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[1] = Lr = 65535 & sr | gr << 16, Ge[1] = me = 65535 & vr | ar << 16, vr = 65535 & (Wt = ze), ar = Wt >>> 16, sr = 65535 & (Lt = jr), gr = Lt >>> 16, Lt = je[2], ar += (Wt = Ge[2]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[2] = jr = 65535 & sr | gr << 16, Ge[2] = ze = 65535 & vr | ar << 16, vr = 65535 & (Wt = rt), ar = Wt >>> 16, sr = 65535 & (Lt = Hr), gr = Lt >>> 16, Lt = je[3], ar += (Wt = Ge[3]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[3] = Hr = 65535 & sr | gr << 16, Ge[3] = rt = 65535 & vr | ar << 16, vr = 65535 & (Wt = Tt), ar = Wt >>> 16, sr = 65535 & (Lt = kr), gr = Lt >>> 16, Lt = je[4], ar += (Wt = Ge[4]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[4] = kr = 65535 & sr | gr << 16, Ge[4] = Tt = 65535 & vr | ar << 16, vr = 65535 & (Wt = Ot), ar = Wt >>> 16, sr = 65535 & (Lt = Xt), gr = Lt >>> 16, Lt = je[5], ar += (Wt = Ge[5]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[5] = Xt = 65535 & sr | gr << 16, Ge[5] = Ot = 65535 & vr | ar << 16, vr = 65535 & (Wt = It), ar = Wt >>> 16, sr = 65535 & (Lt = Qt), gr = Lt >>> 16, Lt = je[6], ar += (Wt = Ge[6]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[6] = Qt = 65535 & sr | gr << 16, Ge[6] = It = 65535 & vr | ar << 16, vr = 65535 & (Wt = We), ar = Wt >>> 16, sr = 65535 & (Lt = br), gr = Lt >>> 16, Lt = je[7], ar += (Wt = Ge[7]) >>> 16, sr += 65535 & Lt, gr += Lt >>> 16, gr += (sr += (ar += (vr += 65535 & Wt) >>> 16) >>> 16) >>> 16, je[7] = br = 65535 & sr | gr << 16, Ge[7] = We = 65535 & vr | ar << 16, mt += 128, Ae -= 128;
            }
            return Ae;
          }
          function P(je, Ge, at) {
            var Ae, qe = new Int32Array(8), Ft = new Int32Array(8), Dt = new Uint8Array(256), wr = at;
            for (qe[0] = 1779033703, qe[1] = 3144134277, qe[2] = 1013904242, qe[3] = 2773480762, qe[4] = 1359893119, qe[5] = 2600822924, qe[6] = 528734635, qe[7] = 1541459225, Ft[0] = 4089235720, Ft[1] = 2227873595, Ft[2] = 4271175723, Ft[3] = 1595750129, Ft[4] = 2917565137, Ft[5] = 725511199, Ft[6] = 4215389547, Ft[7] = 327033209, ee(qe, Ft, Ge, at), at %= 128, Ae = 0; Ae < at; Ae++) Dt[Ae] = Ge[wr - at + Ae];
            for (Dt[at] = 128, Dt[(at = 256 - 128 * (at < 112 ? 1 : 0)) - 9] = 0, k(Dt, at - 8, wr / 536870912 | 0, wr << 3), ee(qe, Ft, Dt, at), Ae = 0; Ae < 8; Ae++) k(je, 8 * Ae, qe[Ae], Ft[Ae]);
            return 0;
          }
          function x(je, Ge) {
            var at = h(), Ae = h(), qe = h(), Ft = h(), Dt = h(), wr = h(), Nt = h(), yr = h(), Ur = h();
            ae(at, je[1], je[0]), ae(Ur, Ge[1], Ge[0]), ue(at, at, Ur), ye(Ae, je[0], je[1]), ye(Ur, Ge[0], Ge[1]), ue(Ae, Ae, Ur), ue(qe, je[3], Ge[3]), ue(qe, qe, b), ue(Ft, je[2], Ge[2]), ye(Ft, Ft, Ft), ae(Dt, Ae, at), ae(wr, Ft, qe), ye(Nt, Ft, qe), ye(yr, Ae, at), ue(je[0], Dt, wr), ue(je[1], yr, Nt), ue(je[2], Nt, wr), ue(je[3], Dt, yr);
          }
          function O(je, Ge, at) {
            var Ae;
            for (Ae = 0; Ae < 4; Ae++) Z(je[Ae], Ge[Ae], at);
          }
          function V(je, Ge) {
            var at = h(), Ae = h(), qe = h();
            ge(qe, Ge[2]), ue(at, Ge[0], qe), ue(Ae, Ge[1], qe), ie(je, Ae), je[31] ^= oe(at) << 7;
          }
          function N(je, Ge, at) {
            var Ae, qe;
            for (J(je[0], g), J(je[1], a), J(je[2], a), J(je[3], g), qe = 255; qe >= 0; --qe) O(je, Ge, Ae = at[qe / 8 | 0] >> (7 & qe) & 1), x(Ge, je), x(je, je), O(je, Ge, Ae);
          }
          function C(je, Ge) {
            var at = [h(), h(), h(), h()];
            J(at[0], S), J(at[1], E), J(at[2], a), ue(at[3], S, E), N(je, at, Ge);
          }
          function p(je, Ge, at) {
            var Ae, qe = new Uint8Array(64), Ft = [h(), h(), h(), h()];
            for (at || f(Ge, 32), P(qe, Ge, 32), qe[0] &= 248, qe[31] &= 127, qe[31] |= 64, C(Ft, qe), V(je, Ft), Ae = 0; Ae < 32; Ae++) Ge[Ae + 32] = je[Ae];
            return 0;
          }
          var A = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
          function U(je, Ge) {
            var at, Ae, qe, Ft;
            for (Ae = 63; Ae >= 32; --Ae) {
              for (at = 0, qe = Ae - 32, Ft = Ae - 12; qe < Ft; ++qe) Ge[qe] += at - 16 * Ge[Ae] * A[qe - (Ae - 32)], at = Math.floor((Ge[qe] + 128) / 256), Ge[qe] -= 256 * at;
              Ge[qe] += at, Ge[Ae] = 0;
            }
            for (at = 0, qe = 0; qe < 32; qe++) Ge[qe] += at - (Ge[31] >> 4) * A[qe], at = Ge[qe] >> 8, Ge[qe] &= 255;
            for (qe = 0; qe < 32; qe++) Ge[qe] -= at * A[qe];
            for (Ae = 0; Ae < 32; Ae++) Ge[Ae + 1] += Ge[Ae] >> 8, je[Ae] = 255 & Ge[Ae];
          }
          function Q(je) {
            var Ge, at = new Float64Array(64);
            for (Ge = 0; Ge < 64; Ge++) at[Ge] = je[Ge];
            for (Ge = 0; Ge < 64; Ge++) je[Ge] = 0;
            U(je, at);
          }
          function se(je, Ge, at, Ae) {
            var qe, Ft, Dt = new Uint8Array(64), wr = new Uint8Array(64), Nt = new Uint8Array(64), yr = new Float64Array(64), Ur = [h(), h(), h(), h()];
            P(Dt, Ae, 32), Dt[0] &= 248, Dt[31] &= 127, Dt[31] |= 64;
            var Pe = at + 64;
            for (qe = 0; qe < at; qe++) je[64 + qe] = Ge[qe];
            for (qe = 0; qe < 32; qe++) je[32 + qe] = Dt[32 + qe];
            for (P(Nt, je.subarray(32), at + 32), Q(Nt), C(Ur, Nt), V(je, Ur), qe = 32; qe < 64; qe++) je[qe] = Ae[qe];
            for (P(wr, je, at + 64), Q(wr), qe = 0; qe < 64; qe++) yr[qe] = 0;
            for (qe = 0; qe < 32; qe++) yr[qe] = Nt[qe];
            for (qe = 0; qe < 32; qe++) for (Ft = 0; Ft < 32; Ft++) yr[qe + Ft] += wr[qe] * Dt[Ft];
            return U(je.subarray(32), yr), Pe;
          }
          function X(je, Ge, at, Ae) {
            var qe, Ft = new Uint8Array(32), Dt = new Uint8Array(64), wr = [h(), h(), h(), h()], Nt = [h(), h(), h(), h()];
            if (at < 64 || function(yr, Ur) {
              var Pe = h(), $e = h(), le = h(), re = h(), Le = h(), nt = h(), ft = h();
              return J(yr[2], a), ce(yr[1], Ur), ne(le, yr[1]), ue(re, le, d), ae(le, le, yr[2]), ye(re, yr[2], re), ne(Le, re), ne(nt, Le), ue(ft, nt, Le), ue(Pe, ft, le), ue(Pe, Pe, re), Te(Pe, Pe), ue(Pe, Pe, le), ue(Pe, Pe, re), ue(Pe, Pe, re), ue(yr[0], Pe, re), ne($e, yr[0]), ue($e, $e, re), $($e, le) && ue(yr[0], yr[0], R), ne($e, yr[0]), ue($e, $e, re), $($e, le) ? -1 : (oe(yr[0]) === Ur[31] >> 7 && ae(yr[0], g, yr[0]), ue(yr[3], yr[0], yr[1]), 0);
            }(Nt, Ae)) return -1;
            for (qe = 0; qe < at; qe++) je[qe] = Ge[qe];
            for (qe = 0; qe < 32; qe++) je[qe + 32] = Ae[qe];
            if (P(Dt, je, at), Q(Dt), N(wr, Nt, Dt), C(Nt, Ge.subarray(32)), x(wr, Nt), V(Ft, wr), at -= 64, I(Ge, 0, Ft, 0)) {
              for (qe = 0; qe < at; qe++) je[qe] = 0;
              return -1;
            }
            for (qe = 0; qe < at; qe++) je[qe] = Ge[qe + 64];
            return at;
          }
          var de = 16, tt = 64, Ne = 32, ut = 64;
          function Ze(je, Ge) {
            if (je.length !== 32) throw new Error("bad key size");
            if (Ge.length !== 24) throw new Error("bad nonce size");
          }
          function Et() {
            for (var je = 0; je < arguments.length; je++) if (!(arguments[je] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
          }
          function rr(je) {
            for (var Ge = 0; Ge < je.length; Ge++) je[Ge] = 0;
          }
          c.lowlevel = { crypto_core_hsalsa20: D, crypto_stream_xor: j, crypto_stream: L, crypto_stream_salsa20_xor: _, crypto_stream_salsa20: T, crypto_onetimeauth: Y, crypto_onetimeauth_verify: te, crypto_verify_16: F, crypto_verify_32: I, crypto_secretbox: G, crypto_secretbox_open: K, crypto_scalarmult: pe, crypto_scalarmult_base: Oe, crypto_box_beforenm: Ve, crypto_box_afternm: _e, crypto_box: function(je, Ge, at, Ae, qe, Ft) {
            var Dt = new Uint8Array(32);
            return Ve(Dt, qe, Ft), _e(je, Ge, at, Ae, Dt);
          }, crypto_box_open: function(je, Ge, at, Ae, qe, Ft) {
            var Dt = new Uint8Array(32);
            return Ve(Dt, qe, Ft), Be(je, Ge, at, Ae, Dt);
          }, crypto_box_keypair: xe, crypto_hash: P, crypto_sign: se, crypto_sign_keypair: p, crypto_sign_open: X, crypto_secretbox_KEYBYTES: 32, crypto_secretbox_NONCEBYTES: 24, crypto_secretbox_ZEROBYTES: 32, crypto_secretbox_BOXZEROBYTES: de, crypto_scalarmult_BYTES: 32, crypto_scalarmult_SCALARBYTES: 32, crypto_box_PUBLICKEYBYTES: 32, crypto_box_SECRETKEYBYTES: 32, crypto_box_BEFORENMBYTES: 32, crypto_box_NONCEBYTES: 24, crypto_box_ZEROBYTES: 32, crypto_box_BOXZEROBYTES: 16, crypto_sign_BYTES: tt, crypto_sign_PUBLICKEYBYTES: Ne, crypto_sign_SECRETKEYBYTES: ut, crypto_sign_SEEDBYTES: 32, crypto_hash_BYTES: 64, gf: h, D: d, L: A, pack25519: ie, unpack25519: ce, M: ue, A: ye, S: ne, Z: ae, pow2523: Te, add: x, set25519: J, modL: U, scalarmult: N, scalarbase: C }, c.randomBytes = function(je) {
            var Ge = new Uint8Array(je);
            return f(Ge, je), Ge;
          }, c.secretbox = function(je, Ge, at) {
            Et(je, Ge, at), Ze(at, Ge);
            for (var Ae = new Uint8Array(32 + je.length), qe = new Uint8Array(Ae.length), Ft = 0; Ft < je.length; Ft++) Ae[Ft + 32] = je[Ft];
            return G(qe, Ae, Ae.length, Ge, at), qe.subarray(de);
          }, c.secretbox.open = function(je, Ge, at) {
            Et(je, Ge, at), Ze(at, Ge);
            for (var Ae = new Uint8Array(de + je.length), qe = new Uint8Array(Ae.length), Ft = 0; Ft < je.length; Ft++) Ae[Ft + de] = je[Ft];
            return Ae.length < 32 || K(qe, Ae, Ae.length, Ge, at) !== 0 ? null : qe.subarray(32);
          }, c.secretbox.keyLength = 32, c.secretbox.nonceLength = 24, c.secretbox.overheadLength = de, c.scalarMult = function(je, Ge) {
            if (Et(je, Ge), je.length !== 32) throw new Error("bad n size");
            if (Ge.length !== 32) throw new Error("bad p size");
            var at = new Uint8Array(32);
            return pe(at, je, Ge), at;
          }, c.scalarMult.base = function(je) {
            if (Et(je), je.length !== 32) throw new Error("bad n size");
            var Ge = new Uint8Array(32);
            return Oe(Ge, je), Ge;
          }, c.scalarMult.scalarLength = 32, c.scalarMult.groupElementLength = 32, c.box = function(je, Ge, at, Ae) {
            var qe = c.box.before(at, Ae);
            return c.secretbox(je, Ge, qe);
          }, c.box.before = function(je, Ge) {
            Et(je, Ge), function(Ae, qe) {
              if (Ae.length !== 32) throw new Error("bad public key size");
              if (qe.length !== 32) throw new Error("bad secret key size");
            }(je, Ge);
            var at = new Uint8Array(32);
            return Ve(at, je, Ge), at;
          }, c.box.after = c.secretbox, c.box.open = function(je, Ge, at, Ae) {
            var qe = c.box.before(at, Ae);
            return c.secretbox.open(je, Ge, qe);
          }, c.box.open.after = c.secretbox.open, c.box.keyPair = function() {
            var je = new Uint8Array(32), Ge = new Uint8Array(32);
            return xe(je, Ge), { publicKey: je, secretKey: Ge };
          }, c.box.keyPair.fromSecretKey = function(je) {
            if (Et(je), je.length !== 32) throw new Error("bad secret key size");
            var Ge = new Uint8Array(32);
            return Oe(Ge, je), { publicKey: Ge, secretKey: new Uint8Array(je) };
          }, c.box.publicKeyLength = 32, c.box.secretKeyLength = 32, c.box.sharedKeyLength = 32, c.box.nonceLength = 24, c.box.overheadLength = c.secretbox.overheadLength, c.sign = function(je, Ge) {
            if (Et(je, Ge), Ge.length !== ut) throw new Error("bad secret key size");
            var at = new Uint8Array(tt + je.length);
            return se(at, je, je.length, Ge), at;
          }, c.sign.open = function(je, Ge) {
            if (Et(je, Ge), Ge.length !== Ne) throw new Error("bad public key size");
            var at = new Uint8Array(je.length), Ae = X(at, je, je.length, Ge);
            if (Ae < 0) return null;
            for (var qe = new Uint8Array(Ae), Ft = 0; Ft < qe.length; Ft++) qe[Ft] = at[Ft];
            return qe;
          }, c.sign.detached = function(je, Ge) {
            for (var at = c.sign(je, Ge), Ae = new Uint8Array(tt), qe = 0; qe < Ae.length; qe++) Ae[qe] = at[qe];
            return Ae;
          }, c.sign.detached.verify = function(je, Ge, at) {
            if (Et(je, Ge, at), Ge.length !== tt) throw new Error("bad signature size");
            if (at.length !== Ne) throw new Error("bad public key size");
            var Ae, qe = new Uint8Array(tt + je.length), Ft = new Uint8Array(tt + je.length);
            for (Ae = 0; Ae < tt; Ae++) qe[Ae] = Ge[Ae];
            for (Ae = 0; Ae < je.length; Ae++) qe[Ae + tt] = je[Ae];
            return X(Ft, qe, qe.length, at) >= 0;
          }, c.sign.keyPair = function() {
            var je = new Uint8Array(Ne), Ge = new Uint8Array(ut);
            return p(je, Ge), { publicKey: je, secretKey: Ge };
          }, c.sign.keyPair.fromSecretKey = function(je) {
            if (Et(je), je.length !== ut) throw new Error("bad secret key size");
            for (var Ge = new Uint8Array(Ne), at = 0; at < Ge.length; at++) Ge[at] = je[32 + at];
            return { publicKey: Ge, secretKey: new Uint8Array(je) };
          }, c.sign.keyPair.fromSeed = function(je) {
            if (Et(je), je.length !== 32) throw new Error("bad seed size");
            for (var Ge = new Uint8Array(Ne), at = new Uint8Array(ut), Ae = 0; Ae < 32; Ae++) at[Ae] = je[Ae];
            return p(Ge, at, true), { publicKey: Ge, secretKey: at };
          }, c.sign.publicKeyLength = Ne, c.sign.secretKeyLength = ut, c.sign.seedLength = 32, c.sign.signatureLength = tt, c.hash = function(je) {
            Et(je);
            var Ge = new Uint8Array(64);
            return P(Ge, je, je.length), Ge;
          }, c.hash.hashLength = 64, c.verify = function(je, Ge) {
            return Et(je, Ge), je.length !== 0 && Ge.length !== 0 && je.length === Ge.length && w(je, 0, Ge, 0, je.length) === 0;
          }, c.setPRNG = function(je) {
            f = je;
          }, function() {
            var je = typeof self < "u" ? self.crypto || self.msCrypto : null;
            je && je.getRandomValues ? c.setPRNG(function(Ge, at) {
              var Ae, qe = new Uint8Array(at);
              for (Ae = 0; Ae < at; Ae += 65536) je.getRandomValues(qe.subarray(Ae, Ae + Math.min(at - Ae, 65536)));
              for (Ae = 0; Ae < at; Ae++) Ge[Ae] = qe[Ae];
              rr(qe);
            }) : (je = u(2894)) && je.randomBytes && c.setPRNG(function(Ge, at) {
              var Ae, qe = je.randomBytes(at);
              for (Ae = 0; Ae < at; Ae++) Ge[Ae] = qe[Ae];
              rr(qe);
            });
          }();
        })(t.exports ? t.exports : self.nacl = self.nacl || {});
      }, 5157: (t) => {
        t.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, 5291: (t, o, u) => {
        var c = u(6048).F.ERR_INVALID_OPT_VALUE;
        t.exports = { getHighWaterMark: function(h, f, r, m) {
          var g = function(a, l, d) {
            return a.highWaterMark != null ? a.highWaterMark : l ? a[d] : null;
          }(f, m, r);
          if (g != null) {
            if (!isFinite(g) || Math.floor(g) !== g || g < 0) throw new c(m ? r : "highWaterMark", g);
            return Math.floor(g);
          }
          return h.objectMode ? 16 : 16384;
        } };
      }, 5328: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.authorizeEntry = R, o.authorizeInvocation = function(w, F, I) {
          var q = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "", D = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : g.Networks.FUTURENET, H = r.Keypair.random().rawPublicKey(), _ = new f.default.Int64((L = H, L.subarray(0, 8).reduce(function(j, z) {
            return j << 8 | z;
          }, 0))), T = q || w.publicKey(), L;
          if (!T) throw new Error("authorizeInvocation requires publicKey parameter");
          return R(new f.default.SorobanAuthorizationEntry({ rootInvocation: I, credentials: f.default.SorobanCredentials.sorobanCredentialsAddress(new f.default.SorobanAddressCredentials({ address: new l.Address(T).toScAddress(), nonce: _, signatureExpirationLedger: 0, signature: f.default.ScVal.scvVec([]) })) }), w, F, D);
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(6691), m = u(7120), g = u(6202), a = u(9152), l = u(1180), d = u(7177);
        function b(w) {
          return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
            return typeof F;
          } : function(F) {
            return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
          }, b(w);
        }
        function S() {
          S = function() {
            return F;
          };
          var w, F = {}, I = Object.prototype, q = I.hasOwnProperty, D = Object.defineProperty || function(_e, Be, Qe) {
            _e[Be] = Qe.value;
          }, H = typeof Symbol == "function" ? Symbol : {}, _ = H.iterator || "@@iterator", T = H.asyncIterator || "@@asyncIterator", L = H.toStringTag || "@@toStringTag";
          function j(_e, Be, Qe) {
            return Object.defineProperty(_e, Be, { value: Qe, enumerable: true, configurable: true, writable: true }), _e[Be];
          }
          try {
            j({}, "");
          } catch {
            j = function(Be, Qe, ee) {
              return Be[Qe] = ee;
            };
          }
          function z(_e, Be, Qe, ee) {
            var P = Be && Be.prototype instanceof Z ? Be : Z, x = Object.create(P.prototype), O = new xe(ee || []);
            return D(x, "_invoke", { value: ge(_e, Qe, O) }), x;
          }
          function Y(_e, Be, Qe) {
            try {
              return { type: "normal", arg: _e.call(Be, Qe) };
            } catch (ee) {
              return { type: "throw", arg: ee };
            }
          }
          F.wrap = z;
          var te = "suspendedStart", G = "suspendedYield", K = "executing", J = "completed", B = {};
          function Z() {
          }
          function ie() {
          }
          function $() {
          }
          var oe = {};
          j(oe, _, function() {
            return this;
          });
          var ce = Object.getPrototypeOf, ye = ce && ce(ce(Ve([])));
          ye && ye !== I && q.call(ye, _) && (oe = ye);
          var ae = $.prototype = Z.prototype = Object.create(oe);
          function ue(_e) {
            ["next", "throw", "return"].forEach(function(Be) {
              j(_e, Be, function(Qe) {
                return this._invoke(Be, Qe);
              });
            });
          }
          function ne(_e, Be) {
            function Qe(P, x, O, V) {
              var N = Y(_e[P], _e, x);
              if (N.type !== "throw") {
                var C = N.arg, p = C.value;
                return p && b(p) == "object" && q.call(p, "__await") ? Be.resolve(p.__await).then(function(A) {
                  Qe("next", A, O, V);
                }, function(A) {
                  Qe("throw", A, O, V);
                }) : Be.resolve(p).then(function(A) {
                  C.value = A, O(C);
                }, function(A) {
                  return Qe("throw", A, O, V);
                });
              }
              V(N.arg);
            }
            var ee;
            D(this, "_invoke", { value: function(P, x) {
              function O() {
                return new Be(function(V, N) {
                  Qe(P, x, V, N);
                });
              }
              return ee = ee ? ee.then(O, O) : O();
            } });
          }
          function ge(_e, Be, Qe) {
            var ee = te;
            return function(P, x) {
              if (ee === K) throw Error("Generator is already running");
              if (ee === J) {
                if (P === "throw") throw x;
                return { value: w, done: true };
              }
              for (Qe.method = P, Qe.arg = x; ; ) {
                var O = Qe.delegate;
                if (O) {
                  var V = Te(O, Qe);
                  if (V) {
                    if (V === B) continue;
                    return V;
                  }
                }
                if (Qe.method === "next") Qe.sent = Qe._sent = Qe.arg;
                else if (Qe.method === "throw") {
                  if (ee === te) throw ee = J, Qe.arg;
                  Qe.dispatchException(Qe.arg);
                } else Qe.method === "return" && Qe.abrupt("return", Qe.arg);
                ee = K;
                var N = Y(_e, Be, Qe);
                if (N.type === "normal") {
                  if (ee = Qe.done ? J : G, N.arg === B) continue;
                  return { value: N.arg, done: Qe.done };
                }
                N.type === "throw" && (ee = J, Qe.method = "throw", Qe.arg = N.arg);
              }
            };
          }
          function Te(_e, Be) {
            var Qe = Be.method, ee = _e.iterator[Qe];
            if (ee === w) return Be.delegate = null, Qe === "throw" && _e.iterator.return && (Be.method = "return", Be.arg = w, Te(_e, Be), Be.method === "throw") || Qe !== "return" && (Be.method = "throw", Be.arg = new TypeError("The iterator does not provide a '" + Qe + "' method")), B;
            var P = Y(ee, _e.iterator, Be.arg);
            if (P.type === "throw") return Be.method = "throw", Be.arg = P.arg, Be.delegate = null, B;
            var x = P.arg;
            return x ? x.done ? (Be[_e.resultName] = x.value, Be.next = _e.nextLoc, Be.method !== "return" && (Be.method = "next", Be.arg = w), Be.delegate = null, B) : x : (Be.method = "throw", Be.arg = new TypeError("iterator result is not an object"), Be.delegate = null, B);
          }
          function pe(_e) {
            var Be = { tryLoc: _e[0] };
            1 in _e && (Be.catchLoc = _e[1]), 2 in _e && (Be.finallyLoc = _e[2], Be.afterLoc = _e[3]), this.tryEntries.push(Be);
          }
          function Oe(_e) {
            var Be = _e.completion || {};
            Be.type = "normal", delete Be.arg, _e.completion = Be;
          }
          function xe(_e) {
            this.tryEntries = [{ tryLoc: "root" }], _e.forEach(pe, this), this.reset(true);
          }
          function Ve(_e) {
            if (_e || _e === "") {
              var Be = _e[_];
              if (Be) return Be.call(_e);
              if (typeof _e.next == "function") return _e;
              if (!isNaN(_e.length)) {
                var Qe = -1, ee = function P() {
                  for (; ++Qe < _e.length; ) if (q.call(_e, Qe)) return P.value = _e[Qe], P.done = false, P;
                  return P.value = w, P.done = true, P;
                };
                return ee.next = ee;
              }
            }
            throw new TypeError(b(_e) + " is not iterable");
          }
          return ie.prototype = $, D(ae, "constructor", { value: $, configurable: true }), D($, "constructor", { value: ie, configurable: true }), ie.displayName = j($, L, "GeneratorFunction"), F.isGeneratorFunction = function(_e) {
            var Be = typeof _e == "function" && _e.constructor;
            return !!Be && (Be === ie || (Be.displayName || Be.name) === "GeneratorFunction");
          }, F.mark = function(_e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(_e, $) : (_e.__proto__ = $, j(_e, L, "GeneratorFunction")), _e.prototype = Object.create(ae), _e;
          }, F.awrap = function(_e) {
            return { __await: _e };
          }, ue(ne.prototype), j(ne.prototype, T, function() {
            return this;
          }), F.AsyncIterator = ne, F.async = function(_e, Be, Qe, ee, P) {
            P === void 0 && (P = Promise);
            var x = new ne(z(_e, Be, Qe, ee), P);
            return F.isGeneratorFunction(Be) ? x : x.next().then(function(O) {
              return O.done ? O.value : x.next();
            });
          }, ue(ae), j(ae, L, "Generator"), j(ae, _, function() {
            return this;
          }), j(ae, "toString", function() {
            return "[object Generator]";
          }), F.keys = function(_e) {
            var Be = Object(_e), Qe = [];
            for (var ee in Be) Qe.push(ee);
            return Qe.reverse(), function P() {
              for (; Qe.length; ) {
                var x = Qe.pop();
                if (x in Be) return P.value = x, P.done = false, P;
              }
              return P.done = true, P;
            };
          }, F.values = Ve, xe.prototype = { constructor: xe, reset: function(_e) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = w, this.done = false, this.delegate = null, this.method = "next", this.arg = w, this.tryEntries.forEach(Oe), !_e) for (var Be in this) Be.charAt(0) === "t" && q.call(this, Be) && !isNaN(+Be.slice(1)) && (this[Be] = w);
          }, stop: function() {
            this.done = true;
            var _e = this.tryEntries[0].completion;
            if (_e.type === "throw") throw _e.arg;
            return this.rval;
          }, dispatchException: function(_e) {
            if (this.done) throw _e;
            var Be = this;
            function Qe(N, C) {
              return x.type = "throw", x.arg = _e, Be.next = N, C && (Be.method = "next", Be.arg = w), !!C;
            }
            for (var ee = this.tryEntries.length - 1; ee >= 0; --ee) {
              var P = this.tryEntries[ee], x = P.completion;
              if (P.tryLoc === "root") return Qe("end");
              if (P.tryLoc <= this.prev) {
                var O = q.call(P, "catchLoc"), V = q.call(P, "finallyLoc");
                if (O && V) {
                  if (this.prev < P.catchLoc) return Qe(P.catchLoc, true);
                  if (this.prev < P.finallyLoc) return Qe(P.finallyLoc);
                } else if (O) {
                  if (this.prev < P.catchLoc) return Qe(P.catchLoc, true);
                } else {
                  if (!V) throw Error("try statement without catch or finally");
                  if (this.prev < P.finallyLoc) return Qe(P.finallyLoc);
                }
              }
            }
          }, abrupt: function(_e, Be) {
            for (var Qe = this.tryEntries.length - 1; Qe >= 0; --Qe) {
              var ee = this.tryEntries[Qe];
              if (ee.tryLoc <= this.prev && q.call(ee, "finallyLoc") && this.prev < ee.finallyLoc) {
                var P = ee;
                break;
              }
            }
            P && (_e === "break" || _e === "continue") && P.tryLoc <= Be && Be <= P.finallyLoc && (P = null);
            var x = P ? P.completion : {};
            return x.type = _e, x.arg = Be, P ? (this.method = "next", this.next = P.finallyLoc, B) : this.complete(x);
          }, complete: function(_e, Be) {
            if (_e.type === "throw") throw _e.arg;
            return _e.type === "break" || _e.type === "continue" ? this.next = _e.arg : _e.type === "return" ? (this.rval = this.arg = _e.arg, this.method = "return", this.next = "end") : _e.type === "normal" && Be && (this.next = Be), B;
          }, finish: function(_e) {
            for (var Be = this.tryEntries.length - 1; Be >= 0; --Be) {
              var Qe = this.tryEntries[Be];
              if (Qe.finallyLoc === _e) return this.complete(Qe.completion, Qe.afterLoc), Oe(Qe), B;
            }
          }, catch: function(_e) {
            for (var Be = this.tryEntries.length - 1; Be >= 0; --Be) {
              var Qe = this.tryEntries[Be];
              if (Qe.tryLoc === _e) {
                var ee = Qe.completion;
                if (ee.type === "throw") {
                  var P = ee.arg;
                  Oe(Qe);
                }
                return P;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(_e, Be, Qe) {
            return this.delegate = { iterator: Ve(_e), resultName: Be, nextLoc: Qe }, this.method === "next" && (this.arg = w), B;
          } }, F;
        }
        function E(w, F, I, q, D, H, _) {
          try {
            var T = w[H](_), L = T.value;
          } catch (j) {
            return void I(j);
          }
          T.done ? F(L) : Promise.resolve(L).then(q, D);
        }
        function R(w, F, I) {
          return k.apply(this, arguments);
        }
        function k() {
          var w;
          return w = S().mark(function F(I, q, D) {
            var H, _, T, L, j, z, Y, te, G, K, J = arguments;
            return S().wrap(function(B) {
              for (; ; ) switch (B.prev = B.next) {
                case 0:
                  if (H = J.length > 3 && J[3] !== void 0 ? J[3] : g.Networks.FUTURENET, I.credentials().switch().value === f.default.SorobanCredentialsType.sorobanCredentialsAddress().value) {
                    B.next = 3;
                    break;
                  }
                  return B.abrupt("return", I);
                case 3:
                  if (_ = f.default.SorobanAuthorizationEntry.fromXDR(I.toXDR()), (T = _.credentials().address()).signatureExpirationLedger(D), L = (0, a.hash)(c.from(H)), j = f.default.HashIdPreimage.envelopeTypeSorobanAuthorization(new f.default.HashIdPreimageSorobanAuthorization({ networkId: L, nonce: T.nonce(), invocation: _.rootInvocation(), signatureExpirationLedger: T.signatureExpirationLedger() })), z = (0, a.hash)(j.toXDR()), typeof q != "function") {
                    B.next = 16;
                    break;
                  }
                  return B.next = 12, q(j);
                case 12:
                  (G = B.sent) != null && G.signature ? (Y = c.from(G.signature), te = G.publicKey) : (Y = c.from(G), te = l.Address.fromScAddress(T.address()).toString()), B.next = 18;
                  break;
                case 16:
                  Y = c.from(q.sign(z)), te = q.publicKey();
                case 18:
                  if (r.Keypair.fromPublicKey(te).verify(z, Y)) {
                    B.next = 20;
                    break;
                  }
                  throw new Error("signature doesn't match payload");
                case 20:
                  return K = (0, d.nativeToScVal)({ public_key: m.StrKey.decodeEd25519PublicKey(te), signature: Y }, { type: { public_key: ["symbol", null], signature: ["symbol", null] } }), T.signature(f.default.ScVal.scvVec([K])), B.abrupt("return", _);
                case 23:
                case "end":
                  return B.stop();
              }
            }, F);
          }), k = function() {
            var F = this, I = arguments;
            return new Promise(function(q, D) {
              var H = w.apply(F, I);
              function _(L) {
                E(H, q, D, _, T, "next", L);
              }
              function T(L) {
                E(H, q, D, _, T, "throw", L);
              }
              _(void 0);
            });
          }, k.apply(this, arguments);
        }
      }, 5340: () => {
      }, 5345: (t) => {
        t.exports = URIError;
      }, 5360: (t, o) => {
        var u = function(g, a) {
          return a || (a = {}), g.split("").forEach(function(l, d) {
            l in a || (a[l] = d);
          }), a;
        }, c = { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", charmap: { 0: 14, 1: 8 } };
        c.charmap = u(c.alphabet, c.charmap);
        var h = { alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ", charmap: { O: 0, I: 1, L: 1 } };
        h.charmap = u(h.alphabet, h.charmap);
        var f = { alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", charmap: {} };
        function r(g) {
          if (this.buf = [], this.shift = 8, this.carry = 0, g) {
            switch (g.type) {
              case "rfc4648":
                this.charmap = o.rfc4648.charmap;
                break;
              case "crockford":
                this.charmap = o.crockford.charmap;
                break;
              case "base32hex":
                this.charmap = o.base32hex.charmap;
                break;
              default:
                throw new Error("invalid type");
            }
            g.charmap && (this.charmap = g.charmap);
          }
        }
        function m(g) {
          if (this.buf = "", this.shift = 3, this.carry = 0, g) {
            switch (g.type) {
              case "rfc4648":
                this.alphabet = o.rfc4648.alphabet;
                break;
              case "crockford":
                this.alphabet = o.crockford.alphabet;
                break;
              case "base32hex":
                this.alphabet = o.base32hex.alphabet;
                break;
              default:
                throw new Error("invalid type");
            }
            g.alphabet ? this.alphabet = g.alphabet : g.lc && (this.alphabet = this.alphabet.toLowerCase());
          }
        }
        f.charmap = u(f.alphabet, f.charmap), r.prototype.charmap = c.charmap, r.prototype.write = function(g) {
          var a = this.charmap, l = this.buf, d = this.shift, b = this.carry;
          return g.toUpperCase().split("").forEach(function(S) {
            if (S != "=") {
              var E = 255 & a[S];
              (d -= 5) > 0 ? b |= E << d : d < 0 ? (l.push(b | E >> -d), b = E << (d += 8) & 255) : (l.push(b | E), d = 8, b = 0);
            }
          }), this.shift = d, this.carry = b, this;
        }, r.prototype.finalize = function(g) {
          return g && this.write(g), this.shift !== 8 && this.carry !== 0 && (this.buf.push(this.carry), this.shift = 8, this.carry = 0), this.buf;
        }, m.prototype.alphabet = c.alphabet, m.prototype.write = function(g) {
          var a, l, d, b = this.shift, S = this.carry;
          for (d = 0; d < g.length; d++) a = S | (l = g[d]) >> b, this.buf += this.alphabet[31 & a], b > 5 && (a = l >> (b -= 5), this.buf += this.alphabet[31 & a]), S = l << (b = 5 - b), b = 8 - b;
          return this.shift = b, this.carry = S, this;
        }, m.prototype.finalize = function(g) {
          return g && this.write(g), this.shift !== 3 && (this.buf += this.alphabet[31 & this.carry], this.shift = 3, this.carry = 0), this.buf;
        }, o.encode = function(g, a) {
          return new m(a).finalize(g);
        }, o.decode = function(g, a) {
          return new r(a).finalize(g);
        }, o.Decoder = r, o.Encoder = m, o.charmap = u, o.crockford = h, o.rfc4648 = c, o.base32hex = f;
      }, 5373: (t, o, u) => {
        var c = u(8636), h = u(2642), f = u(4765);
        t.exports = { formats: f, parse: h, stringify: c };
      }, 5382: (t, o, u) => {
        var c = Object.keys || function(b) {
          var S = [];
          for (var E in b) S.push(E);
          return S;
        };
        t.exports = a;
        var h = u(5412), f = u(6708);
        u(6698)(a, h);
        for (var r = c(f.prototype), m = 0; m < r.length; m++) {
          var g = r[m];
          a.prototype[g] || (a.prototype[g] = f.prototype[g]);
        }
        function a(b) {
          if (!(this instanceof a)) return new a(b);
          h.call(this, b), f.call(this, b), this.allowHalfOpen = true, b && (b.readable === false && (this.readable = false), b.writable === false && (this.writable = false), b.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", l)));
        }
        function l() {
          this._writableState.ended || process.nextTick(d, this);
        }
        function d(b) {
          b.end();
        }
        Object.defineProperty(a.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(a.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(a.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(a.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(b) {
          this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = b, this._writableState.destroyed = b);
        } });
      }, 5412: (t, o, u) => {
        var c;
        t.exports = T, T.ReadableState = _, u(7007).EventEmitter;
        var h = function(ue, ne) {
          return ue.listeners(ne).length;
        }, f = u(345), r = u(8287).Buffer, m = (u.g !== void 0 ? u.g : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
        }, g, a = u(9838);
        g = a && a.debuglog ? a.debuglog("stream") : function() {
        };
        var l, d, b, S = u(2726), E = u(5896), R = u(5291).getHighWaterMark, k = u(6048).F, w = k.ERR_INVALID_ARG_TYPE, F = k.ERR_STREAM_PUSH_AFTER_EOF, I = k.ERR_METHOD_NOT_IMPLEMENTED, q = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        u(6698)(T, f);
        var D = E.errorOrDestroy, H = ["error", "close", "destroy", "pause", "resume"];
        function _(ue, ne, ge) {
          c = c || u(5382), ue = ue || {}, typeof ge != "boolean" && (ge = ne instanceof c), this.objectMode = !!ue.objectMode, ge && (this.objectMode = this.objectMode || !!ue.readableObjectMode), this.highWaterMark = R(this, ue, "readableHighWaterMark", ge), this.buffer = new S(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = ue.emitClose !== false, this.autoDestroy = !!ue.autoDestroy, this.destroyed = false, this.defaultEncoding = ue.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, ue.encoding && (l || (l = u(3141).I), this.decoder = new l(ue.encoding), this.encoding = ue.encoding);
        }
        function T(ue) {
          if (c = c || u(5382), !(this instanceof T)) return new T(ue);
          var ne = this instanceof c;
          this._readableState = new _(ue, this, ne), this.readable = true, ue && (typeof ue.read == "function" && (this._read = ue.read), typeof ue.destroy == "function" && (this._destroy = ue.destroy)), f.call(this);
        }
        function L(ue, ne, ge, Te, pe) {
          g("readableAddChunk", ne);
          var Oe, xe = ue._readableState;
          if (ne === null) xe.reading = false, function(Ve, _e) {
            if (g("onEofChunk"), !_e.ended) {
              if (_e.decoder) {
                var Be = _e.decoder.end();
                Be && Be.length && (_e.buffer.push(Be), _e.length += _e.objectMode ? 1 : Be.length);
              }
              _e.ended = true, _e.sync ? te(Ve) : (_e.needReadable = false, _e.emittedReadable || (_e.emittedReadable = true, G(Ve)));
            }
          }(ue, xe);
          else if (pe || (Oe = function(Ve, _e) {
            var Be;
            Qe = _e, r.isBuffer(Qe) || Qe instanceof m || typeof _e == "string" || _e === void 0 || Ve.objectMode || (Be = new w("chunk", ["string", "Buffer", "Uint8Array"], _e));
            var Qe;
            return Be;
          }(xe, ne)), Oe) D(ue, Oe);
          else if (xe.objectMode || ne && ne.length > 0) if (typeof ne == "string" || xe.objectMode || Object.getPrototypeOf(ne) === r.prototype || (ne = function(Ve) {
            return r.from(Ve);
          }(ne)), Te) xe.endEmitted ? D(ue, new q()) : j(ue, xe, ne, true);
          else if (xe.ended) D(ue, new F());
          else {
            if (xe.destroyed) return false;
            xe.reading = false, xe.decoder && !ge ? (ne = xe.decoder.write(ne), xe.objectMode || ne.length !== 0 ? j(ue, xe, ne, false) : K(ue, xe)) : j(ue, xe, ne, false);
          }
          else Te || (xe.reading = false, K(ue, xe));
          return !xe.ended && (xe.length < xe.highWaterMark || xe.length === 0);
        }
        function j(ue, ne, ge, Te) {
          ne.flowing && ne.length === 0 && !ne.sync ? (ne.awaitDrain = 0, ue.emit("data", ge)) : (ne.length += ne.objectMode ? 1 : ge.length, Te ? ne.buffer.unshift(ge) : ne.buffer.push(ge), ne.needReadable && te(ue)), K(ue, ne);
        }
        Object.defineProperty(T.prototype, "destroyed", { enumerable: false, get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(ue) {
          this._readableState && (this._readableState.destroyed = ue);
        } }), T.prototype.destroy = E.destroy, T.prototype._undestroy = E.undestroy, T.prototype._destroy = function(ue, ne) {
          ne(ue);
        }, T.prototype.push = function(ue, ne) {
          var ge, Te = this._readableState;
          return Te.objectMode ? ge = true : typeof ue == "string" && ((ne = ne || Te.defaultEncoding) !== Te.encoding && (ue = r.from(ue, ne), ne = ""), ge = true), L(this, ue, ne, false, ge);
        }, T.prototype.unshift = function(ue) {
          return L(this, ue, null, true, false);
        }, T.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        }, T.prototype.setEncoding = function(ue) {
          l || (l = u(3141).I);
          var ne = new l(ue);
          this._readableState.decoder = ne, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var ge = this._readableState.buffer.head, Te = ""; ge !== null; ) Te += ne.write(ge.data), ge = ge.next;
          return this._readableState.buffer.clear(), Te !== "" && this._readableState.buffer.push(Te), this._readableState.length = Te.length, this;
        };
        var z = 1073741824;
        function Y(ue, ne) {
          return ue <= 0 || ne.length === 0 && ne.ended ? 0 : ne.objectMode ? 1 : ue != ue ? ne.flowing && ne.length ? ne.buffer.head.data.length : ne.length : (ue > ne.highWaterMark && (ne.highWaterMark = function(ge) {
            return ge >= z ? ge = z : (ge--, ge |= ge >>> 1, ge |= ge >>> 2, ge |= ge >>> 4, ge |= ge >>> 8, ge |= ge >>> 16, ge++), ge;
          }(ue)), ue <= ne.length ? ue : ne.ended ? ne.length : (ne.needReadable = true, 0));
        }
        function te(ue) {
          var ne = ue._readableState;
          g("emitReadable", ne.needReadable, ne.emittedReadable), ne.needReadable = false, ne.emittedReadable || (g("emitReadable", ne.flowing), ne.emittedReadable = true, process.nextTick(G, ue));
        }
        function G(ue) {
          var ne = ue._readableState;
          g("emitReadable_", ne.destroyed, ne.length, ne.ended), ne.destroyed || !ne.length && !ne.ended || (ue.emit("readable"), ne.emittedReadable = false), ne.needReadable = !ne.flowing && !ne.ended && ne.length <= ne.highWaterMark, $(ue);
        }
        function K(ue, ne) {
          ne.readingMore || (ne.readingMore = true, process.nextTick(J, ue, ne));
        }
        function J(ue, ne) {
          for (; !ne.reading && !ne.ended && (ne.length < ne.highWaterMark || ne.flowing && ne.length === 0); ) {
            var ge = ne.length;
            if (g("maybeReadMore read 0"), ue.read(0), ge === ne.length) break;
          }
          ne.readingMore = false;
        }
        function B(ue) {
          var ne = ue._readableState;
          ne.readableListening = ue.listenerCount("readable") > 0, ne.resumeScheduled && !ne.paused ? ne.flowing = true : ue.listenerCount("data") > 0 && ue.resume();
        }
        function Z(ue) {
          g("readable nexttick read 0"), ue.read(0);
        }
        function ie(ue, ne) {
          g("resume", ne.reading), ne.reading || ue.read(0), ne.resumeScheduled = false, ue.emit("resume"), $(ue), ne.flowing && !ne.reading && ue.read(0);
        }
        function $(ue) {
          var ne = ue._readableState;
          for (g("flow", ne.flowing); ne.flowing && ue.read() !== null; ) ;
        }
        function oe(ue, ne) {
          return ne.length === 0 ? null : (ne.objectMode ? ge = ne.buffer.shift() : !ue || ue >= ne.length ? (ge = ne.decoder ? ne.buffer.join("") : ne.buffer.length === 1 ? ne.buffer.first() : ne.buffer.concat(ne.length), ne.buffer.clear()) : ge = ne.buffer.consume(ue, ne.decoder), ge);
          var ge;
        }
        function ce(ue) {
          var ne = ue._readableState;
          g("endReadable", ne.endEmitted), ne.endEmitted || (ne.ended = true, process.nextTick(ye, ne, ue));
        }
        function ye(ue, ne) {
          if (g("endReadableNT", ue.endEmitted, ue.length), !ue.endEmitted && ue.length === 0 && (ue.endEmitted = true, ne.readable = false, ne.emit("end"), ue.autoDestroy)) {
            var ge = ne._writableState;
            (!ge || ge.autoDestroy && ge.finished) && ne.destroy();
          }
        }
        function ae(ue, ne) {
          for (var ge = 0, Te = ue.length; ge < Te; ge++) if (ue[ge] === ne) return ge;
          return -1;
        }
        T.prototype.read = function(ue) {
          g("read", ue), ue = parseInt(ue, 10);
          var ne = this._readableState, ge = ue;
          if (ue !== 0 && (ne.emittedReadable = false), ue === 0 && ne.needReadable && ((ne.highWaterMark !== 0 ? ne.length >= ne.highWaterMark : ne.length > 0) || ne.ended)) return g("read: emitReadable", ne.length, ne.ended), ne.length === 0 && ne.ended ? ce(this) : te(this), null;
          if ((ue = Y(ue, ne)) === 0 && ne.ended) return ne.length === 0 && ce(this), null;
          var Te, pe = ne.needReadable;
          return g("need readable", pe), (ne.length === 0 || ne.length - ue < ne.highWaterMark) && g("length less than watermark", pe = true), ne.ended || ne.reading ? g("reading or ended", pe = false) : pe && (g("do read"), ne.reading = true, ne.sync = true, ne.length === 0 && (ne.needReadable = true), this._read(ne.highWaterMark), ne.sync = false, ne.reading || (ue = Y(ge, ne))), (Te = ue > 0 ? oe(ue, ne) : null) === null ? (ne.needReadable = ne.length <= ne.highWaterMark, ue = 0) : (ne.length -= ue, ne.awaitDrain = 0), ne.length === 0 && (ne.ended || (ne.needReadable = true), ge !== ue && ne.ended && ce(this)), Te !== null && this.emit("data", Te), Te;
        }, T.prototype._read = function(ue) {
          D(this, new I("_read()"));
        }, T.prototype.pipe = function(ue, ne) {
          var ge = this, Te = this._readableState;
          switch (Te.pipesCount) {
            case 0:
              Te.pipes = ue;
              break;
            case 1:
              Te.pipes = [Te.pipes, ue];
              break;
            default:
              Te.pipes.push(ue);
          }
          Te.pipesCount += 1, g("pipe count=%d opts=%j", Te.pipesCount, ne);
          var pe = (!ne || ne.end !== false) && ue !== process.stdout && ue !== process.stderr ? xe : x;
          function Oe(O, V) {
            g("onunpipe"), O === ge && V && V.hasUnpiped === false && (V.hasUnpiped = true, g("cleanup"), ue.removeListener("close", ee), ue.removeListener("finish", P), ue.removeListener("drain", Ve), ue.removeListener("error", Qe), ue.removeListener("unpipe", Oe), ge.removeListener("end", xe), ge.removeListener("end", x), ge.removeListener("data", Be), _e = true, !Te.awaitDrain || ue._writableState && !ue._writableState.needDrain || Ve());
          }
          function xe() {
            g("onend"), ue.end();
          }
          Te.endEmitted ? process.nextTick(pe) : ge.once("end", pe), ue.on("unpipe", Oe);
          var Ve = /* @__PURE__ */ function(O) {
            return function() {
              var V = O._readableState;
              g("pipeOnDrain", V.awaitDrain), V.awaitDrain && V.awaitDrain--, V.awaitDrain === 0 && h(O, "data") && (V.flowing = true, $(O));
            };
          }(ge);
          ue.on("drain", Ve);
          var _e = false;
          function Be(O) {
            g("ondata");
            var V = ue.write(O);
            g("dest.write", V), V === false && ((Te.pipesCount === 1 && Te.pipes === ue || Te.pipesCount > 1 && ae(Te.pipes, ue) !== -1) && !_e && (g("false write response, pause", Te.awaitDrain), Te.awaitDrain++), ge.pause());
          }
          function Qe(O) {
            g("onerror", O), x(), ue.removeListener("error", Qe), h(ue, "error") === 0 && D(ue, O);
          }
          function ee() {
            ue.removeListener("finish", P), x();
          }
          function P() {
            g("onfinish"), ue.removeListener("close", ee), x();
          }
          function x() {
            g("unpipe"), ge.unpipe(ue);
          }
          return ge.on("data", Be), function(O, V, N) {
            if (typeof O.prependListener == "function") return O.prependListener(V, N);
            O._events && O._events[V] ? Array.isArray(O._events[V]) ? O._events[V].unshift(N) : O._events[V] = [N, O._events[V]] : O.on(V, N);
          }(ue, "error", Qe), ue.once("close", ee), ue.once("finish", P), ue.emit("pipe", ge), Te.flowing || (g("pipe resume"), ge.resume()), ue;
        }, T.prototype.unpipe = function(ue) {
          var ne = this._readableState, ge = { hasUnpiped: false };
          if (ne.pipesCount === 0) return this;
          if (ne.pipesCount === 1) return ue && ue !== ne.pipes || (ue || (ue = ne.pipes), ne.pipes = null, ne.pipesCount = 0, ne.flowing = false, ue && ue.emit("unpipe", this, ge)), this;
          if (!ue) {
            var Te = ne.pipes, pe = ne.pipesCount;
            ne.pipes = null, ne.pipesCount = 0, ne.flowing = false;
            for (var Oe = 0; Oe < pe; Oe++) Te[Oe].emit("unpipe", this, { hasUnpiped: false });
            return this;
          }
          var xe = ae(ne.pipes, ue);
          return xe === -1 || (ne.pipes.splice(xe, 1), ne.pipesCount -= 1, ne.pipesCount === 1 && (ne.pipes = ne.pipes[0]), ue.emit("unpipe", this, ge)), this;
        }, T.prototype.on = function(ue, ne) {
          var ge = f.prototype.on.call(this, ue, ne), Te = this._readableState;
          return ue === "data" ? (Te.readableListening = this.listenerCount("readable") > 0, Te.flowing !== false && this.resume()) : ue === "readable" && (Te.endEmitted || Te.readableListening || (Te.readableListening = Te.needReadable = true, Te.flowing = false, Te.emittedReadable = false, g("on readable", Te.length, Te.reading), Te.length ? te(this) : Te.reading || process.nextTick(Z, this))), ge;
        }, T.prototype.addListener = T.prototype.on, T.prototype.removeListener = function(ue, ne) {
          var ge = f.prototype.removeListener.call(this, ue, ne);
          return ue === "readable" && process.nextTick(B, this), ge;
        }, T.prototype.removeAllListeners = function(ue) {
          var ne = f.prototype.removeAllListeners.apply(this, arguments);
          return ue !== "readable" && ue !== void 0 || process.nextTick(B, this), ne;
        }, T.prototype.resume = function() {
          var ue = this._readableState;
          return ue.flowing || (g("resume"), ue.flowing = !ue.readableListening, function(ne, ge) {
            ge.resumeScheduled || (ge.resumeScheduled = true, process.nextTick(ie, ne, ge));
          }(this, ue)), ue.paused = false, this;
        }, T.prototype.pause = function() {
          return g("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (g("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
        }, T.prototype.wrap = function(ue) {
          var ne = this, ge = this._readableState, Te = false;
          for (var pe in ue.on("end", function() {
            if (g("wrapped end"), ge.decoder && !ge.ended) {
              var xe = ge.decoder.end();
              xe && xe.length && ne.push(xe);
            }
            ne.push(null);
          }), ue.on("data", function(xe) {
            g("wrapped data"), ge.decoder && (xe = ge.decoder.write(xe)), ge.objectMode && xe == null || (ge.objectMode || xe && xe.length) && (ne.push(xe) || (Te = true, ue.pause()));
          }), ue) this[pe] === void 0 && typeof ue[pe] == "function" && (this[pe] = /* @__PURE__ */ function(xe) {
            return function() {
              return ue[xe].apply(ue, arguments);
            };
          }(pe));
          for (var Oe = 0; Oe < H.length; Oe++) ue.on(H[Oe], this.emit.bind(this, H[Oe]));
          return this._read = function(xe) {
            g("wrapped _read", xe), Te && (Te = false, ue.resume());
          }, this;
        }, typeof Symbol == "function" && (T.prototype[Symbol.asyncIterator] = function() {
          return d === void 0 && (d = u(2955)), d(this);
        }), Object.defineProperty(T.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(T.prototype, "readableBuffer", { enumerable: false, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(T.prototype, "readableFlowing", { enumerable: false, get: function() {
          return this._readableState.flowing;
        }, set: function(ue) {
          this._readableState && (this._readableState.flowing = ue);
        } }), T._fromList = oe, Object.defineProperty(T.prototype, "readableLength", { enumerable: false, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (T.from = function(ue, ne) {
          return b === void 0 && (b = u(5157)), b(T, ue, ne);
        });
      }, 5479: (t, o, u) => {
        u.r(o), u.d(o, { InvalidChallengeError: () => R, buildChallengeTx: () => T, gatherTxSigners: () => te, readChallengeTx: () => L, verifyChallengeTxSigners: () => z, verifyChallengeTxThreshold: () => j, verifyTxSignedBy: () => Y });
        var c = u(3209), h = u.n(c), f = u(356), r = u(3121);
        function m(G) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K;
          } : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K;
          }, m(G);
        }
        function g(G, K) {
          for (var J = 0; J < K.length; J++) {
            var B = K[J];
            B.enumerable = B.enumerable || false, B.configurable = true, "value" in B && (B.writable = true), Object.defineProperty(G, a(B.key), B);
          }
        }
        function a(G) {
          var K = function(J, B) {
            if (m(J) != "object" || !J) return J;
            var Z = J[Symbol.toPrimitive];
            if (Z !== void 0) {
              var ie = Z.call(J, B);
              if (m(ie) != "object") return ie;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(J);
          }(G, "string");
          return m(K) == "symbol" ? K : K + "";
        }
        function l(G, K, J) {
          return K = E(K), function(B, Z) {
            if (Z && (m(Z) == "object" || typeof Z == "function")) return Z;
            if (Z !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(ie) {
              if (ie === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return ie;
            }(B);
          }(G, b() ? Reflect.construct(K, J || [], E(G).constructor) : K.apply(G, J));
        }
        function d(G) {
          var K = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return d = function(J) {
            if (J === null || !function(Z) {
              try {
                return Function.toString.call(Z).indexOf("[native code]") !== -1;
              } catch {
                return typeof Z == "function";
              }
            }(J)) return J;
            if (typeof J != "function") throw new TypeError("Super expression must either be null or a function");
            if (K !== void 0) {
              if (K.has(J)) return K.get(J);
              K.set(J, B);
            }
            function B() {
              return function(Z, ie, $) {
                if (b()) return Reflect.construct.apply(null, arguments);
                var oe = [null];
                oe.push.apply(oe, ie);
                var ce = new (Z.bind.apply(Z, oe))();
                return $ && S(ce, $.prototype), ce;
              }(J, arguments, E(this).constructor);
            }
            return B.prototype = Object.create(J.prototype, { constructor: { value: B, enumerable: false, writable: true, configurable: true } }), S(B, J);
          }, d(G);
        }
        function b() {
          try {
            var G = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (b = function() {
            return !!G;
          })();
        }
        function S(G, K) {
          return S = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(J, B) {
            return J.__proto__ = B, J;
          }, S(G, K);
        }
        function E(G) {
          return E = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(K) {
            return K.__proto__ || Object.getPrototypeOf(K);
          }, E(G);
        }
        var R = function(G) {
          function K(ie) {
            var $;
            (function(ce, ye) {
              if (!(ce instanceof ye)) throw new TypeError("Cannot call a class as a function");
            })(this, K);
            var oe = (this instanceof K ? this.constructor : void 0).prototype;
            return ($ = l(this, K, [ie])).__proto__ = oe, $.constructor = K, $.name = "InvalidChallengeError", $;
          }
          return function(ie, $) {
            if (typeof $ != "function" && $ !== null) throw new TypeError("Super expression must either be null or a function");
            ie.prototype = Object.create($ && $.prototype, { constructor: { value: ie, writable: true, configurable: true } }), Object.defineProperty(ie, "prototype", { writable: false }), $ && S(ie, $);
          }(K, G), J = K, B && g(J.prototype, B), Z && g(J, Z), Object.defineProperty(J, "prototype", { writable: false }), J;
          var J, B, Z;
        }(d(Error)), k = u(8287).Buffer;
        function w(G) {
          return function(K) {
            if (Array.isArray(K)) return H(K);
          }(G) || _(G) || D(G) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function F(G, K) {
          var J = typeof Symbol < "u" && G[Symbol.iterator] || G["@@iterator"];
          if (!J) {
            if (Array.isArray(G) || (J = D(G)) || K) {
              J && (G = J);
              var B = 0, Z = function() {
              };
              return { s: Z, n: function() {
                return B >= G.length ? { done: true } : { done: false, value: G[B++] };
              }, e: function(ce) {
                throw ce;
              }, f: Z };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var ie, $ = true, oe = false;
          return { s: function() {
            J = J.call(G);
          }, n: function() {
            var ce = J.next();
            return $ = ce.done, ce;
          }, e: function(ce) {
            oe = true, ie = ce;
          }, f: function() {
            try {
              $ || J.return == null || J.return();
            } finally {
              if (oe) throw ie;
            }
          } };
        }
        function I(G) {
          return I = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(K) {
            return typeof K;
          } : function(K) {
            return K && typeof Symbol == "function" && K.constructor === Symbol && K !== Symbol.prototype ? "symbol" : typeof K;
          }, I(G);
        }
        function q(G) {
          return function(K) {
            if (Array.isArray(K)) return K;
          }(G) || _(G) || D(G) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function D(G, K) {
          if (G) {
            if (typeof G == "string") return H(G, K);
            var J = {}.toString.call(G).slice(8, -1);
            return J === "Object" && G.constructor && (J = G.constructor.name), J === "Map" || J === "Set" ? Array.from(G) : J === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(J) ? H(G, K) : void 0;
          }
        }
        function H(G, K) {
          (K == null || K > G.length) && (K = G.length);
          for (var J = 0, B = Array(K); J < K; J++) B[J] = G[J];
          return B;
        }
        function _(G) {
          if (typeof Symbol < "u" && G[Symbol.iterator] != null || G["@@iterator"] != null) return Array.from(G);
        }
        function T(G, K, J) {
          var B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 300, Z = arguments.length > 4 ? arguments[4] : void 0, ie = arguments.length > 5 ? arguments[5] : void 0, $ = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null, oe = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null, ce = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null;
          if (K.startsWith("M") && $) throw Error("memo cannot be used if clientAccountID is a muxed account");
          var ye = new f.Account(G.publicKey(), "-1"), ae = Math.floor(Date.now() / 1e3), ue = h()(48).toString("base64"), ne = new f.TransactionBuilder(ye, { fee: f.BASE_FEE, networkPassphrase: Z, timebounds: { minTime: ae, maxTime: ae + B } }).addOperation(f.Operation.manageData({ name: "".concat(J, " auth"), value: ue, source: K })).addOperation(f.Operation.manageData({ name: "web_auth_domain", value: ie, source: ye.accountId() }));
          if (oe) {
            if (!ce) throw Error("clientSigningKey is required if clientDomain is provided");
            ne.addOperation(f.Operation.manageData({ name: "client_domain", value: oe, source: ce }));
          }
          $ && ne.addMemo(f.Memo.id($));
          var ge = ne.build();
          return ge.sign(G), ge.toEnvelope().toXDR("base64").toString();
        }
        function L(G, K, J, B, Z) {
          var ie, $;
          if (K.startsWith("M")) throw Error("Invalid serverAccountID: multiplexed accounts are not supported.");
          try {
            $ = new f.Transaction(G, J);
          } catch {
            try {
              $ = new f.FeeBumpTransaction(G, J);
            } catch {
              throw new R("Invalid challenge: unable to deserialize challengeTx transaction string");
            }
            throw new R("Invalid challenge: expected a Transaction but received a FeeBumpTransaction");
          }
          if (Number.parseInt($.sequence, 10) !== 0) throw new R("The transaction sequence number should be zero");
          if ($.source !== K) throw new R("The transaction source account is not equal to the server's account");
          if ($.operations.length < 1) throw new R("The transaction should contain at least one operation");
          var oe = q($.operations), ce = oe[0], ye = oe.slice(1);
          if (!ce.source) throw new R("The transaction's operation should contain a source account");
          var ae, ue = ce.source, ne = null;
          if ($.memo.type !== f.MemoNone) {
            if (ue.startsWith("M")) throw new R("The transaction has a memo but the client account ID is a muxed account");
            if ($.memo.type !== f.MemoID) throw new R("The transaction's memo must be of type `id`");
            ne = $.memo.value;
          }
          if (ce.type !== "manageData") throw new R("The transaction's operation type should be 'manageData'");
          if ($.timeBounds && Number.parseInt((ie = $.timeBounds) === null || ie === void 0 ? void 0 : ie.maxTime, 10) === f.TimeoutInfinite) throw new R("The transaction requires non-infinite timebounds");
          if (!r.A.validateTimebounds($, 300)) throw new R("The transaction has expired");
          if (ce.value === void 0) throw new R("The transaction's operation values should not be null");
          if (!ce.value) throw new R("The transaction's operation value should not be null");
          if (k.from(ce.value.toString(), "base64").length !== 48) throw new R("The transaction's operation value should be a 64 bytes base64 random string");
          if (!B) throw new R("Invalid homeDomains: a home domain must be provided for verification");
          if (typeof B == "string") "".concat(B, " auth") === ce.name && (ae = B);
          else {
            if (!Array.isArray(B)) throw new R("Invalid homeDomains: homeDomains type is ".concat(I(B), " but should be a string or an array"));
            ae = B.find(function(Oe) {
              return "".concat(Oe, " auth") === ce.name;
            });
          }
          if (!ae) throw new R("Invalid homeDomains: the transaction's operation key name does not match the expected home domain");
          var ge, Te = F(ye);
          try {
            for (Te.s(); !(ge = Te.n()).done; ) {
              var pe = ge.value;
              if (pe.type !== "manageData") throw new R("The transaction has operations that are not of type 'manageData'");
              if (pe.source !== K && pe.name !== "client_domain") throw new R("The transaction has operations that are unrecognized");
              if (pe.name === "web_auth_domain") {
                if (pe.value === void 0) throw new R("'web_auth_domain' operation value should not be null");
                if (pe.value.compare(k.from(Z))) throw new R("'web_auth_domain' operation value does not match ".concat(Z));
              }
            }
          } catch (Oe) {
            Te.e(Oe);
          } finally {
            Te.f();
          }
          if (!Y($, K)) throw new R("Transaction not signed by server: '".concat(K, "'"));
          return { tx: $, clientAccountID: ue, matchedHomeDomain: ae, memo: ne };
        }
        function j(G, K, J, B, Z, ie, $) {
          for (var oe = z(G, K, J, Z.map(function(ne) {
            return ne.key;
          }), ie, $), ce = 0, ye = function() {
            var ne, ge = ue[ae], Te = ((ne = Z.find(function(pe) {
              return pe.key === ge;
            })) === null || ne === void 0 ? void 0 : ne.weight) || 0;
            ce += Te;
          }, ae = 0, ue = oe; ae < ue.length; ae++) ye();
          if (ce < B) throw new R("signers with weight ".concat(ce, " do not meet threshold ").concat(B, '"'));
          return oe;
        }
        function z(G, K, J, B, Z, ie) {
          var $, oe = L(G, K, J, Z, ie).tx;
          try {
            $ = f.Keypair.fromPublicKey(K);
          } catch (P) {
            throw new Error("Couldn't infer keypair from the provided 'serverAccountID': ".concat(P.message));
          }
          var ce, ye, ae = /* @__PURE__ */ new Set(), ue = F(B);
          try {
            for (ue.s(); !(ce = ue.n()).done; ) {
              var ne = ce.value;
              ne !== $.publicKey() && ne.charAt(0) === "G" && ae.add(ne);
            }
          } catch (P) {
            ue.e(P);
          } finally {
            ue.f();
          }
          if (ae.size === 0) throw new R("No verifiable client signers provided, at least one G... address must be provided");
          var ge, Te = F(oe.operations);
          try {
            for (Te.s(); !(ge = Te.n()).done; ) {
              var pe = ge.value;
              if (pe.type === "manageData" && pe.name === "client_domain") {
                if (ye) throw new R("Found more than one client_domain operation");
                ye = pe.source;
              }
            }
          } catch (P) {
            Te.e(P);
          } finally {
            Te.f();
          }
          var Oe = [$.publicKey()].concat(w(Array.from(ae)));
          ye && Oe.push(ye);
          for (var xe = te(oe, Oe), Ve = false, _e = false, Be = 0, Qe = xe; Be < Qe.length; Be++) {
            var ee = Qe[Be];
            ee === $.publicKey() && (Ve = true), ee === ye && (_e = true);
          }
          if (!Ve) throw new R("Transaction not signed by server: '".concat($.publicKey(), "'"));
          if (ye && !_e) throw new R("Transaction not signed by the source account of the 'client_domain' ManageData operation");
          if (xe.length === 1) throw new R("None of the given signers match the transaction signatures");
          if (xe.length !== oe.signatures.length) throw new R("Transaction has unrecognized signatures");
          return xe.splice(xe.indexOf($.publicKey()), 1), ye && xe.splice(xe.indexOf(ye), 1), xe;
        }
        function Y(G, K) {
          return te(G, [K]).length !== 0;
        }
        function te(G, K) {
          var J, B = G.hash(), Z = w(G.signatures), ie = /* @__PURE__ */ new Set(), $ = F(K);
          try {
            for ($.s(); !(J = $.n()).done; ) {
              var oe = J.value;
              if (Z.length === 0) break;
              var ce = void 0;
              try {
                ce = f.Keypair.fromPublicKey(oe);
              } catch (ue) {
                throw new R("Signer is not a valid address: ".concat(ue.message));
              }
              for (var ye = 0; ye < Z.length; ye++) {
                var ae = Z[ye];
                if (ae.hint().equals(ce.signatureHint()) && ce.verify(B, ae.signature())) {
                  ie.add(oe), Z.splice(ye, 1);
                  break;
                }
              }
            }
          } catch (ue) {
            $.e(ue);
          } finally {
            $.f();
          }
          return Array.from(ie);
        }
      }, 5487: (t, o, u) => {
        function c(d) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, c(d);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Int128 = void 0;
        var h = u(3740);
        function f(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, r(E.key), E);
          }
        }
        function r(d) {
          var b = function(S, E) {
            if (c(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (c(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return c(b) == "symbol" ? b : b + "";
        }
        function m(d, b, S) {
          return b = a(b), function(E, R) {
            if (R && (c(R) == "object" || typeof R == "function")) return R;
            if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(k) {
              if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return k;
            }(E);
          }(d, g() ? Reflect.construct(b, S || [], a(d).constructor) : b.apply(d, S));
        }
        function g() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!d;
          })();
        }
        function a(d) {
          return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, a(d);
        }
        function l(d, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, E) {
            return S.__proto__ = E, S;
          }, l(d, b);
        }
        (o.Int128 = function(d) {
          function b() {
            (function(I, q) {
              if (!(I instanceof q)) throw new TypeError("Cannot call a class as a function");
            })(this, b);
            for (var k = arguments.length, w = new Array(k), F = 0; F < k; F++) w[F] = arguments[F];
            return m(this, b, [w]);
          }
          return function(k, w) {
            if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
            k.prototype = Object.create(w && w.prototype, { constructor: { value: k, writable: true, configurable: true } }), Object.defineProperty(k, "prototype", { writable: false }), w && l(k, w);
          }(b, d), S = b, (E = [{ key: "unsigned", get: function() {
            return false;
          } }, { key: "size", get: function() {
            return 128;
          } }]) && f(S.prototype, E), R && f(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }(h.LargeInt)).defineIntBoundaries();
      }, 5537: (t, o, u) => {
        var c = u(8287).Buffer, h = u(6688), f = u(6698), r = u(6917), m = u(8399), g = r.IncomingMessage, a = r.readyStates, l = t.exports = function(b) {
          var S, E = this;
          m.Writable.call(E), E._opts = b, E._body = [], E._headers = {}, b.auth && E.setHeader("Authorization", "Basic " + c.from(b.auth).toString("base64")), Object.keys(b.headers).forEach(function(k) {
            E.setHeader(k, b.headers[k]);
          });
          var R = true;
          if (b.mode === "disable-fetch" || "requestTimeout" in b && !h.abortController) R = false, S = true;
          else if (b.mode === "prefer-streaming") S = false;
          else if (b.mode === "allow-wrong-content-type") S = !h.overrideMimeType;
          else {
            if (b.mode && b.mode !== "default" && b.mode !== "prefer-fast") throw new Error("Invalid value for opts.mode");
            S = true;
          }
          E._mode = function(k, w) {
            return h.fetch && w ? "fetch" : h.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : h.msstream ? "ms-stream" : h.arraybuffer && k ? "arraybuffer" : "text";
          }(S, R), E._fetchTimer = null, E._socketTimeout = null, E._socketTimer = null, E.on("finish", function() {
            E._onFinish();
          });
        };
        f(l, m.Writable), l.prototype.setHeader = function(b, S) {
          var E = b.toLowerCase();
          d.indexOf(E) === -1 && (this._headers[E] = { name: b, value: S });
        }, l.prototype.getHeader = function(b) {
          var S = this._headers[b.toLowerCase()];
          return S ? S.value : null;
        }, l.prototype.removeHeader = function(b) {
          delete this._headers[b.toLowerCase()];
        }, l.prototype._onFinish = function() {
          var b = this;
          if (!b._destroyed) {
            var S = b._opts;
            "timeout" in S && S.timeout !== 0 && b.setTimeout(S.timeout);
            var E = b._headers, R = null;
            S.method !== "GET" && S.method !== "HEAD" && (R = new Blob(b._body, { type: (E["content-type"] || {}).value || "" }));
            var k = [];
            if (Object.keys(E).forEach(function(q) {
              var D = E[q].name, H = E[q].value;
              Array.isArray(H) ? H.forEach(function(_) {
                k.push([D, _]);
              }) : k.push([D, H]);
            }), b._mode === "fetch") {
              var w = null;
              if (h.abortController) {
                var F = new AbortController();
                w = F.signal, b._fetchAbortController = F, "requestTimeout" in S && S.requestTimeout !== 0 && (b._fetchTimer = u.g.setTimeout(function() {
                  b.emit("requestTimeout"), b._fetchAbortController && b._fetchAbortController.abort();
                }, S.requestTimeout));
              }
              u.g.fetch(b._opts.url, { method: b._opts.method, headers: k, body: R || void 0, mode: "cors", credentials: S.withCredentials ? "include" : "same-origin", signal: w }).then(function(q) {
                b._fetchResponse = q, b._resetTimers(false), b._connect();
              }, function(q) {
                b._resetTimers(true), b._destroyed || b.emit("error", q);
              });
            } else {
              var I = b._xhr = new u.g.XMLHttpRequest();
              try {
                I.open(b._opts.method, b._opts.url, true);
              } catch (q) {
                return void process.nextTick(function() {
                  b.emit("error", q);
                });
              }
              "responseType" in I && (I.responseType = b._mode), "withCredentials" in I && (I.withCredentials = !!S.withCredentials), b._mode === "text" && "overrideMimeType" in I && I.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in S && (I.timeout = S.requestTimeout, I.ontimeout = function() {
                b.emit("requestTimeout");
              }), k.forEach(function(q) {
                I.setRequestHeader(q[0], q[1]);
              }), b._response = null, I.onreadystatechange = function() {
                switch (I.readyState) {
                  case a.LOADING:
                  case a.DONE:
                    b._onXHRProgress();
                }
              }, b._mode === "moz-chunked-arraybuffer" && (I.onprogress = function() {
                b._onXHRProgress();
              }), I.onerror = function() {
                b._destroyed || (b._resetTimers(true), b.emit("error", new Error("XHR error")));
              };
              try {
                I.send(R);
              } catch (q) {
                return void process.nextTick(function() {
                  b.emit("error", q);
                });
              }
            }
          }
        }, l.prototype._onXHRProgress = function() {
          var b = this;
          b._resetTimers(false), function(S) {
            try {
              var E = S.status;
              return E !== null && E !== 0;
            } catch {
              return false;
            }
          }(b._xhr) && !b._destroyed && (b._response || b._connect(), b._response._onXHRProgress(b._resetTimers.bind(b)));
        }, l.prototype._connect = function() {
          var b = this;
          b._destroyed || (b._response = new g(b._xhr, b._fetchResponse, b._mode, b._resetTimers.bind(b)), b._response.on("error", function(S) {
            b.emit("error", S);
          }), b.emit("response", b._response));
        }, l.prototype._write = function(b, S, E) {
          this._body.push(b), E();
        }, l.prototype._resetTimers = function(b) {
          var S = this;
          u.g.clearTimeout(S._socketTimer), S._socketTimer = null, b ? (u.g.clearTimeout(S._fetchTimer), S._fetchTimer = null) : S._socketTimeout && (S._socketTimer = u.g.setTimeout(function() {
            S.emit("timeout");
          }, S._socketTimeout));
        }, l.prototype.abort = l.prototype.destroy = function(b) {
          var S = this;
          S._destroyed = true, S._resetTimers(true), S._response && (S._response._destroyed = true), S._xhr ? S._xhr.abort() : S._fetchAbortController && S._fetchAbortController.abort(), b && S.emit("error", b);
        }, l.prototype.end = function(b, S, E) {
          typeof b == "function" && (E = b, b = void 0), m.Writable.prototype.end.call(this, b, S, E);
        }, l.prototype.setTimeout = function(b, S) {
          var E = this;
          S && E.once("timeout", S), E._socketTimeout = b, E._resetTimers(false);
        }, l.prototype.flushHeaders = function() {
        }, l.prototype.setNoDelay = function() {
        }, l.prototype.setSocketKeepAlive = function() {
        };
        var d = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
      }, 5546: (t) => {
        t.exports = function() {
          function o(u, c, h, f, r, m) {
            this.message = u, this.expected = c, this.found = h, this.offset = f, this.line = r, this.column = m, this.name = "SyntaxError";
          }
          return function(u, c) {
            function h() {
              this.constructor = u;
            }
            h.prototype = c.prototype, u.prototype = new h();
          }(o, Error), { SyntaxError: o, parse: function(u) {
            var c, h = arguments.length > 1 ? arguments[1] : {}, f = {}, r = { start: en }, m = en, g = function() {
              return Ht;
            }, a = f, l = "#", d = { type: "literal", value: "#", description: '"#"' }, b = void 0, S = { type: "any", description: "any character" }, E = "[", R = { type: "literal", value: "[", description: '"["' }, k = "]", w = { type: "literal", value: "]", description: '"]"' }, F = function(Ee) {
              tr(Sr("ObjectPath", Ee, Yt, cr));
            }, I = function(Ee) {
              tr(Sr("ArrayPath", Ee, Yt, cr));
            }, q = function(Ee, ot) {
              return Ee.concat(ot);
            }, D = function(Ee) {
              return [Ee];
            }, H = function(Ee) {
              return Ee;
            }, _ = ".", T = { type: "literal", value: ".", description: '"."' }, L = "=", j = { type: "literal", value: "=", description: '"="' }, z = function(Ee, ot) {
              tr(Sr("Assign", ot, Yt, cr, Ee));
            }, Y = function(Ee) {
              return Ee.join("");
            }, te = function(Ee) {
              return Ee.value;
            }, G = '"""', K = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, J = null, B = function(Ee) {
              return Sr("String", Ee.join(""), Yt, cr);
            }, Z = '"', ie = { type: "literal", value: '"', description: '"\\""' }, $ = "'''", oe = { type: "literal", value: "'''", description: `"'''"` }, ce = "'", ye = { type: "literal", value: "'", description: `"'"` }, ae = function(Ee) {
              return Ee;
            }, ue = function(Ee) {
              return Ee;
            }, ne = "\\", ge = { type: "literal", value: "\\", description: '"\\\\"' }, Te = function() {
              return "";
            }, pe = "e", Oe = { type: "literal", value: "e", description: '"e"' }, xe = "E", Ve = { type: "literal", value: "E", description: '"E"' }, _e = function(Ee, ot) {
              return Sr("Float", parseFloat(Ee + "e" + ot), Yt, cr);
            }, Be = function(Ee) {
              return Sr("Float", parseFloat(Ee), Yt, cr);
            }, Qe = "+", ee = { type: "literal", value: "+", description: '"+"' }, P = function(Ee) {
              return Ee.join("");
            }, x = "-", O = { type: "literal", value: "-", description: '"-"' }, V = function(Ee) {
              return "-" + Ee.join("");
            }, N = function(Ee) {
              return Sr("Integer", parseInt(Ee, 10), Yt, cr);
            }, C = "true", p = { type: "literal", value: "true", description: '"true"' }, A = function() {
              return Sr("Boolean", true, Yt, cr);
            }, U = "false", Q = { type: "literal", value: "false", description: '"false"' }, se = function() {
              return Sr("Boolean", false, Yt, cr);
            }, X = function() {
              return Sr("Array", [], Yt, cr);
            }, de = function(Ee) {
              return Sr("Array", Ee ? [Ee] : [], Yt, cr);
            }, tt = function(Ee) {
              return Sr("Array", Ee, Yt, cr);
            }, Ne = function(Ee, ot) {
              return Sr("Array", Ee.concat(ot), Yt, cr);
            }, ut = function(Ee) {
              return Ee;
            }, Ze = ",", Et = { type: "literal", value: ",", description: '","' }, rr = "{", je = { type: "literal", value: "{", description: '"{"' }, Ge = "}", at = { type: "literal", value: "}", description: '"}"' }, Ae = function(Ee) {
              return Sr("InlineTable", Ee, Yt, cr);
            }, qe = function(Ee, ot) {
              return Sr("InlineTableValue", ot, Yt, cr, Ee);
            }, Ft = function(Ee) {
              return "." + Ee;
            }, Dt = function(Ee) {
              return Ee.join("");
            }, wr = ":", Nt = { type: "literal", value: ":", description: '":"' }, yr = function(Ee) {
              return Ee.join("");
            }, Ur = "T", Pe = { type: "literal", value: "T", description: '"T"' }, $e = "Z", le = { type: "literal", value: "Z", description: '"Z"' }, re = function(Ee, ot) {
              return Sr("Date", /* @__PURE__ */ new Date(Ee + "T" + ot + "Z"), Yt, cr);
            }, Le = function(Ee, ot) {
              return Sr("Date", /* @__PURE__ */ new Date(Ee + "T" + ot), Yt, cr);
            }, nt = /^[ \t]/, ft = { type: "class", value: "[ \\t]", description: "[ \\t]" }, zt = `
`, st = { type: "literal", value: `
`, description: '"\\n"' }, ct = "\r", yt = { type: "literal", value: "\r", description: '"\\r"' }, Zt = /^[0-9a-f]/i, Ct = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, Lt = /^[0-9]/, Wt = { type: "class", value: "[0-9]", description: "[0-9]" }, vr = "_", ar = { type: "literal", value: "_", description: '"_"' }, sr = function() {
              return "";
            }, gr = /^[A-Za-z0-9_\-]/, Tr = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, Mr = function(Ee) {
              return Ee.join("");
            }, Nr = '\\"', Lr = { type: "literal", value: '\\"', description: '"\\\\\\""' }, jr = function() {
              return '"';
            }, Hr = "\\\\", kr = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, Xt = function() {
              return "\\";
            }, Qt = "\\b", br = { type: "literal", value: "\\b", description: '"\\\\b"' }, we = function() {
              return "\b";
            }, me = "\\t", ze = { type: "literal", value: "\\t", description: '"\\\\t"' }, rt = function() {
              return "	";
            }, Tt = "\\n", Ot = { type: "literal", value: "\\n", description: '"\\\\n"' }, It = function() {
              return `
`;
            }, We = "\\f", mt = { type: "literal", value: "\\f", description: '"\\\\f"' }, Gt = function() {
              return "\f";
            }, ir = "\\r", dr = { type: "literal", value: "\\r", description: '"\\\\r"' }, hr = function() {
              return "\r";
            }, Fr = "\\U", Gr = { type: "literal", value: "\\U", description: '"\\\\U"' }, Br = function(Ee) {
              return function(ot, Mt, gt) {
                var Rt = parseInt("0x" + ot);
                if (!(!isFinite(Rt) || Math.floor(Rt) != Rt || Rt < 0 || Rt > 1114111 || Rt > 55295 && Rt < 57344)) return function() {
                  var or, nr, Qr = 16384, Xr = [], Yr = -1, un = arguments.length;
                  if (!un) return "";
                  for (var Kr = ""; ++Yr < un; ) {
                    var Ir = Number(arguments[Yr]);
                    Ir <= 65535 ? Xr.push(Ir) : (or = 55296 + ((Ir -= 65536) >> 10), nr = Ir % 1024 + 56320, Xr.push(or, nr)), (Yr + 1 == un || Xr.length > Qr) && (Kr += String.fromCharCode.apply(null, Xr), Xr.length = 0);
                  }
                  return Kr;
                }(Rt);
                (function(or, nr, Qr) {
                  var Xr = new Error(or);
                  throw Xr.line = nr, Xr.column = Qr, Xr;
                })("Invalid Unicode escape code: " + ot, Mt, gt);
              }(Ee.join(""));
            }, Dr = "\\u", Vr = { type: "literal", value: "\\u", description: '"\\\\u"' }, be = 0, Or = 0, Ue = 0, it = { line: 1, column: 1, seenCR: false }, dt = 0, vt = [], wt = 0, Pt = {};
            if ("startRule" in h) {
              if (!(h.startRule in r)) throw new Error(`Can't start parsing from rule "` + h.startRule + '".');
              m = r[h.startRule];
            }
            function Yt() {
              return qr(Or).line;
            }
            function cr() {
              return qr(Or).column;
            }
            function qr(Ee) {
              return Ue !== Ee && (Ue > Ee && (Ue = 0, it = { line: 1, column: 1, seenCR: false }), function(ot, Mt, gt) {
                var Rt, or;
                for (Rt = Mt; Rt < gt; Rt++) (or = u.charAt(Rt)) === `
` ? (ot.seenCR || ot.line++, ot.column = 1, ot.seenCR = false) : or === "\r" || or === "\u2028" || or === "\u2029" ? (ot.line++, ot.column = 1, ot.seenCR = true) : (ot.column++, ot.seenCR = false);
              }(it, Ue, Ee), Ue = Ee), it;
            }
            function Vt(Ee) {
              be < dt || (be > dt && (dt = be, vt = []), vt.push(Ee));
            }
            function zr(Ee, ot, Mt) {
              var gt = qr(Mt), Rt = Mt < u.length ? u.charAt(Mt) : null;
              return ot !== null && function(or) {
                var nr = 1;
                for (or.sort(function(Qr, Xr) {
                  return Qr.description < Xr.description ? -1 : Qr.description > Xr.description ? 1 : 0;
                }); nr < or.length; ) or[nr - 1] === or[nr] ? or.splice(nr, 1) : nr++;
              }(ot), new o(function(or, nr) {
                var Qr, Xr = new Array(or.length);
                for (Qr = 0; Qr < or.length; Qr++) Xr[Qr] = or[Qr].description;
                return "Expected " + (or.length > 1 ? Xr.slice(0, -1).join(", ") + " or " + Xr[or.length - 1] : Xr[0]) + " but " + (nr ? '"' + function(Yr) {
                  function un(Kr) {
                    return Kr.charCodeAt(0).toString(16).toUpperCase();
                  }
                  return Yr.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(Kr) {
                    return "\\x0" + un(Kr);
                  }).replace(/[\x10-\x1F\x80-\xFF]/g, function(Kr) {
                    return "\\x" + un(Kr);
                  }).replace(/[\u0180-\u0FFF]/g, function(Kr) {
                    return "\\u0" + un(Kr);
                  }).replace(/[\u1080-\uFFFF]/g, function(Kr) {
                    return "\\u" + un(Kr);
                  });
                }(nr) + '"' : "end of input") + " found.";
              }(ot, Rt), ot, Rt, Mt, gt.line, gt.column);
            }
            function en() {
              var Ee, ot, Mt, gt = 49 * be + 0, Rt = Pt[gt];
              if (Rt) return be = Rt.nextPos, Rt.result;
              for (Ee = be, ot = [], Mt = Me(); Mt !== f; ) ot.push(Mt), Mt = Me();
              return ot !== f && (Or = Ee, ot = g()), Ee = ot, Pt[gt] = { nextPos: be, result: Ee }, Ee;
            }
            function Me() {
              var Ee, ot, Mt, gt, Rt, or, nr, Qr = 49 * be + 1, Xr = Pt[Qr];
              if (Xr) return be = Xr.nextPos, Xr.result;
              for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
              if (ot !== f) if (Mt = function() {
                var Yr, un = 49 * be + 2, Kr = Pt[un];
                return Kr ? (be = Kr.nextPos, Kr.result) : (Yr = De(), Yr === f && (Yr = function() {
                  var Ir, An, En, Sn, On, gn, Bn = 49 * be + 4, jn = Pt[Bn];
                  if (jn) return be = jn.nextPos, jn.result;
                  if (Ir = be, u.charCodeAt(be) === 91 ? (An = E, be++) : (An = f, wt === 0 && Vt(R)), An !== f) {
                    for (En = [], Sn = M(); Sn !== f; ) En.push(Sn), Sn = M();
                    if (En !== f) if ((Sn = Ke()) !== f) {
                      for (On = [], gn = M(); gn !== f; ) On.push(gn), gn = M();
                      On !== f ? (u.charCodeAt(be) === 93 ? (gn = k, be++) : (gn = f, wt === 0 && Vt(w)), gn !== f ? (Or = Ir, Ir = An = F(Sn)) : (be = Ir, Ir = a)) : (be = Ir, Ir = a);
                    } else be = Ir, Ir = a;
                    else be = Ir, Ir = a;
                  } else be = Ir, Ir = a;
                  return Pt[Bn] = { nextPos: be, result: Ir }, Ir;
                }(), Yr === f && (Yr = function() {
                  var Ir, An, En, Sn, On, gn, Bn, jn, qn = 49 * be + 5, Qn = Pt[qn];
                  if (Qn) return be = Qn.nextPos, Qn.result;
                  if (Ir = be, u.charCodeAt(be) === 91 ? (An = E, be++) : (An = f, wt === 0 && Vt(R)), An !== f) if (u.charCodeAt(be) === 91 ? (En = E, be++) : (En = f, wt === 0 && Vt(R)), En !== f) {
                    for (Sn = [], On = M(); On !== f; ) Sn.push(On), On = M();
                    if (Sn !== f) if ((On = Ke()) !== f) {
                      for (gn = [], Bn = M(); Bn !== f; ) gn.push(Bn), Bn = M();
                      gn !== f ? (u.charCodeAt(be) === 93 ? (Bn = k, be++) : (Bn = f, wt === 0 && Vt(w)), Bn !== f ? (u.charCodeAt(be) === 93 ? (jn = k, be++) : (jn = f, wt === 0 && Vt(w)), jn !== f ? (Or = Ir, Ir = An = I(On)) : (be = Ir, Ir = a)) : (be = Ir, Ir = a)) : (be = Ir, Ir = a);
                    } else be = Ir, Ir = a;
                    else be = Ir, Ir = a;
                  } else be = Ir, Ir = a;
                  else be = Ir, Ir = a;
                  return Pt[qn] = { nextPos: be, result: Ir }, Ir;
                }(), Yr === f && (Yr = function() {
                  var Ir, An, En, Sn, On, gn, Bn = 49 * be + 9, jn = Pt[Bn];
                  if (jn) return be = jn.nextPos, jn.result;
                  if (Ir = be, An = ur(), An !== f) {
                    for (En = [], Sn = M(); Sn !== f; ) En.push(Sn), Sn = M();
                    if (En !== f) if (u.charCodeAt(be) === 61 ? (Sn = L, be++) : (Sn = f, wt === 0 && Vt(j)), Sn !== f) {
                      for (On = [], gn = M(); gn !== f; ) On.push(gn), gn = M();
                      On !== f && (gn = Wr()) !== f ? (Or = Ir, Ir = An = z(An, gn)) : (be = Ir, Ir = a);
                    } else be = Ir, Ir = a;
                    else be = Ir, Ir = a;
                  } else be = Ir, Ir = a;
                  if (Ir === f) if (Ir = be, (An = Cr()) !== f) {
                    for (En = [], Sn = M(); Sn !== f; ) En.push(Sn), Sn = M();
                    if (En !== f) if (u.charCodeAt(be) === 61 ? (Sn = L, be++) : (Sn = f, wt === 0 && Vt(j)), Sn !== f) {
                      for (On = [], gn = M(); gn !== f; ) On.push(gn), gn = M();
                      On !== f && (gn = Wr()) !== f ? (Or = Ir, Ir = An = z(An, gn)) : (be = Ir, Ir = a);
                    } else be = Ir, Ir = a;
                    else be = Ir, Ir = a;
                  } else be = Ir, Ir = a;
                  return Pt[Bn] = { nextPos: be, result: Ir }, Ir;
                }()))), Pt[un] = { nextPos: be, result: Yr }, Yr);
              }(), Mt !== f) {
                for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                if (gt !== f) {
                  for (Rt = [], or = De(); or !== f; ) Rt.push(or), or = De();
                  if (Rt !== f) {
                    if (or = [], (nr = W()) !== f) for (; nr !== f; ) or.push(nr), nr = W();
                    else or = a;
                    or === f && (or = Se()), or !== f ? Ee = ot = [ot, Mt, gt, Rt, or] : (be = Ee, Ee = a);
                  } else be = Ee, Ee = a;
                } else be = Ee, Ee = a;
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              if (Ee === f) {
                if (Ee = be, ot = [], (Mt = M()) !== f) for (; Mt !== f; ) ot.push(Mt), Mt = M();
                else ot = a;
                if (ot !== f) {
                  if (Mt = [], (gt = W()) !== f) for (; gt !== f; ) Mt.push(gt), gt = W();
                  else Mt = a;
                  Mt === f && (Mt = Se()), Mt !== f ? Ee = ot = [ot, Mt] : (be = Ee, Ee = a);
                } else be = Ee, Ee = a;
                Ee === f && (Ee = W());
              }
              return Pt[Qr] = { nextPos: be, result: Ee }, Ee;
            }
            function De() {
              var Ee, ot, Mt, gt, Rt, or, nr = 49 * be + 3, Qr = Pt[nr];
              if (Qr) return be = Qr.nextPos, Qr.result;
              if (Ee = be, u.charCodeAt(be) === 35 ? (ot = l, be++) : (ot = f, wt === 0 && Vt(d)), ot !== f) {
                for (Mt = [], gt = be, Rt = be, wt++, (or = W()) === f && (or = Se()), wt--, or === f ? Rt = b : (be = Rt, Rt = a), Rt !== f ? (u.length > be ? (or = u.charAt(be), be++) : (or = f, wt === 0 && Vt(S)), or !== f ? gt = Rt = [Rt, or] : (be = gt, gt = a)) : (be = gt, gt = a); gt !== f; ) Mt.push(gt), gt = be, Rt = be, wt++, (or = W()) === f && (or = Se()), wt--, or === f ? Rt = b : (be = Rt, Rt = a), Rt !== f ? (u.length > be ? (or = u.charAt(be), be++) : (or = f, wt === 0 && Vt(S)), or !== f ? gt = Rt = [Rt, or] : (be = gt, gt = a)) : (be = gt, gt = a);
                Mt !== f ? Ee = ot = [ot, Mt] : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              return Pt[nr] = { nextPos: be, result: Ee }, Ee;
            }
            function Ke() {
              var Ee, ot, Mt, gt = 49 * be + 6, Rt = Pt[gt];
              if (Rt) return be = Rt.nextPos, Rt.result;
              if (Ee = be, ot = [], (Mt = St()) !== f) for (; Mt !== f; ) ot.push(Mt), Mt = St();
              else ot = a;
              return ot !== f && (Mt = Bt()) !== f ? (Or = Ee, Ee = ot = q(ot, Mt)) : (be = Ee, Ee = a), Ee === f && (Ee = be, (ot = Bt()) !== f && (Or = Ee, ot = D(ot)), Ee = ot), Pt[gt] = { nextPos: be, result: Ee }, Ee;
            }
            function Bt() {
              var Ee, ot, Mt, gt, Rt, or = 49 * be + 7, nr = Pt[or];
              if (nr) return be = nr.nextPos, nr.result;
              for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
              if (ot !== f) if ((Mt = ur()) !== f) {
                for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                gt !== f ? (Or = Ee, Ee = ot = H(Mt)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              if (Ee === f) {
                for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
                if (ot !== f) if ((Mt = Cr()) !== f) {
                  for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                  gt !== f ? (Or = Ee, Ee = ot = H(Mt)) : (be = Ee, Ee = a);
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              }
              return Pt[or] = { nextPos: be, result: Ee }, Ee;
            }
            function St() {
              var Ee, ot, Mt, gt, Rt, or, nr, Qr = 49 * be + 8, Xr = Pt[Qr];
              if (Xr) return be = Xr.nextPos, Xr.result;
              for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
              if (ot !== f) if ((Mt = ur()) !== f) {
                for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                if (gt !== f) if (u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), Rt !== f) {
                  for (or = [], nr = M(); nr !== f; ) or.push(nr), nr = M();
                  or !== f ? (Or = Ee, Ee = ot = H(Mt)) : (be = Ee, Ee = a);
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              if (Ee === f) {
                for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
                if (ot !== f) if ((Mt = Cr()) !== f) {
                  for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                  if (gt !== f) if (u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), Rt !== f) {
                    for (or = [], nr = M(); nr !== f; ) or.push(nr), nr = M();
                    or !== f ? (Or = Ee, Ee = ot = H(Mt)) : (be = Ee, Ee = a);
                  } else be = Ee, Ee = a;
                  else be = Ee, Ee = a;
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              }
              return Pt[Qr] = { nextPos: be, result: Ee }, Ee;
            }
            function ur() {
              var Ee, ot, Mt, gt = 49 * be + 10, Rt = Pt[gt];
              if (Rt) return be = Rt.nextPos, Rt.result;
              if (Ee = be, ot = [], (Mt = Je()) !== f) for (; Mt !== f; ) ot.push(Mt), Mt = Je();
              else ot = a;
              return ot !== f && (Or = Ee, ot = Y(ot)), Ee = ot, Pt[gt] = { nextPos: be, result: Ee }, Ee;
            }
            function Cr() {
              var Ee, ot, Mt = 49 * be + 11, gt = Pt[Mt];
              return gt ? (be = gt.nextPos, gt.result) : (Ee = be, (ot = Zr()) !== f && (Or = Ee, ot = te(ot)), (Ee = ot) === f && (Ee = be, (ot = dn()) !== f && (Or = Ee, ot = te(ot)), Ee = ot), Pt[Mt] = { nextPos: be, result: Ee }, Ee);
            }
            function Wr() {
              var Ee, ot = 49 * be + 12, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : (Ee = function() {
                var gt, Rt = 49 * be + 13, or = Pt[Rt];
                return or ? (be = or.nextPos, or.result) : (gt = function() {
                  var nr, Qr, Xr, Yr, un, Kr = 49 * be + 14, Ir = Pt[Kr];
                  if (Ir) return be = Ir.nextPos, Ir.result;
                  if (nr = be, u.substr(be, 3) === G ? (Qr = G, be += 3) : (Qr = f, wt === 0 && Vt(K)), Qr !== f) if ((Xr = W()) === f && (Xr = J), Xr !== f) {
                    for (Yr = [], un = pi(); un !== f; ) Yr.push(un), un = pi();
                    Yr !== f ? (u.substr(be, 3) === G ? (un = G, be += 3) : (un = f, wt === 0 && Vt(K)), un !== f ? (Or = nr, nr = Qr = B(Yr)) : (be = nr, nr = a)) : (be = nr, nr = a);
                  } else be = nr, nr = a;
                  else be = nr, nr = a;
                  return Pt[Kr] = { nextPos: be, result: nr }, nr;
                }(), gt === f && (gt = Zr()) === f && (gt = function() {
                  var nr, Qr, Xr, Yr, un, Kr = 49 * be + 16, Ir = Pt[Kr];
                  if (Ir) return be = Ir.nextPos, Ir.result;
                  if (nr = be, u.substr(be, 3) === $ ? (Qr = $, be += 3) : (Qr = f, wt === 0 && Vt(oe)), Qr !== f) if ((Xr = W()) === f && (Xr = J), Xr !== f) {
                    for (Yr = [], un = Bi(); un !== f; ) Yr.push(un), un = Bi();
                    Yr !== f ? (u.substr(be, 3) === $ ? (un = $, be += 3) : (un = f, wt === 0 && Vt(oe)), un !== f ? (Or = nr, nr = Qr = B(Yr)) : (be = nr, nr = a)) : (be = nr, nr = a);
                  } else be = nr, nr = a;
                  else be = nr, nr = a;
                  return Pt[Kr] = { nextPos: be, result: nr }, nr;
                }(), gt === f && (gt = dn())), Pt[Rt] = { nextPos: be, result: gt }, gt);
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or, nr, Qr, Xr = 49 * be + 38, Yr = Pt[Xr];
                return Yr ? (be = Yr.nextPos, Yr.result) : (gt = be, (Rt = fr()) !== f ? (u.charCodeAt(be) === 84 ? (or = Ur, be++) : (or = f, wt === 0 && Vt(Pe)), or !== f ? (nr = function() {
                  var un, Kr, Ir, An, En, Sn, On, gn, Bn, jn, qn, Qn = 49 * be + 36, ii = Pt[Qn];
                  return ii ? (be = ii.nextPos, ii.result) : (un = be, Kr = be, Ir = Re(), Ir !== f && (An = Re()) !== f ? (u.charCodeAt(be) === 58 ? (En = wr, be++) : (En = f, wt === 0 && Vt(Nt)), En !== f && (Sn = Re()) !== f && (On = Re()) !== f ? (u.charCodeAt(be) === 58 ? (gn = wr, be++) : (gn = f, wt === 0 && Vt(Nt)), gn !== f && (Bn = Re()) !== f && (jn = Re()) !== f ? ((qn = $t()) === f && (qn = J), qn !== f ? Kr = Ir = [Ir, An, En, Sn, On, gn, Bn, jn, qn] : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a), Kr !== f && (Or = un, Kr = yr(Kr)), un = Kr, Pt[Qn] = { nextPos: be, result: un }, un);
                }(), nr !== f ? (u.charCodeAt(be) === 90 ? (Qr = $e, be++) : (Qr = f, wt === 0 && Vt(le)), Qr !== f ? (Or = gt, gt = Rt = re(Rt, nr)) : (be = gt, gt = a)) : (be = gt, gt = a)) : (be = gt, gt = a)) : (be = gt, gt = a), gt === f && (gt = be, (Rt = fr()) !== f ? (u.charCodeAt(be) === 84 ? (or = Ur, be++) : (or = f, wt === 0 && Vt(Pe)), or !== f ? (nr = function() {
                  var un, Kr, Ir, An, En, Sn, On, gn, Bn, jn, qn, Qn, ii, vi, uo, jo, la, Rn = 49 * be + 37, Ie = Pt[Rn];
                  return Ie ? (be = Ie.nextPos, Ie.result) : (un = be, Kr = be, Ir = Re(), Ir !== f && (An = Re()) !== f ? (u.charCodeAt(be) === 58 ? (En = wr, be++) : (En = f, wt === 0 && Vt(Nt)), En !== f && (Sn = Re()) !== f && (On = Re()) !== f ? (u.charCodeAt(be) === 58 ? (gn = wr, be++) : (gn = f, wt === 0 && Vt(Nt)), gn !== f && (Bn = Re()) !== f && (jn = Re()) !== f ? ((qn = $t()) === f && (qn = J), qn !== f ? (u.charCodeAt(be) === 45 ? (Qn = x, be++) : (Qn = f, wt === 0 && Vt(O)), Qn === f && (u.charCodeAt(be) === 43 ? (Qn = Qe, be++) : (Qn = f, wt === 0 && Vt(ee))), Qn !== f && (ii = Re()) !== f && (vi = Re()) !== f ? (u.charCodeAt(be) === 58 ? (uo = wr, be++) : (uo = f, wt === 0 && Vt(Nt)), uo !== f && (jo = Re()) !== f && (la = Re()) !== f ? Kr = Ir = [Ir, An, En, Sn, On, gn, Bn, jn, qn, Qn, ii, vi, uo, jo, la] : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a)) : (be = Kr, Kr = a), Kr !== f && (Or = un, Kr = yr(Kr)), un = Kr, Pt[Rn] = { nextPos: be, result: un }, un);
                }(), nr !== f ? (Or = gt, gt = Rt = Le(Rt, nr)) : (be = gt, gt = a)) : (be = gt, gt = a)) : (be = gt, gt = a)), Pt[Xr] = { nextPos: be, result: gt }, gt);
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or, nr, Qr = 49 * be + 23, Xr = Pt[Qr];
                return Xr ? (be = Xr.nextPos, Xr.result) : (gt = be, (Rt = Ni()) === f && (Rt = Un()), Rt !== f ? (u.charCodeAt(be) === 101 ? (or = pe, be++) : (or = f, wt === 0 && Vt(Oe)), or === f && (u.charCodeAt(be) === 69 ? (or = xe, be++) : (or = f, wt === 0 && Vt(Ve))), or !== f && (nr = Un()) !== f ? (Or = gt, gt = Rt = _e(Rt, nr)) : (be = gt, gt = a)) : (be = gt, gt = a), gt === f && (gt = be, (Rt = Ni()) !== f && (Or = gt, Rt = Be(Rt)), gt = Rt), Pt[Qr] = { nextPos: be, result: gt }, gt);
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or = 49 * be + 25, nr = Pt[or];
                return nr ? (be = nr.nextPos, nr.result) : (gt = be, (Rt = Un()) !== f && (Or = gt, Rt = N(Rt)), gt = Rt, Pt[or] = { nextPos: be, result: gt }, gt);
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or = 49 * be + 27, nr = Pt[or];
                return nr ? (be = nr.nextPos, nr.result) : (gt = be, u.substr(be, 4) === C ? (Rt = C, be += 4) : (Rt = f, wt === 0 && Vt(p)), Rt !== f && (Or = gt, Rt = A()), gt = Rt, gt === f && (gt = be, u.substr(be, 5) === U ? (Rt = U, be += 5) : (Rt = f, wt === 0 && Vt(Q)), Rt !== f && (Or = gt, Rt = se()), gt = Rt), Pt[or] = { nextPos: be, result: gt }, gt);
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or, nr, Qr, Xr = 49 * be + 28, Yr = Pt[Xr];
                if (Yr) return be = Yr.nextPos, Yr.result;
                if (gt = be, u.charCodeAt(be) === 91 ? (Rt = E, be++) : (Rt = f, wt === 0 && Vt(R)), Rt !== f) {
                  for (or = [], nr = bt(); nr !== f; ) or.push(nr), nr = bt();
                  or !== f ? (u.charCodeAt(be) === 93 ? (nr = k, be++) : (nr = f, wt === 0 && Vt(w)), nr !== f ? (Or = gt, gt = Rt = X()) : (be = gt, gt = a)) : (be = gt, gt = a);
                } else be = gt, gt = a;
                if (gt === f && (gt = be, u.charCodeAt(be) === 91 ? (Rt = E, be++) : (Rt = f, wt === 0 && Vt(R)), Rt !== f ? ((or = Xe()) === f && (or = J), or !== f ? (u.charCodeAt(be) === 93 ? (nr = k, be++) : (nr = f, wt === 0 && Vt(w)), nr !== f ? (Or = gt, gt = Rt = de(or)) : (be = gt, gt = a)) : (be = gt, gt = a)) : (be = gt, gt = a), gt === f)) {
                  if (gt = be, u.charCodeAt(be) === 91 ? (Rt = E, be++) : (Rt = f, wt === 0 && Vt(R)), Rt !== f) {
                    if (or = [], (nr = Ye()) !== f) for (; nr !== f; ) or.push(nr), nr = Ye();
                    else or = a;
                    or !== f ? (u.charCodeAt(be) === 93 ? (nr = k, be++) : (nr = f, wt === 0 && Vt(w)), nr !== f ? (Or = gt, gt = Rt = tt(or)) : (be = gt, gt = a)) : (be = gt, gt = a);
                  } else be = gt, gt = a;
                  if (gt === f) if (gt = be, u.charCodeAt(be) === 91 ? (Rt = E, be++) : (Rt = f, wt === 0 && Vt(R)), Rt !== f) {
                    if (or = [], (nr = Ye()) !== f) for (; nr !== f; ) or.push(nr), nr = Ye();
                    else or = a;
                    or !== f && (nr = Xe()) !== f ? (u.charCodeAt(be) === 93 ? (Qr = k, be++) : (Qr = f, wt === 0 && Vt(w)), Qr !== f ? (Or = gt, gt = Rt = Ne(or, nr)) : (be = gt, gt = a)) : (be = gt, gt = a);
                  } else be = gt, gt = a;
                }
                return Pt[Xr] = { nextPos: be, result: gt }, gt;
              }(), Ee === f && (Ee = function() {
                var gt, Rt, or, nr, Qr, Xr, Yr = 49 * be + 32, un = Pt[Yr];
                if (un) return be = un.nextPos, un.result;
                if (gt = be, u.charCodeAt(be) === 123 ? (Rt = rr, be++) : (Rt = f, wt === 0 && Vt(je)), Rt !== f) {
                  for (or = [], nr = M(); nr !== f; ) or.push(nr), nr = M();
                  if (or !== f) {
                    for (nr = [], Qr = xt(); Qr !== f; ) nr.push(Qr), Qr = xt();
                    if (nr !== f) {
                      for (Qr = [], Xr = M(); Xr !== f; ) Qr.push(Xr), Xr = M();
                      Qr !== f ? (u.charCodeAt(be) === 125 ? (Xr = Ge, be++) : (Xr = f, wt === 0 && Vt(at)), Xr !== f ? (Or = gt, gt = Rt = Ae(nr)) : (be = gt, gt = a)) : (be = gt, gt = a);
                    } else be = gt, gt = a;
                  } else be = gt, gt = a;
                } else be = gt, gt = a;
                return Pt[Yr] = { nextPos: be, result: gt }, gt;
              }())))))), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function Zr() {
              var Ee, ot, Mt, gt, Rt = 49 * be + 15, or = Pt[Rt];
              if (or) return be = or.nextPos, or.result;
              if (Ee = be, u.charCodeAt(be) === 34 ? (ot = Z, be++) : (ot = f, wt === 0 && Vt(ie)), ot !== f) {
                for (Mt = [], gt = wn(); gt !== f; ) Mt.push(gt), gt = wn();
                Mt !== f ? (u.charCodeAt(be) === 34 ? (gt = Z, be++) : (gt = f, wt === 0 && Vt(ie)), gt !== f ? (Or = Ee, Ee = ot = B(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              return Pt[Rt] = { nextPos: be, result: Ee }, Ee;
            }
            function dn() {
              var Ee, ot, Mt, gt, Rt = 49 * be + 17, or = Pt[Rt];
              if (or) return be = or.nextPos, or.result;
              if (Ee = be, u.charCodeAt(be) === 39 ? (ot = ce, be++) : (ot = f, wt === 0 && Vt(ye)), ot !== f) {
                for (Mt = [], gt = yn(); gt !== f; ) Mt.push(gt), gt = yn();
                Mt !== f ? (u.charCodeAt(be) === 39 ? (gt = ce, be++) : (gt = f, wt === 0 && Vt(ye)), gt !== f ? (Or = Ee, Ee = ot = B(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              return Pt[Rt] = { nextPos: be, result: Ee }, Ee;
            }
            function wn() {
              var Ee, ot, Mt, gt = 49 * be + 18, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : ((Ee = _t()) === f && (Ee = be, ot = be, wt++, u.charCodeAt(be) === 34 ? (Mt = Z, be++) : (Mt = f, wt === 0 && Vt(ie)), wt--, Mt === f ? ot = b : (be = ot, ot = a), ot !== f ? (u.length > be ? (Mt = u.charAt(be), be++) : (Mt = f, wt === 0 && Vt(S)), Mt !== f ? (Or = Ee, Ee = ot = ae(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a)), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function yn() {
              var Ee, ot, Mt, gt = 49 * be + 19, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : (Ee = be, ot = be, wt++, u.charCodeAt(be) === 39 ? (Mt = ce, be++) : (Mt = f, wt === 0 && Vt(ye)), wt--, Mt === f ? ot = b : (be = ot, ot = a), ot !== f ? (u.length > be ? (Mt = u.charAt(be), be++) : (Mt = f, wt === 0 && Vt(S)), Mt !== f ? (Or = Ee, Ee = ot = ae(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function pi() {
              var Ee, ot, Mt, gt = 49 * be + 20, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : ((Ee = _t()) === f && (Ee = function() {
                var or, nr, Qr, Xr, Yr = 49 * be + 21, un = Pt[Yr];
                if (un) return be = un.nextPos, un.result;
                if (or = be, u.charCodeAt(be) === 92 ? (nr = ne, be++) : (nr = f, wt === 0 && Vt(ge)), nr !== f) if (W() !== f) {
                  for (Qr = [], Xr = fe(); Xr !== f; ) Qr.push(Xr), Xr = fe();
                  Qr !== f ? (Or = or, or = nr = Te()) : (be = or, or = a);
                } else be = or, or = a;
                else be = or, or = a;
                return Pt[Yr] = { nextPos: be, result: or }, or;
              }(), Ee === f && (Ee = be, ot = be, wt++, u.substr(be, 3) === G ? (Mt = G, be += 3) : (Mt = f, wt === 0 && Vt(K)), wt--, Mt === f ? ot = b : (be = ot, ot = a), ot !== f ? (u.length > be ? (Mt = u.charAt(be), be++) : (Mt = f, wt === 0 && Vt(S)), Mt !== f ? (Or = Ee, Ee = ot = ue(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a))), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function Bi() {
              var Ee, ot, Mt, gt = 49 * be + 22, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : (Ee = be, ot = be, wt++, u.substr(be, 3) === $ ? (Mt = $, be += 3) : (Mt = f, wt === 0 && Vt(oe)), wt--, Mt === f ? ot = b : (be = ot, ot = a), ot !== f ? (u.length > be ? (Mt = u.charAt(be), be++) : (Mt = f, wt === 0 && Vt(S)), Mt !== f ? (Or = Ee, Ee = ot = ae(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function Ni() {
              var Ee, ot, Mt, gt, Rt, or, nr = 49 * be + 24, Qr = Pt[nr];
              return Qr ? (be = Qr.nextPos, Qr.result) : (Ee = be, u.charCodeAt(be) === 43 ? (ot = Qe, be++) : (ot = f, wt === 0 && Vt(ee)), ot === f && (ot = J), ot !== f ? (Mt = be, (gt = Ut()) !== f ? (u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), Rt !== f && (or = Ut()) !== f ? Mt = gt = [gt, Rt, or] : (be = Mt, Mt = a)) : (be = Mt, Mt = a), Mt !== f ? (Or = Ee, Ee = ot = P(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a), Ee === f && (Ee = be, u.charCodeAt(be) === 45 ? (ot = x, be++) : (ot = f, wt === 0 && Vt(O)), ot !== f ? (Mt = be, (gt = Ut()) !== f ? (u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), Rt !== f && (or = Ut()) !== f ? Mt = gt = [gt, Rt, or] : (be = Mt, Mt = a)) : (be = Mt, Mt = a), Mt !== f ? (Or = Ee, Ee = ot = V(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a)), Pt[nr] = { nextPos: be, result: Ee }, Ee);
            }
            function Un() {
              var Ee, ot, Mt, gt, Rt, or = 49 * be + 26, nr = Pt[or];
              if (nr) return be = nr.nextPos, nr.result;
              if (Ee = be, u.charCodeAt(be) === 43 ? (ot = Qe, be++) : (ot = f, wt === 0 && Vt(ee)), ot === f && (ot = J), ot !== f) {
                if (Mt = [], (gt = Re()) !== f) for (; gt !== f; ) Mt.push(gt), gt = Re();
                else Mt = a;
                Mt !== f ? (gt = be, wt++, u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), wt--, Rt === f ? gt = b : (be = gt, gt = a), gt !== f ? (Or = Ee, Ee = ot = P(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              if (Ee === f) if (Ee = be, u.charCodeAt(be) === 45 ? (ot = x, be++) : (ot = f, wt === 0 && Vt(O)), ot !== f) {
                if (Mt = [], (gt = Re()) !== f) for (; gt !== f; ) Mt.push(gt), gt = Re();
                else Mt = a;
                Mt !== f ? (gt = be, wt++, u.charCodeAt(be) === 46 ? (Rt = _, be++) : (Rt = f, wt === 0 && Vt(T)), wt--, Rt === f ? gt = b : (be = gt, gt = a), gt !== f ? (Or = Ee, Ee = ot = V(Mt)) : (be = Ee, Ee = a)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              return Pt[or] = { nextPos: be, result: Ee }, Ee;
            }
            function Xe() {
              var Ee, ot, Mt, gt, Rt, or = 49 * be + 29, nr = Pt[or];
              if (nr) return be = nr.nextPos, nr.result;
              for (Ee = be, ot = [], Mt = bt(); Mt !== f; ) ot.push(Mt), Mt = bt();
              if (ot !== f) if ((Mt = Wr()) !== f) {
                for (gt = [], Rt = bt(); Rt !== f; ) gt.push(Rt), Rt = bt();
                gt !== f ? (Or = Ee, Ee = ot = ut(Mt)) : (be = Ee, Ee = a);
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              return Pt[or] = { nextPos: be, result: Ee }, Ee;
            }
            function Ye() {
              var Ee, ot, Mt, gt, Rt, or, nr, Qr = 49 * be + 30, Xr = Pt[Qr];
              if (Xr) return be = Xr.nextPos, Xr.result;
              for (Ee = be, ot = [], Mt = bt(); Mt !== f; ) ot.push(Mt), Mt = bt();
              if (ot !== f) if ((Mt = Wr()) !== f) {
                for (gt = [], Rt = bt(); Rt !== f; ) gt.push(Rt), Rt = bt();
                if (gt !== f) if (u.charCodeAt(be) === 44 ? (Rt = Ze, be++) : (Rt = f, wt === 0 && Vt(Et)), Rt !== f) {
                  for (or = [], nr = bt(); nr !== f; ) or.push(nr), nr = bt();
                  or !== f ? (Or = Ee, Ee = ot = ut(Mt)) : (be = Ee, Ee = a);
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              return Pt[Qr] = { nextPos: be, result: Ee }, Ee;
            }
            function bt() {
              var Ee, ot = 49 * be + 31, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : ((Ee = M()) === f && (Ee = W()) === f && (Ee = De()), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function xt() {
              var Ee, ot, Mt, gt, Rt, or, nr, Qr, Xr, Yr, un, Kr = 49 * be + 33, Ir = Pt[Kr];
              if (Ir) return be = Ir.nextPos, Ir.result;
              for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
              if (ot !== f) if ((Mt = ur()) !== f) {
                for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                if (gt !== f) if (u.charCodeAt(be) === 61 ? (Rt = L, be++) : (Rt = f, wt === 0 && Vt(j)), Rt !== f) {
                  for (or = [], nr = M(); nr !== f; ) or.push(nr), nr = M();
                  if (or !== f) if ((nr = Wr()) !== f) {
                    for (Qr = [], Xr = M(); Xr !== f; ) Qr.push(Xr), Xr = M();
                    if (Qr !== f) if (u.charCodeAt(be) === 44 ? (Xr = Ze, be++) : (Xr = f, wt === 0 && Vt(Et)), Xr !== f) {
                      for (Yr = [], un = M(); un !== f; ) Yr.push(un), un = M();
                      Yr !== f ? (Or = Ee, Ee = ot = qe(Mt, nr)) : (be = Ee, Ee = a);
                    } else be = Ee, Ee = a;
                    else be = Ee, Ee = a;
                  } else be = Ee, Ee = a;
                  else be = Ee, Ee = a;
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              } else be = Ee, Ee = a;
              else be = Ee, Ee = a;
              if (Ee === f) {
                for (Ee = be, ot = [], Mt = M(); Mt !== f; ) ot.push(Mt), Mt = M();
                if (ot !== f) if ((Mt = ur()) !== f) {
                  for (gt = [], Rt = M(); Rt !== f; ) gt.push(Rt), Rt = M();
                  if (gt !== f) if (u.charCodeAt(be) === 61 ? (Rt = L, be++) : (Rt = f, wt === 0 && Vt(j)), Rt !== f) {
                    for (or = [], nr = M(); nr !== f; ) or.push(nr), nr = M();
                    or !== f && (nr = Wr()) !== f ? (Or = Ee, Ee = ot = qe(Mt, nr)) : (be = Ee, Ee = a);
                  } else be = Ee, Ee = a;
                  else be = Ee, Ee = a;
                } else be = Ee, Ee = a;
                else be = Ee, Ee = a;
              }
              return Pt[Kr] = { nextPos: be, result: Ee }, Ee;
            }
            function $t() {
              var Ee, ot, Mt, gt = 49 * be + 34, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : (Ee = be, u.charCodeAt(be) === 46 ? (ot = _, be++) : (ot = f, wt === 0 && Vt(T)), ot !== f && (Mt = Ut()) !== f ? (Or = Ee, Ee = ot = Ft(Mt)) : (be = Ee, Ee = a), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function fr() {
              var Ee, ot, Mt, gt, Rt, or, nr, Qr, Xr, Yr, un, Kr, Ir = 49 * be + 35, An = Pt[Ir];
              return An ? (be = An.nextPos, An.result) : (Ee = be, ot = be, (Mt = Re()) !== f && (gt = Re()) !== f && (Rt = Re()) !== f && (or = Re()) !== f ? (u.charCodeAt(be) === 45 ? (nr = x, be++) : (nr = f, wt === 0 && Vt(O)), nr !== f && (Qr = Re()) !== f && (Xr = Re()) !== f ? (u.charCodeAt(be) === 45 ? (Yr = x, be++) : (Yr = f, wt === 0 && Vt(O)), Yr !== f && (un = Re()) !== f && (Kr = Re()) !== f ? ot = Mt = [Mt, gt, Rt, or, nr, Qr, Xr, Yr, un, Kr] : (be = ot, ot = a)) : (be = ot, ot = a)) : (be = ot, ot = a), ot !== f && (Or = Ee, ot = Dt(ot)), Ee = ot, Pt[Ir] = { nextPos: be, result: Ee }, Ee);
            }
            function M() {
              var Ee, ot = 49 * be + 39, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : (nt.test(u.charAt(be)) ? (Ee = u.charAt(be), be++) : (Ee = f, wt === 0 && Vt(ft)), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function W() {
              var Ee, ot, Mt, gt = 49 * be + 40, Rt = Pt[gt];
              return Rt ? (be = Rt.nextPos, Rt.result) : (u.charCodeAt(be) === 10 ? (Ee = zt, be++) : (Ee = f, wt === 0 && Vt(st)), Ee === f && (Ee = be, u.charCodeAt(be) === 13 ? (ot = ct, be++) : (ot = f, wt === 0 && Vt(yt)), ot !== f ? (u.charCodeAt(be) === 10 ? (Mt = zt, be++) : (Mt = f, wt === 0 && Vt(st)), Mt !== f ? Ee = ot = [ot, Mt] : (be = Ee, Ee = a)) : (be = Ee, Ee = a)), Pt[gt] = { nextPos: be, result: Ee }, Ee);
            }
            function fe() {
              var Ee, ot = 49 * be + 41, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : ((Ee = W()) === f && (Ee = M()), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function Se() {
              var Ee, ot, Mt = 49 * be + 42, gt = Pt[Mt];
              return gt ? (be = gt.nextPos, gt.result) : (Ee = be, wt++, u.length > be ? (ot = u.charAt(be), be++) : (ot = f, wt === 0 && Vt(S)), wt--, ot === f ? Ee = b : (be = Ee, Ee = a), Pt[Mt] = { nextPos: be, result: Ee }, Ee);
            }
            function Ce() {
              var Ee, ot = 49 * be + 43, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : (Zt.test(u.charAt(be)) ? (Ee = u.charAt(be), be++) : (Ee = f, wt === 0 && Vt(Ct)), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function Re() {
              var Ee, ot, Mt = 49 * be + 44, gt = Pt[Mt];
              return gt ? (be = gt.nextPos, gt.result) : (Lt.test(u.charAt(be)) ? (Ee = u.charAt(be), be++) : (Ee = f, wt === 0 && Vt(Wt)), Ee === f && (Ee = be, u.charCodeAt(be) === 95 ? (ot = vr, be++) : (ot = f, wt === 0 && Vt(ar)), ot !== f && (Or = Ee, ot = sr()), Ee = ot), Pt[Mt] = { nextPos: be, result: Ee }, Ee);
            }
            function Je() {
              var Ee, ot = 49 * be + 45, Mt = Pt[ot];
              return Mt ? (be = Mt.nextPos, Mt.result) : (gr.test(u.charAt(be)) ? (Ee = u.charAt(be), be++) : (Ee = f, wt === 0 && Vt(Tr)), Pt[ot] = { nextPos: be, result: Ee }, Ee);
            }
            function Ut() {
              var Ee, ot, Mt, gt = 49 * be + 46, Rt = Pt[gt];
              if (Rt) return be = Rt.nextPos, Rt.result;
              if (Ee = be, ot = [], (Mt = Re()) !== f) for (; Mt !== f; ) ot.push(Mt), Mt = Re();
              else ot = a;
              return ot !== f && (Or = Ee, ot = Mr(ot)), Ee = ot, Pt[gt] = { nextPos: be, result: Ee }, Ee;
            }
            function _t() {
              var Ee, ot, Mt = 49 * be + 47, gt = Pt[Mt];
              return gt ? (be = gt.nextPos, gt.result) : (Ee = be, u.substr(be, 2) === Nr ? (ot = Nr, be += 2) : (ot = f, wt === 0 && Vt(Lr)), ot !== f && (Or = Ee, ot = jr()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === Hr ? (ot = Hr, be += 2) : (ot = f, wt === 0 && Vt(kr)), ot !== f && (Or = Ee, ot = Xt()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === Qt ? (ot = Qt, be += 2) : (ot = f, wt === 0 && Vt(br)), ot !== f && (Or = Ee, ot = we()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === me ? (ot = me, be += 2) : (ot = f, wt === 0 && Vt(ze)), ot !== f && (Or = Ee, ot = rt()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === Tt ? (ot = Tt, be += 2) : (ot = f, wt === 0 && Vt(Ot)), ot !== f && (Or = Ee, ot = It()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === We ? (ot = We, be += 2) : (ot = f, wt === 0 && Vt(mt)), ot !== f && (Or = Ee, ot = Gt()), (Ee = ot) === f && (Ee = be, u.substr(be, 2) === ir ? (ot = ir, be += 2) : (ot = f, wt === 0 && Vt(dr)), ot !== f && (Or = Ee, ot = hr()), (Ee = ot) === f && (Ee = function() {
                var Rt, or, nr, Qr, Xr, Yr, un, Kr, Ir, An, En, Sn = 49 * be + 48, On = Pt[Sn];
                return On ? (be = On.nextPos, On.result) : (Rt = be, u.substr(be, 2) === Fr ? (or = Fr, be += 2) : (or = f, wt === 0 && Vt(Gr)), or !== f ? (nr = be, (Qr = Ce()) !== f && (Xr = Ce()) !== f && (Yr = Ce()) !== f && (un = Ce()) !== f && (Kr = Ce()) !== f && (Ir = Ce()) !== f && (An = Ce()) !== f && (En = Ce()) !== f ? nr = Qr = [Qr, Xr, Yr, un, Kr, Ir, An, En] : (be = nr, nr = a), nr !== f ? (Or = Rt, Rt = or = Br(nr)) : (be = Rt, Rt = a)) : (be = Rt, Rt = a), Rt === f && (Rt = be, u.substr(be, 2) === Dr ? (or = Dr, be += 2) : (or = f, wt === 0 && Vt(Vr)), or !== f ? (nr = be, (Qr = Ce()) !== f && (Xr = Ce()) !== f && (Yr = Ce()) !== f && (un = Ce()) !== f ? nr = Qr = [Qr, Xr, Yr, un] : (be = nr, nr = a), nr !== f ? (Or = Rt, Rt = or = Br(nr)) : (be = Rt, Rt = a)) : (be = Rt, Rt = a)), Pt[Sn] = { nextPos: be, result: Rt }, Rt);
              }()))))))), Pt[Mt] = { nextPos: be, result: Ee }, Ee);
            }
            var Ht = [];
            function tr(Ee) {
              Ht.push(Ee);
            }
            function Sr(Ee, ot, Mt, gt, Rt) {
              var or = { type: Ee, value: ot, line: Mt(), column: gt() };
              return Rt && (or.key = Rt), or;
            }
            if ((c = m()) !== f && be === u.length) return c;
            throw c !== f && be < u.length && Vt({ type: "end", description: "end of input" }), zr(null, vt, dt);
          } };
        }();
      }, 5578: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.LiquidityPoolFeeV18 = void 0, o.getLiquidityPoolId = function(a) {
          var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (a !== "constant_product") throw new Error("liquidityPoolType is invalid");
          var d = l.assetA, b = l.assetB, S = l.fee;
          if (!(d && d instanceof r.Asset)) throw new Error("assetA is invalid");
          if (!(b && b instanceof r.Asset)) throw new Error("assetB is invalid");
          if (!S || S !== g) throw new Error("fee is invalid");
          if (r.Asset.compare(d, b) !== -1) throw new Error("Assets are not in lexicographic order");
          var E = f.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR(), R = new f.default.LiquidityPoolConstantProductParameters({ assetA: d.toXDRObject(), assetB: b.toXDRObject(), fee: S }).toXDR(), k = c.concat([E, R]);
          return (0, m.hash)(k);
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(1764), m = u(9152), g = o.LiquidityPoolFeeV18 = 30;
      }, 5680: (t, o, u) => {
        var c = u(5767);
        t.exports = function(h) {
          return !!c(h);
        };
      }, 5767: (t, o, u) => {
        var c = u(2682), h = u(9209), f = u(487), r = u(6556), m = u(5795), g = u(3628), a = r("Object.prototype.toString"), l = u(9092)(), d = typeof globalThis > "u" ? u.g : globalThis, b = h(), S = r("String.prototype.slice"), E = r("Array.prototype.indexOf", true) || function(k, w) {
          for (var F = 0; F < k.length; F += 1) if (k[F] === w) return F;
          return -1;
        }, R = { __proto__: null };
        c(b, l && m && g ? function(k) {
          var w = new d[k]();
          if (Symbol.toStringTag in w && g) {
            var F = g(w), I = m(F, Symbol.toStringTag);
            if (!I && F) {
              var q = g(F);
              I = m(q, Symbol.toStringTag);
            }
            R["$" + k] = f(I.get);
          }
        } : function(k) {
          var w = new d[k](), F = w.slice || w.set;
          F && (R["$" + k] = f(F));
        }), t.exports = function(k) {
          if (!k || typeof k != "object") return false;
          if (!l) {
            var w = S(a(k), 8, -1);
            return E(b, w) > -1 ? w : w === "Object" && function(F) {
              var I = false;
              return c(R, function(q, D) {
                if (!I) try {
                  q(F), I = S(D, 1);
                } catch {
                }
              }), I;
            }(k);
          }
          return m ? function(F) {
            var I = false;
            return c(R, function(q, D) {
              if (!I) try {
                "$" + q(F) === D && (I = S(D, 1));
              } catch {
              }
            }), I;
          }(k) : null;
        };
      }, 5795: (t, o, u) => {
        var c = u(6549);
        if (c) try {
          c([], "length");
        } catch {
          c = null;
        }
        t.exports = c;
      }, 5880: (t) => {
        t.exports = Math.pow;
      }, 5896: (t) => {
        function o(h, f) {
          c(h, f), u(h);
        }
        function u(h) {
          h._writableState && !h._writableState.emitClose || h._readableState && !h._readableState.emitClose || h.emit("close");
        }
        function c(h, f) {
          h.emit("error", f);
        }
        t.exports = { destroy: function(h, f) {
          var r = this, m = this._readableState && this._readableState.destroyed, g = this._writableState && this._writableState.destroyed;
          return m || g ? (f ? f(h) : h && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(c, this, h)) : process.nextTick(c, this, h)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(h || null, function(a) {
            !f && a ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(u, r) : (r._writableState.errorEmitted = true, process.nextTick(o, r, a)) : process.nextTick(o, r, a) : f ? (process.nextTick(u, r), f(a)) : process.nextTick(u, r);
          }), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
        }, errorOrDestroy: function(h, f) {
          var r = h._readableState, m = h._writableState;
          r && r.autoDestroy || m && m.autoDestroy ? h.destroy(f) : h.emit("error", f);
        } };
      }, 5976: (t, o, u) => {
        function c(pe) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Oe) {
            return typeof Oe;
          } : function(Oe) {
            return Oe && typeof Symbol == "function" && Oe.constructor === Symbol && Oe !== Symbol.prototype ? "symbol" : typeof Oe;
          }, c(pe);
        }
        function h(pe, Oe) {
          for (var xe = 0; xe < Oe.length; xe++) {
            var Ve = Oe[xe];
            Ve.enumerable = Ve.enumerable || false, Ve.configurable = true, "value" in Ve && (Ve.writable = true), Object.defineProperty(pe, f(Ve.key), Ve);
          }
        }
        function f(pe) {
          var Oe = function(xe, Ve) {
            if (c(xe) != "object" || !xe) return xe;
            var _e = xe[Symbol.toPrimitive];
            if (_e !== void 0) {
              var Be = _e.call(xe, Ve);
              if (c(Be) != "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(xe);
          }(pe, "string");
          return c(Oe) == "symbol" ? Oe : Oe + "";
        }
        function r(pe, Oe, xe) {
          return Oe = l(Oe), function(Ve, _e) {
            if (_e && (c(_e) == "object" || typeof _e == "function")) return _e;
            if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Be) {
              if (Be === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Be;
            }(Ve);
          }(pe, g() ? Reflect.construct(Oe, xe || [], l(pe).constructor) : Oe.apply(pe, xe));
        }
        function m(pe) {
          var Oe = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return m = function(xe) {
            if (xe === null || !function(_e) {
              try {
                return Function.toString.call(_e).indexOf("[native code]") !== -1;
              } catch {
                return typeof _e == "function";
              }
            }(xe)) return xe;
            if (typeof xe != "function") throw new TypeError("Super expression must either be null or a function");
            if (Oe !== void 0) {
              if (Oe.has(xe)) return Oe.get(xe);
              Oe.set(xe, Ve);
            }
            function Ve() {
              return function(_e, Be, Qe) {
                if (g()) return Reflect.construct.apply(null, arguments);
                var ee = [null];
                ee.push.apply(ee, Be);
                var P = new (_e.bind.apply(_e, ee))();
                return Qe && a(P, Qe.prototype), P;
              }(xe, arguments, l(this).constructor);
            }
            return Ve.prototype = Object.create(xe.prototype, { constructor: { value: Ve, enumerable: false, writable: true, configurable: true } }), a(Ve, xe);
          }, m(pe);
        }
        function g() {
          try {
            var pe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!pe;
          })();
        }
        function a(pe, Oe) {
          return a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ve) {
            return xe.__proto__ = Ve, xe;
          }, a(pe, Oe);
        }
        function l(pe) {
          return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Oe) {
            return Oe.__proto__ || Object.getPrototypeOf(Oe);
          }, l(pe);
        }
        u.d(o, { Cu: () => Te, v7: () => z, nS: () => ie, Dr: () => d, m_: () => I });
        var d = function(pe) {
          function Oe(Be, Qe) {
            var ee;
            (function(x, O) {
              if (!(x instanceof O)) throw new TypeError("Cannot call a class as a function");
            })(this, Oe);
            var P = (this instanceof Oe ? this.constructor : void 0).prototype;
            return (ee = r(this, Oe, [Be])).__proto__ = P, ee.constructor = Oe, ee.response = Qe, ee;
          }
          return function(Be, Qe) {
            if (typeof Qe != "function" && Qe !== null) throw new TypeError("Super expression must either be null or a function");
            Be.prototype = Object.create(Qe && Qe.prototype, { constructor: { value: Be, writable: true, configurable: true } }), Object.defineProperty(Be, "prototype", { writable: false }), Qe && a(Be, Qe);
          }(Oe, pe), xe = Oe, (Ve = [{ key: "getResponse", value: function() {
            return this.response;
          } }]) && h(xe.prototype, Ve), _e && h(xe, _e), Object.defineProperty(xe, "prototype", { writable: false }), xe;
          var xe, Ve, _e;
        }(m(Error));
        function b(pe) {
          return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Oe) {
            return typeof Oe;
          } : function(Oe) {
            return Oe && typeof Symbol == "function" && Oe.constructor === Symbol && Oe !== Symbol.prototype ? "symbol" : typeof Oe;
          }, b(pe);
        }
        function S(pe, Oe) {
          for (var xe = 0; xe < Oe.length; xe++) {
            var Ve = Oe[xe];
            Ve.enumerable = Ve.enumerable || false, Ve.configurable = true, "value" in Ve && (Ve.writable = true), Object.defineProperty(pe, E(Ve.key), Ve);
          }
        }
        function E(pe) {
          var Oe = function(xe, Ve) {
            if (b(xe) != "object" || !xe) return xe;
            var _e = xe[Symbol.toPrimitive];
            if (_e !== void 0) {
              var Be = _e.call(xe, Ve);
              if (b(Be) != "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(xe);
          }(pe, "string");
          return b(Oe) == "symbol" ? Oe : Oe + "";
        }
        function R(pe, Oe, xe) {
          return Oe = w(Oe), function(Ve, _e) {
            if (_e && (b(_e) == "object" || typeof _e == "function")) return _e;
            if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Be) {
              if (Be === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Be;
            }(Ve);
          }(pe, k() ? Reflect.construct(Oe, xe || [], w(pe).constructor) : Oe.apply(pe, xe));
        }
        function k() {
          try {
            var pe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (k = function() {
            return !!pe;
          })();
        }
        function w(pe) {
          return w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Oe) {
            return Oe.__proto__ || Object.getPrototypeOf(Oe);
          }, w(pe);
        }
        function F(pe, Oe) {
          return F = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ve) {
            return xe.__proto__ = Ve, xe;
          }, F(pe, Oe);
        }
        var I = function(pe) {
          function Oe(Be, Qe) {
            var ee;
            (function(x, O) {
              if (!(x instanceof O)) throw new TypeError("Cannot call a class as a function");
            })(this, Oe);
            var P = (this instanceof Oe ? this.constructor : void 0).prototype;
            return (ee = R(this, Oe, [Be, Qe])).__proto__ = P, ee.constructor = Oe, ee.name = "NotFoundError", ee;
          }
          return function(Be, Qe) {
            if (typeof Qe != "function" && Qe !== null) throw new TypeError("Super expression must either be null or a function");
            Be.prototype = Object.create(Qe && Qe.prototype, { constructor: { value: Be, writable: true, configurable: true } }), Object.defineProperty(Be, "prototype", { writable: false }), Qe && F(Be, Qe);
          }(Oe, pe), xe = Oe, Ve && S(xe.prototype, Ve), _e && S(xe, _e), Object.defineProperty(xe, "prototype", { writable: false }), xe;
          var xe, Ve, _e;
        }(d);
        function q(pe) {
          return q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Oe) {
            return typeof Oe;
          } : function(Oe) {
            return Oe && typeof Symbol == "function" && Oe.constructor === Symbol && Oe !== Symbol.prototype ? "symbol" : typeof Oe;
          }, q(pe);
        }
        function D(pe, Oe) {
          for (var xe = 0; xe < Oe.length; xe++) {
            var Ve = Oe[xe];
            Ve.enumerable = Ve.enumerable || false, Ve.configurable = true, "value" in Ve && (Ve.writable = true), Object.defineProperty(pe, H(Ve.key), Ve);
          }
        }
        function H(pe) {
          var Oe = function(xe, Ve) {
            if (q(xe) != "object" || !xe) return xe;
            var _e = xe[Symbol.toPrimitive];
            if (_e !== void 0) {
              var Be = _e.call(xe, Ve);
              if (q(Be) != "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(xe);
          }(pe, "string");
          return q(Oe) == "symbol" ? Oe : Oe + "";
        }
        function _(pe, Oe, xe) {
          return Oe = L(Oe), function(Ve, _e) {
            if (_e && (q(_e) == "object" || typeof _e == "function")) return _e;
            if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Be) {
              if (Be === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Be;
            }(Ve);
          }(pe, T() ? Reflect.construct(Oe, xe || [], L(pe).constructor) : Oe.apply(pe, xe));
        }
        function T() {
          try {
            var pe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (T = function() {
            return !!pe;
          })();
        }
        function L(pe) {
          return L = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Oe) {
            return Oe.__proto__ || Object.getPrototypeOf(Oe);
          }, L(pe);
        }
        function j(pe, Oe) {
          return j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ve) {
            return xe.__proto__ = Ve, xe;
          }, j(pe, Oe);
        }
        var z = function(pe) {
          function Oe(Be, Qe) {
            var ee;
            (function(x, O) {
              if (!(x instanceof O)) throw new TypeError("Cannot call a class as a function");
            })(this, Oe);
            var P = (this instanceof Oe ? this.constructor : void 0).prototype;
            return (ee = _(this, Oe, [Be, Qe])).__proto__ = P, ee.constructor = Oe, ee.name = "BadRequestError", ee;
          }
          return function(Be, Qe) {
            if (typeof Qe != "function" && Qe !== null) throw new TypeError("Super expression must either be null or a function");
            Be.prototype = Object.create(Qe && Qe.prototype, { constructor: { value: Be, writable: true, configurable: true } }), Object.defineProperty(Be, "prototype", { writable: false }), Qe && j(Be, Qe);
          }(Oe, pe), xe = Oe, Ve && D(xe.prototype, Ve), _e && D(xe, _e), Object.defineProperty(xe, "prototype", { writable: false }), xe;
          var xe, Ve, _e;
        }(d);
        function Y(pe) {
          return Y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Oe) {
            return typeof Oe;
          } : function(Oe) {
            return Oe && typeof Symbol == "function" && Oe.constructor === Symbol && Oe !== Symbol.prototype ? "symbol" : typeof Oe;
          }, Y(pe);
        }
        function te(pe, Oe) {
          for (var xe = 0; xe < Oe.length; xe++) {
            var Ve = Oe[xe];
            Ve.enumerable = Ve.enumerable || false, Ve.configurable = true, "value" in Ve && (Ve.writable = true), Object.defineProperty(pe, G(Ve.key), Ve);
          }
        }
        function G(pe) {
          var Oe = function(xe, Ve) {
            if (Y(xe) != "object" || !xe) return xe;
            var _e = xe[Symbol.toPrimitive];
            if (_e !== void 0) {
              var Be = _e.call(xe, Ve);
              if (Y(Be) != "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(xe);
          }(pe, "string");
          return Y(Oe) == "symbol" ? Oe : Oe + "";
        }
        function K(pe, Oe, xe) {
          return Oe = B(Oe), function(Ve, _e) {
            if (_e && (Y(_e) == "object" || typeof _e == "function")) return _e;
            if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Be) {
              if (Be === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Be;
            }(Ve);
          }(pe, J() ? Reflect.construct(Oe, xe || [], B(pe).constructor) : Oe.apply(pe, xe));
        }
        function J() {
          try {
            var pe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (J = function() {
            return !!pe;
          })();
        }
        function B(pe) {
          return B = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Oe) {
            return Oe.__proto__ || Object.getPrototypeOf(Oe);
          }, B(pe);
        }
        function Z(pe, Oe) {
          return Z = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ve) {
            return xe.__proto__ = Ve, xe;
          }, Z(pe, Oe);
        }
        var ie = function(pe) {
          function Oe(Be, Qe) {
            var ee;
            (function(x, O) {
              if (!(x instanceof O)) throw new TypeError("Cannot call a class as a function");
            })(this, Oe);
            var P = (this instanceof Oe ? this.constructor : void 0).prototype;
            return (ee = K(this, Oe, [Be, Qe])).__proto__ = P, ee.constructor = Oe, ee.name = "BadResponseError", ee;
          }
          return function(Be, Qe) {
            if (typeof Qe != "function" && Qe !== null) throw new TypeError("Super expression must either be null or a function");
            Be.prototype = Object.create(Qe && Qe.prototype, { constructor: { value: Be, writable: true, configurable: true } }), Object.defineProperty(Be, "prototype", { writable: false }), Qe && Z(Be, Qe);
          }(Oe, pe), xe = Oe, Ve && te(xe.prototype, Ve), _e && te(xe, _e), Object.defineProperty(xe, "prototype", { writable: false }), xe;
          var xe, Ve, _e;
        }(d);
        function $(pe) {
          return $ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Oe) {
            return typeof Oe;
          } : function(Oe) {
            return Oe && typeof Symbol == "function" && Oe.constructor === Symbol && Oe !== Symbol.prototype ? "symbol" : typeof Oe;
          }, $(pe);
        }
        function oe(pe, Oe) {
          for (var xe = 0; xe < Oe.length; xe++) {
            var Ve = Oe[xe];
            Ve.enumerable = Ve.enumerable || false, Ve.configurable = true, "value" in Ve && (Ve.writable = true), Object.defineProperty(pe, ce(Ve.key), Ve);
          }
        }
        function ce(pe) {
          var Oe = function(xe, Ve) {
            if ($(xe) != "object" || !xe) return xe;
            var _e = xe[Symbol.toPrimitive];
            if (_e !== void 0) {
              var Be = _e.call(xe, Ve);
              if ($(Be) != "object") return Be;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(xe);
          }(pe, "string");
          return $(Oe) == "symbol" ? Oe : Oe + "";
        }
        function ye(pe, Oe, xe) {
          return Oe = ge(Oe), function(Ve, _e) {
            if (_e && ($(_e) == "object" || typeof _e == "function")) return _e;
            if (_e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Be) {
              if (Be === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Be;
            }(Ve);
          }(pe, ue() ? Reflect.construct(Oe, xe || [], ge(pe).constructor) : Oe.apply(pe, xe));
        }
        function ae(pe) {
          var Oe = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return ae = function(xe) {
            if (xe === null || !function(_e) {
              try {
                return Function.toString.call(_e).indexOf("[native code]") !== -1;
              } catch {
                return typeof _e == "function";
              }
            }(xe)) return xe;
            if (typeof xe != "function") throw new TypeError("Super expression must either be null or a function");
            if (Oe !== void 0) {
              if (Oe.has(xe)) return Oe.get(xe);
              Oe.set(xe, Ve);
            }
            function Ve() {
              return function(_e, Be, Qe) {
                if (ue()) return Reflect.construct.apply(null, arguments);
                var ee = [null];
                ee.push.apply(ee, Be);
                var P = new (_e.bind.apply(_e, ee))();
                return Qe && ne(P, Qe.prototype), P;
              }(xe, arguments, ge(this).constructor);
            }
            return Ve.prototype = Object.create(xe.prototype, { constructor: { value: Ve, enumerable: false, writable: true, configurable: true } }), ne(Ve, xe);
          }, ae(pe);
        }
        function ue() {
          try {
            var pe = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (ue = function() {
            return !!pe;
          })();
        }
        function ne(pe, Oe) {
          return ne = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(xe, Ve) {
            return xe.__proto__ = Ve, xe;
          }, ne(pe, Oe);
        }
        function ge(pe) {
          return ge = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(Oe) {
            return Oe.__proto__ || Object.getPrototypeOf(Oe);
          }, ge(pe);
        }
        var Te = function(pe) {
          function Oe(Be, Qe, ee) {
            var P;
            (function(O, V) {
              if (!(O instanceof V)) throw new TypeError("Cannot call a class as a function");
            })(this, Oe);
            var x = (this instanceof Oe ? this.constructor : void 0).prototype;
            return (P = ye(this, Oe, [Be])).__proto__ = x, P.constructor = Oe, P.name = "AccountRequiresMemoError", P.accountId = Qe, P.operationIndex = ee, P;
          }
          return function(Be, Qe) {
            if (typeof Qe != "function" && Qe !== null) throw new TypeError("Super expression must either be null or a function");
            Be.prototype = Object.create(Qe && Qe.prototype, { constructor: { value: Be, writable: true, configurable: true } }), Object.defineProperty(Be, "prototype", { writable: false }), Qe && ne(Be, Qe);
          }(Oe, pe), xe = Oe, Ve && oe(xe.prototype, Ve), _e && oe(xe, _e), Object.defineProperty(xe, "prototype", { writable: false }), xe;
          var xe, Ve, _e;
        }(ae(Error));
      }, 6048: (t) => {
        var o = {};
        function u(h, f, r) {
          r || (r = Error);
          var m = function(g) {
            var a, l;
            function d(b, S, E) {
              return g.call(this, function(R, k, w) {
                return typeof f == "string" ? f : f(R, k, w);
              }(b, S, E)) || this;
            }
            return l = g, (a = d).prototype = Object.create(l.prototype), a.prototype.constructor = a, a.__proto__ = l, d;
          }(r);
          m.prototype.name = r.name, m.prototype.code = h, o[h] = m;
        }
        function c(h, f) {
          if (Array.isArray(h)) {
            var r = h.length;
            return h = h.map(function(m) {
              return String(m);
            }), r > 2 ? "one of ".concat(f, " ").concat(h.slice(0, r - 1).join(", "), ", or ") + h[r - 1] : r === 2 ? "one of ".concat(f, " ").concat(h[0], " or ").concat(h[1]) : "of ".concat(f, " ").concat(h[0]);
          }
          return "of ".concat(f, " ").concat(String(h));
        }
        u("ERR_INVALID_OPT_VALUE", function(h, f) {
          return 'The value "' + f + '" is invalid for option "' + h + '"';
        }, TypeError), u("ERR_INVALID_ARG_TYPE", function(h, f, r) {
          var m, g, a;
          if (typeof f == "string" && (g = "not ", f.substr(0, g.length) === g) ? (m = "must not be", f = f.replace(/^not /, "")) : m = "must be", function(d, b, S) {
            return (S === void 0 || S > d.length) && (S = d.length), d.substring(S - b.length, S) === b;
          }(h, " argument")) a = "The ".concat(h, " ").concat(m, " ").concat(c(f, "type"));
          else {
            var l = function(d, b, S) {
              return typeof S != "number" && (S = 0), !(S + b.length > d.length) && d.indexOf(b, S) !== -1;
            }(h, ".") ? "property" : "argument";
            a = 'The "'.concat(h, '" ').concat(l, " ").concat(m, " ").concat(c(f, "type"));
          }
          return a += ". Received type ".concat(typeof r);
        }, TypeError), u("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), u("ERR_METHOD_NOT_IMPLEMENTED", function(h) {
          return "The " + h + " method is not implemented";
        }), u("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), u("ERR_STREAM_DESTROYED", function(h) {
          return "Cannot call " + h + " after a stream was destroyed";
        }), u("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), u("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), u("ERR_STREAM_WRITE_AFTER_END", "write after end"), u("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), u("ERR_UNKNOWN_ENCODING", function(h) {
          return "Unknown encoding: " + h;
        }, TypeError), u("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.F = o;
      }, 6121: (t, o, u) => {
        u.r(o), u.d(o, { axiosClient: () => be, create: () => Or });
        var c = {};
        function h(Ue, it) {
          return function() {
            return Ue.apply(it, arguments);
          };
        }
        u.r(c), u.d(c, { hasBrowserEnv: () => de, hasStandardBrowserEnv: () => Ne, hasStandardBrowserWebWorkerEnv: () => ut, navigator: () => tt, origin: () => Ze });
        const { toString: f } = Object.prototype, { getPrototypeOf: r } = Object, m = (g = /* @__PURE__ */ Object.create(null), (Ue) => {
          const it = f.call(Ue);
          return g[it] || (g[it] = it.slice(8, -1).toLowerCase());
        });
        var g;
        const a = (Ue) => (Ue = Ue.toLowerCase(), (it) => m(it) === Ue), l = (Ue) => (it) => typeof it === Ue, { isArray: d } = Array, b = l("undefined"), S = a("ArrayBuffer"), E = l("string"), R = l("function"), k = l("number"), w = (Ue) => Ue !== null && typeof Ue == "object", F = (Ue) => {
          if (m(Ue) !== "object") return false;
          const it = r(Ue);
          return !(it !== null && it !== Object.prototype && Object.getPrototypeOf(it) !== null || Symbol.toStringTag in Ue || Symbol.iterator in Ue);
        }, I = a("Date"), q = a("File"), D = a("Blob"), H = a("FileList"), _ = a("URLSearchParams"), [T, L, j, z] = ["ReadableStream", "Request", "Response", "Headers"].map(a);
        function Y(Ue, it, { allOwnKeys: dt = false } = {}) {
          if (Ue == null) return;
          let vt, wt;
          if (typeof Ue != "object" && (Ue = [Ue]), d(Ue)) for (vt = 0, wt = Ue.length; vt < wt; vt++) it.call(null, Ue[vt], vt, Ue);
          else {
            const Pt = dt ? Object.getOwnPropertyNames(Ue) : Object.keys(Ue), Yt = Pt.length;
            let cr;
            for (vt = 0; vt < Yt; vt++) cr = Pt[vt], it.call(null, Ue[cr], cr, Ue);
          }
        }
        function te(Ue, it) {
          it = it.toLowerCase();
          const dt = Object.keys(Ue);
          let vt, wt = dt.length;
          for (; wt-- > 0; ) if (vt = dt[wt], it === vt.toLowerCase()) return vt;
          return null;
        }
        const G = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : vc, K = (Ue) => !b(Ue) && Ue !== G, J = (B = typeof Uint8Array < "u" && r(Uint8Array), (Ue) => B && Ue instanceof B);
        var B;
        const Z = a("HTMLFormElement"), ie = (({ hasOwnProperty: Ue }) => (it, dt) => Ue.call(it, dt))(Object.prototype), $ = a("RegExp"), oe = (Ue, it) => {
          const dt = Object.getOwnPropertyDescriptors(Ue), vt = {};
          Y(dt, (wt, Pt) => {
            let Yt;
            (Yt = it(wt, Pt, Ue)) !== false && (vt[Pt] = Yt || wt);
          }), Object.defineProperties(Ue, vt);
        }, ce = a("AsyncFunction"), ye = (ae = typeof setImmediate == "function", ue = R(G.postMessage), ae ? setImmediate : ue ? (ne = `axios@${Math.random()}`, ge = [], G.addEventListener("message", ({ source: Ue, data: it }) => {
          Ue === G && it === ne && ge.length && ge.shift()();
        }, false), (Ue) => {
          ge.push(Ue), G.postMessage(ne, "*");
        }) : (Ue) => setTimeout(Ue));
        var ae, ue, ne, ge;
        const Te = typeof queueMicrotask < "u" ? queueMicrotask.bind(G) : typeof process < "u" && process.nextTick || ye, pe = { isArray: d, isArrayBuffer: S, isBuffer: function(Ue) {
          return Ue !== null && !b(Ue) && Ue.constructor !== null && !b(Ue.constructor) && R(Ue.constructor.isBuffer) && Ue.constructor.isBuffer(Ue);
        }, isFormData: (Ue) => {
          let it;
          return Ue && (typeof FormData == "function" && Ue instanceof FormData || R(Ue.append) && ((it = m(Ue)) === "formdata" || it === "object" && R(Ue.toString) && Ue.toString() === "[object FormData]"));
        }, isArrayBufferView: function(Ue) {
          let it;
          return it = typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Ue) : Ue && Ue.buffer && S(Ue.buffer), it;
        }, isString: E, isNumber: k, isBoolean: (Ue) => Ue === true || Ue === false, isObject: w, isPlainObject: F, isReadableStream: T, isRequest: L, isResponse: j, isHeaders: z, isUndefined: b, isDate: I, isFile: q, isBlob: D, isRegExp: $, isFunction: R, isStream: (Ue) => w(Ue) && R(Ue.pipe), isURLSearchParams: _, isTypedArray: J, isFileList: H, forEach: Y, merge: function Ue() {
          const { caseless: it } = K(this) && this || {}, dt = {}, vt = (wt, Pt) => {
            const Yt = it && te(dt, Pt) || Pt;
            F(dt[Yt]) && F(wt) ? dt[Yt] = Ue(dt[Yt], wt) : F(wt) ? dt[Yt] = Ue({}, wt) : d(wt) ? dt[Yt] = wt.slice() : dt[Yt] = wt;
          };
          for (let wt = 0, Pt = arguments.length; wt < Pt; wt++) arguments[wt] && Y(arguments[wt], vt);
          return dt;
        }, extend: (Ue, it, dt, { allOwnKeys: vt } = {}) => (Y(it, (wt, Pt) => {
          dt && R(wt) ? Ue[Pt] = h(wt, dt) : Ue[Pt] = wt;
        }, { allOwnKeys: vt }), Ue), trim: (Ue) => Ue.trim ? Ue.trim() : Ue.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: (Ue) => (Ue.charCodeAt(0) === 65279 && (Ue = Ue.slice(1)), Ue), inherits: (Ue, it, dt, vt) => {
          Ue.prototype = Object.create(it.prototype, vt), Ue.prototype.constructor = Ue, Object.defineProperty(Ue, "super", { value: it.prototype }), dt && Object.assign(Ue.prototype, dt);
        }, toFlatObject: (Ue, it, dt, vt) => {
          let wt, Pt, Yt;
          const cr = {};
          if (it = it || {}, Ue == null) return it;
          do {
            for (wt = Object.getOwnPropertyNames(Ue), Pt = wt.length; Pt-- > 0; ) Yt = wt[Pt], vt && !vt(Yt, Ue, it) || cr[Yt] || (it[Yt] = Ue[Yt], cr[Yt] = true);
            Ue = dt !== false && r(Ue);
          } while (Ue && (!dt || dt(Ue, it)) && Ue !== Object.prototype);
          return it;
        }, kindOf: m, kindOfTest: a, endsWith: (Ue, it, dt) => {
          Ue = String(Ue), (dt === void 0 || dt > Ue.length) && (dt = Ue.length), dt -= it.length;
          const vt = Ue.indexOf(it, dt);
          return vt !== -1 && vt === dt;
        }, toArray: (Ue) => {
          if (!Ue) return null;
          if (d(Ue)) return Ue;
          let it = Ue.length;
          if (!k(it)) return null;
          const dt = new Array(it);
          for (; it-- > 0; ) dt[it] = Ue[it];
          return dt;
        }, forEachEntry: (Ue, it) => {
          const dt = (Ue && Ue[Symbol.iterator]).call(Ue);
          let vt;
          for (; (vt = dt.next()) && !vt.done; ) {
            const wt = vt.value;
            it.call(Ue, wt[0], wt[1]);
          }
        }, matchAll: (Ue, it) => {
          let dt;
          const vt = [];
          for (; (dt = Ue.exec(it)) !== null; ) vt.push(dt);
          return vt;
        }, isHTMLForm: Z, hasOwnProperty: ie, hasOwnProp: ie, reduceDescriptors: oe, freezeMethods: (Ue) => {
          oe(Ue, (it, dt) => {
            if (R(Ue) && ["arguments", "caller", "callee"].indexOf(dt) !== -1) return false;
            const vt = Ue[dt];
            R(vt) && (it.enumerable = false, "writable" in it ? it.writable = false : it.set || (it.set = () => {
              throw Error("Can not rewrite read-only method '" + dt + "'");
            }));
          });
        }, toObjectSet: (Ue, it) => {
          const dt = {}, vt = (wt) => {
            wt.forEach((Pt) => {
              dt[Pt] = true;
            });
          };
          return d(Ue) ? vt(Ue) : vt(String(Ue).split(it)), dt;
        }, toCamelCase: (Ue) => Ue.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(it, dt, vt) {
          return dt.toUpperCase() + vt;
        }), noop: () => {
        }, toFiniteNumber: (Ue, it) => Ue != null && Number.isFinite(Ue = +Ue) ? Ue : it, findKey: te, global: G, isContextDefined: K, isSpecCompliantForm: function(Ue) {
          return !!(Ue && R(Ue.append) && Ue[Symbol.toStringTag] === "FormData" && Ue[Symbol.iterator]);
        }, toJSONObject: (Ue) => {
          const it = new Array(10), dt = (vt, wt) => {
            if (w(vt)) {
              if (it.indexOf(vt) >= 0) return;
              if (!("toJSON" in vt)) {
                it[wt] = vt;
                const Pt = d(vt) ? [] : {};
                return Y(vt, (Yt, cr) => {
                  const qr = dt(Yt, wt + 1);
                  !b(qr) && (Pt[cr] = qr);
                }), it[wt] = void 0, Pt;
              }
            }
            return vt;
          };
          return dt(Ue, 0);
        }, isAsyncFn: ce, isThenable: (Ue) => Ue && (w(Ue) || R(Ue)) && R(Ue.then) && R(Ue.catch), setImmediate: ye, asap: Te };
        function Oe(Ue, it, dt, vt, wt) {
          Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = Ue, this.name = "AxiosError", it && (this.code = it), dt && (this.config = dt), vt && (this.request = vt), wt && (this.response = wt, this.status = wt.status ? wt.status : null);
        }
        pe.inherits(Oe, Error, { toJSON: function() {
          return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: pe.toJSONObject(this.config), code: this.code, status: this.status };
        } });
        const xe = Oe.prototype, Ve = {};
        ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((Ue) => {
          Ve[Ue] = { value: Ue };
        }), Object.defineProperties(Oe, Ve), Object.defineProperty(xe, "isAxiosError", { value: true }), Oe.from = (Ue, it, dt, vt, wt, Pt) => {
          const Yt = Object.create(xe);
          return pe.toFlatObject(Ue, Yt, function(cr) {
            return cr !== Error.prototype;
          }, (cr) => cr !== "isAxiosError"), Oe.call(Yt, Ue.message, it, dt, vt, wt), Yt.cause = Ue, Yt.name = Ue.name, Pt && Object.assign(Yt, Pt), Yt;
        };
        const _e = Oe;
        var Be = u(8287).Buffer;
        function Qe(Ue) {
          return pe.isPlainObject(Ue) || pe.isArray(Ue);
        }
        function ee(Ue) {
          return pe.endsWith(Ue, "[]") ? Ue.slice(0, -2) : Ue;
        }
        function P(Ue, it, dt) {
          return Ue ? Ue.concat(it).map(function(vt, wt) {
            return vt = ee(vt), !dt && wt ? "[" + vt + "]" : vt;
          }).join(dt ? "." : "") : it;
        }
        const x = pe.toFlatObject(pe, {}, null, function(Ue) {
          return /^is[A-Z]/.test(Ue);
        }), O = function(Ue, it, dt) {
          if (!pe.isObject(Ue)) throw new TypeError("target must be an object");
          it = it || new FormData();
          const vt = (dt = pe.toFlatObject(dt, { metaTokens: true, dots: false, indexes: false }, false, function(Me, De) {
            return !pe.isUndefined(De[Me]);
          })).metaTokens, wt = dt.visitor || Vt, Pt = dt.dots, Yt = dt.indexes, cr = (dt.Blob || typeof Blob < "u" && Blob) && pe.isSpecCompliantForm(it);
          if (!pe.isFunction(wt)) throw new TypeError("visitor must be a function");
          function qr(Me) {
            if (Me === null) return "";
            if (pe.isDate(Me)) return Me.toISOString();
            if (!cr && pe.isBlob(Me)) throw new _e("Blob is not supported. Use a Buffer instead.");
            return pe.isArrayBuffer(Me) || pe.isTypedArray(Me) ? cr && typeof Blob == "function" ? new Blob([Me]) : Be.from(Me) : Me;
          }
          function Vt(Me, De, Ke) {
            let Bt = Me;
            if (Me && !Ke && typeof Me == "object") {
              if (pe.endsWith(De, "{}")) De = vt ? De : De.slice(0, -2), Me = JSON.stringify(Me);
              else if (pe.isArray(Me) && function(St) {
                return pe.isArray(St) && !St.some(Qe);
              }(Me) || (pe.isFileList(Me) || pe.endsWith(De, "[]")) && (Bt = pe.toArray(Me))) return De = ee(De), Bt.forEach(function(St, ur) {
                !pe.isUndefined(St) && St !== null && it.append(Yt === true ? P([De], ur, Pt) : Yt === null ? De : De + "[]", qr(St));
              }), false;
            }
            return !!Qe(Me) || (it.append(P(Ke, De, Pt), qr(Me)), false);
          }
          const zr = [], en = Object.assign(x, { defaultVisitor: Vt, convertValue: qr, isVisitable: Qe });
          if (!pe.isObject(Ue)) throw new TypeError("data must be an object");
          return function Me(De, Ke) {
            if (!pe.isUndefined(De)) {
              if (zr.indexOf(De) !== -1) throw Error("Circular reference detected in " + Ke.join("."));
              zr.push(De), pe.forEach(De, function(Bt, St) {
                (!(pe.isUndefined(Bt) || Bt === null) && wt.call(it, Bt, pe.isString(St) ? St.trim() : St, Ke, en)) === true && Me(Bt, Ke ? Ke.concat(St) : [St]);
              }), zr.pop();
            }
          }(Ue), it;
        };
        function V(Ue) {
          const it = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
          return encodeURIComponent(Ue).replace(/[!'()~]|%20|%00/g, function(dt) {
            return it[dt];
          });
        }
        function N(Ue, it) {
          this._pairs = [], Ue && O(Ue, this, it);
        }
        const C = N.prototype;
        C.append = function(Ue, it) {
          this._pairs.push([Ue, it]);
        }, C.toString = function(Ue) {
          const it = Ue ? function(dt) {
            return Ue.call(this, dt, V);
          } : V;
          return this._pairs.map(function(dt) {
            return it(dt[0]) + "=" + it(dt[1]);
          }, "").join("&");
        };
        const p = N;
        function A(Ue) {
          return encodeURIComponent(Ue).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        }
        function U(Ue, it, dt) {
          if (!it) return Ue;
          const vt = dt && dt.encode || A;
          pe.isFunction(dt) && (dt = { serialize: dt });
          const wt = dt && dt.serialize;
          let Pt;
          if (Pt = wt ? wt(it, dt) : pe.isURLSearchParams(it) ? it.toString() : new p(it, dt).toString(vt), Pt) {
            const Yt = Ue.indexOf("#");
            Yt !== -1 && (Ue = Ue.slice(0, Yt)), Ue += (Ue.indexOf("?") === -1 ? "?" : "&") + Pt;
          }
          return Ue;
        }
        const Q = class {
          constructor() {
            this.handlers = [];
          }
          use(Ue, it, dt) {
            return this.handlers.push({ fulfilled: Ue, rejected: it, synchronous: !!dt && dt.synchronous, runWhen: dt ? dt.runWhen : null }), this.handlers.length - 1;
          }
          eject(Ue) {
            this.handlers[Ue] && (this.handlers[Ue] = null);
          }
          clear() {
            this.handlers && (this.handlers = []);
          }
          forEach(Ue) {
            pe.forEach(this.handlers, function(it) {
              it !== null && Ue(it);
            });
          }
        }, se = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, X = { isBrowser: true, classes: { URLSearchParams: typeof URLSearchParams < "u" ? URLSearchParams : p, FormData: typeof FormData < "u" ? FormData : null, Blob: typeof Blob < "u" ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, de = typeof window < "u" && typeof document < "u", tt = typeof navigator == "object" && navigator || void 0, Ne = de && (!tt || ["ReactNative", "NativeScript", "NS"].indexOf(tt.product) < 0), ut = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Ze = de && window.location.href || "http://localhost", Et = { ...c, ...X }, rr = function(Ue) {
          function it(dt, vt, wt, Pt) {
            let Yt = dt[Pt++];
            if (Yt === "__proto__") return true;
            const cr = Number.isFinite(+Yt), qr = Pt >= dt.length;
            return Yt = !Yt && pe.isArray(wt) ? wt.length : Yt, qr ? (pe.hasOwnProp(wt, Yt) ? wt[Yt] = [wt[Yt], vt] : wt[Yt] = vt, !cr) : (wt[Yt] && pe.isObject(wt[Yt]) || (wt[Yt] = []), it(dt, vt, wt[Yt], Pt) && pe.isArray(wt[Yt]) && (wt[Yt] = function(Vt) {
              const zr = {}, en = Object.keys(Vt);
              let Me;
              const De = en.length;
              let Ke;
              for (Me = 0; Me < De; Me++) Ke = en[Me], zr[Ke] = Vt[Ke];
              return zr;
            }(wt[Yt])), !cr);
          }
          if (pe.isFormData(Ue) && pe.isFunction(Ue.entries)) {
            const dt = {};
            return pe.forEachEntry(Ue, (vt, wt) => {
              it(function(Pt) {
                return pe.matchAll(/\w+|\[(\w*)]/g, Pt).map((Yt) => Yt[0] === "[]" ? "" : Yt[1] || Yt[0]);
              }(vt), wt, dt, 0);
            }), dt;
          }
          return null;
        }, je = { transitional: se, adapter: ["xhr", "http", "fetch"], transformRequest: [function(Ue, it) {
          const dt = it.getContentType() || "", vt = dt.indexOf("application/json") > -1, wt = pe.isObject(Ue);
          if (wt && pe.isHTMLForm(Ue) && (Ue = new FormData(Ue)), pe.isFormData(Ue)) return vt ? JSON.stringify(rr(Ue)) : Ue;
          if (pe.isArrayBuffer(Ue) || pe.isBuffer(Ue) || pe.isStream(Ue) || pe.isFile(Ue) || pe.isBlob(Ue) || pe.isReadableStream(Ue)) return Ue;
          if (pe.isArrayBufferView(Ue)) return Ue.buffer;
          if (pe.isURLSearchParams(Ue)) return it.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), Ue.toString();
          let Pt;
          if (wt) {
            if (dt.indexOf("application/x-www-form-urlencoded") > -1) return function(Yt, cr) {
              return O(Yt, new Et.classes.URLSearchParams(), Object.assign({ visitor: function(qr, Vt, zr, en) {
                return Et.isNode && pe.isBuffer(qr) ? (this.append(Vt, qr.toString("base64")), false) : en.defaultVisitor.apply(this, arguments);
              } }, cr));
            }(Ue, this.formSerializer).toString();
            if ((Pt = pe.isFileList(Ue)) || dt.indexOf("multipart/form-data") > -1) {
              const Yt = this.env && this.env.FormData;
              return O(Pt ? { "files[]": Ue } : Ue, Yt && new Yt(), this.formSerializer);
            }
          }
          return wt || vt ? (it.setContentType("application/json", false), function(Yt, cr, qr) {
            if (pe.isString(Yt)) try {
              return (cr || JSON.parse)(Yt), pe.trim(Yt);
            } catch (Vt) {
              if (Vt.name !== "SyntaxError") throw Vt;
            }
            return (qr || JSON.stringify)(Yt);
          }(Ue)) : Ue;
        }], transformResponse: [function(Ue) {
          const it = this.transitional || je.transitional, dt = it && it.forcedJSONParsing, vt = this.responseType === "json";
          if (pe.isResponse(Ue) || pe.isReadableStream(Ue)) return Ue;
          if (Ue && pe.isString(Ue) && (dt && !this.responseType || vt)) {
            const wt = !(it && it.silentJSONParsing) && vt;
            try {
              return JSON.parse(Ue);
            } catch (Pt) {
              if (wt) throw Pt.name === "SyntaxError" ? _e.from(Pt, _e.ERR_BAD_RESPONSE, this, null, this.response) : Pt;
            }
          }
          return Ue;
        }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Et.classes.FormData, Blob: Et.classes.Blob }, validateStatus: function(Ue) {
          return Ue >= 200 && Ue < 300;
        }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
        pe.forEach(["delete", "get", "head", "post", "put", "patch"], (Ue) => {
          je.headers[Ue] = {};
        });
        const Ge = je, at = pe.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Ae = Symbol("internals");
        function qe(Ue) {
          return Ue && String(Ue).trim().toLowerCase();
        }
        function Ft(Ue) {
          return Ue === false || Ue == null ? Ue : pe.isArray(Ue) ? Ue.map(Ft) : String(Ue);
        }
        function Dt(Ue, it, dt, vt, wt) {
          return pe.isFunction(vt) ? vt.call(this, it, dt) : (wt && (it = dt), pe.isString(it) ? pe.isString(vt) ? it.indexOf(vt) !== -1 : pe.isRegExp(vt) ? vt.test(it) : void 0 : void 0);
        }
        class wr {
          constructor(it) {
            it && this.set(it);
          }
          set(it, dt, vt) {
            const wt = this;
            function Pt(cr, qr, Vt) {
              const zr = qe(qr);
              if (!zr) throw new Error("header name must be a non-empty string");
              const en = pe.findKey(wt, zr);
              (!en || wt[en] === void 0 || Vt === true || Vt === void 0 && wt[en] !== false) && (wt[en || qr] = Ft(cr));
            }
            const Yt = (cr, qr) => pe.forEach(cr, (Vt, zr) => Pt(Vt, zr, qr));
            if (pe.isPlainObject(it) || it instanceof this.constructor) Yt(it, dt);
            else if (pe.isString(it) && (it = it.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(it.trim())) Yt(((cr) => {
              const qr = {};
              let Vt, zr, en;
              return cr && cr.split(`
`).forEach(function(Me) {
                en = Me.indexOf(":"), Vt = Me.substring(0, en).trim().toLowerCase(), zr = Me.substring(en + 1).trim(), !Vt || qr[Vt] && at[Vt] || (Vt === "set-cookie" ? qr[Vt] ? qr[Vt].push(zr) : qr[Vt] = [zr] : qr[Vt] = qr[Vt] ? qr[Vt] + ", " + zr : zr);
              }), qr;
            })(it), dt);
            else if (pe.isHeaders(it)) for (const [cr, qr] of it.entries()) Pt(qr, cr, vt);
            else it != null && Pt(dt, it, vt);
            return this;
          }
          get(it, dt) {
            if (it = qe(it)) {
              const vt = pe.findKey(this, it);
              if (vt) {
                const wt = this[vt];
                if (!dt) return wt;
                if (dt === true) return function(Pt) {
                  const Yt = /* @__PURE__ */ Object.create(null), cr = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let qr;
                  for (; qr = cr.exec(Pt); ) Yt[qr[1]] = qr[2];
                  return Yt;
                }(wt);
                if (pe.isFunction(dt)) return dt.call(this, wt, vt);
                if (pe.isRegExp(dt)) return dt.exec(wt);
                throw new TypeError("parser must be boolean|regexp|function");
              }
            }
          }
          has(it, dt) {
            if (it = qe(it)) {
              const vt = pe.findKey(this, it);
              return !(!vt || this[vt] === void 0 || dt && !Dt(0, this[vt], vt, dt));
            }
            return false;
          }
          delete(it, dt) {
            const vt = this;
            let wt = false;
            function Pt(Yt) {
              if (Yt = qe(Yt)) {
                const cr = pe.findKey(vt, Yt);
                !cr || dt && !Dt(0, vt[cr], cr, dt) || (delete vt[cr], wt = true);
              }
            }
            return pe.isArray(it) ? it.forEach(Pt) : Pt(it), wt;
          }
          clear(it) {
            const dt = Object.keys(this);
            let vt = dt.length, wt = false;
            for (; vt--; ) {
              const Pt = dt[vt];
              it && !Dt(0, this[Pt], Pt, it, true) || (delete this[Pt], wt = true);
            }
            return wt;
          }
          normalize(it) {
            const dt = this, vt = {};
            return pe.forEach(this, (wt, Pt) => {
              const Yt = pe.findKey(vt, Pt);
              if (Yt) return dt[Yt] = Ft(wt), void delete dt[Pt];
              const cr = it ? function(qr) {
                return qr.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (Vt, zr, en) => zr.toUpperCase() + en);
              }(Pt) : String(Pt).trim();
              cr !== Pt && delete dt[Pt], dt[cr] = Ft(wt), vt[cr] = true;
            }), this;
          }
          concat(...it) {
            return this.constructor.concat(this, ...it);
          }
          toJSON(it) {
            const dt = /* @__PURE__ */ Object.create(null);
            return pe.forEach(this, (vt, wt) => {
              vt != null && vt !== false && (dt[wt] = it && pe.isArray(vt) ? vt.join(", ") : vt);
            }), dt;
          }
          [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]();
          }
          toString() {
            return Object.entries(this.toJSON()).map(([it, dt]) => it + ": " + dt).join(`
`);
          }
          get [Symbol.toStringTag]() {
            return "AxiosHeaders";
          }
          static from(it) {
            return it instanceof this ? it : new this(it);
          }
          static concat(it, ...dt) {
            const vt = new this(it);
            return dt.forEach((wt) => vt.set(wt)), vt;
          }
          static accessor(it) {
            const dt = (this[Ae] = this[Ae] = { accessors: {} }).accessors, vt = this.prototype;
            function wt(Pt) {
              const Yt = qe(Pt);
              dt[Yt] || (function(cr, qr) {
                const Vt = pe.toCamelCase(" " + qr);
                ["get", "set", "has"].forEach((zr) => {
                  Object.defineProperty(cr, zr + Vt, { value: function(en, Me, De) {
                    return this[zr].call(this, qr, en, Me, De);
                  }, configurable: true });
                });
              }(vt, Pt), dt[Yt] = true);
            }
            return pe.isArray(it) ? it.forEach(wt) : wt(it), this;
          }
        }
        wr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), pe.reduceDescriptors(wr.prototype, ({ value: Ue }, it) => {
          let dt = it[0].toUpperCase() + it.slice(1);
          return { get: () => Ue, set(vt) {
            this[dt] = vt;
          } };
        }), pe.freezeMethods(wr);
        const Nt = wr;
        function yr(Ue, it) {
          const dt = this || Ge, vt = it || dt, wt = Nt.from(vt.headers);
          let Pt = vt.data;
          return pe.forEach(Ue, function(Yt) {
            Pt = Yt.call(dt, Pt, wt.normalize(), it ? it.status : void 0);
          }), wt.normalize(), Pt;
        }
        function Ur(Ue) {
          return !(!Ue || !Ue.__CANCEL__);
        }
        function Pe(Ue, it, dt) {
          _e.call(this, Ue ?? "canceled", _e.ERR_CANCELED, it, dt), this.name = "CanceledError";
        }
        pe.inherits(Pe, _e, { __CANCEL__: true });
        const $e = Pe;
        function le(Ue, it, dt) {
          const vt = dt.config.validateStatus;
          dt.status && vt && !vt(dt.status) ? it(new _e("Request failed with status code " + dt.status, [_e.ERR_BAD_REQUEST, _e.ERR_BAD_RESPONSE][Math.floor(dt.status / 100) - 4], dt.config, dt.request, dt)) : Ue(dt);
        }
        const re = function(Ue, it) {
          Ue = Ue || 10;
          const dt = new Array(Ue), vt = new Array(Ue);
          let wt, Pt = 0, Yt = 0;
          return it = it !== void 0 ? it : 1e3, function(cr) {
            const qr = Date.now(), Vt = vt[Yt];
            wt || (wt = qr), dt[Pt] = cr, vt[Pt] = qr;
            let zr = Yt, en = 0;
            for (; zr !== Pt; ) en += dt[zr++], zr %= Ue;
            if (Pt = (Pt + 1) % Ue, Pt === Yt && (Yt = (Yt + 1) % Ue), qr - wt < it) return;
            const Me = Vt && qr - Vt;
            return Me ? Math.round(1e3 * en / Me) : void 0;
          };
        }, Le = function(Ue, it) {
          let dt, vt, wt = 0, Pt = 1e3 / it;
          const Yt = (cr, qr = Date.now()) => {
            wt = qr, dt = null, vt && (clearTimeout(vt), vt = null), Ue.apply(null, cr);
          };
          return [(...cr) => {
            const qr = Date.now(), Vt = qr - wt;
            Vt >= Pt ? Yt(cr, qr) : (dt = cr, vt || (vt = setTimeout(() => {
              vt = null, Yt(dt);
            }, Pt - Vt)));
          }, () => dt && Yt(dt)];
        }, nt = (Ue, it, dt = 3) => {
          let vt = 0;
          const wt = re(50, 250);
          return Le((Pt) => {
            const Yt = Pt.loaded, cr = Pt.lengthComputable ? Pt.total : void 0, qr = Yt - vt, Vt = wt(qr);
            vt = Yt, Ue({ loaded: Yt, total: cr, progress: cr ? Yt / cr : void 0, bytes: qr, rate: Vt || void 0, estimated: Vt && cr && Yt <= cr ? (cr - Yt) / Vt : void 0, event: Pt, lengthComputable: cr != null, [it ? "download" : "upload"]: true });
          }, dt);
        }, ft = (Ue, it) => {
          const dt = Ue != null;
          return [(vt) => it[0]({ lengthComputable: dt, total: Ue, loaded: vt }), it[1]];
        }, zt = (Ue) => (...it) => pe.asap(() => Ue(...it)), st = Et.hasStandardBrowserEnv ? /* @__PURE__ */ ((Ue, it) => (dt) => (dt = new URL(dt, Et.origin), Ue.protocol === dt.protocol && Ue.host === dt.host && (it || Ue.port === dt.port)))(new URL(Et.origin), Et.navigator && /(msie|trident)/i.test(Et.navigator.userAgent)) : () => true, ct = Et.hasStandardBrowserEnv ? { write(Ue, it, dt, vt, wt, Pt) {
          const Yt = [Ue + "=" + encodeURIComponent(it)];
          pe.isNumber(dt) && Yt.push("expires=" + new Date(dt).toGMTString()), pe.isString(vt) && Yt.push("path=" + vt), pe.isString(wt) && Yt.push("domain=" + wt), Pt === true && Yt.push("secure"), document.cookie = Yt.join("; ");
        }, read(Ue) {
          const it = document.cookie.match(new RegExp("(^|;\\s*)(" + Ue + ")=([^;]*)"));
          return it ? decodeURIComponent(it[3]) : null;
        }, remove(Ue) {
          this.write(Ue, "", Date.now() - 864e5);
        } } : { write() {
        }, read: () => null, remove() {
        } };
        function yt(Ue, it, dt) {
          let vt = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(it);
          return Ue && (vt || dt == 0) ? function(wt, Pt) {
            return Pt ? wt.replace(/\/?\/$/, "") + "/" + Pt.replace(/^\/+/, "") : wt;
          }(Ue, it) : it;
        }
        const Zt = (Ue) => Ue instanceof Nt ? { ...Ue } : Ue;
        function Ct(Ue, it) {
          it = it || {};
          const dt = {};
          function vt(Vt, zr, en, Me) {
            return pe.isPlainObject(Vt) && pe.isPlainObject(zr) ? pe.merge.call({ caseless: Me }, Vt, zr) : pe.isPlainObject(zr) ? pe.merge({}, zr) : pe.isArray(zr) ? zr.slice() : zr;
          }
          function wt(Vt, zr, en, Me) {
            return pe.isUndefined(zr) ? pe.isUndefined(Vt) ? void 0 : vt(void 0, Vt, 0, Me) : vt(Vt, zr, 0, Me);
          }
          function Pt(Vt, zr) {
            if (!pe.isUndefined(zr)) return vt(void 0, zr);
          }
          function Yt(Vt, zr) {
            return pe.isUndefined(zr) ? pe.isUndefined(Vt) ? void 0 : vt(void 0, Vt) : vt(void 0, zr);
          }
          function cr(Vt, zr, en) {
            return en in it ? vt(Vt, zr) : en in Ue ? vt(void 0, Vt) : void 0;
          }
          const qr = { url: Pt, method: Pt, data: Pt, baseURL: Yt, transformRequest: Yt, transformResponse: Yt, paramsSerializer: Yt, timeout: Yt, timeoutMessage: Yt, withCredentials: Yt, withXSRFToken: Yt, adapter: Yt, responseType: Yt, xsrfCookieName: Yt, xsrfHeaderName: Yt, onUploadProgress: Yt, onDownloadProgress: Yt, decompress: Yt, maxContentLength: Yt, maxBodyLength: Yt, beforeRedirect: Yt, transport: Yt, httpAgent: Yt, httpsAgent: Yt, cancelToken: Yt, socketPath: Yt, responseEncoding: Yt, validateStatus: cr, headers: (Vt, zr, en) => wt(Zt(Vt), Zt(zr), 0, true) };
          return pe.forEach(Object.keys(Object.assign({}, Ue, it)), function(Vt) {
            const zr = qr[Vt] || wt, en = zr(Ue[Vt], it[Vt], Vt);
            pe.isUndefined(en) && zr !== cr || (dt[Vt] = en);
          }), dt;
        }
        const Lt = (Ue) => {
          const it = Ct({}, Ue);
          let dt, { data: vt, withXSRFToken: wt, xsrfHeaderName: Pt, xsrfCookieName: Yt, headers: cr, auth: qr } = it;
          if (it.headers = cr = Nt.from(cr), it.url = U(yt(it.baseURL, it.url, it.allowAbsoluteUrls), Ue.params, Ue.paramsSerializer), qr && cr.set("Authorization", "Basic " + btoa((qr.username || "") + ":" + (qr.password ? unescape(encodeURIComponent(qr.password)) : ""))), pe.isFormData(vt)) {
            if (Et.hasStandardBrowserEnv || Et.hasStandardBrowserWebWorkerEnv) cr.setContentType(void 0);
            else if ((dt = cr.getContentType()) !== false) {
              const [Vt, ...zr] = dt ? dt.split(";").map((en) => en.trim()).filter(Boolean) : [];
              cr.setContentType([Vt || "multipart/form-data", ...zr].join("; "));
            }
          }
          if (Et.hasStandardBrowserEnv && (wt && pe.isFunction(wt) && (wt = wt(it)), wt || wt !== false && st(it.url))) {
            const Vt = Pt && Yt && ct.read(Yt);
            Vt && cr.set(Pt, Vt);
          }
          return it;
        }, Wt = typeof XMLHttpRequest < "u" && function(Ue) {
          return new Promise(function(it, dt) {
            const vt = Lt(Ue);
            let wt = vt.data;
            const Pt = Nt.from(vt.headers).normalize();
            let Yt, cr, qr, Vt, zr, { responseType: en, onUploadProgress: Me, onDownloadProgress: De } = vt;
            function Ke() {
              Vt && Vt(), zr && zr(), vt.cancelToken && vt.cancelToken.unsubscribe(Yt), vt.signal && vt.signal.removeEventListener("abort", Yt);
            }
            let Bt = new XMLHttpRequest();
            function St() {
              if (!Bt) return;
              const Cr = Nt.from("getAllResponseHeaders" in Bt && Bt.getAllResponseHeaders());
              le(function(Wr) {
                it(Wr), Ke();
              }, function(Wr) {
                dt(Wr), Ke();
              }, { data: en && en !== "text" && en !== "json" ? Bt.response : Bt.responseText, status: Bt.status, statusText: Bt.statusText, headers: Cr, config: Ue, request: Bt }), Bt = null;
            }
            Bt.open(vt.method.toUpperCase(), vt.url, true), Bt.timeout = vt.timeout, "onloadend" in Bt ? Bt.onloadend = St : Bt.onreadystatechange = function() {
              Bt && Bt.readyState === 4 && (Bt.status !== 0 || Bt.responseURL && Bt.responseURL.indexOf("file:") === 0) && setTimeout(St);
            }, Bt.onabort = function() {
              Bt && (dt(new _e("Request aborted", _e.ECONNABORTED, Ue, Bt)), Bt = null);
            }, Bt.onerror = function() {
              dt(new _e("Network Error", _e.ERR_NETWORK, Ue, Bt)), Bt = null;
            }, Bt.ontimeout = function() {
              let Cr = vt.timeout ? "timeout of " + vt.timeout + "ms exceeded" : "timeout exceeded";
              const Wr = vt.transitional || se;
              vt.timeoutErrorMessage && (Cr = vt.timeoutErrorMessage), dt(new _e(Cr, Wr.clarifyTimeoutError ? _e.ETIMEDOUT : _e.ECONNABORTED, Ue, Bt)), Bt = null;
            }, wt === void 0 && Pt.setContentType(null), "setRequestHeader" in Bt && pe.forEach(Pt.toJSON(), function(Cr, Wr) {
              Bt.setRequestHeader(Wr, Cr);
            }), pe.isUndefined(vt.withCredentials) || (Bt.withCredentials = !!vt.withCredentials), en && en !== "json" && (Bt.responseType = vt.responseType), De && ([qr, zr] = nt(De, true), Bt.addEventListener("progress", qr)), Me && Bt.upload && ([cr, Vt] = nt(Me), Bt.upload.addEventListener("progress", cr), Bt.upload.addEventListener("loadend", Vt)), (vt.cancelToken || vt.signal) && (Yt = (Cr) => {
              Bt && (dt(!Cr || Cr.type ? new $e(null, Ue, Bt) : Cr), Bt.abort(), Bt = null);
            }, vt.cancelToken && vt.cancelToken.subscribe(Yt), vt.signal && (vt.signal.aborted ? Yt() : vt.signal.addEventListener("abort", Yt)));
            const ur = function(Cr) {
              const Wr = /^([-+\w]{1,25})(:?\/\/|:)/.exec(Cr);
              return Wr && Wr[1] || "";
            }(vt.url);
            ur && Et.protocols.indexOf(ur) === -1 ? dt(new _e("Unsupported protocol " + ur + ":", _e.ERR_BAD_REQUEST, Ue)) : Bt.send(wt || null);
          });
        }, vr = (Ue, it) => {
          const { length: dt } = Ue = Ue ? Ue.filter(Boolean) : [];
          if (it || dt) {
            let vt, wt = new AbortController();
            const Pt = function(Vt) {
              if (!vt) {
                vt = true, cr();
                const zr = Vt instanceof Error ? Vt : this.reason;
                wt.abort(zr instanceof _e ? zr : new $e(zr instanceof Error ? zr.message : zr));
              }
            };
            let Yt = it && setTimeout(() => {
              Yt = null, Pt(new _e(`timeout ${it} of ms exceeded`, _e.ETIMEDOUT));
            }, it);
            const cr = () => {
              Ue && (Yt && clearTimeout(Yt), Yt = null, Ue.forEach((Vt) => {
                Vt.unsubscribe ? Vt.unsubscribe(Pt) : Vt.removeEventListener("abort", Pt);
              }), Ue = null);
            };
            Ue.forEach((Vt) => Vt.addEventListener("abort", Pt));
            const { signal: qr } = wt;
            return qr.unsubscribe = () => pe.asap(cr), qr;
          }
        }, ar = function* (Ue, it) {
          let dt = Ue.byteLength;
          if (dt < it) return void (yield Ue);
          let vt, wt = 0;
          for (; wt < dt; ) vt = wt + it, yield Ue.slice(wt, vt), wt = vt;
        }, sr = async function* (Ue) {
          if (Ue[Symbol.asyncIterator]) return void (yield* Ue);
          const it = Ue.getReader();
          try {
            for (; ; ) {
              const { done: dt, value: vt } = await it.read();
              if (dt) break;
              yield vt;
            }
          } finally {
            await it.cancel();
          }
        }, gr = (Ue, it, dt, vt) => {
          const wt = async function* (qr, Vt) {
            for await (const zr of sr(qr)) yield* ar(zr, Vt);
          }(Ue, it);
          let Pt, Yt = 0, cr = (qr) => {
            Pt || (Pt = true, vt && vt(qr));
          };
          return new ReadableStream({ async pull(qr) {
            try {
              const { done: Vt, value: zr } = await wt.next();
              if (Vt) return cr(), void qr.close();
              let en = zr.byteLength;
              if (dt) {
                let Me = Yt += en;
                dt(Me);
              }
              qr.enqueue(new Uint8Array(zr));
            } catch (Vt) {
              throw cr(Vt), Vt;
            }
          }, cancel: (qr) => (cr(qr), wt.return()) }, { highWaterMark: 2 });
        }, Tr = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Mr = Tr && typeof ReadableStream == "function", Nr = Tr && (typeof TextEncoder == "function" ? (Lr = new TextEncoder(), (Ue) => Lr.encode(Ue)) : async (Ue) => new Uint8Array(await new Response(Ue).arrayBuffer()));
        var Lr;
        const jr = (Ue, ...it) => {
          try {
            return !!Ue(...it);
          } catch {
            return false;
          }
        }, Hr = Mr && jr(() => {
          let Ue = false;
          const it = new Request(Et.origin, { body: new ReadableStream(), method: "POST", get duplex() {
            return Ue = true, "half";
          } }).headers.has("Content-Type");
          return Ue && !it;
        }), kr = Mr && jr(() => pe.isReadableStream(new Response("").body)), Xt = { stream: kr && ((Ue) => Ue.body) };
        var Qt;
        Tr && (Qt = new Response(), ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((Ue) => {
          !Xt[Ue] && (Xt[Ue] = pe.isFunction(Qt[Ue]) ? (it) => it[Ue]() : (it, dt) => {
            throw new _e(`Response type '${Ue}' is not supported`, _e.ERR_NOT_SUPPORT, dt);
          });
        }));
        const br = async (Ue, it) => {
          const dt = pe.toFiniteNumber(Ue.getContentLength());
          return dt ?? (async (vt) => vt == null ? 0 : pe.isBlob(vt) ? vt.size : pe.isSpecCompliantForm(vt) ? (await new Request(Et.origin, { method: "POST", body: vt }).arrayBuffer()).byteLength : pe.isArrayBufferView(vt) || pe.isArrayBuffer(vt) ? vt.byteLength : (pe.isURLSearchParams(vt) && (vt += ""), pe.isString(vt) ? (await Nr(vt)).byteLength : void 0))(it);
        }, we = { http: null, xhr: Wt, fetch: Tr && (async (Ue) => {
          let { url: it, method: dt, data: vt, signal: wt, cancelToken: Pt, timeout: Yt, onDownloadProgress: cr, onUploadProgress: qr, responseType: Vt, headers: zr, withCredentials: en = "same-origin", fetchOptions: Me } = Lt(Ue);
          Vt = Vt ? (Vt + "").toLowerCase() : "text";
          let De, Ke = vr([wt, Pt && Pt.toAbortSignal()], Yt);
          const Bt = Ke && Ke.unsubscribe && (() => {
            Ke.unsubscribe();
          });
          let St;
          try {
            if (qr && Hr && dt !== "get" && dt !== "head" && (St = await br(zr, vt)) !== 0) {
              let dn, wn = new Request(it, { method: "POST", body: vt, duplex: "half" });
              if (pe.isFormData(vt) && (dn = wn.headers.get("content-type")) && zr.setContentType(dn), wn.body) {
                const [yn, pi] = ft(St, nt(zt(qr)));
                vt = gr(wn.body, 65536, yn, pi);
              }
            }
            pe.isString(en) || (en = en ? "include" : "omit");
            const ur = "credentials" in Request.prototype;
            De = new Request(it, { ...Me, signal: Ke, method: dt.toUpperCase(), headers: zr.normalize().toJSON(), body: vt, duplex: "half", credentials: ur ? en : void 0 });
            let Cr = await fetch(De);
            const Wr = kr && (Vt === "stream" || Vt === "response");
            if (kr && (cr || Wr && Bt)) {
              const dn = {};
              ["status", "statusText", "headers"].forEach((Bi) => {
                dn[Bi] = Cr[Bi];
              });
              const wn = pe.toFiniteNumber(Cr.headers.get("content-length")), [yn, pi] = cr && ft(wn, nt(zt(cr), true)) || [];
              Cr = new Response(gr(Cr.body, 65536, yn, () => {
                pi && pi(), Bt && Bt();
              }), dn);
            }
            Vt = Vt || "text";
            let Zr = await Xt[pe.findKey(Xt, Vt) || "text"](Cr, Ue);
            return !Wr && Bt && Bt(), await new Promise((dn, wn) => {
              le(dn, wn, { data: Zr, headers: Nt.from(Cr.headers), status: Cr.status, statusText: Cr.statusText, config: Ue, request: De });
            });
          } catch (ur) {
            throw Bt && Bt(), ur && ur.name === "TypeError" && /fetch/i.test(ur.message) ? Object.assign(new _e("Network Error", _e.ERR_NETWORK, Ue, De), { cause: ur.cause || ur }) : _e.from(ur, ur && ur.code, Ue, De);
          }
        }) };
        pe.forEach(we, (Ue, it) => {
          if (Ue) {
            try {
              Object.defineProperty(Ue, "name", { value: it });
            } catch {
            }
            Object.defineProperty(Ue, "adapterName", { value: it });
          }
        });
        const me = (Ue) => `- ${Ue}`, ze = (Ue) => pe.isFunction(Ue) || Ue === null || Ue === false, rt = (Ue) => {
          Ue = pe.isArray(Ue) ? Ue : [Ue];
          const { length: it } = Ue;
          let dt, vt;
          const wt = {};
          for (let Pt = 0; Pt < it; Pt++) {
            let Yt;
            if (dt = Ue[Pt], vt = dt, !ze(dt) && (vt = we[(Yt = String(dt)).toLowerCase()], vt === void 0)) throw new _e(`Unknown adapter '${Yt}'`);
            if (vt) break;
            wt[Yt || "#" + Pt] = vt;
          }
          if (!vt) {
            const Pt = Object.entries(wt).map(([cr, qr]) => `adapter ${cr} ` + (qr === false ? "is not supported by the environment" : "is not available in the build"));
            let Yt = it ? Pt.length > 1 ? `since :
` + Pt.map(me).join(`
`) : " " + me(Pt[0]) : "as no adapter specified";
            throw new _e("There is no suitable adapter to dispatch the request " + Yt, "ERR_NOT_SUPPORT");
          }
          return vt;
        };
        function Tt(Ue) {
          if (Ue.cancelToken && Ue.cancelToken.throwIfRequested(), Ue.signal && Ue.signal.aborted) throw new $e(null, Ue);
        }
        function Ot(Ue) {
          return Tt(Ue), Ue.headers = Nt.from(Ue.headers), Ue.data = yr.call(Ue, Ue.transformRequest), ["post", "put", "patch"].indexOf(Ue.method) !== -1 && Ue.headers.setContentType("application/x-www-form-urlencoded", false), rt(Ue.adapter || Ge.adapter)(Ue).then(function(it) {
            return Tt(Ue), it.data = yr.call(Ue, Ue.transformResponse, it), it.headers = Nt.from(it.headers), it;
          }, function(it) {
            return Ur(it) || (Tt(Ue), it && it.response && (it.response.data = yr.call(Ue, Ue.transformResponse, it.response), it.response.headers = Nt.from(it.response.headers))), Promise.reject(it);
          });
        }
        const It = "1.8.4", We = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach((Ue, it) => {
          We[Ue] = function(dt) {
            return typeof dt === Ue || "a" + (it < 1 ? "n " : " ") + Ue;
          };
        });
        const mt = {};
        We.transitional = function(Ue, it, dt) {
          function vt(wt, Pt) {
            return "[Axios v1.8.4] Transitional option '" + wt + "'" + Pt + (dt ? ". " + dt : "");
          }
          return (wt, Pt, Yt) => {
            if (Ue === false) throw new _e(vt(Pt, " has been removed" + (it ? " in " + it : "")), _e.ERR_DEPRECATED);
            return it && !mt[Pt] && (mt[Pt] = true, console.warn(vt(Pt, " has been deprecated since v" + it + " and will be removed in the near future"))), !Ue || Ue(wt, Pt, Yt);
          };
        }, We.spelling = function(Ue) {
          return (it, dt) => (console.warn(`${dt} is likely a misspelling of ${Ue}`), true);
        };
        const Gt = { assertOptions: function(Ue, it, dt) {
          if (typeof Ue != "object") throw new _e("options must be an object", _e.ERR_BAD_OPTION_VALUE);
          const vt = Object.keys(Ue);
          let wt = vt.length;
          for (; wt-- > 0; ) {
            const Pt = vt[wt], Yt = it[Pt];
            if (Yt) {
              const cr = Ue[Pt], qr = cr === void 0 || Yt(cr, Pt, Ue);
              if (qr !== true) throw new _e("option " + Pt + " must be " + qr, _e.ERR_BAD_OPTION_VALUE);
            } else if (dt !== true) throw new _e("Unknown option " + Pt, _e.ERR_BAD_OPTION);
          }
        }, validators: We }, ir = Gt.validators;
        class dr {
          constructor(it) {
            this.defaults = it, this.interceptors = { request: new Q(), response: new Q() };
          }
          async request(it, dt) {
            try {
              return await this._request(it, dt);
            } catch (vt) {
              if (vt instanceof Error) {
                let wt = {};
                Error.captureStackTrace ? Error.captureStackTrace(wt) : wt = new Error();
                const Pt = wt.stack ? wt.stack.replace(/^.+\n/, "") : "";
                try {
                  vt.stack ? Pt && !String(vt.stack).endsWith(Pt.replace(/^.+\n.+\n/, "")) && (vt.stack += `
` + Pt) : vt.stack = Pt;
                } catch {
                }
              }
              throw vt;
            }
          }
          _request(it, dt) {
            typeof it == "string" ? (dt = dt || {}).url = it : dt = it || {}, dt = Ct(this.defaults, dt);
            const { transitional: vt, paramsSerializer: wt, headers: Pt } = dt;
            vt !== void 0 && Gt.assertOptions(vt, { silentJSONParsing: ir.transitional(ir.boolean), forcedJSONParsing: ir.transitional(ir.boolean), clarifyTimeoutError: ir.transitional(ir.boolean) }, false), wt != null && (pe.isFunction(wt) ? dt.paramsSerializer = { serialize: wt } : Gt.assertOptions(wt, { encode: ir.function, serialize: ir.function }, true)), dt.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? dt.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : dt.allowAbsoluteUrls = true), Gt.assertOptions(dt, { baseUrl: ir.spelling("baseURL"), withXsrfToken: ir.spelling("withXSRFToken") }, true), dt.method = (dt.method || this.defaults.method || "get").toLowerCase();
            let Yt = Pt && pe.merge(Pt.common, Pt[dt.method]);
            Pt && pe.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (Ke) => {
              delete Pt[Ke];
            }), dt.headers = Nt.concat(Yt, Pt);
            const cr = [];
            let qr = true;
            this.interceptors.request.forEach(function(Ke) {
              typeof Ke.runWhen == "function" && Ke.runWhen(dt) === false || (qr = qr && Ke.synchronous, cr.unshift(Ke.fulfilled, Ke.rejected));
            });
            const Vt = [];
            let zr;
            this.interceptors.response.forEach(function(Ke) {
              Vt.push(Ke.fulfilled, Ke.rejected);
            });
            let en, Me = 0;
            if (!qr) {
              const Ke = [Ot.bind(this), void 0];
              for (Ke.unshift.apply(Ke, cr), Ke.push.apply(Ke, Vt), en = Ke.length, zr = Promise.resolve(dt); Me < en; ) zr = zr.then(Ke[Me++], Ke[Me++]);
              return zr;
            }
            en = cr.length;
            let De = dt;
            for (Me = 0; Me < en; ) {
              const Ke = cr[Me++], Bt = cr[Me++];
              try {
                De = Ke(De);
              } catch (St) {
                Bt.call(this, St);
                break;
              }
            }
            try {
              zr = Ot.call(this, De);
            } catch (Ke) {
              return Promise.reject(Ke);
            }
            for (Me = 0, en = Vt.length; Me < en; ) zr = zr.then(Vt[Me++], Vt[Me++]);
            return zr;
          }
          getUri(it) {
            return U(yt((it = Ct(this.defaults, it)).baseURL, it.url, it.allowAbsoluteUrls), it.params, it.paramsSerializer);
          }
        }
        pe.forEach(["delete", "get", "head", "options"], function(Ue) {
          dr.prototype[Ue] = function(it, dt) {
            return this.request(Ct(dt || {}, { method: Ue, url: it, data: (dt || {}).data }));
          };
        }), pe.forEach(["post", "put", "patch"], function(Ue) {
          function it(dt) {
            return function(vt, wt, Pt) {
              return this.request(Ct(Pt || {}, { method: Ue, headers: dt ? { "Content-Type": "multipart/form-data" } : {}, url: vt, data: wt }));
            };
          }
          dr.prototype[Ue] = it(), dr.prototype[Ue + "Form"] = it(true);
        });
        const hr = dr;
        class Fr {
          constructor(it) {
            if (typeof it != "function") throw new TypeError("executor must be a function.");
            let dt;
            this.promise = new Promise(function(wt) {
              dt = wt;
            });
            const vt = this;
            this.promise.then((wt) => {
              if (!vt._listeners) return;
              let Pt = vt._listeners.length;
              for (; Pt-- > 0; ) vt._listeners[Pt](wt);
              vt._listeners = null;
            }), this.promise.then = (wt) => {
              let Pt;
              const Yt = new Promise((cr) => {
                vt.subscribe(cr), Pt = cr;
              }).then(wt);
              return Yt.cancel = function() {
                vt.unsubscribe(Pt);
              }, Yt;
            }, it(function(wt, Pt, Yt) {
              vt.reason || (vt.reason = new $e(wt, Pt, Yt), dt(vt.reason));
            });
          }
          throwIfRequested() {
            if (this.reason) throw this.reason;
          }
          subscribe(it) {
            this.reason ? it(this.reason) : this._listeners ? this._listeners.push(it) : this._listeners = [it];
          }
          unsubscribe(it) {
            if (!this._listeners) return;
            const dt = this._listeners.indexOf(it);
            dt !== -1 && this._listeners.splice(dt, 1);
          }
          toAbortSignal() {
            const it = new AbortController(), dt = (vt) => {
              it.abort(vt);
            };
            return this.subscribe(dt), it.signal.unsubscribe = () => this.unsubscribe(dt), it.signal;
          }
          static source() {
            let it;
            return { token: new Fr(function(dt) {
              it = dt;
            }), cancel: it };
          }
        }
        const Gr = Fr, Br = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
        Object.entries(Br).forEach(([Ue, it]) => {
          Br[it] = Ue;
        });
        const Dr = Br, Vr = function Ue(it) {
          const dt = new hr(it), vt = h(hr.prototype.request, dt);
          return pe.extend(vt, hr.prototype, dt, { allOwnKeys: true }), pe.extend(vt, dt, null, { allOwnKeys: true }), vt.create = function(wt) {
            return Ue(Ct(it, wt));
          }, vt;
        }(Ge);
        Vr.Axios = hr, Vr.CanceledError = $e, Vr.CancelToken = Gr, Vr.isCancel = Ur, Vr.VERSION = It, Vr.toFormData = O, Vr.AxiosError = _e, Vr.Cancel = Vr.CanceledError, Vr.all = function(Ue) {
          return Promise.all(Ue);
        }, Vr.spread = function(Ue) {
          return function(it) {
            return Ue.apply(null, it);
          };
        }, Vr.isAxiosError = function(Ue) {
          return pe.isObject(Ue) && Ue.isAxiosError === true;
        }, Vr.mergeConfig = Ct, Vr.AxiosHeaders = Nt, Vr.formToJSON = (Ue) => rr(pe.isHTMLForm(Ue) ? new FormData(Ue) : Ue), Vr.getAdapter = rt, Vr.HttpStatusCode = Dr, Vr.default = Vr;
        var be = Vr, Or = Vr.create;
      }, 6160: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.decodeAddressToMuxedAccount = m, o.encodeMuxedAccount = function(a, l) {
          if (!r.StrKey.isValidEd25519PublicKey(a)) throw new Error("address should be a Stellar account ID (G...)");
          if (typeof l != "string") throw new Error("id should be a string representing a number (uint64)");
          return f.default.MuxedAccount.keyTypeMuxedEd25519(new f.default.MuxedAccountMed25519({ id: f.default.Uint64.fromString(l), ed25519: r.StrKey.decodeEd25519PublicKey(a) }));
        }, o.encodeMuxedAccountToAddress = g, o.extractBaseAddress = function(a) {
          if (r.StrKey.isValidEd25519PublicKey(a)) return a;
          if (!r.StrKey.isValidMed25519PublicKey(a)) throw new TypeError("expected muxed account (M...), got ".concat(a));
          var l = m(a);
          return r.StrKey.encodeEd25519PublicKey(l.med25519().ed25519());
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(7120);
        function m(a) {
          return r.StrKey.isValidMed25519PublicKey(a) ? function(l) {
            var d = r.StrKey.decodeMed25519PublicKey(l);
            return f.default.MuxedAccount.keyTypeMuxedEd25519(new f.default.MuxedAccountMed25519({ id: f.default.Uint64.fromXDR(d.subarray(-8)), ed25519: d.subarray(0, -8) }));
          }(a) : f.default.MuxedAccount.keyTypeEd25519(r.StrKey.decodeEd25519PublicKey(a));
        }
        function g(a) {
          return a.switch().value === f.default.CryptoKeyType.keyTypeMuxedEd25519().value ? function(l) {
            if (l.switch() === f.default.CryptoKeyType.keyTypeEd25519()) return g(l);
            var d = l.med25519();
            return r.StrKey.encodeMed25519PublicKey(c.concat([d.ed25519(), d.id().toXDR("raw")]));
          }(a) : r.StrKey.encodeEd25519PublicKey(a.ed25519());
        }
      }, 6183: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.bumpSequence = function(m) {
          var g = {};
          if (typeof m.bumpTo != "string") throw new Error("bumpTo must be a string");
          try {
            new h.default(m.bumpTo);
          } catch {
            throw new Error("bumpTo must be a stringified number");
          }
          g.bumpTo = c.Hyper.fromString(m.bumpTo);
          var a = new f.default.BumpSequenceOp(g), l = {};
          return l.body = f.default.OperationBody.bumpSequence(a), this.setSourceAccount(l, m), new f.default.Operation(l);
        };
        var c = u(3740), h = r(u(1242)), f = r(u(1918));
        function r(m) {
          return m && m.__esModule ? m : { default: m };
        }
      }, 6188: (t) => {
        t.exports = Math.max;
      }, 6202: (t, o) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Networks = void 0, o.Networks = { PUBLIC: "Public Global Stellar Network ; September 2015", TESTNET: "Test SDF Network ; September 2015", FUTURENET: "Test SDF Future Network ; October 2022", SANDBOX: "Local Sandbox Stellar Network ; September 2022", STANDALONE: "Standalone Network ; February 2017" };
      }, 6238: (t, o, u) => {
        var c = u(6048).F.ERR_STREAM_PREMATURE_CLOSE;
        function h() {
        }
        t.exports = function f(r, m, g) {
          if (typeof m == "function") return f(r, null, m);
          m || (m = {}), g = /* @__PURE__ */ function(I) {
            var q = false;
            return function() {
              if (!q) {
                q = true;
                for (var D = arguments.length, H = new Array(D), _ = 0; _ < D; _++) H[_] = arguments[_];
                I.apply(this, H);
              }
            };
          }(g || h);
          var a = m.readable || m.readable !== false && r.readable, l = m.writable || m.writable !== false && r.writable, d = function() {
            r.writable || S();
          }, b = r._writableState && r._writableState.finished, S = function() {
            l = false, b = true, a || g.call(r);
          }, E = r._readableState && r._readableState.endEmitted, R = function() {
            a = false, E = true, l || g.call(r);
          }, k = function(I) {
            g.call(r, I);
          }, w = function() {
            var I;
            return a && !E ? (r._readableState && r._readableState.ended || (I = new c()), g.call(r, I)) : l && !b ? (r._writableState && r._writableState.ended || (I = new c()), g.call(r, I)) : void 0;
          }, F = function() {
            r.req.on("finish", S);
          };
          return function(I) {
            return I.setHeader && typeof I.abort == "function";
          }(r) ? (r.on("complete", S), r.on("abort", w), r.req ? F() : r.on("request", F)) : l && !r._writableState && (r.on("end", d), r.on("close", d)), r.on("end", R), r.on("finish", S), m.error !== false && r.on("error", k), r.on("close", w), function() {
            r.removeListener("complete", S), r.removeListener("abort", w), r.removeListener("request", F), r.req && r.req.removeListener("finish", S), r.removeListener("end", d), r.removeListener("close", d), r.removeListener("finish", S), r.removeListener("end", R), r.removeListener("error", k), r.removeListener("close", w);
          };
        };
      }, 6272: (t, o, u) => {
        function c(d) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, c(d);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Uint128 = void 0;
        var h = u(3740);
        function f(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, r(E.key), E);
          }
        }
        function r(d) {
          var b = function(S, E) {
            if (c(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (c(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return c(b) == "symbol" ? b : b + "";
        }
        function m(d, b, S) {
          return b = a(b), function(E, R) {
            if (R && (c(R) == "object" || typeof R == "function")) return R;
            if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(k) {
              if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return k;
            }(E);
          }(d, g() ? Reflect.construct(b, S || [], a(d).constructor) : b.apply(d, S));
        }
        function g() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!d;
          })();
        }
        function a(d) {
          return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, a(d);
        }
        function l(d, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, E) {
            return S.__proto__ = E, S;
          }, l(d, b);
        }
        (o.Uint128 = function(d) {
          function b() {
            (function(I, q) {
              if (!(I instanceof q)) throw new TypeError("Cannot call a class as a function");
            })(this, b);
            for (var k = arguments.length, w = new Array(k), F = 0; F < k; F++) w[F] = arguments[F];
            return m(this, b, [w]);
          }
          return function(k, w) {
            if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
            k.prototype = Object.create(w && w.prototype, { constructor: { value: k, writable: true, configurable: true } }), Object.defineProperty(k, "prototype", { writable: false }), w && l(k, w);
          }(b, d), S = b, (E = [{ key: "unsigned", get: function() {
            return true;
          } }, { key: "size", get: function() {
            return 128;
          } }]) && f(S.prototype, E), R && f(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }(h.LargeInt)).defineIntBoundaries();
      }, 6299: (t, o, u) => {
        u.r(o), u.d(o, { AssembledTransaction: () => Ne, Client: () => br, DEFAULT_TIMEOUT: () => E, Err: () => S, NULL_ACCOUNT: () => R, Ok: () => b, SentTransaction: () => ge, Spec: () => ft, basicNodeSigner: () => Ge });
        var c = u(356), h = u(3496), f = u(4076), r = u(8680);
        function m(we) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, m(we);
        }
        function g(we, me) {
          if (!(we instanceof me)) throw new TypeError("Cannot call a class as a function");
        }
        function a(we, me) {
          for (var ze = 0; ze < me.length; ze++) {
            var rt = me[ze];
            rt.enumerable = rt.enumerable || false, rt.configurable = true, "value" in rt && (rt.writable = true), Object.defineProperty(we, d(rt.key), rt);
          }
        }
        function l(we, me, ze) {
          return me && a(we.prototype, me), Object.defineProperty(we, "prototype", { writable: false }), we;
        }
        function d(we) {
          var me = function(ze, rt) {
            if (m(ze) != "object" || !ze) return ze;
            var Tt = ze[Symbol.toPrimitive];
            if (Tt !== void 0) {
              var Ot = Tt.call(ze, rt);
              if (m(Ot) != "object") return Ot;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(ze);
          }(we, "string");
          return m(me) == "symbol" ? me : me + "";
        }
        var b = l(function we(me) {
          g(this, we), this.value = me;
        }, [{ key: "unwrapErr", value: function() {
          throw new Error("No error");
        } }, { key: "unwrap", value: function() {
          return this.value;
        } }, { key: "isOk", value: function() {
          return true;
        } }, { key: "isErr", value: function() {
          return false;
        } }]), S = l(function we(me) {
          g(this, we), this.error = me;
        }, [{ key: "unwrapErr", value: function() {
          return this.error;
        } }, { key: "unwrap", value: function() {
          throw new Error(this.error.message);
        } }, { key: "isOk", value: function() {
          return false;
        } }, { key: "isErr", value: function() {
          return true;
        } }]), E = 300, R = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
        function k() {
          k = function() {
            return me;
          };
          var we, me = {}, ze = Object.prototype, rt = ze.hasOwnProperty, Tt = Object.defineProperty || function(Me, De, Ke) {
            Me[De] = Ke.value;
          }, Ot = typeof Symbol == "function" ? Symbol : {}, It = Ot.iterator || "@@iterator", We = Ot.asyncIterator || "@@asyncIterator", mt = Ot.toStringTag || "@@toStringTag";
          function Gt(Me, De, Ke) {
            return Object.defineProperty(Me, De, { value: Ke, enumerable: true, configurable: true, writable: true }), Me[De];
          }
          try {
            Gt({}, "");
          } catch {
            Gt = function(De, Ke, Bt) {
              return De[Ke] = Bt;
            };
          }
          function ir(Me, De, Ke, Bt) {
            var St = De && De.prototype instanceof Vr ? De : Vr, ur = Object.create(St.prototype), Cr = new zr(Bt || []);
            return Tt(ur, "_invoke", { value: Yt(Me, Ke, Cr) }), ur;
          }
          function dr(Me, De, Ke) {
            try {
              return { type: "normal", arg: Me.call(De, Ke) };
            } catch (Bt) {
              return { type: "throw", arg: Bt };
            }
          }
          me.wrap = ir;
          var hr = "suspendedStart", Fr = "suspendedYield", Gr = "executing", Br = "completed", Dr = {};
          function Vr() {
          }
          function be() {
          }
          function Or() {
          }
          var Ue = {};
          Gt(Ue, It, function() {
            return this;
          });
          var it = Object.getPrototypeOf, dt = it && it(it(en([])));
          dt && dt !== ze && rt.call(dt, It) && (Ue = dt);
          var vt = Or.prototype = Vr.prototype = Object.create(Ue);
          function wt(Me) {
            ["next", "throw", "return"].forEach(function(De) {
              Gt(Me, De, function(Ke) {
                return this._invoke(De, Ke);
              });
            });
          }
          function Pt(Me, De) {
            function Ke(St, ur, Cr, Wr) {
              var Zr = dr(Me[St], Me, ur);
              if (Zr.type !== "throw") {
                var dn = Zr.arg, wn = dn.value;
                return wn && w(wn) == "object" && rt.call(wn, "__await") ? De.resolve(wn.__await).then(function(yn) {
                  Ke("next", yn, Cr, Wr);
                }, function(yn) {
                  Ke("throw", yn, Cr, Wr);
                }) : De.resolve(wn).then(function(yn) {
                  dn.value = yn, Cr(dn);
                }, function(yn) {
                  return Ke("throw", yn, Cr, Wr);
                });
              }
              Wr(Zr.arg);
            }
            var Bt;
            Tt(this, "_invoke", { value: function(St, ur) {
              function Cr() {
                return new De(function(Wr, Zr) {
                  Ke(St, ur, Wr, Zr);
                });
              }
              return Bt = Bt ? Bt.then(Cr, Cr) : Cr();
            } });
          }
          function Yt(Me, De, Ke) {
            var Bt = hr;
            return function(St, ur) {
              if (Bt === Gr) throw Error("Generator is already running");
              if (Bt === Br) {
                if (St === "throw") throw ur;
                return { value: we, done: true };
              }
              for (Ke.method = St, Ke.arg = ur; ; ) {
                var Cr = Ke.delegate;
                if (Cr) {
                  var Wr = cr(Cr, Ke);
                  if (Wr) {
                    if (Wr === Dr) continue;
                    return Wr;
                  }
                }
                if (Ke.method === "next") Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (Bt === hr) throw Bt = Br, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                Bt = Gr;
                var Zr = dr(Me, De, Ke);
                if (Zr.type === "normal") {
                  if (Bt = Ke.done ? Br : Fr, Zr.arg === Dr) continue;
                  return { value: Zr.arg, done: Ke.done };
                }
                Zr.type === "throw" && (Bt = Br, Ke.method = "throw", Ke.arg = Zr.arg);
              }
            };
          }
          function cr(Me, De) {
            var Ke = De.method, Bt = Me.iterator[Ke];
            if (Bt === we) return De.delegate = null, Ke === "throw" && Me.iterator.return && (De.method = "return", De.arg = we, cr(Me, De), De.method === "throw") || Ke !== "return" && (De.method = "throw", De.arg = new TypeError("The iterator does not provide a '" + Ke + "' method")), Dr;
            var St = dr(Bt, Me.iterator, De.arg);
            if (St.type === "throw") return De.method = "throw", De.arg = St.arg, De.delegate = null, Dr;
            var ur = St.arg;
            return ur ? ur.done ? (De[Me.resultName] = ur.value, De.next = Me.nextLoc, De.method !== "return" && (De.method = "next", De.arg = we), De.delegate = null, Dr) : ur : (De.method = "throw", De.arg = new TypeError("iterator result is not an object"), De.delegate = null, Dr);
          }
          function qr(Me) {
            var De = { tryLoc: Me[0] };
            1 in Me && (De.catchLoc = Me[1]), 2 in Me && (De.finallyLoc = Me[2], De.afterLoc = Me[3]), this.tryEntries.push(De);
          }
          function Vt(Me) {
            var De = Me.completion || {};
            De.type = "normal", delete De.arg, Me.completion = De;
          }
          function zr(Me) {
            this.tryEntries = [{ tryLoc: "root" }], Me.forEach(qr, this), this.reset(true);
          }
          function en(Me) {
            if (Me || Me === "") {
              var De = Me[It];
              if (De) return De.call(Me);
              if (typeof Me.next == "function") return Me;
              if (!isNaN(Me.length)) {
                var Ke = -1, Bt = function St() {
                  for (; ++Ke < Me.length; ) if (rt.call(Me, Ke)) return St.value = Me[Ke], St.done = false, St;
                  return St.value = we, St.done = true, St;
                };
                return Bt.next = Bt;
              }
            }
            throw new TypeError(w(Me) + " is not iterable");
          }
          return be.prototype = Or, Tt(vt, "constructor", { value: Or, configurable: true }), Tt(Or, "constructor", { value: be, configurable: true }), be.displayName = Gt(Or, mt, "GeneratorFunction"), me.isGeneratorFunction = function(Me) {
            var De = typeof Me == "function" && Me.constructor;
            return !!De && (De === be || (De.displayName || De.name) === "GeneratorFunction");
          }, me.mark = function(Me) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Me, Or) : (Me.__proto__ = Or, Gt(Me, mt, "GeneratorFunction")), Me.prototype = Object.create(vt), Me;
          }, me.awrap = function(Me) {
            return { __await: Me };
          }, wt(Pt.prototype), Gt(Pt.prototype, We, function() {
            return this;
          }), me.AsyncIterator = Pt, me.async = function(Me, De, Ke, Bt, St) {
            St === void 0 && (St = Promise);
            var ur = new Pt(ir(Me, De, Ke, Bt), St);
            return me.isGeneratorFunction(De) ? ur : ur.next().then(function(Cr) {
              return Cr.done ? Cr.value : ur.next();
            });
          }, wt(vt), Gt(vt, mt, "Generator"), Gt(vt, It, function() {
            return this;
          }), Gt(vt, "toString", function() {
            return "[object Generator]";
          }), me.keys = function(Me) {
            var De = Object(Me), Ke = [];
            for (var Bt in De) Ke.push(Bt);
            return Ke.reverse(), function St() {
              for (; Ke.length; ) {
                var ur = Ke.pop();
                if (ur in De) return St.value = ur, St.done = false, St;
              }
              return St.done = true, St;
            };
          }, me.values = en, zr.prototype = { constructor: zr, reset: function(Me) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = we, this.done = false, this.delegate = null, this.method = "next", this.arg = we, this.tryEntries.forEach(Vt), !Me) for (var De in this) De.charAt(0) === "t" && rt.call(this, De) && !isNaN(+De.slice(1)) && (this[De] = we);
          }, stop: function() {
            this.done = true;
            var Me = this.tryEntries[0].completion;
            if (Me.type === "throw") throw Me.arg;
            return this.rval;
          }, dispatchException: function(Me) {
            if (this.done) throw Me;
            var De = this;
            function Ke(Zr, dn) {
              return ur.type = "throw", ur.arg = Me, De.next = Zr, dn && (De.method = "next", De.arg = we), !!dn;
            }
            for (var Bt = this.tryEntries.length - 1; Bt >= 0; --Bt) {
              var St = this.tryEntries[Bt], ur = St.completion;
              if (St.tryLoc === "root") return Ke("end");
              if (St.tryLoc <= this.prev) {
                var Cr = rt.call(St, "catchLoc"), Wr = rt.call(St, "finallyLoc");
                if (Cr && Wr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                } else if (Cr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                } else {
                  if (!Wr) throw Error("try statement without catch or finally");
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                }
              }
            }
          }, abrupt: function(Me, De) {
            for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
              var Bt = this.tryEntries[Ke];
              if (Bt.tryLoc <= this.prev && rt.call(Bt, "finallyLoc") && this.prev < Bt.finallyLoc) {
                var St = Bt;
                break;
              }
            }
            St && (Me === "break" || Me === "continue") && St.tryLoc <= De && De <= St.finallyLoc && (St = null);
            var ur = St ? St.completion : {};
            return ur.type = Me, ur.arg = De, St ? (this.method = "next", this.next = St.finallyLoc, Dr) : this.complete(ur);
          }, complete: function(Me, De) {
            if (Me.type === "throw") throw Me.arg;
            return Me.type === "break" || Me.type === "continue" ? this.next = Me.arg : Me.type === "return" ? (this.rval = this.arg = Me.arg, this.method = "return", this.next = "end") : Me.type === "normal" && De && (this.next = De), Dr;
          }, finish: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.finallyLoc === Me) return this.complete(Ke.completion, Ke.afterLoc), Vt(Ke), Dr;
            }
          }, catch: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.tryLoc === Me) {
                var Bt = Ke.completion;
                if (Bt.type === "throw") {
                  var St = Bt.arg;
                  Vt(Ke);
                }
                return St;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Me, De, Ke) {
            return this.delegate = { iterator: en(Me), resultName: De, nextLoc: Ke }, this.method === "next" && (this.arg = we), Dr;
          } }, me;
        }
        function w(we) {
          return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, w(we);
        }
        function F(we, me, ze, rt, Tt, Ot, It) {
          try {
            var We = we[Ot](It), mt = We.value;
          } catch (Gt) {
            return void ze(Gt);
          }
          We.done ? me(mt) : Promise.resolve(mt).then(rt, Tt);
        }
        function I(we) {
          return function() {
            var me = this, ze = arguments;
            return new Promise(function(rt, Tt) {
              var Ot = we.apply(me, ze);
              function It(mt) {
                F(Ot, rt, Tt, It, We, "next", mt);
              }
              function We(mt) {
                F(Ot, rt, Tt, It, We, "throw", mt);
              }
              It(void 0);
            });
          };
        }
        function q(we, me, ze) {
          return D.apply(this, arguments);
        }
        function D() {
          return D = I(k().mark(function we(me, ze, rt) {
            var Tt, Ot, It, We, mt, Gt, ir, dr = arguments;
            return k().wrap(function(hr) {
              for (; ; ) switch (hr.prev = hr.next) {
                case 0:
                  return Tt = dr.length > 3 && dr[3] !== void 0 ? dr[3] : 1.5, Ot = dr.length > 4 && dr[4] !== void 0 && dr[4], It = [], We = 0, hr.t0 = It, hr.next = 7, me();
                case 7:
                  if (hr.t1 = hr.sent, hr.t0.push.call(hr.t0, hr.t1), ze(It[It.length - 1])) {
                    hr.next = 11;
                    break;
                  }
                  return hr.abrupt("return", It);
                case 11:
                  mt = new Date(Date.now() + 1e3 * rt).valueOf(), ir = Gt = 1e3;
                case 14:
                  if (!(Date.now() < mt && ze(It[It.length - 1]))) {
                    hr.next = 30;
                    break;
                  }
                  return We += 1, Ot && console.info("Waiting ".concat(Gt, "ms before trying again (bringing the total wait time to ").concat(ir, "ms so far, of total ").concat(1e3 * rt, "ms)")), hr.next = 19, new Promise(function(Fr) {
                    return setTimeout(Fr, Gt);
                  });
                case 19:
                  return Gt *= Tt, new Date(Date.now() + Gt).valueOf() > mt && (Gt = mt - Date.now(), Ot && console.info("was gonna wait too long; new waitTime: ".concat(Gt, "ms"))), ir = Gt + ir, hr.t2 = It, hr.next = 25, me(It[It.length - 1]);
                case 25:
                  hr.t3 = hr.sent, hr.t2.push.call(hr.t2, hr.t3), Ot && ze(It[It.length - 1]) && console.info("".concat(We, ". Called ").concat(me, "; ").concat(It.length, " prev attempts. Most recent: ").concat(JSON.stringify(It[It.length - 1], null, 2))), hr.next = 14;
                  break;
                case 30:
                  return hr.abrupt("return", It);
                case 31:
                case "end":
                  return hr.stop();
              }
            }, we);
          })), D.apply(this, arguments);
        }
        var H, _ = /Error\(Contract, #(\d+)\)/;
        function T(we) {
          for (var me = new c.cereal.XdrReader(we), ze = []; !me.eof; ) ze.push(c.xdr.ScSpecEntry.read(me));
          return ze;
        }
        function L(we, me) {
          return j.apply(this, arguments);
        }
        function j() {
          return (j = I(k().mark(function we(me, ze) {
            return k().wrap(function(rt) {
              for (; ; ) switch (rt.prev = rt.next) {
                case 0:
                  return rt.abrupt("return", me.publicKey ? ze.getAccount(me.publicKey) : new c.Account(R, "0"));
                case 1:
                case "end":
                  return rt.stop();
              }
            }, we);
          }))).apply(this, arguments);
        }
        function z(we, me, ze) {
          return me = J(me), function(rt, Tt) {
            if (Tt && (B(Tt) == "object" || typeof Tt == "function")) return Tt;
            if (Tt !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Ot) {
              if (Ot === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Ot;
            }(rt);
          }(we, G() ? Reflect.construct(me, ze || [], J(we).constructor) : me.apply(we, ze));
        }
        function Y(we, me) {
          if (typeof me != "function" && me !== null) throw new TypeError("Super expression must either be null or a function");
          we.prototype = Object.create(me && me.prototype, { constructor: { value: we, writable: true, configurable: true } }), Object.defineProperty(we, "prototype", { writable: false }), me && K(we, me);
        }
        function te(we) {
          var me = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return te = function(ze) {
            if (ze === null || !function(Tt) {
              try {
                return Function.toString.call(Tt).indexOf("[native code]") !== -1;
              } catch {
                return typeof Tt == "function";
              }
            }(ze)) return ze;
            if (typeof ze != "function") throw new TypeError("Super expression must either be null or a function");
            if (me !== void 0) {
              if (me.has(ze)) return me.get(ze);
              me.set(ze, rt);
            }
            function rt() {
              return function(Tt, Ot, It) {
                if (G()) return Reflect.construct.apply(null, arguments);
                var We = [null];
                We.push.apply(We, Ot);
                var mt = new (Tt.bind.apply(Tt, We))();
                return It && K(mt, It.prototype), mt;
              }(ze, arguments, J(this).constructor);
            }
            return rt.prototype = Object.create(ze.prototype, { constructor: { value: rt, enumerable: false, writable: true, configurable: true } }), K(rt, ze);
          }, te(we);
        }
        function G() {
          try {
            var we = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (G = function() {
            return !!we;
          })();
        }
        function K(we, me) {
          return K = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ze, rt) {
            return ze.__proto__ = rt, ze;
          }, K(we, me);
        }
        function J(we) {
          return J = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(me) {
            return me.__proto__ || Object.getPrototypeOf(me);
          }, J(we);
        }
        function B(we) {
          return B = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, B(we);
        }
        function Z() {
          Z = function() {
            return me;
          };
          var we, me = {}, ze = Object.prototype, rt = ze.hasOwnProperty, Tt = Object.defineProperty || function(Me, De, Ke) {
            Me[De] = Ke.value;
          }, Ot = typeof Symbol == "function" ? Symbol : {}, It = Ot.iterator || "@@iterator", We = Ot.asyncIterator || "@@asyncIterator", mt = Ot.toStringTag || "@@toStringTag";
          function Gt(Me, De, Ke) {
            return Object.defineProperty(Me, De, { value: Ke, enumerable: true, configurable: true, writable: true }), Me[De];
          }
          try {
            Gt({}, "");
          } catch {
            Gt = function(De, Ke, Bt) {
              return De[Ke] = Bt;
            };
          }
          function ir(Me, De, Ke, Bt) {
            var St = De && De.prototype instanceof Vr ? De : Vr, ur = Object.create(St.prototype), Cr = new zr(Bt || []);
            return Tt(ur, "_invoke", { value: Yt(Me, Ke, Cr) }), ur;
          }
          function dr(Me, De, Ke) {
            try {
              return { type: "normal", arg: Me.call(De, Ke) };
            } catch (Bt) {
              return { type: "throw", arg: Bt };
            }
          }
          me.wrap = ir;
          var hr = "suspendedStart", Fr = "suspendedYield", Gr = "executing", Br = "completed", Dr = {};
          function Vr() {
          }
          function be() {
          }
          function Or() {
          }
          var Ue = {};
          Gt(Ue, It, function() {
            return this;
          });
          var it = Object.getPrototypeOf, dt = it && it(it(en([])));
          dt && dt !== ze && rt.call(dt, It) && (Ue = dt);
          var vt = Or.prototype = Vr.prototype = Object.create(Ue);
          function wt(Me) {
            ["next", "throw", "return"].forEach(function(De) {
              Gt(Me, De, function(Ke) {
                return this._invoke(De, Ke);
              });
            });
          }
          function Pt(Me, De) {
            function Ke(St, ur, Cr, Wr) {
              var Zr = dr(Me[St], Me, ur);
              if (Zr.type !== "throw") {
                var dn = Zr.arg, wn = dn.value;
                return wn && B(wn) == "object" && rt.call(wn, "__await") ? De.resolve(wn.__await).then(function(yn) {
                  Ke("next", yn, Cr, Wr);
                }, function(yn) {
                  Ke("throw", yn, Cr, Wr);
                }) : De.resolve(wn).then(function(yn) {
                  dn.value = yn, Cr(dn);
                }, function(yn) {
                  return Ke("throw", yn, Cr, Wr);
                });
              }
              Wr(Zr.arg);
            }
            var Bt;
            Tt(this, "_invoke", { value: function(St, ur) {
              function Cr() {
                return new De(function(Wr, Zr) {
                  Ke(St, ur, Wr, Zr);
                });
              }
              return Bt = Bt ? Bt.then(Cr, Cr) : Cr();
            } });
          }
          function Yt(Me, De, Ke) {
            var Bt = hr;
            return function(St, ur) {
              if (Bt === Gr) throw Error("Generator is already running");
              if (Bt === Br) {
                if (St === "throw") throw ur;
                return { value: we, done: true };
              }
              for (Ke.method = St, Ke.arg = ur; ; ) {
                var Cr = Ke.delegate;
                if (Cr) {
                  var Wr = cr(Cr, Ke);
                  if (Wr) {
                    if (Wr === Dr) continue;
                    return Wr;
                  }
                }
                if (Ke.method === "next") Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (Bt === hr) throw Bt = Br, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                Bt = Gr;
                var Zr = dr(Me, De, Ke);
                if (Zr.type === "normal") {
                  if (Bt = Ke.done ? Br : Fr, Zr.arg === Dr) continue;
                  return { value: Zr.arg, done: Ke.done };
                }
                Zr.type === "throw" && (Bt = Br, Ke.method = "throw", Ke.arg = Zr.arg);
              }
            };
          }
          function cr(Me, De) {
            var Ke = De.method, Bt = Me.iterator[Ke];
            if (Bt === we) return De.delegate = null, Ke === "throw" && Me.iterator.return && (De.method = "return", De.arg = we, cr(Me, De), De.method === "throw") || Ke !== "return" && (De.method = "throw", De.arg = new TypeError("The iterator does not provide a '" + Ke + "' method")), Dr;
            var St = dr(Bt, Me.iterator, De.arg);
            if (St.type === "throw") return De.method = "throw", De.arg = St.arg, De.delegate = null, Dr;
            var ur = St.arg;
            return ur ? ur.done ? (De[Me.resultName] = ur.value, De.next = Me.nextLoc, De.method !== "return" && (De.method = "next", De.arg = we), De.delegate = null, Dr) : ur : (De.method = "throw", De.arg = new TypeError("iterator result is not an object"), De.delegate = null, Dr);
          }
          function qr(Me) {
            var De = { tryLoc: Me[0] };
            1 in Me && (De.catchLoc = Me[1]), 2 in Me && (De.finallyLoc = Me[2], De.afterLoc = Me[3]), this.tryEntries.push(De);
          }
          function Vt(Me) {
            var De = Me.completion || {};
            De.type = "normal", delete De.arg, Me.completion = De;
          }
          function zr(Me) {
            this.tryEntries = [{ tryLoc: "root" }], Me.forEach(qr, this), this.reset(true);
          }
          function en(Me) {
            if (Me || Me === "") {
              var De = Me[It];
              if (De) return De.call(Me);
              if (typeof Me.next == "function") return Me;
              if (!isNaN(Me.length)) {
                var Ke = -1, Bt = function St() {
                  for (; ++Ke < Me.length; ) if (rt.call(Me, Ke)) return St.value = Me[Ke], St.done = false, St;
                  return St.value = we, St.done = true, St;
                };
                return Bt.next = Bt;
              }
            }
            throw new TypeError(B(Me) + " is not iterable");
          }
          return be.prototype = Or, Tt(vt, "constructor", { value: Or, configurable: true }), Tt(Or, "constructor", { value: be, configurable: true }), be.displayName = Gt(Or, mt, "GeneratorFunction"), me.isGeneratorFunction = function(Me) {
            var De = typeof Me == "function" && Me.constructor;
            return !!De && (De === be || (De.displayName || De.name) === "GeneratorFunction");
          }, me.mark = function(Me) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Me, Or) : (Me.__proto__ = Or, Gt(Me, mt, "GeneratorFunction")), Me.prototype = Object.create(vt), Me;
          }, me.awrap = function(Me) {
            return { __await: Me };
          }, wt(Pt.prototype), Gt(Pt.prototype, We, function() {
            return this;
          }), me.AsyncIterator = Pt, me.async = function(Me, De, Ke, Bt, St) {
            St === void 0 && (St = Promise);
            var ur = new Pt(ir(Me, De, Ke, Bt), St);
            return me.isGeneratorFunction(De) ? ur : ur.next().then(function(Cr) {
              return Cr.done ? Cr.value : ur.next();
            });
          }, wt(vt), Gt(vt, mt, "Generator"), Gt(vt, It, function() {
            return this;
          }), Gt(vt, "toString", function() {
            return "[object Generator]";
          }), me.keys = function(Me) {
            var De = Object(Me), Ke = [];
            for (var Bt in De) Ke.push(Bt);
            return Ke.reverse(), function St() {
              for (; Ke.length; ) {
                var ur = Ke.pop();
                if (ur in De) return St.value = ur, St.done = false, St;
              }
              return St.done = true, St;
            };
          }, me.values = en, zr.prototype = { constructor: zr, reset: function(Me) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = we, this.done = false, this.delegate = null, this.method = "next", this.arg = we, this.tryEntries.forEach(Vt), !Me) for (var De in this) De.charAt(0) === "t" && rt.call(this, De) && !isNaN(+De.slice(1)) && (this[De] = we);
          }, stop: function() {
            this.done = true;
            var Me = this.tryEntries[0].completion;
            if (Me.type === "throw") throw Me.arg;
            return this.rval;
          }, dispatchException: function(Me) {
            if (this.done) throw Me;
            var De = this;
            function Ke(Zr, dn) {
              return ur.type = "throw", ur.arg = Me, De.next = Zr, dn && (De.method = "next", De.arg = we), !!dn;
            }
            for (var Bt = this.tryEntries.length - 1; Bt >= 0; --Bt) {
              var St = this.tryEntries[Bt], ur = St.completion;
              if (St.tryLoc === "root") return Ke("end");
              if (St.tryLoc <= this.prev) {
                var Cr = rt.call(St, "catchLoc"), Wr = rt.call(St, "finallyLoc");
                if (Cr && Wr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                } else if (Cr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                } else {
                  if (!Wr) throw Error("try statement without catch or finally");
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                }
              }
            }
          }, abrupt: function(Me, De) {
            for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
              var Bt = this.tryEntries[Ke];
              if (Bt.tryLoc <= this.prev && rt.call(Bt, "finallyLoc") && this.prev < Bt.finallyLoc) {
                var St = Bt;
                break;
              }
            }
            St && (Me === "break" || Me === "continue") && St.tryLoc <= De && De <= St.finallyLoc && (St = null);
            var ur = St ? St.completion : {};
            return ur.type = Me, ur.arg = De, St ? (this.method = "next", this.next = St.finallyLoc, Dr) : this.complete(ur);
          }, complete: function(Me, De) {
            if (Me.type === "throw") throw Me.arg;
            return Me.type === "break" || Me.type === "continue" ? this.next = Me.arg : Me.type === "return" ? (this.rval = this.arg = Me.arg, this.method = "return", this.next = "end") : Me.type === "normal" && De && (this.next = De), Dr;
          }, finish: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.finallyLoc === Me) return this.complete(Ke.completion, Ke.afterLoc), Vt(Ke), Dr;
            }
          }, catch: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.tryLoc === Me) {
                var Bt = Ke.completion;
                if (Bt.type === "throw") {
                  var St = Bt.arg;
                  Vt(Ke);
                }
                return St;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Me, De, Ke) {
            return this.delegate = { iterator: en(Me), resultName: De, nextLoc: Ke }, this.method === "next" && (this.arg = we), Dr;
          } }, me;
        }
        function ie(we, me, ze, rt, Tt, Ot, It) {
          try {
            var We = we[Ot](It), mt = We.value;
          } catch (Gt) {
            return void ze(Gt);
          }
          We.done ? me(mt) : Promise.resolve(mt).then(rt, Tt);
        }
        function $(we) {
          return function() {
            var me = this, ze = arguments;
            return new Promise(function(rt, Tt) {
              var Ot = we.apply(me, ze);
              function It(mt) {
                ie(Ot, rt, Tt, It, We, "next", mt);
              }
              function We(mt) {
                ie(Ot, rt, Tt, It, We, "throw", mt);
              }
              It(void 0);
            });
          };
        }
        function oe(we, me) {
          if (!(we instanceof me)) throw new TypeError("Cannot call a class as a function");
        }
        function ce(we, me) {
          for (var ze = 0; ze < me.length; ze++) {
            var rt = me[ze];
            rt.enumerable = rt.enumerable || false, rt.configurable = true, "value" in rt && (rt.writable = true), Object.defineProperty(we, ue(rt.key), rt);
          }
        }
        function ye(we, me, ze) {
          return me && ce(we.prototype, me), Object.defineProperty(we, "prototype", { writable: false }), we;
        }
        function ae(we, me, ze) {
          return (me = ue(me)) in we ? Object.defineProperty(we, me, { value: ze, enumerable: true, configurable: true, writable: true }) : we[me] = ze, we;
        }
        function ue(we) {
          var me = function(ze, rt) {
            if (B(ze) != "object" || !ze) return ze;
            var Tt = ze[Symbol.toPrimitive];
            if (Tt !== void 0) {
              var Ot = Tt.call(ze, rt);
              if (B(Ot) != "object") return Ot;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (rt === "string" ? String : Number)(ze);
          }(we, "string");
          return B(me) == "symbol" ? me : me + "";
        }
        var ne, ge = function() {
          function we(me) {
            var ze, rt = this;
            oe(this, we), ae(this, "send", $(Z().mark(function Tt() {
              var Ot, It, We;
              return Z().wrap(function(mt) {
                for (; ; ) switch (mt.prev = mt.next) {
                  case 0:
                    return mt.next = 2, rt.server.sendTransaction(rt.assembled.signed);
                  case 2:
                    if (rt.sendTransactionResponse = mt.sent, rt.sendTransactionResponse.status === "PENDING") {
                      mt.next = 5;
                      break;
                    }
                    throw new we.Errors.SendFailed(`Sending the transaction to the network failed!
`.concat(JSON.stringify(rt.sendTransactionResponse, null, 2)));
                  case 5:
                    return It = rt.sendTransactionResponse.hash, We = (Ot = rt.assembled.options.timeoutInSeconds) !== null && Ot !== void 0 ? Ot : E, mt.next = 9, q(function() {
                      return rt.server.getTransaction(It);
                    }, function(Gt) {
                      return Gt.status === f.j.GetTransactionStatus.NOT_FOUND;
                    }, We);
                  case 9:
                    if (rt.getTransactionResponseAll = mt.sent, rt.getTransactionResponse = rt.getTransactionResponseAll[rt.getTransactionResponseAll.length - 1], rt.getTransactionResponse.status !== f.j.GetTransactionStatus.NOT_FOUND) {
                      mt.next = 13;
                      break;
                    }
                    throw new we.Errors.TransactionStillPending("Waited ".concat(We, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(rt.sendTransactionResponse, null, 2), `
`) + "All attempts to get the result: ".concat(JSON.stringify(rt.getTransactionResponseAll, null, 2)));
                  case 13:
                    return mt.abrupt("return", rt);
                  case 14:
                  case "end":
                    return mt.stop();
                }
              }, Tt);
            }))), this.assembled = me, this.server = new h.Server(this.assembled.options.rpcUrl, { allowHttp: (ze = this.assembled.options.allowHttp) !== null && ze !== void 0 && ze });
          }
          return ye(we, [{ key: "result", get: function() {
            if ("getTransactionResponse" in this && this.getTransactionResponse) {
              if ("returnValue" in this.getTransactionResponse) return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
              throw new Error("Transaction failed! Cannot parse result.");
            }
            if (this.sendTransactionResponse) {
              var me, ze = (me = this.sendTransactionResponse.errorResult) === null || me === void 0 ? void 0 : me.result();
              throw ze ? new we.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(ze)) : new we.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
            }
            throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
          } }]);
        }();
        H = ge, ae(ge, "Errors", { SendFailed: function(we) {
          function me() {
            return oe(this, me), z(this, me, arguments);
          }
          return Y(me, we), ye(me);
        }(te(Error)), SendResultOnly: function(we) {
          function me() {
            return oe(this, me), z(this, me, arguments);
          }
          return Y(me, we), ye(me);
        }(te(Error)), TransactionStillPending: function(we) {
          function me() {
            return oe(this, me), z(this, me, arguments);
          }
          return Y(me, we), ye(me);
        }(te(Error)) }), ae(ge, "init", (ne = $(Z().mark(function we(me) {
          var ze, rt;
          return Z().wrap(function(Tt) {
            for (; ; ) switch (Tt.prev = Tt.next) {
              case 0:
                return ze = new H(me), Tt.next = 3, ze.send();
              case 3:
                return rt = Tt.sent, Tt.abrupt("return", rt);
              case 5:
              case "end":
                return Tt.stop();
            }
          }, we);
        })), function(we) {
          return ne.apply(this, arguments);
        }));
        var Te = u(8287).Buffer;
        function pe(we, me, ze) {
          return me = Be(me), function(rt, Tt) {
            if (Tt && (Qe(Tt) == "object" || typeof Tt == "function")) return Tt;
            if (Tt !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(Ot) {
              if (Ot === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return Ot;
            }(rt);
          }(we, Ve() ? Reflect.construct(me, ze || [], Be(we).constructor) : me.apply(we, ze));
        }
        function Oe(we, me) {
          if (typeof me != "function" && me !== null) throw new TypeError("Super expression must either be null or a function");
          we.prototype = Object.create(me && me.prototype, { constructor: { value: we, writable: true, configurable: true } }), Object.defineProperty(we, "prototype", { writable: false }), me && _e(we, me);
        }
        function xe(we) {
          var me = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
          return xe = function(ze) {
            if (ze === null || !function(Tt) {
              try {
                return Function.toString.call(Tt).indexOf("[native code]") !== -1;
              } catch {
                return typeof Tt == "function";
              }
            }(ze)) return ze;
            if (typeof ze != "function") throw new TypeError("Super expression must either be null or a function");
            if (me !== void 0) {
              if (me.has(ze)) return me.get(ze);
              me.set(ze, rt);
            }
            function rt() {
              return function(Tt, Ot, It) {
                if (Ve()) return Reflect.construct.apply(null, arguments);
                var We = [null];
                We.push.apply(We, Ot);
                var mt = new (Tt.bind.apply(Tt, We))();
                return It && _e(mt, It.prototype), mt;
              }(ze, arguments, Be(this).constructor);
            }
            return rt.prototype = Object.create(ze.prototype, { constructor: { value: rt, enumerable: false, writable: true, configurable: true } }), _e(rt, ze);
          }, xe(we);
        }
        function Ve() {
          try {
            var we = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Ve = function() {
            return !!we;
          })();
        }
        function _e(we, me) {
          return _e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ze, rt) {
            return ze.__proto__ = rt, ze;
          }, _e(we, me);
        }
        function Be(we) {
          return Be = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(me) {
            return me.__proto__ || Object.getPrototypeOf(me);
          }, Be(we);
        }
        function Qe(we) {
          return Qe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, Qe(we);
        }
        function ee(we, me) {
          var ze = Object.keys(we);
          if (Object.getOwnPropertySymbols) {
            var rt = Object.getOwnPropertySymbols(we);
            me && (rt = rt.filter(function(Tt) {
              return Object.getOwnPropertyDescriptor(we, Tt).enumerable;
            })), ze.push.apply(ze, rt);
          }
          return ze;
        }
        function P(we) {
          for (var me = 1; me < arguments.length; me++) {
            var ze = arguments[me] != null ? arguments[me] : {};
            me % 2 ? ee(Object(ze), true).forEach(function(rt) {
              de(we, rt, ze[rt]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(we, Object.getOwnPropertyDescriptors(ze)) : ee(Object(ze)).forEach(function(rt) {
              Object.defineProperty(we, rt, Object.getOwnPropertyDescriptor(ze, rt));
            });
          }
          return we;
        }
        function x(we, me) {
          return function(ze) {
            if (Array.isArray(ze)) return ze;
          }(we) || function(ze, rt) {
            var Tt = ze == null ? null : typeof Symbol < "u" && ze[Symbol.iterator] || ze["@@iterator"];
            if (Tt != null) {
              var Ot, It, We, mt, Gt = [], ir = true, dr = false;
              try {
                if (We = (Tt = Tt.call(ze)).next, rt !== 0) for (; !(ir = (Ot = We.call(Tt)).done) && (Gt.push(Ot.value), Gt.length !== rt); ir = true) ;
              } catch (hr) {
                dr = true, It = hr;
              } finally {
                try {
                  if (!ir && Tt.return != null && (mt = Tt.return(), Object(mt) !== mt)) return;
                } finally {
                  if (dr) throw It;
                }
              }
              return Gt;
            }
          }(we, me) || C(we, me) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function O(we, me) {
          var ze = typeof Symbol < "u" && we[Symbol.iterator] || we["@@iterator"];
          if (!ze) {
            if (Array.isArray(we) || (ze = C(we)) || me) {
              ze && (we = ze);
              var rt = 0, Tt = function() {
              };
              return { s: Tt, n: function() {
                return rt >= we.length ? { done: true } : { done: false, value: we[rt++] };
              }, e: function(mt) {
                throw mt;
              }, f: Tt };
            }
            throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }
          var Ot, It = true, We = false;
          return { s: function() {
            ze = ze.call(we);
          }, n: function() {
            var mt = ze.next();
            return It = mt.done, mt;
          }, e: function(mt) {
            We = true, Ot = mt;
          }, f: function() {
            try {
              It || ze.return == null || ze.return();
            } finally {
              if (We) throw Ot;
            }
          } };
        }
        function V() {
          V = function() {
            return me;
          };
          var we, me = {}, ze = Object.prototype, rt = ze.hasOwnProperty, Tt = Object.defineProperty || function(Me, De, Ke) {
            Me[De] = Ke.value;
          }, Ot = typeof Symbol == "function" ? Symbol : {}, It = Ot.iterator || "@@iterator", We = Ot.asyncIterator || "@@asyncIterator", mt = Ot.toStringTag || "@@toStringTag";
          function Gt(Me, De, Ke) {
            return Object.defineProperty(Me, De, { value: Ke, enumerable: true, configurable: true, writable: true }), Me[De];
          }
          try {
            Gt({}, "");
          } catch {
            Gt = function(De, Ke, Bt) {
              return De[Ke] = Bt;
            };
          }
          function ir(Me, De, Ke, Bt) {
            var St = De && De.prototype instanceof Vr ? De : Vr, ur = Object.create(St.prototype), Cr = new zr(Bt || []);
            return Tt(ur, "_invoke", { value: Yt(Me, Ke, Cr) }), ur;
          }
          function dr(Me, De, Ke) {
            try {
              return { type: "normal", arg: Me.call(De, Ke) };
            } catch (Bt) {
              return { type: "throw", arg: Bt };
            }
          }
          me.wrap = ir;
          var hr = "suspendedStart", Fr = "suspendedYield", Gr = "executing", Br = "completed", Dr = {};
          function Vr() {
          }
          function be() {
          }
          function Or() {
          }
          var Ue = {};
          Gt(Ue, It, function() {
            return this;
          });
          var it = Object.getPrototypeOf, dt = it && it(it(en([])));
          dt && dt !== ze && rt.call(dt, It) && (Ue = dt);
          var vt = Or.prototype = Vr.prototype = Object.create(Ue);
          function wt(Me) {
            ["next", "throw", "return"].forEach(function(De) {
              Gt(Me, De, function(Ke) {
                return this._invoke(De, Ke);
              });
            });
          }
          function Pt(Me, De) {
            function Ke(St, ur, Cr, Wr) {
              var Zr = dr(Me[St], Me, ur);
              if (Zr.type !== "throw") {
                var dn = Zr.arg, wn = dn.value;
                return wn && Qe(wn) == "object" && rt.call(wn, "__await") ? De.resolve(wn.__await).then(function(yn) {
                  Ke("next", yn, Cr, Wr);
                }, function(yn) {
                  Ke("throw", yn, Cr, Wr);
                }) : De.resolve(wn).then(function(yn) {
                  dn.value = yn, Cr(dn);
                }, function(yn) {
                  return Ke("throw", yn, Cr, Wr);
                });
              }
              Wr(Zr.arg);
            }
            var Bt;
            Tt(this, "_invoke", { value: function(St, ur) {
              function Cr() {
                return new De(function(Wr, Zr) {
                  Ke(St, ur, Wr, Zr);
                });
              }
              return Bt = Bt ? Bt.then(Cr, Cr) : Cr();
            } });
          }
          function Yt(Me, De, Ke) {
            var Bt = hr;
            return function(St, ur) {
              if (Bt === Gr) throw Error("Generator is already running");
              if (Bt === Br) {
                if (St === "throw") throw ur;
                return { value: we, done: true };
              }
              for (Ke.method = St, Ke.arg = ur; ; ) {
                var Cr = Ke.delegate;
                if (Cr) {
                  var Wr = cr(Cr, Ke);
                  if (Wr) {
                    if (Wr === Dr) continue;
                    return Wr;
                  }
                }
                if (Ke.method === "next") Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (Bt === hr) throw Bt = Br, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                Bt = Gr;
                var Zr = dr(Me, De, Ke);
                if (Zr.type === "normal") {
                  if (Bt = Ke.done ? Br : Fr, Zr.arg === Dr) continue;
                  return { value: Zr.arg, done: Ke.done };
                }
                Zr.type === "throw" && (Bt = Br, Ke.method = "throw", Ke.arg = Zr.arg);
              }
            };
          }
          function cr(Me, De) {
            var Ke = De.method, Bt = Me.iterator[Ke];
            if (Bt === we) return De.delegate = null, Ke === "throw" && Me.iterator.return && (De.method = "return", De.arg = we, cr(Me, De), De.method === "throw") || Ke !== "return" && (De.method = "throw", De.arg = new TypeError("The iterator does not provide a '" + Ke + "' method")), Dr;
            var St = dr(Bt, Me.iterator, De.arg);
            if (St.type === "throw") return De.method = "throw", De.arg = St.arg, De.delegate = null, Dr;
            var ur = St.arg;
            return ur ? ur.done ? (De[Me.resultName] = ur.value, De.next = Me.nextLoc, De.method !== "return" && (De.method = "next", De.arg = we), De.delegate = null, Dr) : ur : (De.method = "throw", De.arg = new TypeError("iterator result is not an object"), De.delegate = null, Dr);
          }
          function qr(Me) {
            var De = { tryLoc: Me[0] };
            1 in Me && (De.catchLoc = Me[1]), 2 in Me && (De.finallyLoc = Me[2], De.afterLoc = Me[3]), this.tryEntries.push(De);
          }
          function Vt(Me) {
            var De = Me.completion || {};
            De.type = "normal", delete De.arg, Me.completion = De;
          }
          function zr(Me) {
            this.tryEntries = [{ tryLoc: "root" }], Me.forEach(qr, this), this.reset(true);
          }
          function en(Me) {
            if (Me || Me === "") {
              var De = Me[It];
              if (De) return De.call(Me);
              if (typeof Me.next == "function") return Me;
              if (!isNaN(Me.length)) {
                var Ke = -1, Bt = function St() {
                  for (; ++Ke < Me.length; ) if (rt.call(Me, Ke)) return St.value = Me[Ke], St.done = false, St;
                  return St.value = we, St.done = true, St;
                };
                return Bt.next = Bt;
              }
            }
            throw new TypeError(Qe(Me) + " is not iterable");
          }
          return be.prototype = Or, Tt(vt, "constructor", { value: Or, configurable: true }), Tt(Or, "constructor", { value: be, configurable: true }), be.displayName = Gt(Or, mt, "GeneratorFunction"), me.isGeneratorFunction = function(Me) {
            var De = typeof Me == "function" && Me.constructor;
            return !!De && (De === be || (De.displayName || De.name) === "GeneratorFunction");
          }, me.mark = function(Me) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Me, Or) : (Me.__proto__ = Or, Gt(Me, mt, "GeneratorFunction")), Me.prototype = Object.create(vt), Me;
          }, me.awrap = function(Me) {
            return { __await: Me };
          }, wt(Pt.prototype), Gt(Pt.prototype, We, function() {
            return this;
          }), me.AsyncIterator = Pt, me.async = function(Me, De, Ke, Bt, St) {
            St === void 0 && (St = Promise);
            var ur = new Pt(ir(Me, De, Ke, Bt), St);
            return me.isGeneratorFunction(De) ? ur : ur.next().then(function(Cr) {
              return Cr.done ? Cr.value : ur.next();
            });
          }, wt(vt), Gt(vt, mt, "Generator"), Gt(vt, It, function() {
            return this;
          }), Gt(vt, "toString", function() {
            return "[object Generator]";
          }), me.keys = function(Me) {
            var De = Object(Me), Ke = [];
            for (var Bt in De) Ke.push(Bt);
            return Ke.reverse(), function St() {
              for (; Ke.length; ) {
                var ur = Ke.pop();
                if (ur in De) return St.value = ur, St.done = false, St;
              }
              return St.done = true, St;
            };
          }, me.values = en, zr.prototype = { constructor: zr, reset: function(Me) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = we, this.done = false, this.delegate = null, this.method = "next", this.arg = we, this.tryEntries.forEach(Vt), !Me) for (var De in this) De.charAt(0) === "t" && rt.call(this, De) && !isNaN(+De.slice(1)) && (this[De] = we);
          }, stop: function() {
            this.done = true;
            var Me = this.tryEntries[0].completion;
            if (Me.type === "throw") throw Me.arg;
            return this.rval;
          }, dispatchException: function(Me) {
            if (this.done) throw Me;
            var De = this;
            function Ke(Zr, dn) {
              return ur.type = "throw", ur.arg = Me, De.next = Zr, dn && (De.method = "next", De.arg = we), !!dn;
            }
            for (var Bt = this.tryEntries.length - 1; Bt >= 0; --Bt) {
              var St = this.tryEntries[Bt], ur = St.completion;
              if (St.tryLoc === "root") return Ke("end");
              if (St.tryLoc <= this.prev) {
                var Cr = rt.call(St, "catchLoc"), Wr = rt.call(St, "finallyLoc");
                if (Cr && Wr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                } else if (Cr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                } else {
                  if (!Wr) throw Error("try statement without catch or finally");
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                }
              }
            }
          }, abrupt: function(Me, De) {
            for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
              var Bt = this.tryEntries[Ke];
              if (Bt.tryLoc <= this.prev && rt.call(Bt, "finallyLoc") && this.prev < Bt.finallyLoc) {
                var St = Bt;
                break;
              }
            }
            St && (Me === "break" || Me === "continue") && St.tryLoc <= De && De <= St.finallyLoc && (St = null);
            var ur = St ? St.completion : {};
            return ur.type = Me, ur.arg = De, St ? (this.method = "next", this.next = St.finallyLoc, Dr) : this.complete(ur);
          }, complete: function(Me, De) {
            if (Me.type === "throw") throw Me.arg;
            return Me.type === "break" || Me.type === "continue" ? this.next = Me.arg : Me.type === "return" ? (this.rval = this.arg = Me.arg, this.method = "return", this.next = "end") : Me.type === "normal" && De && (this.next = De), Dr;
          }, finish: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.finallyLoc === Me) return this.complete(Ke.completion, Ke.afterLoc), Vt(Ke), Dr;
            }
          }, catch: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.tryLoc === Me) {
                var Bt = Ke.completion;
                if (Bt.type === "throw") {
                  var St = Bt.arg;
                  Vt(Ke);
                }
                return St;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Me, De, Ke) {
            return this.delegate = { iterator: en(Me), resultName: De, nextLoc: Ke }, this.method === "next" && (this.arg = we), Dr;
          } }, me;
        }
        function N(we) {
          return function(me) {
            if (Array.isArray(me)) return p(me);
          }(we) || function(me) {
            if (typeof Symbol < "u" && me[Symbol.iterator] != null || me["@@iterator"] != null) return Array.from(me);
          }(we) || C(we) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function C(we, me) {
          if (we) {
            if (typeof we == "string") return p(we, me);
            var ze = {}.toString.call(we).slice(8, -1);
            return ze === "Object" && we.constructor && (ze = we.constructor.name), ze === "Map" || ze === "Set" ? Array.from(we) : ze === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ze) ? p(we, me) : void 0;
          }
        }
        function p(we, me) {
          (me == null || me > we.length) && (me = we.length);
          for (var ze = 0, rt = Array(me); ze < me; ze++) rt[ze] = we[ze];
          return rt;
        }
        function A(we, me, ze, rt, Tt, Ot, It) {
          try {
            var We = we[Ot](It), mt = We.value;
          } catch (Gt) {
            return void ze(Gt);
          }
          We.done ? me(mt) : Promise.resolve(mt).then(rt, Tt);
        }
        function U(we) {
          return function() {
            var me = this, ze = arguments;
            return new Promise(function(rt, Tt) {
              var Ot = we.apply(me, ze);
              function It(mt) {
                A(Ot, rt, Tt, It, We, "next", mt);
              }
              function We(mt) {
                A(Ot, rt, Tt, It, We, "throw", mt);
              }
              It(void 0);
            });
          };
        }
        function Q(we, me) {
          if (!(we instanceof me)) throw new TypeError("Cannot call a class as a function");
        }
        function se(we, me) {
          for (var ze = 0; ze < me.length; ze++) {
            var rt = me[ze];
            rt.enumerable = rt.enumerable || false, rt.configurable = true, "value" in rt && (rt.writable = true), Object.defineProperty(we, tt(rt.key), rt);
          }
        }
        function X(we, me, ze) {
          return me && se(we.prototype, me), ze && se(we, ze), Object.defineProperty(we, "prototype", { writable: false }), we;
        }
        function de(we, me, ze) {
          return (me = tt(me)) in we ? Object.defineProperty(we, me, { value: ze, enumerable: true, configurable: true, writable: true }) : we[me] = ze, we;
        }
        function tt(we) {
          var me = function(ze, rt) {
            if (Qe(ze) != "object" || !ze) return ze;
            var Tt = ze[Symbol.toPrimitive];
            if (Tt !== void 0) {
              var Ot = Tt.call(ze, rt);
              if (Qe(Ot) != "object") return Ot;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (rt === "string" ? String : Number)(ze);
          }(we, "string");
          return Qe(me) == "symbol" ? me : me + "";
        }
        var Ne = function() {
          function we(Ot) {
            var It, We, mt = this;
            Q(this, we), de(this, "simulate", U(V().mark(function Gt() {
              var ir, dr, hr, Fr, Gr, Br, Dr, Vr = arguments;
              return V().wrap(function(be) {
                for (; ; ) switch (be.prev = be.next) {
                  case 0:
                    if (ir = (Vr.length > 0 && Vr[0] !== void 0 ? Vr[0] : {}).restore, mt.built) {
                      be.next = 5;
                      break;
                    }
                    if (mt.raw) {
                      be.next = 4;
                      break;
                    }
                    throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
                  case 4:
                    mt.built = mt.raw.build();
                  case 5:
                    return ir = ir ?? mt.options.restore, delete mt.simulationResult, delete mt.simulationTransactionData, be.next = 10, mt.server.simulateTransaction(mt.built);
                  case 10:
                    if (mt.simulation = be.sent, !ir || !f.j.isSimulationRestore(mt.simulation)) {
                      be.next = 25;
                      break;
                    }
                    return be.next = 14, L(mt.options, mt.server);
                  case 14:
                    return dr = be.sent, be.next = 17, mt.restoreFootprint(mt.simulation.restorePreamble, dr);
                  case 17:
                    if ((hr = be.sent).status !== f.j.GetTransactionStatus.SUCCESS) {
                      be.next = 24;
                      break;
                    }
                    return Dr = new c.Contract(mt.options.contractId), mt.raw = new c.TransactionBuilder(dr, { fee: (Fr = mt.options.fee) !== null && Fr !== void 0 ? Fr : c.BASE_FEE, networkPassphrase: mt.options.networkPassphrase }).addOperation(Dr.call.apply(Dr, [mt.options.method].concat(N((Gr = mt.options.args) !== null && Gr !== void 0 ? Gr : [])))).setTimeout((Br = mt.options.timeoutInSeconds) !== null && Br !== void 0 ? Br : E), be.next = 23, mt.simulate();
                  case 23:
                    return be.abrupt("return", mt);
                  case 24:
                    throw new we.Errors.RestorationFailure(`Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:
`.concat(JSON.stringify(hr)));
                  case 25:
                    return f.j.isSimulationSuccess(mt.simulation) && (mt.built = (0, r.X)(mt.built, mt.simulation).build()), be.abrupt("return", mt);
                  case 27:
                  case "end":
                    return be.stop();
                }
              }, Gt);
            }))), de(this, "sign", U(V().mark(function Gt() {
              var ir, dr, hr, Fr, Gr, Br, Dr, Vr, be, Or, Ue, it, dt = arguments;
              return V().wrap(function(vt) {
                for (; ; ) switch (vt.prev = vt.next) {
                  case 0:
                    if (hr = (dr = dt.length > 0 && dt[0] !== void 0 ? dt[0] : {}).force, Fr = hr !== void 0 && hr, Gr = dr.signTransaction, Br = Gr === void 0 ? mt.options.signTransaction : Gr, mt.built) {
                      vt.next = 3;
                      break;
                    }
                    throw new Error("Transaction has not yet been simulated");
                  case 3:
                    if (Fr || !mt.isReadCall) {
                      vt.next = 5;
                      break;
                    }
                    throw new we.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
                  case 5:
                    if (Br) {
                      vt.next = 7;
                      break;
                    }
                    throw new we.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
                  case 7:
                    if (!(Dr = mt.needsNonInvokerSigningBy().filter(function(wt) {
                      return !wt.startsWith("C");
                    })).length) {
                      vt.next = 10;
                      break;
                    }
                    throw new we.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(Dr, ". ") + "See `needsNonInvokerSigningBy` for details.");
                  case 10:
                    return Vr = (ir = mt.options.timeoutInSeconds) !== null && ir !== void 0 ? ir : E, mt.built = c.TransactionBuilder.cloneFrom(mt.built, { fee: mt.built.fee, timebounds: void 0, sorobanData: mt.simulationData.transactionData }).setTimeout(Vr).build(), be = { networkPassphrase: mt.options.networkPassphrase }, mt.options.address && (be.address = mt.options.address), mt.options.submit !== void 0 && (be.submit = mt.options.submit), mt.options.submitUrl && (be.submitUrl = mt.options.submitUrl), vt.next = 18, Br(mt.built.toXDR(), be);
                  case 18:
                    Or = vt.sent, Ue = Or.signedTxXdr, it = Or.error, mt.handleWalletError(it), mt.signed = c.TransactionBuilder.fromXDR(Ue, mt.options.networkPassphrase);
                  case 23:
                  case "end":
                    return vt.stop();
                }
              }, Gt);
            }))), de(this, "signAndSend", U(V().mark(function Gt() {
              var ir, dr, hr, Fr, Gr, Br, Dr = arguments;
              return V().wrap(function(Vr) {
                for (; ; ) switch (Vr.prev = Vr.next) {
                  case 0:
                    if (dr = (ir = Dr.length > 0 && Dr[0] !== void 0 ? Dr[0] : {}).force, hr = dr !== void 0 && dr, Fr = ir.signTransaction, Gr = Fr === void 0 ? mt.options.signTransaction : Fr, mt.signed) {
                      Vr.next = 10;
                      break;
                    }
                    return Br = mt.options.submit, mt.options.submit && (mt.options.submit = false), Vr.prev = 4, Vr.next = 7, mt.sign({ force: hr, signTransaction: Gr });
                  case 7:
                    return Vr.prev = 7, mt.options.submit = Br, Vr.finish(7);
                  case 10:
                    return Vr.abrupt("return", mt.send());
                  case 11:
                  case "end":
                    return Vr.stop();
                }
              }, Gt, null, [[4, , 7, 10]]);
            }))), de(this, "needsNonInvokerSigningBy", function() {
              var Gt, ir = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).includeAlreadySigned, dr = ir !== void 0 && ir;
              if (!mt.built) throw new Error("Transaction has not yet been simulated");
              if (!("operations" in mt.built)) throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(mt.built)));
              var hr = mt.built.operations[0];
              return N(new Set(((Gt = hr.auth) !== null && Gt !== void 0 ? Gt : []).filter(function(Fr) {
                return Fr.credentials().switch() === c.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (dr || Fr.credentials().address().signature().switch().name === "scvVoid");
              }).map(function(Fr) {
                return c.Address.fromScAddress(Fr.credentials().address().address()).toString();
              })));
            }), de(this, "signAuthEntries", U(V().mark(function Gt() {
              var ir, dr, hr, Fr, Gr, Br, Dr, Vr, be, Or, Ue, it, dt, vt, wt, Pt, Yt = arguments;
              return V().wrap(function(cr) {
                for (; ; ) switch (cr.prev = cr.next) {
                  case 0:
                    if (hr = (dr = Yt.length > 0 && Yt[0] !== void 0 ? Yt[0] : {}).expiration, Fr = hr === void 0 ? U(V().mark(function qr() {
                      return V().wrap(function(Vt) {
                        for (; ; ) switch (Vt.prev = Vt.next) {
                          case 0:
                            return Vt.next = 2, mt.server.getLatestLedger();
                          case 2:
                            return Vt.t0 = Vt.sent.sequence, Vt.abrupt("return", Vt.t0 + 100);
                          case 4:
                          case "end":
                            return Vt.stop();
                        }
                      }, qr);
                    }))() : hr, Gr = dr.signAuthEntry, Br = Gr === void 0 ? mt.options.signAuthEntry : Gr, Dr = dr.address, Vr = Dr === void 0 ? mt.options.publicKey : Dr, be = dr.authorizeEntry, Or = be === void 0 ? c.authorizeEntry : be, mt.built) {
                      cr.next = 3;
                      break;
                    }
                    throw new Error("Transaction has not yet been assembled or simulated");
                  case 3:
                    if (Or !== c.authorizeEntry) {
                      cr.next = 11;
                      break;
                    }
                    if ((Ue = mt.needsNonInvokerSigningBy()).length !== 0) {
                      cr.next = 7;
                      break;
                    }
                    throw new we.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
                  case 7:
                    if (Ue.indexOf(Vr ?? "") !== -1) {
                      cr.next = 9;
                      break;
                    }
                    throw new we.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(Vr, '"'));
                  case 9:
                    if (Br) {
                      cr.next = 11;
                      break;
                    }
                    throw new we.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
                  case 11:
                    it = mt.built.operations[0], dt = (ir = it.auth) !== null && ir !== void 0 ? ir : [], vt = O(dt.entries()), cr.prev = 14, Pt = V().mark(function qr() {
                      var Vt, zr, en, Me, De;
                      return V().wrap(function(Ke) {
                        for (; ; ) switch (Ke.prev = Ke.next) {
                          case 0:
                            if (Vt = x(wt.value, 2), zr = Vt[0], en = Vt[1], (Me = c.xdr.SorobanCredentials.fromXDR(en.credentials().toXDR())).switch() === c.xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {
                              Ke.next = 4;
                              break;
                            }
                            return Ke.abrupt("return", 0);
                          case 4:
                            if (c.Address.fromScAddress(Me.address().address()).toString() === Vr) {
                              Ke.next = 7;
                              break;
                            }
                            return Ke.abrupt("return", 0);
                          case 7:
                            return De = Br ?? Promise.resolve, Ke.t0 = Or, Ke.t1 = en, Ke.t2 = function() {
                              var Bt = U(V().mark(function St(ur) {
                                var Cr, Wr, Zr;
                                return V().wrap(function(dn) {
                                  for (; ; ) switch (dn.prev = dn.next) {
                                    case 0:
                                      return dn.next = 2, De(ur.toXDR("base64"), { address: Vr });
                                    case 2:
                                      return Cr = dn.sent, Wr = Cr.signedAuthEntry, Zr = Cr.error, mt.handleWalletError(Zr), dn.abrupt("return", Te.from(Wr, "base64"));
                                    case 7:
                                    case "end":
                                      return dn.stop();
                                  }
                                }, St);
                              }));
                              return function(St) {
                                return Bt.apply(this, arguments);
                              };
                            }(), Ke.next = 13, Fr;
                          case 13:
                            return Ke.t3 = Ke.sent, Ke.t4 = mt.options.networkPassphrase, Ke.next = 17, (0, Ke.t0)(Ke.t1, Ke.t2, Ke.t3, Ke.t4);
                          case 17:
                            dt[zr] = Ke.sent;
                          case 18:
                          case "end":
                            return Ke.stop();
                        }
                      }, qr);
                    }), vt.s();
                  case 17:
                    if ((wt = vt.n()).done) {
                      cr.next = 24;
                      break;
                    }
                    return cr.delegateYield(Pt(), "t0", 19);
                  case 19:
                    if (cr.t0 !== 0) {
                      cr.next = 22;
                      break;
                    }
                    return cr.abrupt("continue", 22);
                  case 22:
                    cr.next = 17;
                    break;
                  case 24:
                    cr.next = 29;
                    break;
                  case 26:
                    cr.prev = 26, cr.t1 = cr.catch(14), vt.e(cr.t1);
                  case 29:
                    return cr.prev = 29, vt.f(), cr.finish(29);
                  case 32:
                  case "end":
                    return cr.stop();
                }
              }, Gt, null, [[14, 26, 29, 32]]);
            }))), this.options = Ot, this.options.simulate = (It = this.options.simulate) === null || It === void 0 || It, this.server = new h.Server(this.options.rpcUrl, { allowHttp: (We = this.options.allowHttp) !== null && We !== void 0 && We });
          }
          return X(we, [{ key: "toJSON", value: function() {
            var Ot;
            return JSON.stringify({ method: this.options.method, tx: (Ot = this.built) === null || Ot === void 0 ? void 0 : Ot.toXDR(), simulationResult: { auth: this.simulationData.result.auth.map(function(It) {
              return It.toXDR("base64");
            }), retval: this.simulationData.result.retval.toXDR("base64") }, simulationTransactionData: this.simulationData.transactionData.toXDR("base64") });
          } }, { key: "toXDR", value: function() {
            var Ot;
            if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
            return (Ot = this.built) === null || Ot === void 0 ? void 0 : Ot.toEnvelope().toXDR("base64");
          } }, { key: "handleWalletError", value: function(Ot) {
            if (Ot) {
              var It = Ot.message, We = Ot.code, mt = "".concat(It).concat(Ot.ext ? " (".concat(Ot.ext.join(", "), ")") : "");
              switch (We) {
                case -1:
                  throw new we.Errors.InternalWalletError(mt);
                case -2:
                  throw new we.Errors.ExternalServiceError(mt);
                case -3:
                  throw new we.Errors.InvalidClientRequest(mt);
                case -4:
                  throw new we.Errors.UserRejected(mt);
                default:
                  throw new Error("Unhandled error: ".concat(mt));
              }
            }
          } }, { key: "simulationData", get: function() {
            var Ot;
            if (this.simulationResult && this.simulationTransactionData) return { result: this.simulationResult, transactionData: this.simulationTransactionData };
            var It = this.simulation;
            if (!It) throw new we.Errors.NotYetSimulated("Transaction has not yet been simulated");
            if (f.j.isSimulationError(It)) throw new we.Errors.SimulationFailed('Transaction simulation failed: "'.concat(It.error, '"'));
            if (f.j.isSimulationRestore(It)) throw new we.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
            return this.simulationResult = (Ot = It.result) !== null && Ot !== void 0 ? Ot : { auth: [], retval: c.xdr.ScVal.scvVoid() }, this.simulationTransactionData = It.transactionData.build(), { result: this.simulationResult, transactionData: this.simulationTransactionData };
          } }, { key: "result", get: function() {
            try {
              if (!this.simulationData.result) throw new Error("No simulation result!");
              return this.options.parseResultXdr(this.simulationData.result.retval);
            } catch (We) {
              if (w(It = We) !== "object" || It === null || !("toString" in It)) throw We;
              var Ot = this.parseError(We.toString());
              if (Ot) return Ot;
              throw We;
            }
            var It;
          } }, { key: "parseError", value: function(Ot) {
            if (this.options.errorTypes) {
              var It = Ot.match(_);
              if (It) {
                var We = parseInt(It[1], 10), mt = this.options.errorTypes[We];
                if (mt) return new S(mt);
              }
            }
          } }, { key: "send", value: (Tt = U(V().mark(function Ot() {
            var It;
            return V().wrap(function(We) {
              for (; ; ) switch (We.prev = We.next) {
                case 0:
                  if (this.signed) {
                    We.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  return We.next = 4, ge.init(this);
                case 4:
                  return It = We.sent, We.abrupt("return", It);
                case 6:
                case "end":
                  return We.stop();
              }
            }, Ot, this);
          })), function() {
            return Tt.apply(this, arguments);
          }) }, { key: "isReadCall", get: function() {
            var Ot = this.simulationData.result.auth.length, It = this.simulationData.transactionData.resources().footprint().readWrite().length;
            return Ot === 0 && It === 0;
          } }, { key: "restoreFootprint", value: (rt = U(V().mark(function Ot(It, We) {
            var mt, Gt;
            return V().wrap(function(ir) {
              for (; ; ) switch (ir.prev = ir.next) {
                case 0:
                  if (this.options.signTransaction) {
                    ir.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (We == null) {
                    ir.next = 6;
                    break;
                  }
                  ir.t0 = We, ir.next = 9;
                  break;
                case 6:
                  return ir.next = 8, L(this.options, this.server);
                case 8:
                  ir.t0 = ir.sent;
                case 9:
                  return We = ir.t0, ir.next = 12, we.buildFootprintRestoreTransaction(P({}, this.options), It.transactionData, We, It.minResourceFee);
                case 12:
                  return mt = ir.sent, ir.next = 15, mt.signAndSend();
                case 15:
                  if ((Gt = ir.sent).getTransactionResponse) {
                    ir.next = 18;
                    break;
                  }
                  throw new we.Errors.RestorationFailure(`The attempt at automatic restore failed. 
`.concat(JSON.stringify(Gt)));
                case 18:
                  return ir.abrupt("return", Gt.getTransactionResponse);
                case 19:
                case "end":
                  return ir.stop();
              }
            }, Ot, this);
          })), function(Ot, It) {
            return rt.apply(this, arguments);
          }) }], [{ key: "fromJSON", value: function(Ot, It) {
            var We = It.tx, mt = It.simulationResult, Gt = It.simulationTransactionData, ir = new we(Ot);
            return ir.built = c.TransactionBuilder.fromXDR(We, Ot.networkPassphrase), ir.simulationResult = { auth: mt.auth.map(function(dr) {
              return c.xdr.SorobanAuthorizationEntry.fromXDR(dr, "base64");
            }), retval: c.xdr.ScVal.fromXDR(mt.retval, "base64") }, ir.simulationTransactionData = c.xdr.SorobanTransactionData.fromXDR(Gt, "base64"), ir;
          } }, { key: "fromXDR", value: function(Ot, It, We) {
            var mt, Gt = c.xdr.TransactionEnvelope.fromXDR(It, "base64"), ir = c.TransactionBuilder.fromXDR(Gt, Ot.networkPassphrase), dr = ir.operations[0];
            if (dr == null || (mt = dr.func) === null || mt === void 0 || !mt.value || typeof dr.func.value != "function") throw new Error("Could not extract the method from the transaction envelope.");
            var hr = dr.func.value();
            if (hr == null || !hr.functionName) throw new Error("Could not extract the method name from the transaction envelope.");
            var Fr = hr.functionName().toString("utf-8"), Gr = new we(P(P({}, Ot), {}, { method: Fr, parseResultXdr: function(Br) {
              return We.funcResToNative(Fr, Br);
            } }));
            return Gr.built = ir, Gr;
          } }, { key: "build", value: function(Ot) {
            var It, We = new c.Contract(Ot.contractId);
            return we.buildWithOp(We.call.apply(We, [Ot.method].concat(N((It = Ot.args) !== null && It !== void 0 ? It : []))), Ot);
          } }, { key: "buildWithOp", value: (ze = U(V().mark(function Ot(It, We) {
            var mt, Gt, ir, dr;
            return V().wrap(function(hr) {
              for (; ; ) switch (hr.prev = hr.next) {
                case 0:
                  return ir = new we(We), hr.next = 3, L(We, ir.server);
                case 3:
                  if (dr = hr.sent, ir.raw = new c.TransactionBuilder(dr, { fee: (mt = We.fee) !== null && mt !== void 0 ? mt : c.BASE_FEE, networkPassphrase: We.networkPassphrase }).setTimeout((Gt = We.timeoutInSeconds) !== null && Gt !== void 0 ? Gt : E).addOperation(It), !We.simulate) {
                    hr.next = 8;
                    break;
                  }
                  return hr.next = 8, ir.simulate();
                case 8:
                  return hr.abrupt("return", ir);
                case 9:
                case "end":
                  return hr.stop();
              }
            }, Ot);
          })), function(Ot, It) {
            return ze.apply(this, arguments);
          }) }, { key: "buildFootprintRestoreTransaction", value: (me = U(V().mark(function Ot(It, We, mt, Gt) {
            var ir, dr;
            return V().wrap(function(hr) {
              for (; ; ) switch (hr.prev = hr.next) {
                case 0:
                  return (dr = new we(It)).raw = new c.TransactionBuilder(mt, { fee: Gt, networkPassphrase: It.networkPassphrase }).setSorobanData(We instanceof c.SorobanDataBuilder ? We.build() : We).addOperation(c.Operation.restoreFootprint({})).setTimeout((ir = It.timeoutInSeconds) !== null && ir !== void 0 ? ir : E), hr.next = 4, dr.simulate({ restore: false });
                case 4:
                  return hr.abrupt("return", dr);
                case 5:
                case "end":
                  return hr.stop();
              }
            }, Ot);
          })), function(Ot, It, We, mt) {
            return me.apply(this, arguments);
          }) }]);
          var me, ze, rt, Tt;
        }();
        de(Ne, "Errors", { ExpiredState: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), RestorationFailure: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), NeedsMoreSignatures: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), NoSignatureNeeded: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), NoUnsignedNonInvokerAuthEntries: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), NoSigner: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), NotYetSimulated: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), FakeAccount: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), SimulationFailed: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), InternalWalletError: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), ExternalServiceError: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), InvalidClientRequest: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)), UserRejected: function(we) {
          function me() {
            return Q(this, me), pe(this, me, arguments);
          }
          return Oe(me, we), X(me);
        }(xe(Error)) });
        var ut = u(8287).Buffer;
        function Ze(we) {
          return Ze = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, Ze(we);
        }
        function Et() {
          Et = function() {
            return me;
          };
          var we, me = {}, ze = Object.prototype, rt = ze.hasOwnProperty, Tt = Object.defineProperty || function(Me, De, Ke) {
            Me[De] = Ke.value;
          }, Ot = typeof Symbol == "function" ? Symbol : {}, It = Ot.iterator || "@@iterator", We = Ot.asyncIterator || "@@asyncIterator", mt = Ot.toStringTag || "@@toStringTag";
          function Gt(Me, De, Ke) {
            return Object.defineProperty(Me, De, { value: Ke, enumerable: true, configurable: true, writable: true }), Me[De];
          }
          try {
            Gt({}, "");
          } catch {
            Gt = function(De, Ke, Bt) {
              return De[Ke] = Bt;
            };
          }
          function ir(Me, De, Ke, Bt) {
            var St = De && De.prototype instanceof Vr ? De : Vr, ur = Object.create(St.prototype), Cr = new zr(Bt || []);
            return Tt(ur, "_invoke", { value: Yt(Me, Ke, Cr) }), ur;
          }
          function dr(Me, De, Ke) {
            try {
              return { type: "normal", arg: Me.call(De, Ke) };
            } catch (Bt) {
              return { type: "throw", arg: Bt };
            }
          }
          me.wrap = ir;
          var hr = "suspendedStart", Fr = "suspendedYield", Gr = "executing", Br = "completed", Dr = {};
          function Vr() {
          }
          function be() {
          }
          function Or() {
          }
          var Ue = {};
          Gt(Ue, It, function() {
            return this;
          });
          var it = Object.getPrototypeOf, dt = it && it(it(en([])));
          dt && dt !== ze && rt.call(dt, It) && (Ue = dt);
          var vt = Or.prototype = Vr.prototype = Object.create(Ue);
          function wt(Me) {
            ["next", "throw", "return"].forEach(function(De) {
              Gt(Me, De, function(Ke) {
                return this._invoke(De, Ke);
              });
            });
          }
          function Pt(Me, De) {
            function Ke(St, ur, Cr, Wr) {
              var Zr = dr(Me[St], Me, ur);
              if (Zr.type !== "throw") {
                var dn = Zr.arg, wn = dn.value;
                return wn && Ze(wn) == "object" && rt.call(wn, "__await") ? De.resolve(wn.__await).then(function(yn) {
                  Ke("next", yn, Cr, Wr);
                }, function(yn) {
                  Ke("throw", yn, Cr, Wr);
                }) : De.resolve(wn).then(function(yn) {
                  dn.value = yn, Cr(dn);
                }, function(yn) {
                  return Ke("throw", yn, Cr, Wr);
                });
              }
              Wr(Zr.arg);
            }
            var Bt;
            Tt(this, "_invoke", { value: function(St, ur) {
              function Cr() {
                return new De(function(Wr, Zr) {
                  Ke(St, ur, Wr, Zr);
                });
              }
              return Bt = Bt ? Bt.then(Cr, Cr) : Cr();
            } });
          }
          function Yt(Me, De, Ke) {
            var Bt = hr;
            return function(St, ur) {
              if (Bt === Gr) throw Error("Generator is already running");
              if (Bt === Br) {
                if (St === "throw") throw ur;
                return { value: we, done: true };
              }
              for (Ke.method = St, Ke.arg = ur; ; ) {
                var Cr = Ke.delegate;
                if (Cr) {
                  var Wr = cr(Cr, Ke);
                  if (Wr) {
                    if (Wr === Dr) continue;
                    return Wr;
                  }
                }
                if (Ke.method === "next") Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (Bt === hr) throw Bt = Br, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                Bt = Gr;
                var Zr = dr(Me, De, Ke);
                if (Zr.type === "normal") {
                  if (Bt = Ke.done ? Br : Fr, Zr.arg === Dr) continue;
                  return { value: Zr.arg, done: Ke.done };
                }
                Zr.type === "throw" && (Bt = Br, Ke.method = "throw", Ke.arg = Zr.arg);
              }
            };
          }
          function cr(Me, De) {
            var Ke = De.method, Bt = Me.iterator[Ke];
            if (Bt === we) return De.delegate = null, Ke === "throw" && Me.iterator.return && (De.method = "return", De.arg = we, cr(Me, De), De.method === "throw") || Ke !== "return" && (De.method = "throw", De.arg = new TypeError("The iterator does not provide a '" + Ke + "' method")), Dr;
            var St = dr(Bt, Me.iterator, De.arg);
            if (St.type === "throw") return De.method = "throw", De.arg = St.arg, De.delegate = null, Dr;
            var ur = St.arg;
            return ur ? ur.done ? (De[Me.resultName] = ur.value, De.next = Me.nextLoc, De.method !== "return" && (De.method = "next", De.arg = we), De.delegate = null, Dr) : ur : (De.method = "throw", De.arg = new TypeError("iterator result is not an object"), De.delegate = null, Dr);
          }
          function qr(Me) {
            var De = { tryLoc: Me[0] };
            1 in Me && (De.catchLoc = Me[1]), 2 in Me && (De.finallyLoc = Me[2], De.afterLoc = Me[3]), this.tryEntries.push(De);
          }
          function Vt(Me) {
            var De = Me.completion || {};
            De.type = "normal", delete De.arg, Me.completion = De;
          }
          function zr(Me) {
            this.tryEntries = [{ tryLoc: "root" }], Me.forEach(qr, this), this.reset(true);
          }
          function en(Me) {
            if (Me || Me === "") {
              var De = Me[It];
              if (De) return De.call(Me);
              if (typeof Me.next == "function") return Me;
              if (!isNaN(Me.length)) {
                var Ke = -1, Bt = function St() {
                  for (; ++Ke < Me.length; ) if (rt.call(Me, Ke)) return St.value = Me[Ke], St.done = false, St;
                  return St.value = we, St.done = true, St;
                };
                return Bt.next = Bt;
              }
            }
            throw new TypeError(Ze(Me) + " is not iterable");
          }
          return be.prototype = Or, Tt(vt, "constructor", { value: Or, configurable: true }), Tt(Or, "constructor", { value: be, configurable: true }), be.displayName = Gt(Or, mt, "GeneratorFunction"), me.isGeneratorFunction = function(Me) {
            var De = typeof Me == "function" && Me.constructor;
            return !!De && (De === be || (De.displayName || De.name) === "GeneratorFunction");
          }, me.mark = function(Me) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Me, Or) : (Me.__proto__ = Or, Gt(Me, mt, "GeneratorFunction")), Me.prototype = Object.create(vt), Me;
          }, me.awrap = function(Me) {
            return { __await: Me };
          }, wt(Pt.prototype), Gt(Pt.prototype, We, function() {
            return this;
          }), me.AsyncIterator = Pt, me.async = function(Me, De, Ke, Bt, St) {
            St === void 0 && (St = Promise);
            var ur = new Pt(ir(Me, De, Ke, Bt), St);
            return me.isGeneratorFunction(De) ? ur : ur.next().then(function(Cr) {
              return Cr.done ? Cr.value : ur.next();
            });
          }, wt(vt), Gt(vt, mt, "Generator"), Gt(vt, It, function() {
            return this;
          }), Gt(vt, "toString", function() {
            return "[object Generator]";
          }), me.keys = function(Me) {
            var De = Object(Me), Ke = [];
            for (var Bt in De) Ke.push(Bt);
            return Ke.reverse(), function St() {
              for (; Ke.length; ) {
                var ur = Ke.pop();
                if (ur in De) return St.value = ur, St.done = false, St;
              }
              return St.done = true, St;
            };
          }, me.values = en, zr.prototype = { constructor: zr, reset: function(Me) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = we, this.done = false, this.delegate = null, this.method = "next", this.arg = we, this.tryEntries.forEach(Vt), !Me) for (var De in this) De.charAt(0) === "t" && rt.call(this, De) && !isNaN(+De.slice(1)) && (this[De] = we);
          }, stop: function() {
            this.done = true;
            var Me = this.tryEntries[0].completion;
            if (Me.type === "throw") throw Me.arg;
            return this.rval;
          }, dispatchException: function(Me) {
            if (this.done) throw Me;
            var De = this;
            function Ke(Zr, dn) {
              return ur.type = "throw", ur.arg = Me, De.next = Zr, dn && (De.method = "next", De.arg = we), !!dn;
            }
            for (var Bt = this.tryEntries.length - 1; Bt >= 0; --Bt) {
              var St = this.tryEntries[Bt], ur = St.completion;
              if (St.tryLoc === "root") return Ke("end");
              if (St.tryLoc <= this.prev) {
                var Cr = rt.call(St, "catchLoc"), Wr = rt.call(St, "finallyLoc");
                if (Cr && Wr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                } else if (Cr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                } else {
                  if (!Wr) throw Error("try statement without catch or finally");
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                }
              }
            }
          }, abrupt: function(Me, De) {
            for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
              var Bt = this.tryEntries[Ke];
              if (Bt.tryLoc <= this.prev && rt.call(Bt, "finallyLoc") && this.prev < Bt.finallyLoc) {
                var St = Bt;
                break;
              }
            }
            St && (Me === "break" || Me === "continue") && St.tryLoc <= De && De <= St.finallyLoc && (St = null);
            var ur = St ? St.completion : {};
            return ur.type = Me, ur.arg = De, St ? (this.method = "next", this.next = St.finallyLoc, Dr) : this.complete(ur);
          }, complete: function(Me, De) {
            if (Me.type === "throw") throw Me.arg;
            return Me.type === "break" || Me.type === "continue" ? this.next = Me.arg : Me.type === "return" ? (this.rval = this.arg = Me.arg, this.method = "return", this.next = "end") : Me.type === "normal" && De && (this.next = De), Dr;
          }, finish: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.finallyLoc === Me) return this.complete(Ke.completion, Ke.afterLoc), Vt(Ke), Dr;
            }
          }, catch: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.tryLoc === Me) {
                var Bt = Ke.completion;
                if (Bt.type === "throw") {
                  var St = Bt.arg;
                  Vt(Ke);
                }
                return St;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Me, De, Ke) {
            return this.delegate = { iterator: en(Me), resultName: De, nextLoc: Ke }, this.method === "next" && (this.arg = we), Dr;
          } }, me;
        }
        function rr(we, me, ze, rt, Tt, Ot, It) {
          try {
            var We = we[Ot](It), mt = We.value;
          } catch (Gt) {
            return void ze(Gt);
          }
          We.done ? me(mt) : Promise.resolve(mt).then(rt, Tt);
        }
        function je(we) {
          return function() {
            var me = this, ze = arguments;
            return new Promise(function(rt, Tt) {
              var Ot = we.apply(me, ze);
              function It(mt) {
                rr(Ot, rt, Tt, It, We, "next", mt);
              }
              function We(mt) {
                rr(Ot, rt, Tt, It, We, "throw", mt);
              }
              It(void 0);
            });
          };
        }
        var Ge = function(we, me) {
          return { signTransaction: (rt = je(Et().mark(function Tt(Ot, It) {
            var We;
            return Et().wrap(function(mt) {
              for (; ; ) switch (mt.prev = mt.next) {
                case 0:
                  return (We = c.TransactionBuilder.fromXDR(Ot, (It == null ? void 0 : It.networkPassphrase) || me)).sign(we), mt.abrupt("return", { signedTxXdr: We.toXDR(), signerAddress: we.publicKey() });
                case 3:
                case "end":
                  return mt.stop();
              }
            }, Tt);
          })), function(Tt, Ot) {
            return rt.apply(this, arguments);
          }), signAuthEntry: (ze = je(Et().mark(function Tt(Ot) {
            var It;
            return Et().wrap(function(We) {
              for (; ; ) switch (We.prev = We.next) {
                case 0:
                  return It = we.sign((0, c.hash)(ut.from(Ot, "base64"))).toString("base64"), We.abrupt("return", { signedAuthEntry: It, signerAddress: we.publicKey() });
                case 2:
                case "end":
                  return We.stop();
              }
            }, Tt);
          })), function(Tt) {
            return ze.apply(this, arguments);
          }) };
          var ze, rt;
        }, at = u(8287).Buffer;
        function Ae(we, me) {
          var ze = Object.keys(we);
          if (Object.getOwnPropertySymbols) {
            var rt = Object.getOwnPropertySymbols(we);
            me && (rt = rt.filter(function(Tt) {
              return Object.getOwnPropertyDescriptor(we, Tt).enumerable;
            })), ze.push.apply(ze, rt);
          }
          return ze;
        }
        function qe(we) {
          for (var me = 1; me < arguments.length; me++) {
            var ze = arguments[me] != null ? arguments[me] : {};
            me % 2 ? Ae(Object(ze), true).forEach(function(rt) {
              wr(we, rt, ze[rt]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(we, Object.getOwnPropertyDescriptors(ze)) : Ae(Object(ze)).forEach(function(rt) {
              Object.defineProperty(we, rt, Object.getOwnPropertyDescriptor(ze, rt));
            });
          }
          return we;
        }
        function Ft(we) {
          return Ft = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, Ft(we);
        }
        function Dt(we, me) {
          for (var ze = 0; ze < me.length; ze++) {
            var rt = me[ze];
            rt.enumerable = rt.enumerable || false, rt.configurable = true, "value" in rt && (rt.writable = true), Object.defineProperty(we, Nt(rt.key), rt);
          }
        }
        function wr(we, me, ze) {
          return (me = Nt(me)) in we ? Object.defineProperty(we, me, { value: ze, enumerable: true, configurable: true, writable: true }) : we[me] = ze, we;
        }
        function Nt(we) {
          var me = function(ze, rt) {
            if (Ft(ze) != "object" || !ze) return ze;
            var Tt = ze[Symbol.toPrimitive];
            if (Tt !== void 0) {
              var Ot = Tt.call(ze, rt);
              if (Ft(Ot) != "object") return Ot;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (rt === "string" ? String : Number)(ze);
          }(we, "string");
          return Ft(me) == "symbol" ? me : me + "";
        }
        function yr(we, me) {
          return function(ze) {
            if (Array.isArray(ze)) return ze;
          }(we) || function(ze, rt) {
            var Tt = ze == null ? null : typeof Symbol < "u" && ze[Symbol.iterator] || ze["@@iterator"];
            if (Tt != null) {
              var Ot, It, We, mt, Gt = [], ir = true, dr = false;
              try {
                if (We = (Tt = Tt.call(ze)).next, rt === 0) {
                  if (Object(Tt) !== Tt) return;
                  ir = false;
                } else for (; !(ir = (Ot = We.call(Tt)).done) && (Gt.push(Ot.value), Gt.length !== rt); ir = true) ;
              } catch (hr) {
                dr = true, It = hr;
              } finally {
                try {
                  if (!ir && Tt.return != null && (mt = Tt.return(), Object(mt) !== mt)) return;
                } finally {
                  if (dr) throw It;
                }
              }
              return Gt;
            }
          }(we, me) || function(ze, rt) {
            if (ze) {
              if (typeof ze == "string") return Ur(ze, rt);
              var Tt = {}.toString.call(ze).slice(8, -1);
              return Tt === "Object" && ze.constructor && (Tt = ze.constructor.name), Tt === "Map" || Tt === "Set" ? Array.from(ze) : Tt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Tt) ? Ur(ze, rt) : void 0;
            }
          }(we, me) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function Ur(we, me) {
          (me == null || me > we.length) && (me = we.length);
          for (var ze = 0, rt = Array(me); ze < me; ze++) rt[ze] = we[ze];
          return rt;
        }
        function Pe(we) {
          return /^\d+$/.test(we.name().toString());
        }
        var $e = { U32: { type: "integer", minimum: 0, maximum: 4294967295 }, I32: { type: "integer", minimum: -2147483648, maximum: 2147483647 }, U64: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 20 }, I64: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 21 }, U128: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 39 }, I128: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 40 }, U256: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 78 }, I256: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 79 }, Address: { type: "string", format: "address", description: "Address can be a public key or contract id" }, ScString: { type: "string", description: "ScString is a string" }, ScSymbol: { type: "string", description: "ScSymbol is a string" }, DataUrl: { type: "string", pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$" } };
        function le(we) {
          var me;
          switch (we.switch().value) {
            case c.xdr.ScSpecType.scSpecTypeVal().value:
              me = "Val";
              break;
            case c.xdr.ScSpecType.scSpecTypeBool().value:
              return { type: "boolean" };
            case c.xdr.ScSpecType.scSpecTypeVoid().value:
              return { type: "null" };
            case c.xdr.ScSpecType.scSpecTypeError().value:
              me = "Error";
              break;
            case c.xdr.ScSpecType.scSpecTypeU32().value:
              me = "U32";
              break;
            case c.xdr.ScSpecType.scSpecTypeI32().value:
              me = "I32";
              break;
            case c.xdr.ScSpecType.scSpecTypeU64().value:
              me = "U64";
              break;
            case c.xdr.ScSpecType.scSpecTypeI64().value:
              me = "I64";
              break;
            case c.xdr.ScSpecType.scSpecTypeTimepoint().value:
              throw new Error("Timepoint type not supported");
            case c.xdr.ScSpecType.scSpecTypeDuration().value:
              throw new Error("Duration not supported");
            case c.xdr.ScSpecType.scSpecTypeU128().value:
              me = "U128";
              break;
            case c.xdr.ScSpecType.scSpecTypeI128().value:
              me = "I128";
              break;
            case c.xdr.ScSpecType.scSpecTypeU256().value:
              me = "U256";
              break;
            case c.xdr.ScSpecType.scSpecTypeI256().value:
              me = "I256";
              break;
            case c.xdr.ScSpecType.scSpecTypeBytes().value:
              me = "DataUrl";
              break;
            case c.xdr.ScSpecType.scSpecTypeString().value:
              me = "ScString";
              break;
            case c.xdr.ScSpecType.scSpecTypeSymbol().value:
              me = "ScSymbol";
              break;
            case c.xdr.ScSpecType.scSpecTypeAddress().value:
              me = "Address";
              break;
            case c.xdr.ScSpecType.scSpecTypeOption().value:
              return le(we.option().valueType());
            case c.xdr.ScSpecType.scSpecTypeResult().value:
              break;
            case c.xdr.ScSpecType.scSpecTypeVec().value:
              return { type: "array", items: le(we.vec().elementType()) };
            case c.xdr.ScSpecType.scSpecTypeMap().value:
              var ze = we.map();
              return { type: "array", items: { type: "array", items: [le(ze.keyType()), le(ze.valueType())], minItems: 2, maxItems: 2 } };
            case c.xdr.ScSpecType.scSpecTypeTuple().value:
              var rt = we.tuple(), Tt = rt.valueTypes().length, Ot = Tt;
              return { type: "array", items: rt.valueTypes().map(le), minItems: Tt, maxItems: Ot };
            case c.xdr.ScSpecType.scSpecTypeBytesN().value:
              return { $ref: "#/definitions/DataUrl", maxLength: we.bytesN().n() };
            case c.xdr.ScSpecType.scSpecTypeUdt().value:
              me = we.udt().name().toString();
          }
          return { $ref: "#/definitions/".concat(me) };
        }
        function re(we) {
          var me = {}, ze = [];
          we.forEach(function(Tt) {
            var Ot = Tt.type(), It = Tt.name().toString();
            me[It] = le(Ot), Ot.switch().value !== c.xdr.ScSpecType.scSpecTypeOption().value && ze.push(It);
          });
          var rt = { properties: me };
          return ze.length > 0 && (rt.required = ze), rt;
        }
        var Le, nt, ft = (Le = function we(me) {
          if (function(rt, Tt) {
            if (!(rt instanceof Tt)) throw new TypeError("Cannot call a class as a function");
          }(this, we), wr(this, "entries", []), me.length === 0) throw new Error("Contract spec must have at least one entry");
          var ze = me[0];
          this.entries = typeof ze == "string" ? me.map(function(rt) {
            return c.xdr.ScSpecEntry.fromXDR(rt, "base64");
          }) : me;
        }, nt = [{ key: "funcs", value: function() {
          return this.entries.filter(function(we) {
            return we.switch().value === c.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(we) {
            return we.functionV0();
          });
        } }, { key: "getFunc", value: function(we) {
          var me = this.findEntry(we);
          if (me.switch().value !== c.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) throw new Error("".concat(we, " is not a function"));
          return me.functionV0();
        } }, { key: "funcArgsToScVals", value: function(we, me) {
          var ze = this;
          return this.getFunc(we).inputs().map(function(rt) {
            return ze.nativeToScVal(function(Tt, Ot) {
              var It = Ot.name().toString(), We = Object.entries(Tt).find(function(mt) {
                return yr(mt, 1)[0] === It;
              });
              if (!We) throw new Error("Missing field ".concat(It));
              return We[1];
            }(me, rt), rt.type());
          });
        } }, { key: "funcResToNative", value: function(we, me) {
          var ze = typeof me == "string" ? c.xdr.ScVal.fromXDR(me, "base64") : me, rt = this.getFunc(we).outputs();
          if (rt.length === 0) {
            var Tt = ze.switch();
            if (Tt.value !== c.xdr.ScValType.scvVoid().value) throw new Error("Expected void, got ".concat(Tt.name));
            return null;
          }
          if (rt.length > 1) throw new Error("Multiple outputs not supported");
          var Ot = rt[0];
          return Ot.switch().value === c.xdr.ScSpecType.scSpecTypeResult().value ? new b(this.scValToNative(ze, Ot.result().okType())) : this.scValToNative(ze, Ot);
        } }, { key: "findEntry", value: function(we) {
          var me = this.entries.find(function(ze) {
            return ze.value().name().toString() === we;
          });
          if (!me) throw new Error("no such entry: ".concat(we));
          return me;
        } }, { key: "nativeToScVal", value: function(we, me) {
          var ze = this, rt = me.switch(), Tt = rt.value;
          if (rt.value === c.xdr.ScSpecType.scSpecTypeUdt().value) {
            var Ot = me.udt();
            return this.nativeToUdt(we, Ot.name().toString());
          }
          if (Tt === c.xdr.ScSpecType.scSpecTypeOption().value) {
            var It = me.option();
            return we === void 0 ? c.xdr.ScVal.scvVoid() : this.nativeToScVal(we, It.valueType());
          }
          switch (Ft(we)) {
            case "object":
              var We, mt, Gt;
              if (we === null) {
                if (Tt === c.xdr.ScSpecType.scSpecTypeVoid().value) return c.xdr.ScVal.scvVoid();
                throw new TypeError("Type ".concat(me, " was not void, but value was null"));
              }
              if (we instanceof c.xdr.ScVal) return we;
              if (we instanceof c.Address) {
                if (me.switch().value !== c.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(me, " was not address, but value was Address"));
                return we.toScVal();
              }
              if (we instanceof c.Contract) {
                if (me.switch().value !== c.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(me, " was not address, but value was Address"));
                return we.address().toScVal();
              }
              if (we instanceof Uint8Array || at.isBuffer(we)) {
                var ir = Uint8Array.from(we);
                switch (Tt) {
                  case c.xdr.ScSpecType.scSpecTypeBytesN().value:
                    var dr = me.bytesN();
                    if (ir.length !== dr.n()) throw new TypeError("expected ".concat(dr.n(), " bytes, but got ").concat(ir.length));
                    return c.xdr.ScVal.scvBytes(ir);
                  case c.xdr.ScSpecType.scSpecTypeBytes().value:
                    return c.xdr.ScVal.scvBytes(ir);
                  default:
                    throw new TypeError("invalid type (".concat(me, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(we)) switch (Tt) {
                case c.xdr.ScSpecType.scSpecTypeVec().value:
                  var hr = me.vec().elementType();
                  return c.xdr.ScVal.scvVec(we.map(function(cr) {
                    return ze.nativeToScVal(cr, hr);
                  }));
                case c.xdr.ScSpecType.scSpecTypeTuple().value:
                  var Fr = me.tuple().valueTypes();
                  if (we.length !== Fr.length) throw new TypeError("Tuple expects ".concat(Fr.length, " values, but ").concat(we.length, " were provided"));
                  return c.xdr.ScVal.scvVec(we.map(function(cr, qr) {
                    return ze.nativeToScVal(cr, Fr[qr]);
                  }));
                case c.xdr.ScSpecType.scSpecTypeMap().value:
                  var Gr = me.map(), Br = Gr.keyType(), Dr = Gr.valueType();
                  return c.xdr.ScVal.scvMap(we.map(function(cr) {
                    var qr = ze.nativeToScVal(cr[0], Br), Vt = ze.nativeToScVal(cr[1], Dr);
                    return new c.xdr.ScMapEntry({ key: qr, val: Vt });
                  }));
                default:
                  throw new TypeError("Type ".concat(me, " was not vec, but value was Array"));
              }
              if (we.constructor === Map) {
                if (Tt !== c.xdr.ScSpecType.scSpecTypeMap().value) throw new TypeError("Type ".concat(me, " was not map, but value was Map"));
                for (var Vr = me.map(), be = [], Or = we.entries(), Ue = Or.next(); !Ue.done; ) {
                  var it = yr(Ue.value, 2), dt = it[0], vt = it[1], wt = this.nativeToScVal(dt, Vr.keyType()), Pt = this.nativeToScVal(vt, Vr.valueType());
                  be.push(new c.xdr.ScMapEntry({ key: wt, val: Pt })), Ue = Or.next();
                }
                return c.xdr.ScVal.scvMap(be);
              }
              throw ((We = (mt = we.constructor) === null || mt === void 0 ? void 0 : mt.name) !== null && We !== void 0 ? We : "") !== "Object" ? new TypeError("cannot interpret ".concat((Gt = we.constructor) === null || Gt === void 0 ? void 0 : Gt.name, " value as ScVal (").concat(JSON.stringify(we), ")")) : new TypeError("Received object ".concat(we, "  did not match the provided type ").concat(me));
            case "number":
            case "bigint":
              switch (Tt) {
                case c.xdr.ScSpecType.scSpecTypeU32().value:
                  return c.xdr.ScVal.scvU32(we);
                case c.xdr.ScSpecType.scSpecTypeI32().value:
                  return c.xdr.ScVal.scvI32(we);
                case c.xdr.ScSpecType.scSpecTypeU64().value:
                case c.xdr.ScSpecType.scSpecTypeI64().value:
                case c.xdr.ScSpecType.scSpecTypeU128().value:
                case c.xdr.ScSpecType.scSpecTypeI128().value:
                case c.xdr.ScSpecType.scSpecTypeU256().value:
                case c.xdr.ScSpecType.scSpecTypeI256().value:
                  var Yt = rt.name.substring(10).toLowerCase();
                  return new c.XdrLargeInt(Yt, we).toScVal();
                default:
                  throw new TypeError("invalid type (".concat(me, ") specified for integer"));
              }
            case "string":
              return function(cr, qr) {
                switch (qr.value) {
                  case c.xdr.ScSpecType.scSpecTypeString().value:
                    return c.xdr.ScVal.scvString(cr);
                  case c.xdr.ScSpecType.scSpecTypeSymbol().value:
                    return c.xdr.ScVal.scvSymbol(cr);
                  case c.xdr.ScSpecType.scSpecTypeAddress().value:
                    var Vt = c.Address.fromString(cr);
                    return c.xdr.ScVal.scvAddress(Vt.toScAddress());
                  case c.xdr.ScSpecType.scSpecTypeU64().value:
                    return new c.XdrLargeInt("u64", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeI64().value:
                    return new c.XdrLargeInt("i64", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeU128().value:
                    return new c.XdrLargeInt("u128", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeI128().value:
                    return new c.XdrLargeInt("i128", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeU256().value:
                    return new c.XdrLargeInt("u256", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeI256().value:
                    return new c.XdrLargeInt("i256", cr).toScVal();
                  case c.xdr.ScSpecType.scSpecTypeBytes().value:
                  case c.xdr.ScSpecType.scSpecTypeBytesN().value:
                    return c.xdr.ScVal.scvBytes(at.from(cr, "base64"));
                  default:
                    throw new TypeError("invalid type ".concat(qr.name, " specified for string value"));
                }
              }(we, rt);
            case "boolean":
              if (Tt !== c.xdr.ScSpecType.scSpecTypeBool().value) throw TypeError("Type ".concat(me, " was not bool, but value was bool"));
              return c.xdr.ScVal.scvBool(we);
            case "undefined":
              if (!me) return c.xdr.ScVal.scvVoid();
              switch (Tt) {
                case c.xdr.ScSpecType.scSpecTypeVoid().value:
                case c.xdr.ScSpecType.scSpecTypeOption().value:
                  return c.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(me, " was not void, but value was undefined"));
              }
            case "function":
              return this.nativeToScVal(we(), me);
            default:
              throw new TypeError("failed to convert typeof ".concat(Ft(we), " (").concat(we, ")"));
          }
        } }, { key: "nativeToUdt", value: function(we, me) {
          var ze = this.findEntry(me);
          switch (ze.switch()) {
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof we != "number") throw new TypeError("expected number for enum ".concat(me, ", but got ").concat(Ft(we)));
              return this.nativeToEnum(we, ze.udtEnumV0());
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(we, ze.udtStructV0());
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(we, ze.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(me));
          }
        } }, { key: "nativeToUnion", value: function(we, me) {
          var ze = this, rt = we.tag, Tt = me.cases().find(function(mt) {
            return mt.value().name().toString() === rt;
          });
          if (!Tt) throw new TypeError("no such enum entry: ".concat(rt, " in ").concat(me));
          var Ot = c.xdr.ScVal.scvSymbol(rt);
          switch (Tt.switch()) {
            case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0():
              return c.xdr.ScVal.scvVec([Ot]);
            case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0():
              var It = Tt.tupleCase().type();
              if (Array.isArray(we.values)) {
                if (we.values.length !== It.length) throw new TypeError("union ".concat(me, " expects ").concat(It.length, " values, but got ").concat(we.values.length));
                var We = we.values.map(function(mt, Gt) {
                  return ze.nativeToScVal(mt, It[Gt]);
                });
                return We.unshift(Ot), c.xdr.ScVal.scvVec(We);
              }
              throw new Error("failed to parse union case ".concat(Tt, " with ").concat(we));
            default:
              throw new Error("failed to parse union ".concat(me, " with ").concat(we));
          }
        } }, { key: "nativeToStruct", value: function(we, me) {
          var ze = this, rt = me.fields();
          if (rt.some(Pe)) {
            if (!rt.every(Pe)) throw new Error("mixed numeric and non-numeric field names are not allowed");
            return c.xdr.ScVal.scvVec(rt.map(function(Tt, Ot) {
              return ze.nativeToScVal(we[Ot], rt[Ot].type());
            }));
          }
          return c.xdr.ScVal.scvMap(rt.map(function(Tt) {
            var Ot = Tt.name().toString();
            return new c.xdr.ScMapEntry({ key: ze.nativeToScVal(Ot, c.xdr.ScSpecTypeDef.scSpecTypeSymbol()), val: ze.nativeToScVal(we[Ot], Tt.type()) });
          }));
        } }, { key: "nativeToEnum", value: function(we, me) {
          if (me.cases().some(function(ze) {
            return ze.value() === we;
          })) return c.xdr.ScVal.scvU32(we);
          throw new TypeError("no such enum entry: ".concat(we, " in ").concat(me));
        } }, { key: "scValStrToNative", value: function(we, me) {
          return this.scValToNative(c.xdr.ScVal.fromXDR(we, "base64"), me);
        } }, { key: "scValToNative", value: function(we, me) {
          var ze = this, rt = me.switch(), Tt = rt.value;
          if (Tt === c.xdr.ScSpecType.scSpecTypeUdt().value) return this.scValUdtToNative(we, me.udt());
          switch (we.switch().value) {
            case c.xdr.ScValType.scvVoid().value:
              return;
            case c.xdr.ScValType.scvU64().value:
            case c.xdr.ScValType.scvI64().value:
            case c.xdr.ScValType.scvU128().value:
            case c.xdr.ScValType.scvI128().value:
            case c.xdr.ScValType.scvU256().value:
            case c.xdr.ScValType.scvI256().value:
              return (0, c.scValToBigInt)(we);
            case c.xdr.ScValType.scvVec().value:
              if (Tt === c.xdr.ScSpecType.scSpecTypeVec().value) {
                var Ot, It = me.vec();
                return ((Ot = we.vec()) !== null && Ot !== void 0 ? Ot : []).map(function(Br) {
                  return ze.scValToNative(Br, It.elementType());
                });
              }
              if (Tt === c.xdr.ScSpecType.scSpecTypeTuple().value) {
                var We, mt = me.tuple().valueTypes();
                return ((We = we.vec()) !== null && We !== void 0 ? We : []).map(function(Br, Dr) {
                  return ze.scValToNative(Br, mt[Dr]);
                });
              }
              throw new TypeError("Type ".concat(me, " was not vec, but ").concat(we, " is"));
            case c.xdr.ScValType.scvAddress().value:
              return c.Address.fromScVal(we).toString();
            case c.xdr.ScValType.scvMap().value:
              var Gt, ir = (Gt = we.map()) !== null && Gt !== void 0 ? Gt : [];
              if (Tt === c.xdr.ScSpecType.scSpecTypeMap().value) {
                var dr = me.map(), hr = dr.keyType(), Fr = dr.valueType();
                return ir.map(function(Br) {
                  return [ze.scValToNative(Br.key(), hr), ze.scValToNative(Br.val(), Fr)];
                });
              }
              throw new TypeError("ScSpecType ".concat(rt.name, " was not map, but ").concat(JSON.stringify(we, null, 2), " is"));
            case c.xdr.ScValType.scvBool().value:
            case c.xdr.ScValType.scvU32().value:
            case c.xdr.ScValType.scvI32().value:
            case c.xdr.ScValType.scvBytes().value:
              return we.value();
            case c.xdr.ScValType.scvString().value:
            case c.xdr.ScValType.scvSymbol().value:
              var Gr;
              if (Tt !== c.xdr.ScSpecType.scSpecTypeString().value && Tt !== c.xdr.ScSpecType.scSpecTypeSymbol().value) throw new Error("ScSpecType ".concat(rt.name, " was not string or symbol, but ").concat(JSON.stringify(we, null, 2), " is"));
              return (Gr = we.value()) === null || Gr === void 0 ? void 0 : Gr.toString();
            case c.xdr.ScValType.scvTimepoint().value:
            case c.xdr.ScValType.scvDuration().value:
              return (0, c.scValToBigInt)(c.xdr.ScVal.scvU64(we.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(we, null, 2), " to native type from type ").concat(rt.name));
          }
        } }, { key: "scValUdtToNative", value: function(we, me) {
          var ze = this.findEntry(me.name().toString());
          switch (ze.switch()) {
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(we);
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(we, ze.udtStructV0());
            case c.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(we, ze.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(me.name().toString(), ": ").concat(ze));
          }
        } }, { key: "unionToNative", value: function(we, me) {
          var ze = this, rt = we.vec();
          if (!rt) throw new Error("".concat(JSON.stringify(we, null, 2), " is not a vec"));
          if (rt.length === 0 && me.cases.length !== 0) throw new Error("".concat(we, " has length 0, but the there are at least one case in the union"));
          var Tt = rt[0].sym().toString();
          if (rt[0].switch().value !== c.xdr.ScValType.scvSymbol().value) throw new Error("{vec[0]} is not a symbol");
          var Ot = me.cases().find(/* @__PURE__ */ function(mt) {
            return function(Gt) {
              switch (Gt.switch().value) {
                case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
                  return Gt.tupleCase().name().toString() === mt;
                case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
                  return Gt.voidCase().name().toString() === mt;
                default:
                  return false;
              }
            };
          }(Tt));
          if (!Ot) throw new Error("failed to find entry ".concat(Tt, " in union {udt.name().toString()}"));
          var It = { tag: Tt };
          if (Ot.switch().value === c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var We = Ot.tupleCase().type().map(function(mt, Gt) {
              return ze.scValToNative(rt[Gt + 1], mt);
            });
            It.values = We;
          }
          return It;
        } }, { key: "structToNative", value: function(we, me) {
          var ze, rt, Tt = this, Ot = {}, It = me.fields();
          return It.some(Pe) ? (rt = we.vec()) === null || rt === void 0 ? void 0 : rt.map(function(We, mt) {
            return Tt.scValToNative(We, It[mt].type());
          }) : ((ze = we.map()) === null || ze === void 0 || ze.forEach(function(We, mt) {
            var Gt = It[mt];
            Ot[Gt.name().toString()] = Tt.scValToNative(We.val(), Gt.type());
          }), Ot);
        } }, { key: "enumToNative", value: function(we) {
          if (we.switch().value !== c.xdr.ScValType.scvU32().value) throw new Error("Enum must have a u32 value");
          return we.u32();
        } }, { key: "errorCases", value: function() {
          return this.entries.filter(function(we) {
            return we.switch().value === c.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(we) {
            return we.value().cases();
          });
        } }, { key: "jsonSchema", value: function(we) {
          var me = {};
          this.entries.forEach(function(rt) {
            switch (rt.switch().value) {
              case c.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value:
                var Tt = rt.udtEnumV0();
                me[Tt.name().toString()] = function(dr) {
                  var hr = dr.doc().toString(), Fr = dr.cases(), Gr = [];
                  Fr.forEach(function(Dr) {
                    var Vr = Dr.name().toString(), be = Dr.doc().toString();
                    Gr.push({ description: be, title: Vr, enum: [Dr.value()], type: "number" });
                  });
                  var Br = { oneOf: Gr };
                  return hr.length > 0 && (Br.description = hr), Br;
                }(Tt);
                break;
              case c.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value:
                var Ot = rt.udtStructV0();
                me[Ot.name().toString()] = function(dr) {
                  var hr = dr.fields();
                  if (hr.some(Pe)) {
                    if (!hr.every(Pe)) throw new Error("mixed numeric and non-numeric field names are not allowed");
                    return { type: "array", items: hr.map(function(Vr, be) {
                      return le(hr[be].type());
                    }), minItems: hr.length, maxItems: hr.length };
                  }
                  var Fr = dr.doc().toString(), Gr = re(hr), Br = Gr.properties, Dr = Gr.required;
                  return Br.additionalProperties = false, { description: Fr, properties: Br, required: Dr, type: "object" };
                }(Ot);
                break;
              case c.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value:
                var It = rt.udtUnionV0();
                me[It.name().toString()] = function(dr) {
                  var hr = dr.doc().toString(), Fr = dr.cases(), Gr = [];
                  Fr.forEach(function(Dr) {
                    switch (Dr.switch().value) {
                      case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value:
                        var Vr = Dr.voidCase().name().toString();
                        Gr.push({ type: "object", title: Vr, properties: { tag: Vr }, additionalProperties: false, required: ["tag"] });
                        break;
                      case c.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value:
                        var be = Dr.tupleCase(), Or = be.name().toString();
                        Gr.push({ type: "object", title: Or, properties: { tag: Or, values: { type: "array", items: be.type().map(le) } }, required: ["tag", "values"], additionalProperties: false });
                    }
                  });
                  var Br = { oneOf: Gr };
                  return hr.length > 0 && (Br.description = hr), Br;
                }(It);
                break;
              case c.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value:
                var We = rt.functionV0(), mt = We.name().toString(), Gt = function(dr) {
                  var hr = re(dr.inputs()), Fr = hr.properties, Gr = hr.required, Br = { additionalProperties: false, properties: Fr, type: "object" };
                  (Gr == null ? void 0 : Gr.length) > 0 && (Br.required = Gr);
                  var Dr = { properties: { args: Br } }, Vr = dr.outputs(), be = Vr.length > 0 ? le(Vr[0]) : le(c.xdr.ScSpecTypeDef.scSpecTypeVoid()), Or = dr.doc().toString();
                  return Or.length > 0 && (Dr.description = Or), Dr.additionalProperties = false, be.additionalProperties = false, { input: Dr, output: be };
                }(We), ir = Gt.input;
                me[mt] = ir;
              case c.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value:
            }
          });
          var ze = { $schema: "http://json-schema.org/draft-07/schema#", definitions: qe(qe({}, $e), me) };
          return we && (ze.$ref = "#/definitions/".concat(we)), ze;
        } }], nt && Dt(Le.prototype, nt), Object.defineProperty(Le, "prototype", { writable: false }), Le), zt = u(8287).Buffer;
        function st(we) {
          return st = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(me) {
            return typeof me;
          } : function(me) {
            return me && typeof Symbol == "function" && me.constructor === Symbol && me !== Symbol.prototype ? "symbol" : typeof me;
          }, st(we);
        }
        var ct = ["method"], yt = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
        function Zt() {
          Zt = function() {
            return me;
          };
          var we, me = {}, ze = Object.prototype, rt = ze.hasOwnProperty, Tt = Object.defineProperty || function(Me, De, Ke) {
            Me[De] = Ke.value;
          }, Ot = typeof Symbol == "function" ? Symbol : {}, It = Ot.iterator || "@@iterator", We = Ot.asyncIterator || "@@asyncIterator", mt = Ot.toStringTag || "@@toStringTag";
          function Gt(Me, De, Ke) {
            return Object.defineProperty(Me, De, { value: Ke, enumerable: true, configurable: true, writable: true }), Me[De];
          }
          try {
            Gt({}, "");
          } catch {
            Gt = function(De, Ke, Bt) {
              return De[Ke] = Bt;
            };
          }
          function ir(Me, De, Ke, Bt) {
            var St = De && De.prototype instanceof Vr ? De : Vr, ur = Object.create(St.prototype), Cr = new zr(Bt || []);
            return Tt(ur, "_invoke", { value: Yt(Me, Ke, Cr) }), ur;
          }
          function dr(Me, De, Ke) {
            try {
              return { type: "normal", arg: Me.call(De, Ke) };
            } catch (Bt) {
              return { type: "throw", arg: Bt };
            }
          }
          me.wrap = ir;
          var hr = "suspendedStart", Fr = "suspendedYield", Gr = "executing", Br = "completed", Dr = {};
          function Vr() {
          }
          function be() {
          }
          function Or() {
          }
          var Ue = {};
          Gt(Ue, It, function() {
            return this;
          });
          var it = Object.getPrototypeOf, dt = it && it(it(en([])));
          dt && dt !== ze && rt.call(dt, It) && (Ue = dt);
          var vt = Or.prototype = Vr.prototype = Object.create(Ue);
          function wt(Me) {
            ["next", "throw", "return"].forEach(function(De) {
              Gt(Me, De, function(Ke) {
                return this._invoke(De, Ke);
              });
            });
          }
          function Pt(Me, De) {
            function Ke(St, ur, Cr, Wr) {
              var Zr = dr(Me[St], Me, ur);
              if (Zr.type !== "throw") {
                var dn = Zr.arg, wn = dn.value;
                return wn && st(wn) == "object" && rt.call(wn, "__await") ? De.resolve(wn.__await).then(function(yn) {
                  Ke("next", yn, Cr, Wr);
                }, function(yn) {
                  Ke("throw", yn, Cr, Wr);
                }) : De.resolve(wn).then(function(yn) {
                  dn.value = yn, Cr(dn);
                }, function(yn) {
                  return Ke("throw", yn, Cr, Wr);
                });
              }
              Wr(Zr.arg);
            }
            var Bt;
            Tt(this, "_invoke", { value: function(St, ur) {
              function Cr() {
                return new De(function(Wr, Zr) {
                  Ke(St, ur, Wr, Zr);
                });
              }
              return Bt = Bt ? Bt.then(Cr, Cr) : Cr();
            } });
          }
          function Yt(Me, De, Ke) {
            var Bt = hr;
            return function(St, ur) {
              if (Bt === Gr) throw Error("Generator is already running");
              if (Bt === Br) {
                if (St === "throw") throw ur;
                return { value: we, done: true };
              }
              for (Ke.method = St, Ke.arg = ur; ; ) {
                var Cr = Ke.delegate;
                if (Cr) {
                  var Wr = cr(Cr, Ke);
                  if (Wr) {
                    if (Wr === Dr) continue;
                    return Wr;
                  }
                }
                if (Ke.method === "next") Ke.sent = Ke._sent = Ke.arg;
                else if (Ke.method === "throw") {
                  if (Bt === hr) throw Bt = Br, Ke.arg;
                  Ke.dispatchException(Ke.arg);
                } else Ke.method === "return" && Ke.abrupt("return", Ke.arg);
                Bt = Gr;
                var Zr = dr(Me, De, Ke);
                if (Zr.type === "normal") {
                  if (Bt = Ke.done ? Br : Fr, Zr.arg === Dr) continue;
                  return { value: Zr.arg, done: Ke.done };
                }
                Zr.type === "throw" && (Bt = Br, Ke.method = "throw", Ke.arg = Zr.arg);
              }
            };
          }
          function cr(Me, De) {
            var Ke = De.method, Bt = Me.iterator[Ke];
            if (Bt === we) return De.delegate = null, Ke === "throw" && Me.iterator.return && (De.method = "return", De.arg = we, cr(Me, De), De.method === "throw") || Ke !== "return" && (De.method = "throw", De.arg = new TypeError("The iterator does not provide a '" + Ke + "' method")), Dr;
            var St = dr(Bt, Me.iterator, De.arg);
            if (St.type === "throw") return De.method = "throw", De.arg = St.arg, De.delegate = null, Dr;
            var ur = St.arg;
            return ur ? ur.done ? (De[Me.resultName] = ur.value, De.next = Me.nextLoc, De.method !== "return" && (De.method = "next", De.arg = we), De.delegate = null, Dr) : ur : (De.method = "throw", De.arg = new TypeError("iterator result is not an object"), De.delegate = null, Dr);
          }
          function qr(Me) {
            var De = { tryLoc: Me[0] };
            1 in Me && (De.catchLoc = Me[1]), 2 in Me && (De.finallyLoc = Me[2], De.afterLoc = Me[3]), this.tryEntries.push(De);
          }
          function Vt(Me) {
            var De = Me.completion || {};
            De.type = "normal", delete De.arg, Me.completion = De;
          }
          function zr(Me) {
            this.tryEntries = [{ tryLoc: "root" }], Me.forEach(qr, this), this.reset(true);
          }
          function en(Me) {
            if (Me || Me === "") {
              var De = Me[It];
              if (De) return De.call(Me);
              if (typeof Me.next == "function") return Me;
              if (!isNaN(Me.length)) {
                var Ke = -1, Bt = function St() {
                  for (; ++Ke < Me.length; ) if (rt.call(Me, Ke)) return St.value = Me[Ke], St.done = false, St;
                  return St.value = we, St.done = true, St;
                };
                return Bt.next = Bt;
              }
            }
            throw new TypeError(st(Me) + " is not iterable");
          }
          return be.prototype = Or, Tt(vt, "constructor", { value: Or, configurable: true }), Tt(Or, "constructor", { value: be, configurable: true }), be.displayName = Gt(Or, mt, "GeneratorFunction"), me.isGeneratorFunction = function(Me) {
            var De = typeof Me == "function" && Me.constructor;
            return !!De && (De === be || (De.displayName || De.name) === "GeneratorFunction");
          }, me.mark = function(Me) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Me, Or) : (Me.__proto__ = Or, Gt(Me, mt, "GeneratorFunction")), Me.prototype = Object.create(vt), Me;
          }, me.awrap = function(Me) {
            return { __await: Me };
          }, wt(Pt.prototype), Gt(Pt.prototype, We, function() {
            return this;
          }), me.AsyncIterator = Pt, me.async = function(Me, De, Ke, Bt, St) {
            St === void 0 && (St = Promise);
            var ur = new Pt(ir(Me, De, Ke, Bt), St);
            return me.isGeneratorFunction(De) ? ur : ur.next().then(function(Cr) {
              return Cr.done ? Cr.value : ur.next();
            });
          }, wt(vt), Gt(vt, mt, "Generator"), Gt(vt, It, function() {
            return this;
          }), Gt(vt, "toString", function() {
            return "[object Generator]";
          }), me.keys = function(Me) {
            var De = Object(Me), Ke = [];
            for (var Bt in De) Ke.push(Bt);
            return Ke.reverse(), function St() {
              for (; Ke.length; ) {
                var ur = Ke.pop();
                if (ur in De) return St.value = ur, St.done = false, St;
              }
              return St.done = true, St;
            };
          }, me.values = en, zr.prototype = { constructor: zr, reset: function(Me) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = we, this.done = false, this.delegate = null, this.method = "next", this.arg = we, this.tryEntries.forEach(Vt), !Me) for (var De in this) De.charAt(0) === "t" && rt.call(this, De) && !isNaN(+De.slice(1)) && (this[De] = we);
          }, stop: function() {
            this.done = true;
            var Me = this.tryEntries[0].completion;
            if (Me.type === "throw") throw Me.arg;
            return this.rval;
          }, dispatchException: function(Me) {
            if (this.done) throw Me;
            var De = this;
            function Ke(Zr, dn) {
              return ur.type = "throw", ur.arg = Me, De.next = Zr, dn && (De.method = "next", De.arg = we), !!dn;
            }
            for (var Bt = this.tryEntries.length - 1; Bt >= 0; --Bt) {
              var St = this.tryEntries[Bt], ur = St.completion;
              if (St.tryLoc === "root") return Ke("end");
              if (St.tryLoc <= this.prev) {
                var Cr = rt.call(St, "catchLoc"), Wr = rt.call(St, "finallyLoc");
                if (Cr && Wr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                } else if (Cr) {
                  if (this.prev < St.catchLoc) return Ke(St.catchLoc, true);
                } else {
                  if (!Wr) throw Error("try statement without catch or finally");
                  if (this.prev < St.finallyLoc) return Ke(St.finallyLoc);
                }
              }
            }
          }, abrupt: function(Me, De) {
            for (var Ke = this.tryEntries.length - 1; Ke >= 0; --Ke) {
              var Bt = this.tryEntries[Ke];
              if (Bt.tryLoc <= this.prev && rt.call(Bt, "finallyLoc") && this.prev < Bt.finallyLoc) {
                var St = Bt;
                break;
              }
            }
            St && (Me === "break" || Me === "continue") && St.tryLoc <= De && De <= St.finallyLoc && (St = null);
            var ur = St ? St.completion : {};
            return ur.type = Me, ur.arg = De, St ? (this.method = "next", this.next = St.finallyLoc, Dr) : this.complete(ur);
          }, complete: function(Me, De) {
            if (Me.type === "throw") throw Me.arg;
            return Me.type === "break" || Me.type === "continue" ? this.next = Me.arg : Me.type === "return" ? (this.rval = this.arg = Me.arg, this.method = "return", this.next = "end") : Me.type === "normal" && De && (this.next = De), Dr;
          }, finish: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.finallyLoc === Me) return this.complete(Ke.completion, Ke.afterLoc), Vt(Ke), Dr;
            }
          }, catch: function(Me) {
            for (var De = this.tryEntries.length - 1; De >= 0; --De) {
              var Ke = this.tryEntries[De];
              if (Ke.tryLoc === Me) {
                var Bt = Ke.completion;
                if (Bt.type === "throw") {
                  var St = Bt.arg;
                  Vt(Ke);
                }
                return St;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Me, De, Ke) {
            return this.delegate = { iterator: en(Me), resultName: De, nextLoc: Ke }, this.method === "next" && (this.arg = we), Dr;
          } }, me;
        }
        function Ct(we, me) {
          var ze = Object.keys(we);
          if (Object.getOwnPropertySymbols) {
            var rt = Object.getOwnPropertySymbols(we);
            me && (rt = rt.filter(function(Tt) {
              return Object.getOwnPropertyDescriptor(we, Tt).enumerable;
            })), ze.push.apply(ze, rt);
          }
          return ze;
        }
        function Lt(we) {
          for (var me = 1; me < arguments.length; me++) {
            var ze = arguments[me] != null ? arguments[me] : {};
            me % 2 ? Ct(Object(ze), true).forEach(function(rt) {
              ar(we, rt, ze[rt]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(we, Object.getOwnPropertyDescriptors(ze)) : Ct(Object(ze)).forEach(function(rt) {
              Object.defineProperty(we, rt, Object.getOwnPropertyDescriptor(ze, rt));
            });
          }
          return we;
        }
        function Wt(we, me) {
          if (we == null) return {};
          var ze, rt, Tt = function(It, We) {
            if (It == null) return {};
            var mt = {};
            for (var Gt in It) if ({}.hasOwnProperty.call(It, Gt)) {
              if (We.indexOf(Gt) !== -1) continue;
              mt[Gt] = It[Gt];
            }
            return mt;
          }(we, me);
          if (Object.getOwnPropertySymbols) {
            var Ot = Object.getOwnPropertySymbols(we);
            for (rt = 0; rt < Ot.length; rt++) ze = Ot[rt], me.indexOf(ze) === -1 && {}.propertyIsEnumerable.call(we, ze) && (Tt[ze] = we[ze]);
          }
          return Tt;
        }
        function vr(we, me) {
          for (var ze = 0; ze < me.length; ze++) {
            var rt = me[ze];
            rt.enumerable = rt.enumerable || false, rt.configurable = true, "value" in rt && (rt.writable = true), Object.defineProperty(we, sr(rt.key), rt);
          }
        }
        function ar(we, me, ze) {
          return (me = sr(me)) in we ? Object.defineProperty(we, me, { value: ze, enumerable: true, configurable: true, writable: true }) : we[me] = ze, we;
        }
        function sr(we) {
          var me = function(ze, rt) {
            if (st(ze) != "object" || !ze) return ze;
            var Tt = ze[Symbol.toPrimitive];
            if (Tt !== void 0) {
              var Ot = Tt.call(ze, rt);
              if (st(Ot) != "object") return Ot;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (rt === "string" ? String : Number)(ze);
          }(we, "string");
          return st(me) == "symbol" ? me : me + "";
        }
        function gr(we) {
          return function(me) {
            if (Array.isArray(me)) return Tr(me);
          }(we) || function(me) {
            if (typeof Symbol < "u" && me[Symbol.iterator] != null || me["@@iterator"] != null) return Array.from(me);
          }(we) || function(me, ze) {
            if (me) {
              if (typeof me == "string") return Tr(me, ze);
              var rt = {}.toString.call(me).slice(8, -1);
              return rt === "Object" && me.constructor && (rt = me.constructor.name), rt === "Map" || rt === "Set" ? Array.from(me) : rt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(rt) ? Tr(me, ze) : void 0;
            }
          }(we) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function Tr(we, me) {
          (me == null || me > we.length) && (me = we.length);
          for (var ze = 0, rt = Array(me); ze < me; ze++) rt[ze] = we[ze];
          return rt;
        }
        function Mr(we, me, ze, rt, Tt, Ot, It) {
          try {
            var We = we[Ot](It), mt = We.value;
          } catch (Gt) {
            return void ze(Gt);
          }
          We.done ? me(mt) : Promise.resolve(mt).then(rt, Tt);
        }
        function Nr(we) {
          return function() {
            var me = this, ze = arguments;
            return new Promise(function(rt, Tt) {
              var Ot = we.apply(me, ze);
              function It(mt) {
                Mr(Ot, rt, Tt, It, We, "next", mt);
              }
              function We(mt) {
                Mr(Ot, rt, Tt, It, We, "throw", mt);
              }
              It(void 0);
            });
          };
        }
        var Lr = "__constructor";
        function jr(we) {
          return Hr.apply(this, arguments);
        }
        function Hr() {
          return (Hr = Nr(Zt().mark(function we(me) {
            var ze, rt, Tt, Ot, It, We;
            return Zt().wrap(function(mt) {
              for (; ; ) switch (mt.prev = mt.next) {
                case 0:
                  return mt.prev = 0, mt.next = 3, WebAssembly.compile(me);
                case 3:
                  rt = mt.sent, ze = WebAssembly.Module.customSections(rt, "contractspecv0"), mt.next = 11;
                  break;
                case 7:
                  mt.prev = 7, mt.t0 = mt.catch(0), Tt = kr(me), ze = Tt.get("contractspecv0");
                case 11:
                  if (ze && ze.length !== 0) {
                    mt.next = 13;
                    break;
                  }
                  throw new Error("Could not obtain contract spec from wasm");
                case 13:
                  return Ot = zt.from(ze[0]), It = T(Ot), We = new ft(It), mt.abrupt("return", We);
                case 17:
                case "end":
                  return mt.stop();
              }
            }, we, null, [[0, 7]]);
          }))).apply(this, arguments);
        }
        function kr(we) {
          var me = /* @__PURE__ */ new Map(), ze = we.buffer.slice(we.byteOffset, we.byteOffset + we.byteLength), rt = 0, Tt = function(Fr) {
            if (rt + Fr > we.byteLength) throw new Error("Buffer overflow");
            var Gr = new Uint8Array(ze, rt, Fr);
            return rt += Fr, Gr;
          };
          if (gr(Tt(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
          if (gr(Tt(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
          for (; rt < we.byteLength; ) {
            var Ot = Tt(1)[0], It = hr(), We = rt;
            if (Ot === 0) {
              var mt = hr();
              if (mt === 0 || rt + mt > We + It) continue;
              var Gt = Tt(mt), ir = Tt(It - (rt - We));
              try {
                var dr = new TextDecoder("utf-8", { fatal: true }).decode(Gt);
                ir.length > 0 && me.set(dr, (me.get(dr) || []).concat(ir));
              } catch {
              }
            } else rt += It;
          }
          function hr() {
            for (var Fr = 0, Gr = 0; ; ) {
              var Br = Tt(1)[0];
              if (Fr |= (127 & Br) << Gr, !(128 & Br)) break;
              if ((Gr += 7) >= 32) throw new Error("Invalid WASM value");
            }
            return Fr >>> 0;
          }
          return me;
        }
        function Xt(we, me) {
          return Qt.apply(this, arguments);
        }
        function Qt() {
          return Qt = Nr(Zt().mark(function we(me, ze) {
            var rt, Tt, Ot, It, We, mt, Gt = arguments;
            return Zt().wrap(function(ir) {
              for (; ; ) switch (ir.prev = ir.next) {
                case 0:
                  if (rt = Gt.length > 2 && Gt[2] !== void 0 ? Gt[2] : "hex", ze && ze.rpcUrl) {
                    ir.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  return Tt = ze.rpcUrl, Ot = ze.allowHttp, It = { allowHttp: Ot }, We = new h.Server(Tt, It), ir.next = 8, We.getContractWasmByHash(me, rt);
                case 8:
                  return mt = ir.sent, ir.abrupt("return", jr(mt));
                case 10:
                case "end":
                  return ir.stop();
              }
            }, we);
          })), Qt.apply(this, arguments);
        }
        var br = function() {
          function we(Ot, It) {
            var We = this;
            (function(mt, Gt) {
              if (!(mt instanceof Gt)) throw new TypeError("Cannot call a class as a function");
            })(this, we), ar(this, "txFromJSON", function(mt) {
              var Gt = JSON.parse(mt), ir = Gt.method, dr = Wt(Gt, ct);
              return Ne.fromJSON(Lt(Lt({}, We.options), {}, { method: ir, parseResultXdr: function(hr) {
                return We.spec.funcResToNative(ir, hr);
              } }), dr);
            }), ar(this, "txFromXDR", function(mt) {
              return Ne.fromXDR(We.options, mt, We.spec);
            }), this.spec = Ot, this.options = It, this.spec.funcs().forEach(function(mt) {
              var Gt = mt.name().toString();
              if (Gt !== Lr) {
                var ir = function(dr, hr) {
                  return Ne.build(Lt(Lt(Lt({ method: Gt, args: dr && Ot.funcArgsToScVals(Gt, dr) }, It), hr), {}, { errorTypes: Ot.errorCases().reduce(function(Fr, Gr) {
                    return Lt(Lt({}, Fr), {}, ar({}, Gr.value(), { message: Gr.doc().toString() }));
                  }, {}), parseResultXdr: function(Fr) {
                    return Ot.funcResToNative(Gt, Fr);
                  } }));
                };
                We[Gt] = Ot.getFunc(Gt).inputs().length === 0 ? function(dr) {
                  return ir(void 0, dr);
                } : ir;
              }
            });
          }
          return function(Ot, It, We) {
            return We && vr(Ot, We), Object.defineProperty(Ot, "prototype", { writable: false }), Ot;
          }(we, null, [{ key: "deploy", value: (Tt = Nr(Zt().mark(function Ot(It, We) {
            var mt, Gt, ir, dr, hr, Fr, Gr, Br, Dr;
            return Zt().wrap(function(Vr) {
              for (; ; ) switch (Vr.prev = Vr.next) {
                case 0:
                  return mt = We.wasmHash, Gt = We.salt, ir = We.format, dr = We.fee, hr = We.timeoutInSeconds, Fr = We.simulate, Gr = Wt(We, yt), Vr.next = 3, Xt(mt, Gr, ir);
                case 3:
                  return Br = Vr.sent, Dr = c.Operation.createCustomContract({ address: new c.Address(We.address || We.publicKey), wasmHash: typeof mt == "string" ? zt.from(mt, ir ?? "hex") : mt, salt: Gt, constructorArgs: It ? Br.funcArgsToScVals(Lr, It) : [] }), Vr.abrupt("return", Ne.buildWithOp(Dr, Lt(Lt({ fee: dr, timeoutInSeconds: hr, simulate: Fr }, Gr), {}, { contractId: "ignored", method: Lr, parseResultXdr: function(be) {
                    return new we(Br, Lt(Lt({}, Gr), {}, { contractId: c.Address.fromScVal(be).toString() }));
                  } })));
                case 6:
                case "end":
                  return Vr.stop();
              }
            }, Ot);
          })), function(Ot, It) {
            return Tt.apply(this, arguments);
          }) }, { key: "fromWasmHash", value: (rt = Nr(Zt().mark(function Ot(It, We) {
            var mt, Gt, ir, dr, hr, Fr, Gr = arguments;
            return Zt().wrap(function(Br) {
              for (; ; ) switch (Br.prev = Br.next) {
                case 0:
                  if (mt = Gr.length > 2 && Gr[2] !== void 0 ? Gr[2] : "hex", We && We.rpcUrl) {
                    Br.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  return Gt = We.rpcUrl, ir = We.allowHttp, dr = { allowHttp: ir }, hr = new h.Server(Gt, dr), Br.next = 8, hr.getContractWasmByHash(It, mt);
                case 8:
                  return Fr = Br.sent, Br.abrupt("return", we.fromWasm(Fr, We));
                case 10:
                case "end":
                  return Br.stop();
              }
            }, Ot);
          })), function(Ot, It) {
            return rt.apply(this, arguments);
          }) }, { key: "fromWasm", value: (ze = Nr(Zt().mark(function Ot(It, We) {
            var mt;
            return Zt().wrap(function(Gt) {
              for (; ; ) switch (Gt.prev = Gt.next) {
                case 0:
                  return Gt.next = 2, jr(It);
                case 2:
                  return mt = Gt.sent, Gt.abrupt("return", new we(mt, We));
                case 4:
                case "end":
                  return Gt.stop();
              }
            }, Ot);
          })), function(Ot, It) {
            return ze.apply(this, arguments);
          }) }, { key: "from", value: (me = Nr(Zt().mark(function Ot(It) {
            var We, mt, Gt, ir, dr, hr;
            return Zt().wrap(function(Fr) {
              for (; ; ) switch (Fr.prev = Fr.next) {
                case 0:
                  if (It && It.rpcUrl && It.contractId) {
                    Fr.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  return We = It.rpcUrl, mt = It.contractId, Gt = It.allowHttp, ir = { allowHttp: Gt }, dr = new h.Server(We, ir), Fr.next = 7, dr.getContractWasmByContractId(mt);
                case 7:
                  return hr = Fr.sent, Fr.abrupt("return", we.fromWasm(hr, It));
                case 9:
                case "end":
                  return Fr.stop();
              }
            }, Ot);
          })), function(Ot) {
            return me.apply(this, arguments);
          }) }]);
          var me, ze, rt, Tt;
        }();
      }, 6396: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.TransactionBuilder = o.TimeoutInfinite = o.BASE_FEE = void 0, o.isValidDate = L;
        var c = u(3740), h = R(u(1242)), f = R(u(1918)), r = u(2135), m = u(2243), g = u(6160), a = u(380), l = u(9260), d = u(4842), b = u(7120), S = u(225), E = u(4172);
        function R(j) {
          return j && j.__esModule ? j : { default: j };
        }
        function k(j) {
          return k = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(z) {
            return typeof z;
          } : function(z) {
            return z && typeof Symbol == "function" && z.constructor === Symbol && z !== Symbol.prototype ? "symbol" : typeof z;
          }, k(j);
        }
        function w(j) {
          return function(z) {
            if (Array.isArray(z)) return F(z);
          }(j) || function(z) {
            if (typeof Symbol < "u" && z[Symbol.iterator] != null || z["@@iterator"] != null) return Array.from(z);
          }(j) || function(z, Y) {
            if (z) {
              if (typeof z == "string") return F(z, Y);
              var te = {}.toString.call(z).slice(8, -1);
              return te === "Object" && z.constructor && (te = z.constructor.name), te === "Map" || te === "Set" ? Array.from(z) : te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te) ? F(z, Y) : void 0;
            }
          }(j) || function() {
            throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function F(j, z) {
          (z == null || z > j.length) && (z = j.length);
          for (var Y = 0, te = Array(z); Y < z; Y++) te[Y] = j[Y];
          return te;
        }
        function I(j, z) {
          var Y = Object.keys(j);
          if (Object.getOwnPropertySymbols) {
            var te = Object.getOwnPropertySymbols(j);
            z && (te = te.filter(function(G) {
              return Object.getOwnPropertyDescriptor(j, G).enumerable;
            })), Y.push.apply(Y, te);
          }
          return Y;
        }
        function q(j) {
          for (var z = 1; z < arguments.length; z++) {
            var Y = arguments[z] != null ? arguments[z] : {};
            z % 2 ? I(Object(Y), true).forEach(function(te) {
              D(j, te, Y[te]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(j, Object.getOwnPropertyDescriptors(Y)) : I(Object(Y)).forEach(function(te) {
              Object.defineProperty(j, te, Object.getOwnPropertyDescriptor(Y, te));
            });
          }
          return j;
        }
        function D(j, z, Y) {
          return (z = _(z)) in j ? Object.defineProperty(j, z, { value: Y, enumerable: true, configurable: true, writable: true }) : j[z] = Y, j;
        }
        function H(j, z) {
          for (var Y = 0; Y < z.length; Y++) {
            var te = z[Y];
            te.enumerable = te.enumerable || false, te.configurable = true, "value" in te && (te.writable = true), Object.defineProperty(j, _(te.key), te);
          }
        }
        function _(j) {
          var z = function(Y, te) {
            if (k(Y) != "object" || !Y) return Y;
            var G = Y[Symbol.toPrimitive];
            if (G !== void 0) {
              var K = G.call(Y, te);
              if (k(K) != "object") return K;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(Y);
          }(j, "string");
          return k(z) == "symbol" ? z : z + "";
        }
        var T = o.BASE_FEE = "100";
        o.TimeoutInfinite = 0, o.TransactionBuilder = function() {
          function j(G) {
            var K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (function(J, B) {
              if (!(J instanceof B)) throw new TypeError("Cannot call a class as a function");
            }(this, j), !G) throw new Error("must specify source account for the transaction");
            if (K.fee === void 0) throw new Error("must specify fee for the transaction (in stroops)");
            this.source = G, this.operations = [], this.baseFee = K.fee, this.timebounds = K.timebounds ? q({}, K.timebounds) : null, this.ledgerbounds = K.ledgerbounds ? q({}, K.ledgerbounds) : null, this.minAccountSequence = K.minAccountSequence || null, this.minAccountSequenceAge = K.minAccountSequenceAge || null, this.minAccountSequenceLedgerGap = K.minAccountSequenceLedgerGap || null, this.extraSigners = K.extraSigners ? w(K.extraSigners) : null, this.memo = K.memo || E.Memo.none(), this.networkPassphrase = K.networkPassphrase || null, this.sorobanData = K.sorobanData ? new d.SorobanDataBuilder(K.sorobanData).build() : null;
          }
          return z = j, te = [{ key: "cloneFrom", value: function(G) {
            var K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!(G instanceof a.Transaction)) throw new TypeError("expected a 'Transaction', got: ".concat(G));
            var J, B = (BigInt(G.sequence) - 1n).toString();
            if (b.StrKey.isValidMed25519PublicKey(G.source)) J = m.MuxedAccount.fromAddress(G.source, B);
            else {
              if (!b.StrKey.isValidEd25519PublicKey(G.source)) throw new TypeError("unsupported tx source account: ".concat(G.source));
              J = new r.Account(G.source, B);
            }
            var Z = new j(J, q({ fee: (parseInt(G.fee, 10) / G.operations.length || T).toString(), memo: G.memo, networkPassphrase: G.networkPassphrase, timebounds: G.timeBounds, ledgerbounds: G.ledgerBounds, minAccountSequence: G.minAccountSequence, minAccountSequenceAge: G.minAccountSequenceAge, minAccountSequenceLedgerGap: G.minAccountSequenceLedgerGap, extraSigners: G.extraSigners }, K));
            return G._tx.operations().forEach(function(ie) {
              return Z.addOperation(ie);
            }), Z;
          } }, { key: "buildFeeBumpTransaction", value: function(G, K, J, B) {
            var Z = J.operations.length, ie = new h.default(J.fee).div(Z), $ = new h.default(K);
            if ($.lt(ie)) throw new Error("Invalid baseFee, it should be at least ".concat(ie, " stroops."));
            var oe = new h.default(T);
            if ($.lt(oe)) throw new Error("Invalid baseFee, it should be at least ".concat(oe, " stroops."));
            var ce, ye = J.toEnvelope();
            if (ye.switch() === f.default.EnvelopeType.envelopeTypeTxV0()) {
              var ae = ye.v0().tx(), ue = new f.default.Transaction({ sourceAccount: new f.default.MuxedAccount.keyTypeEd25519(ae.sourceAccountEd25519()), fee: ae.fee(), seqNum: ae.seqNum(), cond: f.default.Preconditions.precondTime(ae.timeBounds()), memo: ae.memo(), operations: ae.operations(), ext: new f.default.TransactionExt(0) });
              ye = new f.default.TransactionEnvelope.envelopeTypeTx(new f.default.TransactionV1Envelope({ tx: ue, signatures: ye.v0().signatures() }));
            }
            ce = typeof G == "string" ? (0, g.decodeAddressToMuxedAccount)(G) : G.xdrMuxedAccount();
            var ne = new f.default.FeeBumpTransaction({ feeSource: ce, fee: f.default.Int64.fromString($.times(Z + 1).toString()), innerTx: f.default.FeeBumpTransactionInnerTx.envelopeTypeTx(ye.v1()), ext: new f.default.FeeBumpTransactionExt(0) }), ge = new f.default.FeeBumpTransactionEnvelope({ tx: ne, signatures: [] }), Te = new f.default.TransactionEnvelope.envelopeTypeTxFeeBump(ge);
            return new l.FeeBumpTransaction(Te, B);
          } }, { key: "fromXDR", value: function(G, K) {
            return typeof G == "string" && (G = f.default.TransactionEnvelope.fromXDR(G, "base64")), G.switch() === f.default.EnvelopeType.envelopeTypeTxFeeBump() ? new l.FeeBumpTransaction(G, K) : new a.Transaction(G, K);
          } }], (Y = [{ key: "addOperation", value: function(G) {
            return this.operations.push(G), this;
          } }, { key: "addOperationAt", value: function(G, K) {
            return this.operations.splice(K, 0, G), this;
          } }, { key: "clearOperations", value: function() {
            return this.operations = [], this;
          } }, { key: "clearOperationAt", value: function(G) {
            return this.operations.splice(G, 1), this;
          } }, { key: "addMemo", value: function(G) {
            return this.memo = G, this;
          } }, { key: "setTimeout", value: function(G) {
            if (this.timebounds !== null && this.timebounds.maxTime > 0) throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
            if (G < 0) throw new Error("timeout cannot be negative");
            if (G > 0) {
              var K = Math.floor(Date.now() / 1e3) + G;
              this.timebounds === null ? this.timebounds = { minTime: 0, maxTime: K } : this.timebounds = { minTime: this.timebounds.minTime, maxTime: K };
            } else this.timebounds = { minTime: 0, maxTime: 0 };
            return this;
          } }, { key: "setTimebounds", value: function(G, K) {
            if (typeof G == "number" && (G = new Date(1e3 * G)), typeof K == "number" && (K = new Date(1e3 * K)), this.timebounds !== null) throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
            var J = Math.floor(G.valueOf() / 1e3), B = Math.floor(K.valueOf() / 1e3);
            if (J < 0) throw new Error("min_time cannot be negative");
            if (B < 0) throw new Error("max_time cannot be negative");
            if (B > 0 && J > B) throw new Error("min_time cannot be greater than max_time");
            return this.timebounds = { minTime: J, maxTime: B }, this;
          } }, { key: "setLedgerbounds", value: function(G, K) {
            if (this.ledgerbounds !== null) throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
            if (G < 0) throw new Error("min_ledger cannot be negative");
            if (K < 0) throw new Error("max_ledger cannot be negative");
            if (K > 0 && G > K) throw new Error("min_ledger cannot be greater than max_ledger");
            return this.ledgerbounds = { minLedger: G, maxLedger: K }, this;
          } }, { key: "setMinAccountSequence", value: function(G) {
            if (this.minAccountSequence !== null) throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
            return this.minAccountSequence = G, this;
          } }, { key: "setMinAccountSequenceAge", value: function(G) {
            if (typeof G != "number") throw new Error("min_account_sequence_age must be a number");
            if (this.minAccountSequenceAge !== null) throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
            if (G < 0) throw new Error("min_account_sequence_age cannot be negative");
            return this.minAccountSequenceAge = G, this;
          } }, { key: "setMinAccountSequenceLedgerGap", value: function(G) {
            if (this.minAccountSequenceLedgerGap !== null) throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
            if (G < 0) throw new Error("min_account_sequence_ledger_gap cannot be negative");
            return this.minAccountSequenceLedgerGap = G, this;
          } }, { key: "setExtraSigners", value: function(G) {
            if (!Array.isArray(G)) throw new Error("extra_signers must be an array of strings.");
            if (this.extraSigners !== null) throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
            if (G.length > 2) throw new Error("extra_signers cannot be longer than 2 elements.");
            return this.extraSigners = w(G), this;
          } }, { key: "setNetworkPassphrase", value: function(G) {
            return this.networkPassphrase = G, this;
          } }, { key: "setSorobanData", value: function(G) {
            return this.sorobanData = new d.SorobanDataBuilder(G).build(), this;
          } }, { key: "build", value: function() {
            var G = new h.default(this.source.sequenceNumber()).plus(1), K = { fee: new h.default(this.baseFee).times(this.operations.length).toNumber(), seqNum: f.default.SequenceNumber.fromString(G.toString()), memo: this.memo ? this.memo.toXDRObject() : null };
            if (this.timebounds === null || this.timebounds.minTime === void 0 || this.timebounds.maxTime === void 0) throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
            L(this.timebounds.minTime) && (this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3), L(this.timebounds.maxTime) && (this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3), this.timebounds.minTime = c.UnsignedHyper.fromString(this.timebounds.minTime.toString()), this.timebounds.maxTime = c.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
            var J = new f.default.TimeBounds(this.timebounds);
            if (this.hasV2Preconditions()) {
              var B = null;
              this.ledgerbounds !== null && (B = new f.default.LedgerBounds(this.ledgerbounds));
              var Z = this.minAccountSequence || "0";
              Z = f.default.SequenceNumber.fromString(Z);
              var ie = c.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0"), $ = this.minAccountSequenceLedgerGap || 0, oe = this.extraSigners !== null ? this.extraSigners.map(S.SignerKey.decodeAddress) : [];
              K.cond = f.default.Preconditions.precondV2(new f.default.PreconditionsV2({ timeBounds: J, ledgerBounds: B, minSeqNum: Z, minSeqAge: ie, minSeqLedgerGap: $, extraSigners: oe }));
            } else K.cond = f.default.Preconditions.precondTime(J);
            K.sourceAccount = (0, g.decodeAddressToMuxedAccount)(this.source.accountId()), this.sorobanData ? K.ext = new f.default.TransactionExt(1, this.sorobanData) : K.ext = new f.default.TransactionExt(0, f.default.Void);
            var ce = new f.default.Transaction(K);
            ce.operations(this.operations);
            var ye = new f.default.TransactionEnvelope.envelopeTypeTx(new f.default.TransactionV1Envelope({ tx: ce })), ae = new a.Transaction(ye, this.networkPassphrase);
            return this.source.incrementSequenceNumber(), ae;
          } }, { key: "hasV2Preconditions", value: function() {
            return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
          } }]) && H(z.prototype, Y), te && H(z, te), Object.defineProperty(z, "prototype", { writable: false }), z;
          var z, Y, te;
        }();
        function L(j) {
          return j instanceof Date && !isNaN(j);
        }
      }, 6549: (t) => {
        t.exports = Object.getOwnPropertyDescriptor;
      }, 6556: (t, o, u) => {
        var c = u(453), h = u(3126), f = h([c("%String.prototype.indexOf%")]);
        t.exports = function(r, m) {
          var g = c(r, !!m);
          return typeof g == "function" && f(r, ".prototype.") > -1 ? h([g]) : g;
        };
      }, 6578: (t) => {
        t.exports = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"];
      }, 6688: (t, o, u) => {
        var c;
        function h() {
          if (c !== void 0) return c;
          if (u.g.XMLHttpRequest) {
            c = new u.g.XMLHttpRequest();
            try {
              c.open("GET", u.g.XDomainRequest ? "/" : "https://example.com");
            } catch {
              c = null;
            }
          } else c = null;
          return c;
        }
        function f(m) {
          var g = h();
          if (!g) return false;
          try {
            return g.responseType = m, g.responseType === m;
          } catch {
          }
          return false;
        }
        function r(m) {
          return typeof m == "function";
        }
        o.fetch = r(u.g.fetch) && r(u.g.ReadableStream), o.writableStream = r(u.g.WritableStream), o.abortController = r(u.g.AbortController), o.arraybuffer = o.fetch || f("arraybuffer"), o.msstream = !o.fetch && f("ms-stream"), o.mozchunkedarraybuffer = !o.fetch && f("moz-chunked-arraybuffer"), o.overrideMimeType = o.fetch || !!h() && r(h().overrideMimeType), c = null;
      }, 6691: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.Keypair = void 0;
        var h = a(u(4940)), f = u(15), r = u(7120), m = u(9152), g = a(u(1918));
        function a(S) {
          return S && S.__esModule ? S : { default: S };
        }
        function l(S) {
          return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
            return typeof E;
          } : function(E) {
            return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
          }, l(S);
        }
        function d(S, E) {
          for (var R = 0; R < E.length; R++) {
            var k = E[R];
            k.enumerable = k.enumerable || false, k.configurable = true, "value" in k && (k.writable = true), Object.defineProperty(S, b(k.key), k);
          }
        }
        function b(S) {
          var E = function(R, k) {
            if (l(R) != "object" || !R) return R;
            var w = R[Symbol.toPrimitive];
            if (w !== void 0) {
              var F = w.call(R, k);
              if (l(F) != "object") return F;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(R);
          }(S, "string");
          return l(E) == "symbol" ? E : E + "";
        }
        o.Keypair = function() {
          return S = function k(w) {
            if (function(F, I) {
              if (!(F instanceof I)) throw new TypeError("Cannot call a class as a function");
            }(this, k), w.type !== "ed25519") throw new Error("Invalid keys type");
            if (this.type = w.type, w.secretKey) {
              if (w.secretKey = c.from(w.secretKey), w.secretKey.length !== 32) throw new Error("secretKey length is invalid");
              if (this._secretSeed = w.secretKey, this._publicKey = (0, f.generate)(w.secretKey), this._secretKey = c.concat([w.secretKey, this._publicKey]), w.publicKey && !this._publicKey.equals(c.from(w.publicKey))) throw new Error("secretKey does not match publicKey");
            } else if (this._publicKey = c.from(w.publicKey), this._publicKey.length !== 32) throw new Error("publicKey length is invalid");
          }, R = [{ key: "fromSecret", value: function(k) {
            var w = r.StrKey.decodeEd25519SecretSeed(k);
            return this.fromRawEd25519Seed(w);
          } }, { key: "fromRawEd25519Seed", value: function(k) {
            return new this({ type: "ed25519", secretKey: k });
          } }, { key: "master", value: function(k) {
            if (!k) throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
            return this.fromRawEd25519Seed((0, m.hash)(k));
          } }, { key: "fromPublicKey", value: function(k) {
            if ((k = r.StrKey.decodeEd25519PublicKey(k)).length !== 32) throw new Error("Invalid Stellar public key");
            return new this({ type: "ed25519", publicKey: k });
          } }, { key: "random", value: function() {
            var k = h.default.randomBytes(32);
            return this.fromRawEd25519Seed(k);
          } }], (E = [{ key: "xdrAccountId", value: function() {
            return new g.default.AccountId.publicKeyTypeEd25519(this._publicKey);
          } }, { key: "xdrPublicKey", value: function() {
            return new g.default.PublicKey.publicKeyTypeEd25519(this._publicKey);
          } }, { key: "xdrMuxedAccount", value: function(k) {
            if (k !== void 0) {
              if (typeof k != "string") throw new TypeError("expected string for ID, got ".concat(l(k)));
              return g.default.MuxedAccount.keyTypeMuxedEd25519(new g.default.MuxedAccountMed25519({ id: g.default.Uint64.fromString(k), ed25519: this._publicKey }));
            }
            return new g.default.MuxedAccount.keyTypeEd25519(this._publicKey);
          } }, { key: "rawPublicKey", value: function() {
            return this._publicKey;
          } }, { key: "signatureHint", value: function() {
            var k = this.xdrAccountId().toXDR();
            return k.slice(k.length - 4);
          } }, { key: "publicKey", value: function() {
            return r.StrKey.encodeEd25519PublicKey(this._publicKey);
          } }, { key: "secret", value: function() {
            if (!this._secretSeed) throw new Error("no secret key available");
            if (this.type === "ed25519") return r.StrKey.encodeEd25519SecretSeed(this._secretSeed);
            throw new Error("Invalid Keypair type");
          } }, { key: "rawSecretKey", value: function() {
            return this._secretSeed;
          } }, { key: "canSign", value: function() {
            return !!this._secretKey;
          } }, { key: "sign", value: function(k) {
            if (!this.canSign()) throw new Error("cannot sign: no secret key available");
            return (0, f.sign)(k, this._secretKey);
          } }, { key: "verify", value: function(k, w) {
            return (0, f.verify)(k, w, this._publicKey);
          } }, { key: "signDecorated", value: function(k) {
            var w = this.sign(k), F = this.signatureHint();
            return new g.default.DecoratedSignature({ hint: F, signature: w });
          } }, { key: "signPayloadDecorated", value: function(k) {
            var w = this.sign(k), F = this.signatureHint(), I = c.from(k.slice(-4));
            return I.length < 4 && (I = c.concat([I, c.alloc(4 - k.length, 0)])), new g.default.DecoratedSignature({ hint: I.map(function(q, D) {
              return q ^ F[D];
            }), signature: w });
          } }]) && d(S.prototype, E), R && d(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }();
      }, 6698: (t) => {
        typeof Object.create == "function" ? t.exports = function(o, u) {
          u && (o.super_ = u, o.prototype = Object.create(u.prototype, { constructor: { value: o, enumerable: false, writable: true, configurable: true } }));
        } : t.exports = function(o, u) {
          if (u) {
            o.super_ = u;
            var c = function() {
            };
            c.prototype = u.prototype, o.prototype = new c(), o.prototype.constructor = o;
          }
        };
      }, 6708: (t, o, u) => {
        function c(K) {
          var J = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(B, Z, ie) {
              var $ = B.entry;
              for (B.entry = null; $; ) {
                var oe = $.callback;
                Z.pendingcb--, oe(ie), $ = $.next;
              }
              Z.corkedRequestsFree.next = B;
            })(J, K);
          };
        }
        var h;
        t.exports = T, T.WritableState = _;
        var f = { deprecate: u(4643) }, r = u(345), m = u(8287).Buffer, g = (u.g !== void 0 ? u.g : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
        }, a, l = u(5896), d = u(5291).getHighWaterMark, b = u(6048).F, S = b.ERR_INVALID_ARG_TYPE, E = b.ERR_METHOD_NOT_IMPLEMENTED, R = b.ERR_MULTIPLE_CALLBACK, k = b.ERR_STREAM_CANNOT_PIPE, w = b.ERR_STREAM_DESTROYED, F = b.ERR_STREAM_NULL_VALUES, I = b.ERR_STREAM_WRITE_AFTER_END, q = b.ERR_UNKNOWN_ENCODING, D = l.errorOrDestroy;
        function H() {
        }
        function _(K, J, B) {
          h = h || u(5382), K = K || {}, typeof B != "boolean" && (B = J instanceof h), this.objectMode = !!K.objectMode, B && (this.objectMode = this.objectMode || !!K.writableObjectMode), this.highWaterMark = d(this, K, "writableHighWaterMark", B), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
          var Z = K.decodeStrings === false;
          this.decodeStrings = !Z, this.defaultEncoding = K.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(ie) {
            (function($, oe) {
              var ce = $._writableState, ye = ce.sync, ae = ce.writecb;
              if (typeof ae != "function") throw new R();
              if (function(ne) {
                ne.writing = false, ne.writecb = null, ne.length -= ne.writelen, ne.writelen = 0;
              }(ce), oe) (function(ne, ge, Te, pe, Oe) {
                --ge.pendingcb, Te ? (process.nextTick(Oe, pe), process.nextTick(G, ne, ge), ne._writableState.errorEmitted = true, D(ne, pe)) : (Oe(pe), ne._writableState.errorEmitted = true, D(ne, pe), G(ne, ge));
              })($, ce, ye, oe, ae);
              else {
                var ue = Y(ce) || $.destroyed;
                ue || ce.corked || ce.bufferProcessing || !ce.bufferedRequest || z($, ce), ye ? process.nextTick(j, $, ce, ue, ae) : j($, ce, ue, ae);
              }
            })(J, ie);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = K.emitClose !== false, this.autoDestroy = !!K.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new c(this);
        }
        function T(K) {
          var J = this instanceof (h = h || u(5382));
          if (!J && !a.call(T, this)) return new T(K);
          this._writableState = new _(K, this, J), this.writable = true, K && (typeof K.write == "function" && (this._write = K.write), typeof K.writev == "function" && (this._writev = K.writev), typeof K.destroy == "function" && (this._destroy = K.destroy), typeof K.final == "function" && (this._final = K.final)), r.call(this);
        }
        function L(K, J, B, Z, ie, $, oe) {
          J.writelen = Z, J.writecb = oe, J.writing = true, J.sync = true, J.destroyed ? J.onwrite(new w("write")) : B ? K._writev(ie, J.onwrite) : K._write(ie, $, J.onwrite), J.sync = false;
        }
        function j(K, J, B, Z) {
          B || function(ie, $) {
            $.length === 0 && $.needDrain && ($.needDrain = false, ie.emit("drain"));
          }(K, J), J.pendingcb--, Z(), G(K, J);
        }
        function z(K, J) {
          J.bufferProcessing = true;
          var B = J.bufferedRequest;
          if (K._writev && B && B.next) {
            var Z = J.bufferedRequestCount, ie = new Array(Z), $ = J.corkedRequestsFree;
            $.entry = B;
            for (var oe = 0, ce = true; B; ) ie[oe] = B, B.isBuf || (ce = false), B = B.next, oe += 1;
            ie.allBuffers = ce, L(K, J, true, J.length, ie, "", $.finish), J.pendingcb++, J.lastBufferedRequest = null, $.next ? (J.corkedRequestsFree = $.next, $.next = null) : J.corkedRequestsFree = new c(J), J.bufferedRequestCount = 0;
          } else {
            for (; B; ) {
              var ye = B.chunk, ae = B.encoding, ue = B.callback;
              if (L(K, J, false, J.objectMode ? 1 : ye.length, ye, ae, ue), B = B.next, J.bufferedRequestCount--, J.writing) break;
            }
            B === null && (J.lastBufferedRequest = null);
          }
          J.bufferedRequest = B, J.bufferProcessing = false;
        }
        function Y(K) {
          return K.ending && K.length === 0 && K.bufferedRequest === null && !K.finished && !K.writing;
        }
        function te(K, J) {
          K._final(function(B) {
            J.pendingcb--, B && D(K, B), J.prefinished = true, K.emit("prefinish"), G(K, J);
          });
        }
        function G(K, J) {
          var B = Y(J);
          if (B && (function(ie, $) {
            $.prefinished || $.finalCalled || (typeof ie._final != "function" || $.destroyed ? ($.prefinished = true, ie.emit("prefinish")) : ($.pendingcb++, $.finalCalled = true, process.nextTick(te, ie, $)));
          }(K, J), J.pendingcb === 0 && (J.finished = true, K.emit("finish"), J.autoDestroy))) {
            var Z = K._readableState;
            (!Z || Z.autoDestroy && Z.endEmitted) && K.destroy();
          }
          return B;
        }
        u(6698)(T, r), _.prototype.getBuffer = function() {
          for (var K = this.bufferedRequest, J = []; K; ) J.push(K), K = K.next;
          return J;
        }, function() {
          try {
            Object.defineProperty(_.prototype, "buffer", { get: f.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (a = Function.prototype[Symbol.hasInstance], Object.defineProperty(T, Symbol.hasInstance, { value: function(K) {
          return !!a.call(this, K) || this === T && K && K._writableState instanceof _;
        } })) : a = function(K) {
          return K instanceof this;
        }, T.prototype.pipe = function() {
          D(this, new k());
        }, T.prototype.write = function(K, J, B) {
          var Z, ie = this._writableState, $ = false, oe = !ie.objectMode && (Z = K, m.isBuffer(Z) || Z instanceof g);
          return oe && !m.isBuffer(K) && (K = function(ce) {
            return m.from(ce);
          }(K)), typeof J == "function" && (B = J, J = null), oe ? J = "buffer" : J || (J = ie.defaultEncoding), typeof B != "function" && (B = H), ie.ending ? function(ce, ye) {
            var ae = new I();
            D(ce, ae), process.nextTick(ye, ae);
          }(this, B) : (oe || function(ce, ye, ae, ue) {
            var ne;
            return ae === null ? ne = new F() : typeof ae == "string" || ye.objectMode || (ne = new S("chunk", ["string", "Buffer"], ae)), !ne || (D(ce, ne), process.nextTick(ue, ne), false);
          }(this, ie, K, B)) && (ie.pendingcb++, $ = function(ce, ye, ae, ue, ne, ge) {
            if (!ae) {
              var Te = function(Ve, _e, Be) {
                return Ve.objectMode || Ve.decodeStrings === false || typeof _e != "string" || (_e = m.from(_e, Be)), _e;
              }(ye, ue, ne);
              ue !== Te && (ae = true, ne = "buffer", ue = Te);
            }
            var pe = ye.objectMode ? 1 : ue.length;
            ye.length += pe;
            var Oe = ye.length < ye.highWaterMark;
            if (Oe || (ye.needDrain = true), ye.writing || ye.corked) {
              var xe = ye.lastBufferedRequest;
              ye.lastBufferedRequest = { chunk: ue, encoding: ne, isBuf: ae, callback: ge, next: null }, xe ? xe.next = ye.lastBufferedRequest : ye.bufferedRequest = ye.lastBufferedRequest, ye.bufferedRequestCount += 1;
            } else L(ce, ye, false, pe, ue, ne, ge);
            return Oe;
          }(this, ie, oe, K, J, B)), $;
        }, T.prototype.cork = function() {
          this._writableState.corked++;
        }, T.prototype.uncork = function() {
          var K = this._writableState;
          K.corked && (K.corked--, K.writing || K.corked || K.bufferProcessing || !K.bufferedRequest || z(this, K));
        }, T.prototype.setDefaultEncoding = function(K) {
          if (typeof K == "string" && (K = K.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((K + "").toLowerCase()) > -1)) throw new q(K);
          return this._writableState.defaultEncoding = K, this;
        }, Object.defineProperty(T.prototype, "writableBuffer", { enumerable: false, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(T.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
          return this._writableState.highWaterMark;
        } }), T.prototype._write = function(K, J, B) {
          B(new E("_write()"));
        }, T.prototype._writev = null, T.prototype.end = function(K, J, B) {
          var Z = this._writableState;
          return typeof K == "function" ? (B = K, K = null, J = null) : typeof J == "function" && (B = J, J = null), K != null && this.write(K, J), Z.corked && (Z.corked = 1, this.uncork()), Z.ending || function(ie, $, oe) {
            $.ending = true, G(ie, $), oe && ($.finished ? process.nextTick(oe) : ie.once("finish", oe)), $.ended = true, ie.writable = false;
          }(this, Z, B), this;
        }, Object.defineProperty(T.prototype, "writableLength", { enumerable: false, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(T.prototype, "destroyed", { enumerable: false, get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(K) {
          this._writableState && (this._writableState.destroyed = K);
        } }), T.prototype.destroy = l.destroy, T.prototype._undestroy = l.undestroy, T.prototype._destroy = function(K, J) {
          J(K);
        };
      }, 6710: (t, o, u) => {
        var c = u(6698), h = u(4107), f = u(392), r = u(2861).Buffer, m = new Array(64);
        function g() {
          this.init(), this._w = m, f.call(this, 64, 56);
        }
        c(g, h), g.prototype.init = function() {
          return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
        }, g.prototype._hash = function() {
          var a = r.allocUnsafe(28);
          return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
        }, t.exports = g;
      }, 6743: (t, o, u) => {
        var c = u(1734);
        t.exports = Function.prototype.bind || c;
      }, 6866: (t) => {
        t.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
      }, 6897: (t, o, u) => {
        var c = u(453), h = u(41), f = u(592)(), r = u(5795), m = u(9675), g = c("%Math.floor%");
        t.exports = function(a, l) {
          if (typeof a != "function") throw new m("`fn` is not a function");
          if (typeof l != "number" || l < 0 || l > 4294967295 || g(l) !== l) throw new m("`length` must be a positive 32-bit integer");
          var d = arguments.length > 2 && !!arguments[2], b = true, S = true;
          if ("length" in a && r) {
            var E = r(a, "length");
            E && !E.configurable && (b = false), E && !E.writable && (S = false);
          }
          return (b || S || !d) && (f ? h(a, "length", l, true, true) : h(a, "length", l)), a;
        };
      }, 6917: (t, o, u) => {
        var c = u(8287).Buffer, h = u(6688), f = u(6698), r = u(8399), m = o.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, g = o.IncomingMessage = function(a, l, d, b) {
          var S = this;
          if (r.Readable.call(S), S._mode = d, S.headers = {}, S.rawHeaders = [], S.trailers = {}, S.rawTrailers = [], S.on("end", function() {
            process.nextTick(function() {
              S.emit("close");
            });
          }), d === "fetch") {
            if (S._fetchResponse = l, S.url = l.url, S.statusCode = l.status, S.statusMessage = l.statusText, l.headers.forEach(function(F, I) {
              S.headers[I.toLowerCase()] = F, S.rawHeaders.push(I, F);
            }), h.writableStream) {
              var E = new WritableStream({ write: function(F) {
                return b(false), new Promise(function(I, q) {
                  S._destroyed ? q() : S.push(c.from(F)) ? I() : S._resumeFetch = I;
                });
              }, close: function() {
                b(true), S._destroyed || S.push(null);
              }, abort: function(F) {
                b(true), S._destroyed || S.emit("error", F);
              } });
              try {
                return void l.body.pipeTo(E).catch(function(F) {
                  b(true), S._destroyed || S.emit("error", F);
                });
              } catch {
              }
            }
            var R = l.body.getReader();
            (function F() {
              R.read().then(function(I) {
                S._destroyed || (b(I.done), I.done ? S.push(null) : (S.push(c.from(I.value)), F()));
              }).catch(function(I) {
                b(true), S._destroyed || S.emit("error", I);
              });
            })();
          } else if (S._xhr = a, S._pos = 0, S.url = a.responseURL, S.statusCode = a.status, S.statusMessage = a.statusText, a.getAllResponseHeaders().split(/\r?\n/).forEach(function(F) {
            var I = F.match(/^([^:]+):\s*(.*)/);
            if (I) {
              var q = I[1].toLowerCase();
              q === "set-cookie" ? (S.headers[q] === void 0 && (S.headers[q] = []), S.headers[q].push(I[2])) : S.headers[q] !== void 0 ? S.headers[q] += ", " + I[2] : S.headers[q] = I[2], S.rawHeaders.push(I[1], I[2]);
            }
          }), S._charset = "x-user-defined", !h.overrideMimeType) {
            var k = S.rawHeaders["mime-type"];
            if (k) {
              var w = k.match(/;\s*charset=([^;])(;|$)/);
              w && (S._charset = w[1].toLowerCase());
            }
            S._charset || (S._charset = "utf-8");
          }
        };
        f(g, r.Readable), g.prototype._read = function() {
          var a = this._resumeFetch;
          a && (this._resumeFetch = null, a());
        }, g.prototype._onXHRProgress = function(a) {
          var l = this, d = l._xhr, b = null;
          switch (l._mode) {
            case "text":
              if ((b = d.responseText).length > l._pos) {
                var S = b.substr(l._pos);
                if (l._charset === "x-user-defined") {
                  for (var E = c.alloc(S.length), R = 0; R < S.length; R++) E[R] = 255 & S.charCodeAt(R);
                  l.push(E);
                } else l.push(S, l._charset);
                l._pos = b.length;
              }
              break;
            case "arraybuffer":
              if (d.readyState !== m.DONE || !d.response) break;
              b = d.response, l.push(c.from(new Uint8Array(b)));
              break;
            case "moz-chunked-arraybuffer":
              if (b = d.response, d.readyState !== m.LOADING || !b) break;
              l.push(c.from(new Uint8Array(b)));
              break;
            case "ms-stream":
              if (b = d.response, d.readyState !== m.LOADING) break;
              var k = new u.g.MSStreamReader();
              k.onprogress = function() {
                k.result.byteLength > l._pos && (l.push(c.from(new Uint8Array(k.result.slice(l._pos)))), l._pos = k.result.byteLength);
              }, k.onload = function() {
                a(true), l.push(null);
              }, k.readAsArrayBuffer(b);
          }
          l._xhr.readyState === m.DONE && l._mode !== "ms-stream" && (a(true), l.push(null));
        };
      }, 7007: (t) => {
        var o, u = typeof Reflect == "object" ? Reflect : null, c = u && typeof u.apply == "function" ? u.apply : function(k, w, F) {
          return Function.prototype.apply.call(k, w, F);
        };
        o = u && typeof u.ownKeys == "function" ? u.ownKeys : Object.getOwnPropertySymbols ? function(k) {
          return Object.getOwnPropertyNames(k).concat(Object.getOwnPropertySymbols(k));
        } : function(k) {
          return Object.getOwnPropertyNames(k);
        };
        var h = Number.isNaN || function(k) {
          return k != k;
        };
        function f() {
          f.init.call(this);
        }
        t.exports = f, t.exports.once = function(k, w) {
          return new Promise(function(F, I) {
            function q(H) {
              k.removeListener(w, D), I(H);
            }
            function D() {
              typeof k.removeListener == "function" && k.removeListener("error", q), F([].slice.call(arguments));
            }
            R(k, w, D, { once: true }), w !== "error" && function(H, _, T) {
              typeof H.on == "function" && R(H, "error", _, T);
            }(k, q, { once: true });
          });
        }, f.EventEmitter = f, f.prototype._events = void 0, f.prototype._eventsCount = 0, f.prototype._maxListeners = void 0;
        var r = 10;
        function m(k) {
          if (typeof k != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof k);
        }
        function g(k) {
          return k._maxListeners === void 0 ? f.defaultMaxListeners : k._maxListeners;
        }
        function a(k, w, F, I) {
          var q, D, H, _;
          if (m(F), (D = k._events) === void 0 ? (D = k._events = /* @__PURE__ */ Object.create(null), k._eventsCount = 0) : (D.newListener !== void 0 && (k.emit("newListener", w, F.listener ? F.listener : F), D = k._events), H = D[w]), H === void 0) H = D[w] = F, ++k._eventsCount;
          else if (typeof H == "function" ? H = D[w] = I ? [F, H] : [H, F] : I ? H.unshift(F) : H.push(F), (q = g(k)) > 0 && H.length > q && !H.warned) {
            H.warned = true;
            var T = new Error("Possible EventEmitter memory leak detected. " + H.length + " " + String(w) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            T.name = "MaxListenersExceededWarning", T.emitter = k, T.type = w, T.count = H.length, _ = T, console && console.warn && console.warn(_);
          }
          return k;
        }
        function l() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function d(k, w, F) {
          var I = { fired: false, wrapFn: void 0, target: k, type: w, listener: F }, q = l.bind(I);
          return q.listener = F, I.wrapFn = q, q;
        }
        function b(k, w, F) {
          var I = k._events;
          if (I === void 0) return [];
          var q = I[w];
          return q === void 0 ? [] : typeof q == "function" ? F ? [q.listener || q] : [q] : F ? function(D) {
            for (var H = new Array(D.length), _ = 0; _ < H.length; ++_) H[_] = D[_].listener || D[_];
            return H;
          }(q) : E(q, q.length);
        }
        function S(k) {
          var w = this._events;
          if (w !== void 0) {
            var F = w[k];
            if (typeof F == "function") return 1;
            if (F !== void 0) return F.length;
          }
          return 0;
        }
        function E(k, w) {
          for (var F = new Array(w), I = 0; I < w; ++I) F[I] = k[I];
          return F;
        }
        function R(k, w, F, I) {
          if (typeof k.on == "function") I.once ? k.once(w, F) : k.on(w, F);
          else {
            if (typeof k.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof k);
            k.addEventListener(w, function q(D) {
              I.once && k.removeEventListener(w, q), F(D);
            });
          }
        }
        Object.defineProperty(f, "defaultMaxListeners", { enumerable: true, get: function() {
          return r;
        }, set: function(k) {
          if (typeof k != "number" || k < 0 || h(k)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + k + ".");
          r = k;
        } }), f.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, f.prototype.setMaxListeners = function(k) {
          if (typeof k != "number" || k < 0 || h(k)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + k + ".");
          return this._maxListeners = k, this;
        }, f.prototype.getMaxListeners = function() {
          return g(this);
        }, f.prototype.emit = function(k) {
          for (var w = [], F = 1; F < arguments.length; F++) w.push(arguments[F]);
          var I = k === "error", q = this._events;
          if (q !== void 0) I = I && q.error === void 0;
          else if (!I) return false;
          if (I) {
            var D;
            if (w.length > 0 && (D = w[0]), D instanceof Error) throw D;
            var H = new Error("Unhandled error." + (D ? " (" + D.message + ")" : ""));
            throw H.context = D, H;
          }
          var _ = q[k];
          if (_ === void 0) return false;
          if (typeof _ == "function") c(_, this, w);
          else {
            var T = _.length, L = E(_, T);
            for (F = 0; F < T; ++F) c(L[F], this, w);
          }
          return true;
        }, f.prototype.addListener = function(k, w) {
          return a(this, k, w, false);
        }, f.prototype.on = f.prototype.addListener, f.prototype.prependListener = function(k, w) {
          return a(this, k, w, true);
        }, f.prototype.once = function(k, w) {
          return m(w), this.on(k, d(this, k, w)), this;
        }, f.prototype.prependOnceListener = function(k, w) {
          return m(w), this.prependListener(k, d(this, k, w)), this;
        }, f.prototype.removeListener = function(k, w) {
          var F, I, q, D, H;
          if (m(w), (I = this._events) === void 0) return this;
          if ((F = I[k]) === void 0) return this;
          if (F === w || F.listener === w) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete I[k], I.removeListener && this.emit("removeListener", k, F.listener || w));
          else if (typeof F != "function") {
            for (q = -1, D = F.length - 1; D >= 0; D--) if (F[D] === w || F[D].listener === w) {
              H = F[D].listener, q = D;
              break;
            }
            if (q < 0) return this;
            q === 0 ? F.shift() : function(_, T) {
              for (; T + 1 < _.length; T++) _[T] = _[T + 1];
              _.pop();
            }(F, q), F.length === 1 && (I[k] = F[0]), I.removeListener !== void 0 && this.emit("removeListener", k, H || w);
          }
          return this;
        }, f.prototype.off = f.prototype.removeListener, f.prototype.removeAllListeners = function(k) {
          var w, F, I;
          if ((F = this._events) === void 0) return this;
          if (F.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : F[k] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete F[k]), this;
          if (arguments.length === 0) {
            var q, D = Object.keys(F);
            for (I = 0; I < D.length; ++I) (q = D[I]) !== "removeListener" && this.removeAllListeners(q);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (w = F[k]) == "function") this.removeListener(k, w);
          else if (w !== void 0) for (I = w.length - 1; I >= 0; I--) this.removeListener(k, w[I]);
          return this;
        }, f.prototype.listeners = function(k) {
          return b(this, k, true);
        }, f.prototype.rawListeners = function(k) {
          return b(this, k, false);
        }, f.listenerCount = function(k, w) {
          return typeof k.listenerCount == "function" ? k.listenerCount(w) : S.call(k, w);
        }, f.prototype.listenerCount = S, f.prototype.eventNames = function() {
          return this._eventsCount > 0 ? o(this._events) : [];
        };
      }, 7119: (t) => {
        t.exports = typeof Reflect < "u" && Reflect && Reflect.apply;
      }, 7120: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.StrKey = void 0, o.decodeCheck = S, o.encodeCheck = E;
        var h, f = (h = u(5360)) && h.__esModule ? h : { default: h }, r = u(1346);
        function m(k) {
          return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(w) {
            return typeof w;
          } : function(w) {
            return w && typeof Symbol == "function" && w.constructor === Symbol && w !== Symbol.prototype ? "symbol" : typeof w;
          }, m(k);
        }
        function g(k, w) {
          for (var F = 0; F < w.length; F++) {
            var I = w[F];
            I.enumerable = I.enumerable || false, I.configurable = true, "value" in I && (I.writable = true), Object.defineProperty(k, a(I.key), I);
          }
        }
        function a(k) {
          var w = function(F, I) {
            if (m(F) != "object" || !F) return F;
            var q = F[Symbol.toPrimitive];
            if (q !== void 0) {
              var D = q.call(F, I);
              if (m(D) != "object") return D;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(F);
          }(k, "string");
          return m(w) == "symbol" ? w : w + "";
        }
        var l = { ed25519PublicKey: 48, ed25519SecretSeed: 144, med25519PublicKey: 96, preAuthTx: 152, sha256Hash: 184, signedPayload: 120, contract: 16 }, d = { G: "ed25519PublicKey", S: "ed25519SecretSeed", M: "med25519PublicKey", T: "preAuthTx", X: "sha256Hash", P: "signedPayload", C: "contract" };
        o.StrKey = function() {
          return function(k, w, F) {
            return F && g(k, F), Object.defineProperty(k, "prototype", { writable: false }), k;
          }(function k() {
            (function(w, F) {
              if (!(w instanceof F)) throw new TypeError("Cannot call a class as a function");
            })(this, k);
          }, null, [{ key: "encodeEd25519PublicKey", value: function(k) {
            return E("ed25519PublicKey", k);
          } }, { key: "decodeEd25519PublicKey", value: function(k) {
            return S("ed25519PublicKey", k);
          } }, { key: "isValidEd25519PublicKey", value: function(k) {
            return b("ed25519PublicKey", k);
          } }, { key: "encodeEd25519SecretSeed", value: function(k) {
            return E("ed25519SecretSeed", k);
          } }, { key: "decodeEd25519SecretSeed", value: function(k) {
            return S("ed25519SecretSeed", k);
          } }, { key: "isValidEd25519SecretSeed", value: function(k) {
            return b("ed25519SecretSeed", k);
          } }, { key: "encodeMed25519PublicKey", value: function(k) {
            return E("med25519PublicKey", k);
          } }, { key: "decodeMed25519PublicKey", value: function(k) {
            return S("med25519PublicKey", k);
          } }, { key: "isValidMed25519PublicKey", value: function(k) {
            return b("med25519PublicKey", k);
          } }, { key: "encodePreAuthTx", value: function(k) {
            return E("preAuthTx", k);
          } }, { key: "decodePreAuthTx", value: function(k) {
            return S("preAuthTx", k);
          } }, { key: "encodeSha256Hash", value: function(k) {
            return E("sha256Hash", k);
          } }, { key: "decodeSha256Hash", value: function(k) {
            return S("sha256Hash", k);
          } }, { key: "encodeSignedPayload", value: function(k) {
            return E("signedPayload", k);
          } }, { key: "decodeSignedPayload", value: function(k) {
            return S("signedPayload", k);
          } }, { key: "isValidSignedPayload", value: function(k) {
            return b("signedPayload", k);
          } }, { key: "encodeContract", value: function(k) {
            return E("contract", k);
          } }, { key: "decodeContract", value: function(k) {
            return S("contract", k);
          } }, { key: "isValidContract", value: function(k) {
            return b("contract", k);
          } }, { key: "getVersionByteForPrefix", value: function(k) {
            return d[k[0]];
          } }]);
        }();
        function b(k, w) {
          if (typeof w != "string") return false;
          switch (k) {
            case "ed25519PublicKey":
            case "ed25519SecretSeed":
            case "preAuthTx":
            case "sha256Hash":
            case "contract":
              if (w.length !== 56) return false;
              break;
            case "med25519PublicKey":
              if (w.length !== 69) return false;
              break;
            case "signedPayload":
              if (w.length < 56 || w.length > 165) return false;
              break;
            default:
              return false;
          }
          var F = "";
          try {
            F = S(k, w);
          } catch {
            return false;
          }
          switch (k) {
            case "ed25519PublicKey":
            case "ed25519SecretSeed":
            case "preAuthTx":
            case "sha256Hash":
            case "contract":
              return F.length === 32;
            case "med25519PublicKey":
              return F.length === 40;
            case "signedPayload":
              return F.length >= 40 && F.length <= 100;
            default:
              return false;
          }
        }
        function S(k, w) {
          if (typeof w != "string") throw new TypeError("encoded argument must be of type String");
          var F = f.default.decode(w), I = F[0], q = F.slice(0, -2), D = q.slice(1), H = F.slice(-2);
          if (w !== f.default.encode(F)) throw new Error("invalid encoded string");
          var _ = l[k];
          if (_ === void 0) throw new Error("".concat(k, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(l).join(", ")));
          if (I !== _) throw new Error("invalid version byte. expected ".concat(_, ", got ").concat(I));
          var T = R(q);
          if (!(0, r.verifyChecksum)(T, H)) throw new Error("invalid checksum");
          return c.from(D);
        }
        function E(k, w) {
          if (w == null) throw new Error("cannot encode null data");
          var F = l[k];
          if (F === void 0) throw new Error("".concat(k, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(l).join(", ")));
          w = c.from(w);
          var I = c.from([F]), q = c.concat([I, w]), D = c.from(R(q)), H = c.concat([q, D]);
          return f.default.encode(H);
        }
        function R(k) {
          for (var w = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920], F = 0, I = 0; I < k.length; I += 1) F = F << 8 ^ w[F >> 8 ^ k[I]], F &= 65535;
          var q = new Uint8Array(2);
          return q[0] = 255 & F, q[1] = F >> 8 & 255, q;
        }
      }, 7176: (t, o, u) => {
        var c, h = u(3126), f = u(5795);
        try {
          c = [].__proto__ === Array.prototype;
        } catch (a) {
          if (!a || typeof a != "object" || !("code" in a) || a.code !== "ERR_PROTO_ACCESS") throw a;
        }
        var r = !!c && f && f(Object.prototype, "__proto__"), m = Object, g = m.getPrototypeOf;
        t.exports = r && typeof r.get == "function" ? h([r.get]) : typeof g == "function" && function(a) {
          return g(a == null ? a : m(a));
        };
      }, 7177: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.nativeToScVal = function E(R) {
          var k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          switch (b(R)) {
            case "object":
              var w, F, I;
              if (R === null) return f.default.ScVal.scvVoid();
              if (R instanceof f.default.ScVal) return R;
              if (R instanceof m.Address) return R.toScVal();
              if (R instanceof r.Keypair) return E(R.publicKey(), { type: "address" });
              if (R instanceof g.Contract) return R.address().toScVal();
              if (R instanceof Uint8Array || c.isBuffer(R)) {
                var q, D = Uint8Array.from(R);
                switch ((q = k == null ? void 0 : k.type) !== null && q !== void 0 ? q : "bytes") {
                  case "bytes":
                    return f.default.ScVal.scvBytes(D);
                  case "symbol":
                    return f.default.ScVal.scvSymbol(D);
                  case "string":
                    return f.default.ScVal.scvString(D);
                  default:
                    throw new TypeError("invalid type (".concat(k.type, ") specified for bytes-like value"));
                }
              }
              if (Array.isArray(R)) return f.default.ScVal.scvVec(R.map(function(T) {
                return E(T, k);
              }));
              if (((w = (F = R.constructor) === null || F === void 0 ? void 0 : F.name) !== null && w !== void 0 ? w : "") !== "Object") throw new TypeError("cannot interpret ".concat((I = R.constructor) === null || I === void 0 ? void 0 : I.name, " value as ScVal (").concat(JSON.stringify(R), ")"));
              return f.default.ScVal.scvMap(Object.entries(R).sort(function(T, L) {
                var j = l(T, 1)[0], z = l(L, 1)[0];
                return j.localeCompare(z);
              }).map(function(T) {
                var L, j, z = l(T, 2), Y = z[0], te = z[1], G = l((L = ((j = k == null ? void 0 : k.type) !== null && j !== void 0 ? j : {})[Y]) !== null && L !== void 0 ? L : [null, null], 2), K = G[0], J = G[1], B = K ? { type: K } : {}, Z = J ? { type: J } : {};
                return new f.default.ScMapEntry({ key: E(Y, B), val: E(te, Z) });
              }));
            case "number":
            case "bigint":
              switch (k == null ? void 0 : k.type) {
                case "u32":
                  return f.default.ScVal.scvU32(R);
                case "i32":
                  return f.default.ScVal.scvI32(R);
              }
              return new a.ScInt(R, { type: k == null ? void 0 : k.type }).toScVal();
            case "string":
              var H, _ = (H = k == null ? void 0 : k.type) !== null && H !== void 0 ? H : "string";
              switch (_) {
                case "string":
                  return f.default.ScVal.scvString(R);
                case "symbol":
                  return f.default.ScVal.scvSymbol(R);
                case "address":
                  return new m.Address(R).toScVal();
                case "u32":
                  return f.default.ScVal.scvU32(parseInt(R, 10));
                case "i32":
                  return f.default.ScVal.scvI32(parseInt(R, 10));
                default:
                  if (a.XdrLargeInt.isType(_)) return new a.XdrLargeInt(_, R).toScVal();
                  throw new TypeError("invalid type (".concat(k.type, ") specified for string value"));
              }
            case "boolean":
              return f.default.ScVal.scvBool(R);
            case "undefined":
              return f.default.ScVal.scvVoid();
            case "function":
              return E(R());
            default:
              throw new TypeError("failed to convert typeof ".concat(b(R), " (").concat(R, ")"));
          }
        }, o.scValToNative = S;
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(6691), m = u(1180), g = u(7452), a = u(8549);
        function l(E, R) {
          return function(k) {
            if (Array.isArray(k)) return k;
          }(E) || function(k, w) {
            var F = k == null ? null : typeof Symbol < "u" && k[Symbol.iterator] || k["@@iterator"];
            if (F != null) {
              var I, q, D, H, _ = [], T = true, L = false;
              try {
                if (D = (F = F.call(k)).next, w === 0) {
                  if (Object(F) !== F) return;
                  T = false;
                } else for (; !(T = (I = D.call(F)).done) && (_.push(I.value), _.length !== w); T = true) ;
              } catch (j) {
                L = true, q = j;
              } finally {
                try {
                  if (!T && F.return != null && (H = F.return(), Object(H) !== H)) return;
                } finally {
                  if (L) throw q;
                }
              }
              return _;
            }
          }(E, R) || function(k, w) {
            if (k) {
              if (typeof k == "string") return d(k, w);
              var F = {}.toString.call(k).slice(8, -1);
              return F === "Object" && k.constructor && (F = k.constructor.name), F === "Map" || F === "Set" ? Array.from(k) : F === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(F) ? d(k, w) : void 0;
            }
          }(E, R) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function d(E, R) {
          (R == null || R > E.length) && (R = E.length);
          for (var k = 0, w = Array(R); k < R; k++) w[k] = E[k];
          return w;
        }
        function b(E) {
          return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
            return typeof R;
          } : function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
          }, b(E);
        }
        function S(E) {
          var R, k;
          switch (E.switch().value) {
            case f.default.ScValType.scvVoid().value:
              return null;
            case f.default.ScValType.scvU64().value:
            case f.default.ScValType.scvI64().value:
              return E.value().toBigInt();
            case f.default.ScValType.scvU128().value:
            case f.default.ScValType.scvI128().value:
            case f.default.ScValType.scvU256().value:
            case f.default.ScValType.scvI256().value:
              return (0, a.scValToBigInt)(E);
            case f.default.ScValType.scvVec().value:
              return ((R = E.vec()) !== null && R !== void 0 ? R : []).map(S);
            case f.default.ScValType.scvAddress().value:
              return m.Address.fromScVal(E).toString();
            case f.default.ScValType.scvMap().value:
              return Object.fromEntries(((k = E.map()) !== null && k !== void 0 ? k : []).map(function(I) {
                return [S(I.key()), S(I.val())];
              }));
            case f.default.ScValType.scvBool().value:
            case f.default.ScValType.scvU32().value:
            case f.default.ScValType.scvI32().value:
            case f.default.ScValType.scvBytes().value:
              return E.value();
            case f.default.ScValType.scvSymbol().value:
            case f.default.ScValType.scvString().value:
              var w = E.value();
              if (c.isBuffer(w) || ArrayBuffer.isView(w)) try {
                return new TextDecoder().decode(w);
              } catch {
                return new Uint8Array(w.buffer);
              }
              return w;
            case f.default.ScValType.scvTimepoint().value:
            case f.default.ScValType.scvDuration().value:
              return new f.default.Uint64(E.value()).toBigInt();
            case f.default.ScValType.scvError().value:
              if (E.error().switch().value === f.default.ScErrorType.sceContract().value) return { type: "contract", code: E.error().contractCode() };
              var F = E.error();
              return { type: "system", code: F.code().value, value: F.code().name };
            default:
              return E.value();
          }
        }
        f.default.scvSortedMap = function(E) {
          var R = Array.from(E).sort(function(k, w) {
            var F = S(k.key()), I = S(w.key());
            switch (b(F)) {
              case "number":
              case "bigint":
                return F < I ? -1 : 1;
              default:
                return F.toString().localeCompare(I.toString());
            }
          });
          return f.default.ScVal.scvMap(R);
        };
      }, 7237: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Operation = o.AuthRevocableFlag = o.AuthRequiredFlag = o.AuthImmutableFlag = o.AuthClawbackEnabledFlag = void 0;
        var c = u(3740), h = k(u(1242)), f = u(645), r = u(4151), m = u(1764), g = u(2262), a = u(1387), l = u(7120), d = u(9353), b = k(u(1918)), S = function(_, T) {
          if (_ && _.__esModule) return _;
          if (_ === null || w(_) != "object" && typeof _ != "function") return { default: _ };
          var L = R(T);
          if (L && L.has(_)) return L.get(_);
          var j = { __proto__: null }, z = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var Y in _) if (Y !== "default" && {}.hasOwnProperty.call(_, Y)) {
            var te = z ? Object.getOwnPropertyDescriptor(_, Y) : null;
            te && (te.get || te.set) ? Object.defineProperty(j, Y, te) : j[Y] = _[Y];
          }
          return j.default = _, L && L.set(_, j), j;
        }(u(7511)), E = u(6160);
        function R(_) {
          if (typeof WeakMap != "function") return null;
          var T = /* @__PURE__ */ new WeakMap(), L = /* @__PURE__ */ new WeakMap();
          return (R = function(j) {
            return j ? L : T;
          })(_);
        }
        function k(_) {
          return _ && _.__esModule ? _ : { default: _ };
        }
        function w(_) {
          return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
            return typeof T;
          } : function(T) {
            return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
          }, w(_);
        }
        function F(_, T) {
          for (var L = 0; L < T.length; L++) {
            var j = T[L];
            j.enumerable = j.enumerable || false, j.configurable = true, "value" in j && (j.writable = true), Object.defineProperty(_, I(j.key), j);
          }
        }
        function I(_) {
          var T = function(L, j) {
            if (w(L) != "object" || !L) return L;
            var z = L[Symbol.toPrimitive];
            if (z !== void 0) {
              var Y = z.call(L, j);
              if (w(Y) != "object") return Y;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(L);
          }(_, "string");
          return w(T) == "symbol" ? T : T + "";
        }
        var q = 1e7, D = (o.AuthRequiredFlag = 1, o.AuthRevocableFlag = 2, o.AuthImmutableFlag = 4, o.AuthClawbackEnabledFlag = 8, o.Operation = function() {
          return _ = function j() {
            (function(z, Y) {
              if (!(z instanceof Y)) throw new TypeError("Cannot call a class as a function");
            })(this, j);
          }, L = [{ key: "setSourceAccount", value: function(j, z) {
            if (z.source) try {
              j.sourceAccount = (0, E.decodeAddressToMuxedAccount)(z.source);
            } catch {
              throw new Error("Source address is invalid");
            }
          } }, { key: "fromXDRObject", value: function(j) {
            var z = {};
            j.sourceAccount() && (z.source = (0, E.encodeMuxedAccountToAddress)(j.sourceAccount()));
            var Y = j.body().value(), te = j.body().switch().name;
            switch (te) {
              case "createAccount":
                z.type = "createAccount", z.destination = H(Y.destination()), z.startingBalance = this._fromXDRAmount(Y.startingBalance());
                break;
              case "payment":
                z.type = "payment", z.destination = (0, E.encodeMuxedAccountToAddress)(Y.destination()), z.asset = m.Asset.fromOperation(Y.asset()), z.amount = this._fromXDRAmount(Y.amount());
                break;
              case "pathPaymentStrictReceive":
                z.type = "pathPaymentStrictReceive", z.sendAsset = m.Asset.fromOperation(Y.sendAsset()), z.sendMax = this._fromXDRAmount(Y.sendMax()), z.destination = (0, E.encodeMuxedAccountToAddress)(Y.destination()), z.destAsset = m.Asset.fromOperation(Y.destAsset()), z.destAmount = this._fromXDRAmount(Y.destAmount()), z.path = [];
                var G = Y.path();
                Object.keys(G).forEach(function(ye) {
                  z.path.push(m.Asset.fromOperation(G[ye]));
                });
                break;
              case "pathPaymentStrictSend":
                z.type = "pathPaymentStrictSend", z.sendAsset = m.Asset.fromOperation(Y.sendAsset()), z.sendAmount = this._fromXDRAmount(Y.sendAmount()), z.destination = (0, E.encodeMuxedAccountToAddress)(Y.destination()), z.destAsset = m.Asset.fromOperation(Y.destAsset()), z.destMin = this._fromXDRAmount(Y.destMin()), z.path = [];
                var K = Y.path();
                Object.keys(K).forEach(function(ye) {
                  z.path.push(m.Asset.fromOperation(K[ye]));
                });
                break;
              case "changeTrust":
                z.type = "changeTrust", Y.line().switch() === b.default.AssetType.assetTypePoolShare() ? z.line = g.LiquidityPoolAsset.fromOperation(Y.line()) : z.line = m.Asset.fromOperation(Y.line()), z.limit = this._fromXDRAmount(Y.limit());
                break;
              case "allowTrust":
                z.type = "allowTrust", z.trustor = H(Y.trustor()), z.assetCode = Y.asset().value().toString(), z.assetCode = (0, f.trimEnd)(z.assetCode, "\0"), z.authorize = Y.authorize();
                break;
              case "setOptions":
                if (z.type = "setOptions", Y.inflationDest() && (z.inflationDest = H(Y.inflationDest())), z.clearFlags = Y.clearFlags(), z.setFlags = Y.setFlags(), z.masterWeight = Y.masterWeight(), z.lowThreshold = Y.lowThreshold(), z.medThreshold = Y.medThreshold(), z.highThreshold = Y.highThreshold(), z.homeDomain = Y.homeDomain() !== void 0 ? Y.homeDomain().toString("ascii") : void 0, Y.signer()) {
                  var J = {}, B = Y.signer().key().arm();
                  if (B === "ed25519") J.ed25519PublicKey = H(Y.signer().key());
                  else if (B === "preAuthTx") J.preAuthTx = Y.signer().key().preAuthTx();
                  else if (B === "hashX") J.sha256Hash = Y.signer().key().hashX();
                  else if (B === "ed25519SignedPayload") {
                    var Z = Y.signer().key().ed25519SignedPayload();
                    J.ed25519SignedPayload = l.StrKey.encodeSignedPayload(Z.toXDR());
                  }
                  J.weight = Y.signer().weight(), z.signer = J;
                }
                break;
              case "manageOffer":
              case "manageSellOffer":
                z.type = "manageSellOffer", z.selling = m.Asset.fromOperation(Y.selling()), z.buying = m.Asset.fromOperation(Y.buying()), z.amount = this._fromXDRAmount(Y.amount()), z.price = this._fromXDRPrice(Y.price()), z.offerId = Y.offerId().toString();
                break;
              case "manageBuyOffer":
                z.type = "manageBuyOffer", z.selling = m.Asset.fromOperation(Y.selling()), z.buying = m.Asset.fromOperation(Y.buying()), z.buyAmount = this._fromXDRAmount(Y.buyAmount()), z.price = this._fromXDRPrice(Y.price()), z.offerId = Y.offerId().toString();
                break;
              case "createPassiveOffer":
              case "createPassiveSellOffer":
                z.type = "createPassiveSellOffer", z.selling = m.Asset.fromOperation(Y.selling()), z.buying = m.Asset.fromOperation(Y.buying()), z.amount = this._fromXDRAmount(Y.amount()), z.price = this._fromXDRPrice(Y.price());
                break;
              case "accountMerge":
                z.type = "accountMerge", z.destination = (0, E.encodeMuxedAccountToAddress)(Y);
                break;
              case "manageData":
                z.type = "manageData", z.name = Y.dataName().toString("ascii"), z.value = Y.dataValue();
                break;
              case "inflation":
                z.type = "inflation";
                break;
              case "bumpSequence":
                z.type = "bumpSequence", z.bumpTo = Y.bumpTo().toString();
                break;
              case "createClaimableBalance":
                z.type = "createClaimableBalance", z.asset = m.Asset.fromOperation(Y.asset()), z.amount = this._fromXDRAmount(Y.amount()), z.claimants = [], Y.claimants().forEach(function(ye) {
                  z.claimants.push(a.Claimant.fromXDR(ye));
                });
                break;
              case "claimClaimableBalance":
                z.type = "claimClaimableBalance", z.balanceId = Y.toXDR("hex");
                break;
              case "beginSponsoringFutureReserves":
                z.type = "beginSponsoringFutureReserves", z.sponsoredId = H(Y.sponsoredId());
                break;
              case "endSponsoringFutureReserves":
                z.type = "endSponsoringFutureReserves";
                break;
              case "revokeSponsorship":
                (function(ye, ae) {
                  switch (ye.switch().name) {
                    case "revokeSponsorshipLedgerEntry":
                      var ue = ye.ledgerKey();
                      switch (ue.switch().name) {
                        case b.default.LedgerEntryType.account().name:
                          ae.type = "revokeAccountSponsorship", ae.account = H(ue.account().accountId());
                          break;
                        case b.default.LedgerEntryType.trustline().name:
                          ae.type = "revokeTrustlineSponsorship", ae.account = H(ue.trustLine().accountId());
                          var ne = ue.trustLine().asset();
                          ne.switch() === b.default.AssetType.assetTypePoolShare() ? ae.asset = d.LiquidityPoolId.fromOperation(ne) : ae.asset = m.Asset.fromOperation(ne);
                          break;
                        case b.default.LedgerEntryType.offer().name:
                          ae.type = "revokeOfferSponsorship", ae.seller = H(ue.offer().sellerId()), ae.offerId = ue.offer().offerId().toString();
                          break;
                        case b.default.LedgerEntryType.data().name:
                          ae.type = "revokeDataSponsorship", ae.account = H(ue.data().accountId()), ae.name = ue.data().dataName().toString("ascii");
                          break;
                        case b.default.LedgerEntryType.claimableBalance().name:
                          ae.type = "revokeClaimableBalanceSponsorship", ae.balanceId = ue.claimableBalance().balanceId().toXDR("hex");
                          break;
                        case b.default.LedgerEntryType.liquidityPool().name:
                          ae.type = "revokeLiquidityPoolSponsorship", ae.liquidityPoolId = ue.liquidityPool().liquidityPoolId().toString("hex");
                          break;
                        default:
                          throw new Error("Unknown ledgerKey: ".concat(ye.switch().name));
                      }
                      break;
                    case "revokeSponsorshipSigner":
                      ae.type = "revokeSignerSponsorship", ae.account = H(ye.signer().accountId()), ae.signer = function(ge) {
                        var Te = {};
                        switch (ge.switch().name) {
                          case b.default.SignerKeyType.signerKeyTypeEd25519().name:
                            Te.ed25519PublicKey = l.StrKey.encodeEd25519PublicKey(ge.ed25519());
                            break;
                          case b.default.SignerKeyType.signerKeyTypePreAuthTx().name:
                            Te.preAuthTx = ge.preAuthTx().toString("hex");
                            break;
                          case b.default.SignerKeyType.signerKeyTypeHashX().name:
                            Te.sha256Hash = ge.hashX().toString("hex");
                            break;
                          default:
                            throw new Error("Unknown signerKey: ".concat(ge.switch().name));
                        }
                        return Te;
                      }(ye.signer().signerKey());
                      break;
                    default:
                      throw new Error("Unknown revokeSponsorship: ".concat(ye.switch().name));
                  }
                })(Y, z);
                break;
              case "clawback":
                z.type = "clawback", z.amount = this._fromXDRAmount(Y.amount()), z.from = (0, E.encodeMuxedAccountToAddress)(Y.from()), z.asset = m.Asset.fromOperation(Y.asset());
                break;
              case "clawbackClaimableBalance":
                z.type = "clawbackClaimableBalance", z.balanceId = Y.toXDR("hex");
                break;
              case "setTrustLineFlags":
                z.type = "setTrustLineFlags", z.asset = m.Asset.fromOperation(Y.asset()), z.trustor = H(Y.trustor());
                var ie = Y.clearFlags(), $ = Y.setFlags(), oe = { authorized: b.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: b.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: b.default.TrustLineFlags.trustlineClawbackEnabledFlag() };
                z.flags = {}, Object.keys(oe).forEach(function(ye) {
                  var ae;
                  z.flags[ye] = (ae = oe[ye].value, !!($ & ae) || !(ie & ae) && void 0);
                });
                break;
              case "liquidityPoolDeposit":
                z.type = "liquidityPoolDeposit", z.liquidityPoolId = Y.liquidityPoolId().toString("hex"), z.maxAmountA = this._fromXDRAmount(Y.maxAmountA()), z.maxAmountB = this._fromXDRAmount(Y.maxAmountB()), z.minPrice = this._fromXDRPrice(Y.minPrice()), z.maxPrice = this._fromXDRPrice(Y.maxPrice());
                break;
              case "liquidityPoolWithdraw":
                z.type = "liquidityPoolWithdraw", z.liquidityPoolId = Y.liquidityPoolId().toString("hex"), z.amount = this._fromXDRAmount(Y.amount()), z.minAmountA = this._fromXDRAmount(Y.minAmountA()), z.minAmountB = this._fromXDRAmount(Y.minAmountB());
                break;
              case "invokeHostFunction":
                var ce;
                z.type = "invokeHostFunction", z.func = Y.hostFunction(), z.auth = (ce = Y.auth()) !== null && ce !== void 0 ? ce : [];
                break;
              case "extendFootprintTtl":
                z.type = "extendFootprintTtl", z.extendTo = Y.extendTo();
                break;
              case "restoreFootprint":
                z.type = "restoreFootprint";
                break;
              default:
                throw new Error("Unknown operation: ".concat(te));
            }
            return z;
          } }, { key: "isValidAmount", value: function(j) {
            var z, Y = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            if (typeof j != "string") return false;
            try {
              z = new h.default(j);
            } catch {
              return false;
            }
            return !(!Y && z.isZero() || z.isNegative() || z.times(q).gt(new h.default("9223372036854775807").toString()) || z.decimalPlaces() > 7 || z.isNaN() || !z.isFinite());
          } }, { key: "constructAmountRequirementsError", value: function(j) {
            return "".concat(j, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
          } }, { key: "_checkUnsignedIntValue", value: function(j, z) {
            var Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (z !== void 0) switch (typeof z == "string" && (z = parseFloat(z)), true) {
              case (typeof z != "number" || !Number.isFinite(z) || z % 1 != 0):
                throw new Error("".concat(j, " value is invalid"));
              case z < 0:
                throw new Error("".concat(j, " value must be unsigned"));
              case (!Y || Y && Y(z, j)):
                return z;
              default:
                throw new Error("".concat(j, " value is invalid"));
            }
          } }, { key: "_toXDRAmount", value: function(j) {
            var z = new h.default(j).times(q);
            return c.Hyper.fromString(z.toString());
          } }, { key: "_fromXDRAmount", value: function(j) {
            return new h.default(j).div(q).toFixed(7);
          } }, { key: "_fromXDRPrice", value: function(j) {
            return new h.default(j.n()).div(new h.default(j.d())).toString();
          } }, { key: "_toXDRPrice", value: function(j) {
            var z;
            if (j.n && j.d) z = new b.default.Price(j);
            else {
              var Y = (0, r.best_r)(j);
              z = new b.default.Price({ n: parseInt(Y[0], 10), d: parseInt(Y[1], 10) });
            }
            if (z.n() < 0 || z.d() < 0) throw new Error("price must be positive");
            return z;
          } }], (T = null) && F(_.prototype, T), L && F(_, L), Object.defineProperty(_, "prototype", { writable: false }), _;
          var _, T, L;
        }());
        function H(_) {
          return l.StrKey.encodeEd25519PublicKey(_.ed25519());
        }
        D.accountMerge = S.accountMerge, D.allowTrust = S.allowTrust, D.bumpSequence = S.bumpSequence, D.changeTrust = S.changeTrust, D.createAccount = S.createAccount, D.createClaimableBalance = S.createClaimableBalance, D.claimClaimableBalance = S.claimClaimableBalance, D.clawbackClaimableBalance = S.clawbackClaimableBalance, D.createPassiveSellOffer = S.createPassiveSellOffer, D.inflation = S.inflation, D.manageData = S.manageData, D.manageSellOffer = S.manageSellOffer, D.manageBuyOffer = S.manageBuyOffer, D.pathPaymentStrictReceive = S.pathPaymentStrictReceive, D.pathPaymentStrictSend = S.pathPaymentStrictSend, D.payment = S.payment, D.setOptions = S.setOptions, D.beginSponsoringFutureReserves = S.beginSponsoringFutureReserves, D.endSponsoringFutureReserves = S.endSponsoringFutureReserves, D.revokeAccountSponsorship = S.revokeAccountSponsorship, D.revokeTrustlineSponsorship = S.revokeTrustlineSponsorship, D.revokeOfferSponsorship = S.revokeOfferSponsorship, D.revokeDataSponsorship = S.revokeDataSponsorship, D.revokeClaimableBalanceSponsorship = S.revokeClaimableBalanceSponsorship, D.revokeLiquidityPoolSponsorship = S.revokeLiquidityPoolSponsorship, D.revokeSignerSponsorship = S.revokeSignerSponsorship, D.clawback = S.clawback, D.setTrustLineFlags = S.setTrustLineFlags, D.liquidityPoolDeposit = S.liquidityPoolDeposit, D.liquidityPoolWithdraw = S.liquidityPoolWithdraw, D.invokeHostFunction = S.invokeHostFunction, D.extendFootprintTtl = S.extendFootprintTtl, D.restoreFootprint = S.restoreFootprint, D.createStellarAssetContract = S.createStellarAssetContract, D.invokeContractFunction = S.invokeContractFunction, D.createCustomContract = S.createCustomContract, D.uploadContractWasm = S.uploadContractWasm;
      }, 7239: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.claimClaimableBalance = function() {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          f(r.balanceId);
          var m = {};
          m.balanceId = h.default.ClaimableBalanceId.fromXDR(r.balanceId, "hex");
          var g = new h.default.ClaimClaimableBalanceOp(m), a = {};
          return a.body = h.default.OperationBody.claimClaimableBalance(g), this.setSourceAccount(a, r), new h.default.Operation(a);
        }, o.validateClaimableBalanceId = f;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
        function f(r) {
          if (typeof r != "string" || r.length !== 72) throw new Error("must provide a valid claimable balance id");
        }
      }, 7244: (t, o, u) => {
        var c = u(9092)(), h = u(6556)("Object.prototype.toString"), f = function(g) {
          return !(c && g && typeof g == "object" && Symbol.toStringTag in g) && h(g) === "[object Arguments]";
        }, r = function(g) {
          return !!f(g) || g !== null && typeof g == "object" && "length" in g && typeof g.length == "number" && g.length >= 0 && h(g) !== "[object Array]" && "callee" in g && h(g.callee) === "[object Function]";
        }, m = function() {
          return f(arguments);
        }();
        f.isLegacyArguments = r, t.exports = m ? f : r;
      }, 7421: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.inflation = function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = {};
          return r.body = h.default.OperationBody.inflation(), this.setSourceAccount(r, f), new h.default.Operation(r);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 7429: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.XdrLargeInt = void 0;
        var c, h = u(3740), f = u(6272), r = u(8672), m = u(5487), g = u(4063), a = (c = u(1918)) && c.__esModule ? c : { default: c };
        function l(E) {
          return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(R) {
            return typeof R;
          } : function(R) {
            return R && typeof Symbol == "function" && R.constructor === Symbol && R !== Symbol.prototype ? "symbol" : typeof R;
          }, l(E);
        }
        function d(E, R) {
          for (var k = 0; k < R.length; k++) {
            var w = R[k];
            w.enumerable = w.enumerable || false, w.configurable = true, "value" in w && (w.writable = true), Object.defineProperty(E, S(w.key), w);
          }
        }
        function b(E, R, k) {
          return (R = S(R)) in E ? Object.defineProperty(E, R, { value: k, enumerable: true, configurable: true, writable: true }) : E[R] = k, E;
        }
        function S(E) {
          var R = function(k, w) {
            if (l(k) != "object" || !k) return k;
            var F = k[Symbol.toPrimitive];
            if (F !== void 0) {
              var I = F.call(k, w);
              if (l(I) != "object") return I;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (w === "string" ? String : Number)(k);
          }(E, "string");
          return l(R) == "symbol" ? R : R + "";
        }
        o.XdrLargeInt = function() {
          return function(E, R, k) {
            return R && d(E.prototype, R), k && d(E, k), Object.defineProperty(E, "prototype", { writable: false }), E;
          }(function E(R, k) {
            switch (function(w, F) {
              if (!(w instanceof F)) throw new TypeError("Cannot call a class as a function");
            }(this, E), b(this, "int", void 0), b(this, "type", void 0), k instanceof Array || (k = [k]), k = k.map(function(w) {
              return typeof w == "bigint" ? w : w instanceof E ? w.toBigInt() : BigInt(w);
            }), R) {
              case "i64":
                this.int = new h.Hyper(k);
                break;
              case "i128":
                this.int = new m.Int128(k);
                break;
              case "i256":
                this.int = new g.Int256(k);
                break;
              case "u64":
                this.int = new h.UnsignedHyper(k);
                break;
              case "u128":
                this.int = new f.Uint128(k);
                break;
              case "u256":
                this.int = new r.Uint256(k);
                break;
              default:
                throw TypeError("invalid type: ".concat(R));
            }
            this.type = R;
          }, [{ key: "toNumber", value: function() {
            var E = this.int.toBigInt();
            if (E > Number.MAX_SAFE_INTEGER || E < Number.MIN_SAFE_INTEGER) throw RangeError("value ".concat(E, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
            return Number(E);
          } }, { key: "toBigInt", value: function() {
            return this.int.toBigInt();
          } }, { key: "toI64", value: function() {
            this._sizeCheck(64);
            var E = this.toBigInt();
            if (BigInt.asIntN(64, E) !== E) throw RangeError("value too large for i64: ".concat(E));
            return a.default.ScVal.scvI64(new a.default.Int64(E));
          } }, { key: "toU64", value: function() {
            return this._sizeCheck(64), a.default.ScVal.scvU64(new a.default.Uint64(BigInt.asUintN(64, this.toBigInt())));
          } }, { key: "toI128", value: function() {
            this._sizeCheck(128);
            var E = this.int.toBigInt(), R = BigInt.asIntN(64, E >> 64n), k = BigInt.asUintN(64, E);
            return a.default.ScVal.scvI128(new a.default.Int128Parts({ hi: new a.default.Int64(R), lo: new a.default.Uint64(k) }));
          } }, { key: "toU128", value: function() {
            this._sizeCheck(128);
            var E = this.int.toBigInt();
            return a.default.ScVal.scvU128(new a.default.UInt128Parts({ hi: new a.default.Uint64(BigInt.asUintN(64, E >> 64n)), lo: new a.default.Uint64(BigInt.asUintN(64, E)) }));
          } }, { key: "toI256", value: function() {
            var E = this.int.toBigInt(), R = BigInt.asIntN(64, E >> 192n), k = BigInt.asUintN(64, E >> 128n), w = BigInt.asUintN(64, E >> 64n), F = BigInt.asUintN(64, E);
            return a.default.ScVal.scvI256(new a.default.Int256Parts({ hiHi: new a.default.Int64(R), hiLo: new a.default.Uint64(k), loHi: new a.default.Uint64(w), loLo: new a.default.Uint64(F) }));
          } }, { key: "toU256", value: function() {
            var E = this.int.toBigInt(), R = BigInt.asUintN(64, E >> 192n), k = BigInt.asUintN(64, E >> 128n), w = BigInt.asUintN(64, E >> 64n), F = BigInt.asUintN(64, E);
            return a.default.ScVal.scvU256(new a.default.UInt256Parts({ hiHi: new a.default.Uint64(R), hiLo: new a.default.Uint64(k), loHi: new a.default.Uint64(w), loLo: new a.default.Uint64(F) }));
          } }, { key: "toScVal", value: function() {
            switch (this.type) {
              case "i64":
                return this.toI64();
              case "i128":
                return this.toI128();
              case "i256":
                return this.toI256();
              case "u64":
                return this.toU64();
              case "u128":
                return this.toU128();
              case "u256":
                return this.toU256();
              default:
                throw TypeError("invalid type: ".concat(this.type));
            }
          } }, { key: "valueOf", value: function() {
            return this.int.valueOf();
          } }, { key: "toString", value: function() {
            return this.int.toString();
          } }, { key: "toJSON", value: function() {
            return { value: this.toBigInt().toString(), type: this.type };
          } }, { key: "_sizeCheck", value: function(E) {
            if (this.int.size > E) throw RangeError("value too large for ".concat(E, " bits (").concat(this.type, ")"));
          } }], [{ key: "isType", value: function(E) {
            switch (E) {
              case "i64":
              case "i128":
              case "i256":
              case "u64":
              case "u128":
              case "u256":
                return true;
              default:
                return false;
            }
          } }, { key: "getType", value: function(E) {
            return E.slice(3).toLowerCase();
          } }]);
        }();
      }, 7452: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.Contract = void 0;
        var c, h = u(1180), f = u(7237), r = (c = u(1918)) && c.__esModule ? c : { default: c }, m = u(7120);
        function g(d) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, g(d);
        }
        function a(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, l(E.key), E);
          }
        }
        function l(d) {
          var b = function(S, E) {
            if (g(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (g(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return g(b) == "symbol" ? b : b + "";
        }
        o.Contract = function() {
          return function(d, b, S) {
            return b && a(d.prototype, b), Object.defineProperty(d, "prototype", { writable: false }), d;
          }(function d(b) {
            (function(S, E) {
              if (!(S instanceof E)) throw new TypeError("Cannot call a class as a function");
            })(this, d);
            try {
              this._id = m.StrKey.decodeContract(b);
            } catch {
              throw new Error("Invalid contract ID: ".concat(b));
            }
          }, [{ key: "contractId", value: function() {
            return m.StrKey.encodeContract(this._id);
          } }, { key: "toString", value: function() {
            return this.contractId();
          } }, { key: "address", value: function() {
            return h.Address.contract(this._id);
          } }, { key: "call", value: function(d) {
            for (var b = arguments.length, S = new Array(b > 1 ? b - 1 : 0), E = 1; E < b; E++) S[E - 1] = arguments[E];
            return f.Operation.invokeContractFunction({ contract: this.address().toString(), function: d, args: S });
          } }, { key: "getFootprint", value: function() {
            return r.default.LedgerKey.contractData(new r.default.LedgerKeyContractData({ contract: this.address().toScAddress(), key: r.default.ScVal.scvLedgerKeyContractInstance(), durability: r.default.ContractDataDurability.persistent() }));
          } }]);
        }();
      }, 7505: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.beginSponsoringFutureReserves = function() {
          var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!f.StrKey.isValidEd25519PublicKey(m.sponsoredId)) throw new Error("sponsoredId is invalid");
          var g = new h.default.BeginSponsoringFutureReservesOp({ sponsoredId: r.Keypair.fromPublicKey(m.sponsoredId).xdrAccountId() }), a = {};
          return a.body = h.default.OperationBody.beginSponsoringFutureReserves(g), this.setSourceAccount(a, m), new h.default.Operation(a);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(7120), r = u(6691);
      }, 7510: (t) => {
        t.exports = function() {
          for (var u = {}, c = 0; c < arguments.length; c++) {
            var h = arguments[c];
            for (var f in h) o.call(h, f) && (u[f] = h[f]);
          }
          return u;
        };
        var o = Object.prototype.hasOwnProperty;
      }, 7511: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), Object.defineProperty(o, "accountMerge", { enumerable: true, get: function() {
          return f.accountMerge;
        } }), Object.defineProperty(o, "allowTrust", { enumerable: true, get: function() {
          return r.allowTrust;
        } }), Object.defineProperty(o, "beginSponsoringFutureReserves", { enumerable: true, get: function() {
          return q.beginSponsoringFutureReserves;
        } }), Object.defineProperty(o, "bumpSequence", { enumerable: true, get: function() {
          return m.bumpSequence;
        } }), Object.defineProperty(o, "changeTrust", { enumerable: true, get: function() {
          return g.changeTrust;
        } }), Object.defineProperty(o, "claimClaimableBalance", { enumerable: true, get: function() {
          return d.claimClaimableBalance;
        } }), Object.defineProperty(o, "clawback", { enumerable: true, get: function() {
          return _.clawback;
        } }), Object.defineProperty(o, "clawbackClaimableBalance", { enumerable: true, get: function() {
          return b.clawbackClaimableBalance;
        } }), Object.defineProperty(o, "createAccount", { enumerable: true, get: function() {
          return a.createAccount;
        } }), Object.defineProperty(o, "createClaimableBalance", { enumerable: true, get: function() {
          return l.createClaimableBalance;
        } }), Object.defineProperty(o, "createCustomContract", { enumerable: true, get: function() {
          return z.createCustomContract;
        } }), Object.defineProperty(o, "createPassiveSellOffer", { enumerable: true, get: function() {
          return h.createPassiveSellOffer;
        } }), Object.defineProperty(o, "createStellarAssetContract", { enumerable: true, get: function() {
          return z.createStellarAssetContract;
        } }), Object.defineProperty(o, "endSponsoringFutureReserves", { enumerable: true, get: function() {
          return D.endSponsoringFutureReserves;
        } }), Object.defineProperty(o, "extendFootprintTtl", { enumerable: true, get: function() {
          return Y.extendFootprintTtl;
        } }), Object.defineProperty(o, "inflation", { enumerable: true, get: function() {
          return S.inflation;
        } }), Object.defineProperty(o, "invokeContractFunction", { enumerable: true, get: function() {
          return z.invokeContractFunction;
        } }), Object.defineProperty(o, "invokeHostFunction", { enumerable: true, get: function() {
          return z.invokeHostFunction;
        } }), Object.defineProperty(o, "liquidityPoolDeposit", { enumerable: true, get: function() {
          return L.liquidityPoolDeposit;
        } }), Object.defineProperty(o, "liquidityPoolWithdraw", { enumerable: true, get: function() {
          return j.liquidityPoolWithdraw;
        } }), Object.defineProperty(o, "manageBuyOffer", { enumerable: true, get: function() {
          return R.manageBuyOffer;
        } }), Object.defineProperty(o, "manageData", { enumerable: true, get: function() {
          return E.manageData;
        } }), Object.defineProperty(o, "manageSellOffer", { enumerable: true, get: function() {
          return c.manageSellOffer;
        } }), Object.defineProperty(o, "pathPaymentStrictReceive", { enumerable: true, get: function() {
          return k.pathPaymentStrictReceive;
        } }), Object.defineProperty(o, "pathPaymentStrictSend", { enumerable: true, get: function() {
          return w.pathPaymentStrictSend;
        } }), Object.defineProperty(o, "payment", { enumerable: true, get: function() {
          return F.payment;
        } }), Object.defineProperty(o, "restoreFootprint", { enumerable: true, get: function() {
          return te.restoreFootprint;
        } }), Object.defineProperty(o, "revokeAccountSponsorship", { enumerable: true, get: function() {
          return H.revokeAccountSponsorship;
        } }), Object.defineProperty(o, "revokeClaimableBalanceSponsorship", { enumerable: true, get: function() {
          return H.revokeClaimableBalanceSponsorship;
        } }), Object.defineProperty(o, "revokeDataSponsorship", { enumerable: true, get: function() {
          return H.revokeDataSponsorship;
        } }), Object.defineProperty(o, "revokeLiquidityPoolSponsorship", { enumerable: true, get: function() {
          return H.revokeLiquidityPoolSponsorship;
        } }), Object.defineProperty(o, "revokeOfferSponsorship", { enumerable: true, get: function() {
          return H.revokeOfferSponsorship;
        } }), Object.defineProperty(o, "revokeSignerSponsorship", { enumerable: true, get: function() {
          return H.revokeSignerSponsorship;
        } }), Object.defineProperty(o, "revokeTrustlineSponsorship", { enumerable: true, get: function() {
          return H.revokeTrustlineSponsorship;
        } }), Object.defineProperty(o, "setOptions", { enumerable: true, get: function() {
          return I.setOptions;
        } }), Object.defineProperty(o, "setTrustLineFlags", { enumerable: true, get: function() {
          return T.setTrustLineFlags;
        } }), Object.defineProperty(o, "uploadContractWasm", { enumerable: true, get: function() {
          return z.uploadContractWasm;
        } });
        var c = u(862), h = u(9073), f = u(4295), r = u(3683), m = u(6183), g = u(2810), a = u(2115), l = u(4831), d = u(7239), b = u(2203), S = u(7421), E = u(1411), R = u(1922), k = u(2075), w = u(3874), F = u(3533), I = u(2018), q = u(7505), D = u(721), H = u(7790), _ = u(7651), T = u(1804), L = u(9845), j = u(4737), z = u(4403), Y = u(8752), te = u(149);
      }, 7526: (t, o) => {
        o.byteLength = function(a) {
          var l = m(a), d = l[0], b = l[1];
          return 3 * (d + b) / 4 - b;
        }, o.toByteArray = function(a) {
          var l, d, b = m(a), S = b[0], E = b[1], R = new h(function(F, I, q) {
            return 3 * (I + q) / 4 - q;
          }(0, S, E)), k = 0, w = E > 0 ? S - 4 : S;
          for (d = 0; d < w; d += 4) l = c[a.charCodeAt(d)] << 18 | c[a.charCodeAt(d + 1)] << 12 | c[a.charCodeAt(d + 2)] << 6 | c[a.charCodeAt(d + 3)], R[k++] = l >> 16 & 255, R[k++] = l >> 8 & 255, R[k++] = 255 & l;
          return E === 2 && (l = c[a.charCodeAt(d)] << 2 | c[a.charCodeAt(d + 1)] >> 4, R[k++] = 255 & l), E === 1 && (l = c[a.charCodeAt(d)] << 10 | c[a.charCodeAt(d + 1)] << 4 | c[a.charCodeAt(d + 2)] >> 2, R[k++] = l >> 8 & 255, R[k++] = 255 & l), R;
        }, o.fromByteArray = function(a) {
          for (var l, d = a.length, b = d % 3, S = [], E = 16383, R = 0, k = d - b; R < k; R += E) S.push(g(a, R, R + E > k ? k : R + E));
          return b === 1 ? (l = a[d - 1], S.push(u[l >> 2] + u[l << 4 & 63] + "==")) : b === 2 && (l = (a[d - 2] << 8) + a[d - 1], S.push(u[l >> 10] + u[l >> 4 & 63] + u[l << 2 & 63] + "=")), S.join("");
        };
        for (var u = [], c = [], h = typeof Uint8Array < "u" ? Uint8Array : Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = 0; r < 64; ++r) u[r] = f[r], c[f.charCodeAt(r)] = r;
        function m(a) {
          var l = a.length;
          if (l % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var d = a.indexOf("=");
          return d === -1 && (d = l), [d, d === l ? 0 : 4 - d % 4];
        }
        function g(a, l, d) {
          for (var b, S, E = [], R = l; R < d; R += 3) b = (a[R] << 16 & 16711680) + (a[R + 1] << 8 & 65280) + (255 & a[R + 2]), E.push(u[(S = b) >> 18 & 63] + u[S >> 12 & 63] + u[S >> 6 & 63] + u[63 & S]);
          return E.join("");
        }
        c[45] = 62, c[95] = 63;
      }, 7600: (t, o, u) => {
        u.r(o), u.d(o, { Api: () => {
        }, FEDERATION_RESPONSE_MAX_SIZE: () => F, Server: () => I });
        var c = u(356), h = u(4193), f = u.n(h), r = u(8732), m = u(5976), g = u(3898), a = u(9983);
        function l(q) {
          return l = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
            return typeof D;
          } : function(D) {
            return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
          }, l(q);
        }
        function d(q, D) {
          return function(H) {
            if (Array.isArray(H)) return H;
          }(q) || function(H, _) {
            var T = H == null ? null : typeof Symbol < "u" && H[Symbol.iterator] || H["@@iterator"];
            if (T != null) {
              var L, j, z, Y, te = [], G = true, K = false;
              try {
                if (z = (T = T.call(H)).next, _ !== 0) for (; !(G = (L = z.call(T)).done) && (te.push(L.value), te.length !== _); G = true) ;
              } catch (J) {
                K = true, j = J;
              } finally {
                try {
                  if (!G && T.return != null && (Y = T.return(), Object(Y) !== Y)) return;
                } finally {
                  if (K) throw j;
                }
              }
              return te;
            }
          }(q, D) || function(H, _) {
            if (H) {
              if (typeof H == "string") return b(H, _);
              var T = {}.toString.call(H).slice(8, -1);
              return T === "Object" && H.constructor && (T = H.constructor.name), T === "Map" || T === "Set" ? Array.from(H) : T === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(T) ? b(H, _) : void 0;
            }
          }(q, D) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function b(q, D) {
          (D == null || D > q.length) && (D = q.length);
          for (var H = 0, _ = Array(D); H < D; H++) _[H] = q[H];
          return _;
        }
        function S() {
          S = function() {
            return D;
          };
          var q, D = {}, H = Object.prototype, _ = H.hasOwnProperty, T = Object.defineProperty || function(ee, P, x) {
            ee[P] = x.value;
          }, L = typeof Symbol == "function" ? Symbol : {}, j = L.iterator || "@@iterator", z = L.asyncIterator || "@@asyncIterator", Y = L.toStringTag || "@@toStringTag";
          function te(ee, P, x) {
            return Object.defineProperty(ee, P, { value: x, enumerable: true, configurable: true, writable: true }), ee[P];
          }
          try {
            te({}, "");
          } catch {
            te = function(P, x, O) {
              return P[x] = O;
            };
          }
          function G(ee, P, x, O) {
            var V = P && P.prototype instanceof oe ? P : oe, N = Object.create(V.prototype), C = new Be(O || []);
            return T(N, "_invoke", { value: Oe(ee, x, C) }), N;
          }
          function K(ee, P, x) {
            try {
              return { type: "normal", arg: ee.call(P, x) };
            } catch (O) {
              return { type: "throw", arg: O };
            }
          }
          D.wrap = G;
          var J = "suspendedStart", B = "suspendedYield", Z = "executing", ie = "completed", $ = {};
          function oe() {
          }
          function ce() {
          }
          function ye() {
          }
          var ae = {};
          te(ae, j, function() {
            return this;
          });
          var ue = Object.getPrototypeOf, ne = ue && ue(ue(Qe([])));
          ne && ne !== H && _.call(ne, j) && (ae = ne);
          var ge = ye.prototype = oe.prototype = Object.create(ae);
          function Te(ee) {
            ["next", "throw", "return"].forEach(function(P) {
              te(ee, P, function(x) {
                return this._invoke(P, x);
              });
            });
          }
          function pe(ee, P) {
            function x(V, N, C, p) {
              var A = K(ee[V], ee, N);
              if (A.type !== "throw") {
                var U = A.arg, Q = U.value;
                return Q && l(Q) == "object" && _.call(Q, "__await") ? P.resolve(Q.__await).then(function(se) {
                  x("next", se, C, p);
                }, function(se) {
                  x("throw", se, C, p);
                }) : P.resolve(Q).then(function(se) {
                  U.value = se, C(U);
                }, function(se) {
                  return x("throw", se, C, p);
                });
              }
              p(A.arg);
            }
            var O;
            T(this, "_invoke", { value: function(V, N) {
              function C() {
                return new P(function(p, A) {
                  x(V, N, p, A);
                });
              }
              return O = O ? O.then(C, C) : C();
            } });
          }
          function Oe(ee, P, x) {
            var O = J;
            return function(V, N) {
              if (O === Z) throw Error("Generator is already running");
              if (O === ie) {
                if (V === "throw") throw N;
                return { value: q, done: true };
              }
              for (x.method = V, x.arg = N; ; ) {
                var C = x.delegate;
                if (C) {
                  var p = xe(C, x);
                  if (p) {
                    if (p === $) continue;
                    return p;
                  }
                }
                if (x.method === "next") x.sent = x._sent = x.arg;
                else if (x.method === "throw") {
                  if (O === J) throw O = ie, x.arg;
                  x.dispatchException(x.arg);
                } else x.method === "return" && x.abrupt("return", x.arg);
                O = Z;
                var A = K(ee, P, x);
                if (A.type === "normal") {
                  if (O = x.done ? ie : B, A.arg === $) continue;
                  return { value: A.arg, done: x.done };
                }
                A.type === "throw" && (O = ie, x.method = "throw", x.arg = A.arg);
              }
            };
          }
          function xe(ee, P) {
            var x = P.method, O = ee.iterator[x];
            if (O === q) return P.delegate = null, x === "throw" && ee.iterator.return && (P.method = "return", P.arg = q, xe(ee, P), P.method === "throw") || x !== "return" && (P.method = "throw", P.arg = new TypeError("The iterator does not provide a '" + x + "' method")), $;
            var V = K(O, ee.iterator, P.arg);
            if (V.type === "throw") return P.method = "throw", P.arg = V.arg, P.delegate = null, $;
            var N = V.arg;
            return N ? N.done ? (P[ee.resultName] = N.value, P.next = ee.nextLoc, P.method !== "return" && (P.method = "next", P.arg = q), P.delegate = null, $) : N : (P.method = "throw", P.arg = new TypeError("iterator result is not an object"), P.delegate = null, $);
          }
          function Ve(ee) {
            var P = { tryLoc: ee[0] };
            1 in ee && (P.catchLoc = ee[1]), 2 in ee && (P.finallyLoc = ee[2], P.afterLoc = ee[3]), this.tryEntries.push(P);
          }
          function _e(ee) {
            var P = ee.completion || {};
            P.type = "normal", delete P.arg, ee.completion = P;
          }
          function Be(ee) {
            this.tryEntries = [{ tryLoc: "root" }], ee.forEach(Ve, this), this.reset(true);
          }
          function Qe(ee) {
            if (ee || ee === "") {
              var P = ee[j];
              if (P) return P.call(ee);
              if (typeof ee.next == "function") return ee;
              if (!isNaN(ee.length)) {
                var x = -1, O = function V() {
                  for (; ++x < ee.length; ) if (_.call(ee, x)) return V.value = ee[x], V.done = false, V;
                  return V.value = q, V.done = true, V;
                };
                return O.next = O;
              }
            }
            throw new TypeError(l(ee) + " is not iterable");
          }
          return ce.prototype = ye, T(ge, "constructor", { value: ye, configurable: true }), T(ye, "constructor", { value: ce, configurable: true }), ce.displayName = te(ye, Y, "GeneratorFunction"), D.isGeneratorFunction = function(ee) {
            var P = typeof ee == "function" && ee.constructor;
            return !!P && (P === ce || (P.displayName || P.name) === "GeneratorFunction");
          }, D.mark = function(ee) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(ee, ye) : (ee.__proto__ = ye, te(ee, Y, "GeneratorFunction")), ee.prototype = Object.create(ge), ee;
          }, D.awrap = function(ee) {
            return { __await: ee };
          }, Te(pe.prototype), te(pe.prototype, z, function() {
            return this;
          }), D.AsyncIterator = pe, D.async = function(ee, P, x, O, V) {
            V === void 0 && (V = Promise);
            var N = new pe(G(ee, P, x, O), V);
            return D.isGeneratorFunction(P) ? N : N.next().then(function(C) {
              return C.done ? C.value : N.next();
            });
          }, Te(ge), te(ge, Y, "Generator"), te(ge, j, function() {
            return this;
          }), te(ge, "toString", function() {
            return "[object Generator]";
          }), D.keys = function(ee) {
            var P = Object(ee), x = [];
            for (var O in P) x.push(O);
            return x.reverse(), function V() {
              for (; x.length; ) {
                var N = x.pop();
                if (N in P) return V.value = N, V.done = false, V;
              }
              return V.done = true, V;
            };
          }, D.values = Qe, Be.prototype = { constructor: Be, reset: function(ee) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = q, this.done = false, this.delegate = null, this.method = "next", this.arg = q, this.tryEntries.forEach(_e), !ee) for (var P in this) P.charAt(0) === "t" && _.call(this, P) && !isNaN(+P.slice(1)) && (this[P] = q);
          }, stop: function() {
            this.done = true;
            var ee = this.tryEntries[0].completion;
            if (ee.type === "throw") throw ee.arg;
            return this.rval;
          }, dispatchException: function(ee) {
            if (this.done) throw ee;
            var P = this;
            function x(A, U) {
              return N.type = "throw", N.arg = ee, P.next = A, U && (P.method = "next", P.arg = q), !!U;
            }
            for (var O = this.tryEntries.length - 1; O >= 0; --O) {
              var V = this.tryEntries[O], N = V.completion;
              if (V.tryLoc === "root") return x("end");
              if (V.tryLoc <= this.prev) {
                var C = _.call(V, "catchLoc"), p = _.call(V, "finallyLoc");
                if (C && p) {
                  if (this.prev < V.catchLoc) return x(V.catchLoc, true);
                  if (this.prev < V.finallyLoc) return x(V.finallyLoc);
                } else if (C) {
                  if (this.prev < V.catchLoc) return x(V.catchLoc, true);
                } else {
                  if (!p) throw Error("try statement without catch or finally");
                  if (this.prev < V.finallyLoc) return x(V.finallyLoc);
                }
              }
            }
          }, abrupt: function(ee, P) {
            for (var x = this.tryEntries.length - 1; x >= 0; --x) {
              var O = this.tryEntries[x];
              if (O.tryLoc <= this.prev && _.call(O, "finallyLoc") && this.prev < O.finallyLoc) {
                var V = O;
                break;
              }
            }
            V && (ee === "break" || ee === "continue") && V.tryLoc <= P && P <= V.finallyLoc && (V = null);
            var N = V ? V.completion : {};
            return N.type = ee, N.arg = P, V ? (this.method = "next", this.next = V.finallyLoc, $) : this.complete(N);
          }, complete: function(ee, P) {
            if (ee.type === "throw") throw ee.arg;
            return ee.type === "break" || ee.type === "continue" ? this.next = ee.arg : ee.type === "return" ? (this.rval = this.arg = ee.arg, this.method = "return", this.next = "end") : ee.type === "normal" && P && (this.next = P), $;
          }, finish: function(ee) {
            for (var P = this.tryEntries.length - 1; P >= 0; --P) {
              var x = this.tryEntries[P];
              if (x.finallyLoc === ee) return this.complete(x.completion, x.afterLoc), _e(x), $;
            }
          }, catch: function(ee) {
            for (var P = this.tryEntries.length - 1; P >= 0; --P) {
              var x = this.tryEntries[P];
              if (x.tryLoc === ee) {
                var O = x.completion;
                if (O.type === "throw") {
                  var V = O.arg;
                  _e(x);
                }
                return V;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(ee, P, x) {
            return this.delegate = { iterator: Qe(ee), resultName: P, nextLoc: x }, this.method === "next" && (this.arg = q), $;
          } }, D;
        }
        function E(q, D, H, _, T, L, j) {
          try {
            var z = q[L](j), Y = z.value;
          } catch (te) {
            return void H(te);
          }
          z.done ? D(Y) : Promise.resolve(Y).then(_, T);
        }
        function R(q) {
          return function() {
            var D = this, H = arguments;
            return new Promise(function(_, T) {
              var L = q.apply(D, H);
              function j(Y) {
                E(L, _, T, j, z, "next", Y);
              }
              function z(Y) {
                E(L, _, T, j, z, "throw", Y);
              }
              j(void 0);
            });
          };
        }
        function k(q, D) {
          for (var H = 0; H < D.length; H++) {
            var _ = D[H];
            _.enumerable = _.enumerable || false, _.configurable = true, "value" in _ && (_.writable = true), Object.defineProperty(q, w(_.key), _);
          }
        }
        function w(q) {
          var D = function(H, _) {
            if (l(H) != "object" || !H) return H;
            var T = H[Symbol.toPrimitive];
            if (T !== void 0) {
              var L = T.call(H, _);
              if (l(L) != "object") return L;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(H);
          }(q, "string");
          return l(D) == "symbol" ? D : D + "";
        }
        var F = 102400, I = function() {
          function q(G, K) {
            var J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            (function(Z, ie) {
              if (!(Z instanceof ie)) throw new TypeError("Cannot call a class as a function");
            })(this, q), this.serverURL = f()(G), this.domain = K;
            var B = J.allowHttp === void 0 ? r.T.isAllowHttp() : J.allowHttp;
            if (this.timeout = J.timeout === void 0 ? r.T.getTimeout() : J.timeout, this.serverURL.protocol() !== "https" && !B) throw new Error("Cannot connect to insecure federation server");
          }
          return D = q, H = [{ key: "resolveAddress", value: (te = R(S().mark(function G(K) {
            var J, B;
            return S().wrap(function(Z) {
              for (; ; ) switch (Z.prev = Z.next) {
                case 0:
                  if (J = K, !(K.indexOf("*") < 0)) {
                    Z.next = 5;
                    break;
                  }
                  if (this.domain) {
                    Z.next = 4;
                    break;
                  }
                  return Z.abrupt("return", Promise.reject(new Error("Unknown domain. Make sure `address` contains a domain (ex. `bob*stellar.org`) or pass `domain` parameter when instantiating the server object.")));
                case 4:
                  J = "".concat(K, "*").concat(this.domain);
                case 5:
                  return B = this.serverURL.query({ type: "name", q: J }), Z.abrupt("return", this._sendRequest(B));
                case 7:
                case "end":
                  return Z.stop();
              }
            }, G, this);
          })), function(G) {
            return te.apply(this, arguments);
          }) }, { key: "resolveAccountId", value: (Y = R(S().mark(function G(K) {
            var J;
            return S().wrap(function(B) {
              for (; ; ) switch (B.prev = B.next) {
                case 0:
                  return J = this.serverURL.query({ type: "id", q: K }), B.abrupt("return", this._sendRequest(J));
                case 2:
                case "end":
                  return B.stop();
              }
            }, G, this);
          })), function(G) {
            return Y.apply(this, arguments);
          }) }, { key: "resolveTransactionId", value: (z = R(S().mark(function G(K) {
            var J;
            return S().wrap(function(B) {
              for (; ; ) switch (B.prev = B.next) {
                case 0:
                  return J = this.serverURL.query({ type: "txid", q: K }), B.abrupt("return", this._sendRequest(J));
                case 2:
                case "end":
                  return B.stop();
              }
            }, G, this);
          })), function(G) {
            return z.apply(this, arguments);
          }) }, { key: "_sendRequest", value: (j = R(S().mark(function G(K) {
            var J;
            return S().wrap(function(B) {
              for (; ; ) switch (B.prev = B.next) {
                case 0:
                  return J = this.timeout, B.abrupt("return", a.ok.get(K.toString(), { maxContentLength: F, timeout: J }).then(function(Z) {
                    if (Z.data.memo !== void 0 && typeof Z.data.memo != "string") throw new Error("memo value should be of type string");
                    return Z.data;
                  }).catch(function(Z) {
                    if (Z instanceof Error) {
                      if (Z.message.match(/^maxContentLength size/)) throw new Error("federation response exceeds allowed size of ".concat(F));
                      return Promise.reject(Z);
                    }
                    return Promise.reject(new m.nS("Server query failed. Server responded: ".concat(Z.status, " ").concat(Z.statusText), Z.data));
                  }));
                case 2:
                case "end":
                  return B.stop();
              }
            }, G, this);
          })), function(G) {
            return j.apply(this, arguments);
          }) }], _ = [{ key: "resolve", value: (L = R(S().mark(function G(K) {
            var J, B, Z, ie, $, oe = arguments;
            return S().wrap(function(ce) {
              for (; ; ) switch (ce.prev = ce.next) {
                case 0:
                  if (J = oe.length > 1 && oe[1] !== void 0 ? oe[1] : {}, !(K.indexOf("*") < 0)) {
                    ce.next = 5;
                    break;
                  }
                  if (c.StrKey.isValidEd25519PublicKey(K)) {
                    ce.next = 4;
                    break;
                  }
                  return ce.abrupt("return", Promise.reject(new Error("Invalid Account ID")));
                case 4:
                  return ce.abrupt("return", Promise.resolve({ account_id: K }));
                case 5:
                  if (B = K.split("*"), Z = d(B, 2), ie = Z[1], B.length === 2 && ie) {
                    ce.next = 9;
                    break;
                  }
                  return ce.abrupt("return", Promise.reject(new Error("Invalid Stellar address")));
                case 9:
                  return ce.next = 11, q.createForDomain(ie, J);
                case 11:
                  return $ = ce.sent, ce.abrupt("return", $.resolveAddress(K));
                case 13:
                case "end":
                  return ce.stop();
              }
            }, G);
          })), function(G) {
            return L.apply(this, arguments);
          }) }, { key: "createForDomain", value: (T = R(S().mark(function G(K) {
            var J, B, Z = arguments;
            return S().wrap(function(ie) {
              for (; ; ) switch (ie.prev = ie.next) {
                case 0:
                  return J = Z.length > 1 && Z[1] !== void 0 ? Z[1] : {}, ie.next = 3, g.Resolver.resolve(K, J);
                case 3:
                  if ((B = ie.sent).FEDERATION_SERVER) {
                    ie.next = 6;
                    break;
                  }
                  return ie.abrupt("return", Promise.reject(new Error("stellar.toml does not contain FEDERATION_SERVER field")));
                case 6:
                  return ie.abrupt("return", new q(B.FEDERATION_SERVER, K, J));
                case 7:
                case "end":
                  return ie.stop();
              }
            }, G);
          })), function(G) {
            return T.apply(this, arguments);
          }) }], H && k(D.prototype, H), _ && k(D, _), Object.defineProperty(D, "prototype", { writable: false }), D;
          var D, H, _, T, L, j, z, Y, te;
        }();
      }, 7651: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.clawback = function(r) {
          var m = {};
          if (!this.isValidAmount(r.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          m.amount = this._toXDRAmount(r.amount), m.asset = r.asset.toXDRObject();
          try {
            m.from = (0, f.decodeAddressToMuxedAccount)(r.from);
          } catch {
            throw new Error("from address is invalid");
          }
          var g = { body: h.default.OperationBody.clawback(new h.default.ClawbackOp(m)) };
          return this.setSourceAccount(g, r), new h.default.Operation(g);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c }, f = u(6160);
      }, 7720: (t, o, u) => {
        var c = u(4765), h = Object.prototype.hasOwnProperty, f = Array.isArray, r = function() {
          for (var a = [], l = 0; l < 256; ++l) a.push("%" + ((l < 16 ? "0" : "") + l.toString(16)).toUpperCase());
          return a;
        }(), m = function(a, l) {
          for (var d = l && l.plainObjects ? { __proto__: null } : {}, b = 0; b < a.length; ++b) a[b] !== void 0 && (d[b] = a[b]);
          return d;
        }, g = 1024;
        t.exports = { arrayToObject: m, assign: function(a, l) {
          return Object.keys(l).reduce(function(d, b) {
            return d[b] = l[b], d;
          }, a);
        }, combine: function(a, l) {
          return [].concat(a, l);
        }, compact: function(a) {
          for (var l = [{ obj: { o: a }, prop: "o" }], d = [], b = 0; b < l.length; ++b) for (var S = l[b], E = S.obj[S.prop], R = Object.keys(E), k = 0; k < R.length; ++k) {
            var w = R[k], F = E[w];
            typeof F == "object" && F !== null && d.indexOf(F) === -1 && (l.push({ obj: E, prop: w }), d.push(F));
          }
          return function(I) {
            for (; I.length > 1; ) {
              var q = I.pop(), D = q.obj[q.prop];
              if (f(D)) {
                for (var H = [], _ = 0; _ < D.length; ++_) D[_] !== void 0 && H.push(D[_]);
                q.obj[q.prop] = H;
              }
            }
          }(l), a;
        }, decode: function(a, l, d) {
          var b = a.replace(/\+/g, " ");
          if (d === "iso-8859-1") return b.replace(/%[0-9a-f]{2}/gi, unescape);
          try {
            return decodeURIComponent(b);
          } catch {
            return b;
          }
        }, encode: function(a, l, d, b, S) {
          if (a.length === 0) return a;
          var E = a;
          if (typeof a == "symbol" ? E = Symbol.prototype.toString.call(a) : typeof a != "string" && (E = String(a)), d === "iso-8859-1") return escape(E).replace(/%u[0-9a-f]{4}/gi, function(D) {
            return "%26%23" + parseInt(D.slice(2), 16) + "%3B";
          });
          for (var R = "", k = 0; k < E.length; k += g) {
            for (var w = E.length >= g ? E.slice(k, k + g) : E, F = [], I = 0; I < w.length; ++I) {
              var q = w.charCodeAt(I);
              q === 45 || q === 46 || q === 95 || q === 126 || q >= 48 && q <= 57 || q >= 65 && q <= 90 || q >= 97 && q <= 122 || S === c.RFC1738 && (q === 40 || q === 41) ? F[F.length] = w.charAt(I) : q < 128 ? F[F.length] = r[q] : q < 2048 ? F[F.length] = r[192 | q >> 6] + r[128 | 63 & q] : q < 55296 || q >= 57344 ? F[F.length] = r[224 | q >> 12] + r[128 | q >> 6 & 63] + r[128 | 63 & q] : (I += 1, q = 65536 + ((1023 & q) << 10 | 1023 & w.charCodeAt(I)), F[F.length] = r[240 | q >> 18] + r[128 | q >> 12 & 63] + r[128 | q >> 6 & 63] + r[128 | 63 & q]);
            }
            R += F.join("");
          }
          return R;
        }, isBuffer: function(a) {
          return !(!a || typeof a != "object") && !!(a.constructor && a.constructor.isBuffer && a.constructor.isBuffer(a));
        }, isRegExp: function(a) {
          return Object.prototype.toString.call(a) === "[object RegExp]";
        }, maybeMap: function(a, l) {
          if (f(a)) {
            for (var d = [], b = 0; b < a.length; b += 1) d.push(l(a[b]));
            return d;
          }
          return l(a);
        }, merge: function a(l, d, b) {
          if (!d) return l;
          if (typeof d != "object" && typeof d != "function") {
            if (f(l)) l.push(d);
            else {
              if (!l || typeof l != "object") return [l, d];
              (b && (b.plainObjects || b.allowPrototypes) || !h.call(Object.prototype, d)) && (l[d] = true);
            }
            return l;
          }
          if (!l || typeof l != "object") return [l].concat(d);
          var S = l;
          return f(l) && !f(d) && (S = m(l, b)), f(l) && f(d) ? (d.forEach(function(E, R) {
            if (h.call(l, R)) {
              var k = l[R];
              k && typeof k == "object" && E && typeof E == "object" ? l[R] = a(k, E, b) : l.push(E);
            } else l[R] = E;
          }), l) : Object.keys(d).reduce(function(E, R) {
            var k = d[R];
            return h.call(E, R) ? E[R] = a(E[R], k, b) : E[R] = k, E;
          }, S);
        } };
      }, 7758: (t, o, u) => {
        var c, h = u(6048).F, f = h.ERR_MISSING_ARGS, r = h.ERR_STREAM_DESTROYED;
        function m(l) {
          if (l) throw l;
        }
        function g(l) {
          l();
        }
        function a(l, d) {
          return l.pipe(d);
        }
        t.exports = function() {
          for (var l = arguments.length, d = new Array(l), b = 0; b < l; b++) d[b] = arguments[b];
          var S, E = function(k) {
            return k.length ? typeof k[k.length - 1] != "function" ? m : k.pop() : m;
          }(d);
          if (Array.isArray(d[0]) && (d = d[0]), d.length < 2) throw new f("streams");
          var R = d.map(function(k, w) {
            var F = w < d.length - 1;
            return function(I, q, D, H) {
              H = /* @__PURE__ */ function(L) {
                var j = false;
                return function() {
                  j || (j = true, L.apply(void 0, arguments));
                };
              }(H);
              var _ = false;
              I.on("close", function() {
                _ = true;
              }), c === void 0 && (c = u(6238)), c(I, { readable: q, writable: D }, function(L) {
                if (L) return H(L);
                _ = true, H();
              });
              var T = false;
              return function(L) {
                if (!_ && !T) return T = true, function(j) {
                  return j.setHeader && typeof j.abort == "function";
                }(I) ? I.abort() : typeof I.destroy == "function" ? I.destroy() : void H(L || new r("pipe"));
              };
            }(k, F, w > 0, function(I) {
              S || (S = I), I && R.forEach(g), F || (R.forEach(g), E(S));
            });
          });
          return d.reduce(a);
        };
      }, 7790: (t, o, u) => {
        var c = u(8287).Buffer;
        Object.defineProperty(o, "__esModule", { value: true }), o.revokeAccountSponsorship = function() {
          var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!r.StrKey.isValidEd25519PublicKey(l.account)) throw new Error("account is invalid");
          var d = f.default.LedgerKey.account(new f.default.LedgerKeyAccount({ accountId: m.Keypair.fromPublicKey(l.account).xdrAccountId() })), b = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(d), S = {};
          return S.body = f.default.OperationBody.revokeSponsorship(b), this.setSourceAccount(S, l), new f.default.Operation(S);
        }, o.revokeClaimableBalanceSponsorship = function() {
          var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (typeof l.balanceId != "string") throw new Error("balanceId is invalid");
          var d = f.default.LedgerKey.claimableBalance(new f.default.LedgerKeyClaimableBalance({ balanceId: f.default.ClaimableBalanceId.fromXDR(l.balanceId, "hex") })), b = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(d), S = {};
          return S.body = f.default.OperationBody.revokeSponsorship(b), this.setSourceAccount(S, l), new f.default.Operation(S);
        }, o.revokeDataSponsorship = function() {
          var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!r.StrKey.isValidEd25519PublicKey(l.account)) throw new Error("account is invalid");
          if (typeof l.name != "string" || l.name.length > 64) throw new Error("name must be a string, up to 64 characters");
          var d = f.default.LedgerKey.data(new f.default.LedgerKeyData({ accountId: m.Keypair.fromPublicKey(l.account).xdrAccountId(), dataName: l.name })), b = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(d), S = {};
          return S.body = f.default.OperationBody.revokeSponsorship(b), this.setSourceAccount(S, l), new f.default.Operation(S);
        }, o.revokeLiquidityPoolSponsorship = function() {
          var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (typeof l.liquidityPoolId != "string") throw new Error("liquidityPoolId is invalid");
          var d = f.default.LedgerKey.liquidityPool(new f.default.LedgerKeyLiquidityPool({ liquidityPoolId: f.default.PoolId.fromXDR(l.liquidityPoolId, "hex") })), b = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(d), S = { body: f.default.OperationBody.revokeSponsorship(b) };
          return this.setSourceAccount(S, l), new f.default.Operation(S);
        }, o.revokeOfferSponsorship = function() {
          var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!r.StrKey.isValidEd25519PublicKey(l.seller)) throw new Error("seller is invalid");
          if (typeof l.offerId != "string") throw new Error("offerId is invalid");
          var d = f.default.LedgerKey.offer(new f.default.LedgerKeyOffer({ sellerId: m.Keypair.fromPublicKey(l.seller).xdrAccountId(), offerId: f.default.Int64.fromString(l.offerId) })), b = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(d), S = {};
          return S.body = f.default.OperationBody.revokeSponsorship(b), this.setSourceAccount(S, l), new f.default.Operation(S);
        }, o.revokeSignerSponsorship = function() {
          var l, d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!r.StrKey.isValidEd25519PublicKey(d.account)) throw new Error("account is invalid");
          if (d.signer.ed25519PublicKey) {
            if (!r.StrKey.isValidEd25519PublicKey(d.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
            var b = r.StrKey.decodeEd25519PublicKey(d.signer.ed25519PublicKey);
            l = new f.default.SignerKey.signerKeyTypeEd25519(b);
          } else if (d.signer.preAuthTx) {
            var S;
            if (S = typeof d.signer.preAuthTx == "string" ? c.from(d.signer.preAuthTx, "hex") : d.signer.preAuthTx, !c.isBuffer(S) || S.length !== 32) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
            l = new f.default.SignerKey.signerKeyTypePreAuthTx(S);
          } else {
            if (!d.signer.sha256Hash) throw new Error("signer is invalid");
            var E;
            if (E = typeof d.signer.sha256Hash == "string" ? c.from(d.signer.sha256Hash, "hex") : d.signer.sha256Hash, !c.isBuffer(E) || E.length !== 32) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
            l = new f.default.SignerKey.signerKeyTypeHashX(E);
          }
          var R = new f.default.RevokeSponsorshipOpSigner({ accountId: m.Keypair.fromPublicKey(d.account).xdrAccountId(), signerKey: l }), k = f.default.RevokeSponsorshipOp.revokeSponsorshipSigner(R), w = {};
          return w.body = f.default.OperationBody.revokeSponsorship(k), this.setSourceAccount(w, d), new f.default.Operation(w);
        }, o.revokeTrustlineSponsorship = function() {
          var l, d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!r.StrKey.isValidEd25519PublicKey(d.account)) throw new Error("account is invalid");
          if (d.asset instanceof g.Asset) l = d.asset.toTrustLineXDRObject();
          else {
            if (!(d.asset instanceof a.LiquidityPoolId)) throw new TypeError("asset must be an Asset or LiquidityPoolId");
            l = d.asset.toXDRObject();
          }
          var b = f.default.LedgerKey.trustline(new f.default.LedgerKeyTrustLine({ accountId: m.Keypair.fromPublicKey(d.account).xdrAccountId(), asset: l })), S = f.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(b), E = {};
          return E.body = f.default.OperationBody.revokeSponsorship(S), this.setSourceAccount(E, d), new f.default.Operation(E);
        };
        var h, f = (h = u(1918)) && h.__esModule ? h : { default: h }, r = u(7120), m = u(6691), g = u(1764), a = u(9353);
      }, 7816: (t, o, u) => {
        var c = u(6698), h = u(392), f = u(2861).Buffer, r = [1518500249, 1859775393, -1894007588, -899497514], m = new Array(80);
        function g() {
          this.init(), this._w = m, h.call(this, 64, 56);
        }
        function a(d) {
          return d << 30 | d >>> 2;
        }
        function l(d, b, S, E) {
          return d === 0 ? b & S | ~b & E : d === 2 ? b & S | b & E | S & E : b ^ S ^ E;
        }
        c(g, h), g.prototype.init = function() {
          return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
        }, g.prototype._update = function(d) {
          for (var b, S = this._w, E = 0 | this._a, R = 0 | this._b, k = 0 | this._c, w = 0 | this._d, F = 0 | this._e, I = 0; I < 16; ++I) S[I] = d.readInt32BE(4 * I);
          for (; I < 80; ++I) S[I] = S[I - 3] ^ S[I - 8] ^ S[I - 14] ^ S[I - 16];
          for (var q = 0; q < 80; ++q) {
            var D = ~~(q / 20), H = 0 | ((b = E) << 5 | b >>> 27) + l(D, R, k, w) + F + S[q] + r[D];
            F = w, w = k, k = a(R), R = E, E = H;
          }
          this._a = E + this._a | 0, this._b = R + this._b | 0, this._c = k + this._c | 0, this._d = w + this._d | 0, this._e = F + this._e | 0;
        }, g.prototype._hash = function() {
          var d = f.allocUnsafe(20);
          return d.writeInt32BE(0 | this._a, 0), d.writeInt32BE(0 | this._b, 4), d.writeInt32BE(0 | this._c, 8), d.writeInt32BE(0 | this._d, 12), d.writeInt32BE(0 | this._e, 16), d;
        }, t.exports = g;
      }, 7938: (t, o, u) => {
        function c(r) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
            return typeof m;
          } : function(m) {
            return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
          }, c(r);
        }
        function h(r) {
          if (typeof WeakMap != "function") return null;
          var m = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
          return (h = function(a) {
            return a ? g : m;
          })(r);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.default = void 0;
        var f = function(r, m) {
          if (r && r.__esModule) return r;
          if (r === null || c(r) != "object" && typeof r != "function") return { default: r };
          var g = h(m);
          if (g && g.has(r)) return g.get(r);
          var a = { __proto__: null }, l = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var d in r) if (d !== "default" && {}.hasOwnProperty.call(r, d)) {
            var b = l ? Object.getOwnPropertyDescriptor(r, d) : null;
            b && (b.get || b.set) ? Object.defineProperty(a, d, b) : a[d] = r[d];
          }
          return a.default = r, g && g.set(r, a), a;
        }(u(3740)).config(function(r) {
          var m = 1024;
          r.typedef("Value", r.varOpaque()), r.struct("ScpBallot", [["counter", r.lookup("Uint32")], ["value", r.lookup("Value")]]), r.enum("ScpStatementType", { scpStPrepare: 0, scpStConfirm: 1, scpStExternalize: 2, scpStNominate: 3 }), r.struct("ScpNomination", [["quorumSetHash", r.lookup("Hash")], ["votes", r.varArray(r.lookup("Value"), 2147483647)], ["accepted", r.varArray(r.lookup("Value"), 2147483647)]]), r.struct("ScpStatementPrepare", [["quorumSetHash", r.lookup("Hash")], ["ballot", r.lookup("ScpBallot")], ["prepared", r.option(r.lookup("ScpBallot"))], ["preparedPrime", r.option(r.lookup("ScpBallot"))], ["nC", r.lookup("Uint32")], ["nH", r.lookup("Uint32")]]), r.struct("ScpStatementConfirm", [["ballot", r.lookup("ScpBallot")], ["nPrepared", r.lookup("Uint32")], ["nCommit", r.lookup("Uint32")], ["nH", r.lookup("Uint32")], ["quorumSetHash", r.lookup("Hash")]]), r.struct("ScpStatementExternalize", [["commit", r.lookup("ScpBallot")], ["nH", r.lookup("Uint32")], ["commitQuorumSetHash", r.lookup("Hash")]]), r.union("ScpStatementPledges", { switchOn: r.lookup("ScpStatementType"), switchName: "type", switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]], arms: { prepare: r.lookup("ScpStatementPrepare"), confirm: r.lookup("ScpStatementConfirm"), externalize: r.lookup("ScpStatementExternalize"), nominate: r.lookup("ScpNomination") } }), r.struct("ScpStatement", [["nodeId", r.lookup("NodeId")], ["slotIndex", r.lookup("Uint64")], ["pledges", r.lookup("ScpStatementPledges")]]), r.struct("ScpEnvelope", [["statement", r.lookup("ScpStatement")], ["signature", r.lookup("Signature")]]), r.struct("ScpQuorumSet", [["threshold", r.lookup("Uint32")], ["validators", r.varArray(r.lookup("NodeId"), 2147483647)], ["innerSets", r.varArray(r.lookup("ScpQuorumSet"), 2147483647)]]), r.typedef("Thresholds", r.opaque(4)), r.typedef("String32", r.string(32)), r.typedef("String64", r.string(64)), r.typedef("SequenceNumber", r.lookup("Int64")), r.typedef("DataValue", r.varOpaque(64)), r.typedef("PoolId", r.lookup("Hash")), r.typedef("AssetCode4", r.opaque(4)), r.typedef("AssetCode12", r.opaque(12)), r.enum("AssetType", { assetTypeNative: 0, assetTypeCreditAlphanum4: 1, assetTypeCreditAlphanum12: 2, assetTypePoolShare: 3 }), r.union("AssetCode", { switchOn: r.lookup("AssetType"), switchName: "type", switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]], arms: { assetCode4: r.lookup("AssetCode4"), assetCode12: r.lookup("AssetCode12") } }), r.struct("AlphaNum4", [["assetCode", r.lookup("AssetCode4")], ["issuer", r.lookup("AccountId")]]), r.struct("AlphaNum12", [["assetCode", r.lookup("AssetCode12")], ["issuer", r.lookup("AccountId")]]), r.union("Asset", { switchOn: r.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", r.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]], arms: { alphaNum4: r.lookup("AlphaNum4"), alphaNum12: r.lookup("AlphaNum12") } }), r.struct("Price", [["n", r.lookup("Int32")], ["d", r.lookup("Int32")]]), r.struct("Liabilities", [["buying", r.lookup("Int64")], ["selling", r.lookup("Int64")]]), r.enum("ThresholdIndices", { thresholdMasterWeight: 0, thresholdLow: 1, thresholdMed: 2, thresholdHigh: 3 }), r.enum("LedgerEntryType", { account: 0, trustline: 1, offer: 2, data: 3, claimableBalance: 4, liquidityPool: 5, contractData: 6, contractCode: 7, configSetting: 8, ttl: 9 }), r.struct("Signer", [["key", r.lookup("SignerKey")], ["weight", r.lookup("Uint32")]]), r.enum("AccountFlags", { authRequiredFlag: 1, authRevocableFlag: 2, authImmutableFlag: 4, authClawbackEnabledFlag: 8 }), r.const("MASK_ACCOUNT_FLAGS", 7), r.const("MASK_ACCOUNT_FLAGS_V17", 15), r.const("MAX_SIGNERS", 20), r.typedef("SponsorshipDescriptor", r.option(r.lookup("AccountId"))), r.struct("AccountEntryExtensionV3", [["ext", r.lookup("ExtensionPoint")], ["seqLedger", r.lookup("Uint32")], ["seqTime", r.lookup("TimePoint")]]), r.union("AccountEntryExtensionV2Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [3, "v3"]], arms: { v3: r.lookup("AccountEntryExtensionV3") } }), r.struct("AccountEntryExtensionV2", [["numSponsored", r.lookup("Uint32")], ["numSponsoring", r.lookup("Uint32")], ["signerSponsoringIDs", r.varArray(r.lookup("SponsorshipDescriptor"), r.lookup("MAX_SIGNERS"))], ["ext", r.lookup("AccountEntryExtensionV2Ext")]]), r.union("AccountEntryExtensionV1Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [2, "v2"]], arms: { v2: r.lookup("AccountEntryExtensionV2") } }), r.struct("AccountEntryExtensionV1", [["liabilities", r.lookup("Liabilities")], ["ext", r.lookup("AccountEntryExtensionV1Ext")]]), r.union("AccountEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("AccountEntryExtensionV1") } }), r.struct("AccountEntry", [["accountId", r.lookup("AccountId")], ["balance", r.lookup("Int64")], ["seqNum", r.lookup("SequenceNumber")], ["numSubEntries", r.lookup("Uint32")], ["inflationDest", r.option(r.lookup("AccountId"))], ["flags", r.lookup("Uint32")], ["homeDomain", r.lookup("String32")], ["thresholds", r.lookup("Thresholds")], ["signers", r.varArray(r.lookup("Signer"), r.lookup("MAX_SIGNERS"))], ["ext", r.lookup("AccountEntryExt")]]), r.enum("TrustLineFlags", { authorizedFlag: 1, authorizedToMaintainLiabilitiesFlag: 2, trustlineClawbackEnabledFlag: 4 }), r.const("MASK_TRUSTLINE_FLAGS", 1), r.const("MASK_TRUSTLINE_FLAGS_V13", 3), r.const("MASK_TRUSTLINE_FLAGS_V17", 7), r.enum("LiquidityPoolType", { liquidityPoolConstantProduct: 0 }), r.union("TrustLineAsset", { switchOn: r.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", r.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]], arms: { alphaNum4: r.lookup("AlphaNum4"), alphaNum12: r.lookup("AlphaNum12"), liquidityPoolId: r.lookup("PoolId") } }), r.union("TrustLineEntryExtensionV2Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", r.lookup("Int32")], ["ext", r.lookup("TrustLineEntryExtensionV2Ext")]]), r.union("TrustLineEntryV1Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [2, "v2"]], arms: { v2: r.lookup("TrustLineEntryExtensionV2") } }), r.struct("TrustLineEntryV1", [["liabilities", r.lookup("Liabilities")], ["ext", r.lookup("TrustLineEntryV1Ext")]]), r.union("TrustLineEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("TrustLineEntryV1") } }), r.struct("TrustLineEntry", [["accountId", r.lookup("AccountId")], ["asset", r.lookup("TrustLineAsset")], ["balance", r.lookup("Int64")], ["limit", r.lookup("Int64")], ["flags", r.lookup("Uint32")], ["ext", r.lookup("TrustLineEntryExt")]]), r.enum("OfferEntryFlags", { passiveFlag: 1 }), r.const("MASK_OFFERENTRY_FLAGS", 1), r.union("OfferEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("OfferEntry", [["sellerId", r.lookup("AccountId")], ["offerId", r.lookup("Int64")], ["selling", r.lookup("Asset")], ["buying", r.lookup("Asset")], ["amount", r.lookup("Int64")], ["price", r.lookup("Price")], ["flags", r.lookup("Uint32")], ["ext", r.lookup("OfferEntryExt")]]), r.union("DataEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("DataEntry", [["accountId", r.lookup("AccountId")], ["dataName", r.lookup("String64")], ["dataValue", r.lookup("DataValue")], ["ext", r.lookup("DataEntryExt")]]), r.enum("ClaimPredicateType", { claimPredicateUnconditional: 0, claimPredicateAnd: 1, claimPredicateOr: 2, claimPredicateNot: 3, claimPredicateBeforeAbsoluteTime: 4, claimPredicateBeforeRelativeTime: 5 }), r.union("ClaimPredicate", { switchOn: r.lookup("ClaimPredicateType"), switchName: "type", switches: [["claimPredicateUnconditional", r.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]], arms: { andPredicates: r.varArray(r.lookup("ClaimPredicate"), 2), orPredicates: r.varArray(r.lookup("ClaimPredicate"), 2), notPredicate: r.option(r.lookup("ClaimPredicate")), absBefore: r.lookup("Int64"), relBefore: r.lookup("Int64") } }), r.enum("ClaimantType", { claimantTypeV0: 0 }), r.struct("ClaimantV0", [["destination", r.lookup("AccountId")], ["predicate", r.lookup("ClaimPredicate")]]), r.union("Claimant", { switchOn: r.lookup("ClaimantType"), switchName: "type", switches: [["claimantTypeV0", "v0"]], arms: { v0: r.lookup("ClaimantV0") } }), r.enum("ClaimableBalanceIdType", { claimableBalanceIdTypeV0: 0 }), r.union("ClaimableBalanceId", { switchOn: r.lookup("ClaimableBalanceIdType"), switchName: "type", switches: [["claimableBalanceIdTypeV0", "v0"]], arms: { v0: r.lookup("Hash") } }), r.enum("ClaimableBalanceFlags", { claimableBalanceClawbackEnabledFlag: 1 }), r.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1), r.union("ClaimableBalanceEntryExtensionV1Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("ClaimableBalanceEntryExtensionV1", [["ext", r.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", r.lookup("Uint32")]]), r.union("ClaimableBalanceEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("ClaimableBalanceEntryExtensionV1") } }), r.struct("ClaimableBalanceEntry", [["balanceId", r.lookup("ClaimableBalanceId")], ["claimants", r.varArray(r.lookup("Claimant"), 10)], ["asset", r.lookup("Asset")], ["amount", r.lookup("Int64")], ["ext", r.lookup("ClaimableBalanceEntryExt")]]), r.struct("LiquidityPoolConstantProductParameters", [["assetA", r.lookup("Asset")], ["assetB", r.lookup("Asset")], ["fee", r.lookup("Int32")]]), r.struct("LiquidityPoolEntryConstantProduct", [["params", r.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", r.lookup("Int64")], ["reserveB", r.lookup("Int64")], ["totalPoolShares", r.lookup("Int64")], ["poolSharesTrustLineCount", r.lookup("Int64")]]), r.union("LiquidityPoolEntryBody", { switchOn: r.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: r.lookup("LiquidityPoolEntryConstantProduct") } }), r.struct("LiquidityPoolEntry", [["liquidityPoolId", r.lookup("PoolId")], ["body", r.lookup("LiquidityPoolEntryBody")]]), r.enum("ContractDataDurability", { temporary: 0, persistent: 1 }), r.struct("ContractDataEntry", [["ext", r.lookup("ExtensionPoint")], ["contract", r.lookup("ScAddress")], ["key", r.lookup("ScVal")], ["durability", r.lookup("ContractDataDurability")], ["val", r.lookup("ScVal")]]), r.struct("ContractCodeCostInputs", [["ext", r.lookup("ExtensionPoint")], ["nInstructions", r.lookup("Uint32")], ["nFunctions", r.lookup("Uint32")], ["nGlobals", r.lookup("Uint32")], ["nTableEntries", r.lookup("Uint32")], ["nTypes", r.lookup("Uint32")], ["nDataSegments", r.lookup("Uint32")], ["nElemSegments", r.lookup("Uint32")], ["nImports", r.lookup("Uint32")], ["nExports", r.lookup("Uint32")], ["nDataSegmentBytes", r.lookup("Uint32")]]), r.struct("ContractCodeEntryV1", [["ext", r.lookup("ExtensionPoint")], ["costInputs", r.lookup("ContractCodeCostInputs")]]), r.union("ContractCodeEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("ContractCodeEntryV1") } }), r.struct("ContractCodeEntry", [["ext", r.lookup("ContractCodeEntryExt")], ["hash", r.lookup("Hash")], ["code", r.varOpaque()]]), r.struct("TtlEntry", [["keyHash", r.lookup("Hash")], ["liveUntilLedgerSeq", r.lookup("Uint32")]]), r.union("LedgerEntryExtensionV1Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("LedgerEntryExtensionV1", [["sponsoringId", r.lookup("SponsorshipDescriptor")], ["ext", r.lookup("LedgerEntryExtensionV1Ext")]]), r.union("LedgerEntryData", { switchOn: r.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: r.lookup("AccountEntry"), trustLine: r.lookup("TrustLineEntry"), offer: r.lookup("OfferEntry"), data: r.lookup("DataEntry"), claimableBalance: r.lookup("ClaimableBalanceEntry"), liquidityPool: r.lookup("LiquidityPoolEntry"), contractData: r.lookup("ContractDataEntry"), contractCode: r.lookup("ContractCodeEntry"), configSetting: r.lookup("ConfigSettingEntry"), ttl: r.lookup("TtlEntry") } }), r.union("LedgerEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("LedgerEntryExtensionV1") } }), r.struct("LedgerEntry", [["lastModifiedLedgerSeq", r.lookup("Uint32")], ["data", r.lookup("LedgerEntryData")], ["ext", r.lookup("LedgerEntryExt")]]), r.struct("LedgerKeyAccount", [["accountId", r.lookup("AccountId")]]), r.struct("LedgerKeyTrustLine", [["accountId", r.lookup("AccountId")], ["asset", r.lookup("TrustLineAsset")]]), r.struct("LedgerKeyOffer", [["sellerId", r.lookup("AccountId")], ["offerId", r.lookup("Int64")]]), r.struct("LedgerKeyData", [["accountId", r.lookup("AccountId")], ["dataName", r.lookup("String64")]]), r.struct("LedgerKeyClaimableBalance", [["balanceId", r.lookup("ClaimableBalanceId")]]), r.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", r.lookup("PoolId")]]), r.struct("LedgerKeyContractData", [["contract", r.lookup("ScAddress")], ["key", r.lookup("ScVal")], ["durability", r.lookup("ContractDataDurability")]]), r.struct("LedgerKeyContractCode", [["hash", r.lookup("Hash")]]), r.struct("LedgerKeyConfigSetting", [["configSettingId", r.lookup("ConfigSettingId")]]), r.struct("LedgerKeyTtl", [["keyHash", r.lookup("Hash")]]), r.union("LedgerKey", { switchOn: r.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: r.lookup("LedgerKeyAccount"), trustLine: r.lookup("LedgerKeyTrustLine"), offer: r.lookup("LedgerKeyOffer"), data: r.lookup("LedgerKeyData"), claimableBalance: r.lookup("LedgerKeyClaimableBalance"), liquidityPool: r.lookup("LedgerKeyLiquidityPool"), contractData: r.lookup("LedgerKeyContractData"), contractCode: r.lookup("LedgerKeyContractCode"), configSetting: r.lookup("LedgerKeyConfigSetting"), ttl: r.lookup("LedgerKeyTtl") } }), r.enum("EnvelopeType", { envelopeTypeTxV0: 0, envelopeTypeScp: 1, envelopeTypeTx: 2, envelopeTypeAuth: 3, envelopeTypeScpvalue: 4, envelopeTypeTxFeeBump: 5, envelopeTypeOpId: 6, envelopeTypePoolRevokeOpId: 7, envelopeTypeContractId: 8, envelopeTypeSorobanAuthorization: 9 }), r.enum("BucketListType", { live: 0, hotArchive: 1, coldArchive: 2 }), r.enum("BucketEntryType", { metaentry: -1, liveentry: 0, deadentry: 1, initentry: 2 }), r.enum("HotArchiveBucketEntryType", { hotArchiveMetaentry: -1, hotArchiveArchived: 0, hotArchiveLive: 1, hotArchiveDeleted: 2 }), r.enum("ColdArchiveBucketEntryType", { coldArchiveMetaentry: -1, coldArchiveArchivedLeaf: 0, coldArchiveDeletedLeaf: 1, coldArchiveBoundaryLeaf: 2, coldArchiveHash: 3 }), r.union("BucketMetadataExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "bucketListType"]], arms: { bucketListType: r.lookup("BucketListType") } }), r.struct("BucketMetadata", [["ledgerVersion", r.lookup("Uint32")], ["ext", r.lookup("BucketMetadataExt")]]), r.union("BucketEntry", { switchOn: r.lookup("BucketEntryType"), switchName: "type", switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]], arms: { liveEntry: r.lookup("LedgerEntry"), deadEntry: r.lookup("LedgerKey"), metaEntry: r.lookup("BucketMetadata") } }), r.union("HotArchiveBucketEntry", { switchOn: r.lookup("HotArchiveBucketEntryType"), switchName: "type", switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]], arms: { archivedEntry: r.lookup("LedgerEntry"), key: r.lookup("LedgerKey"), metaEntry: r.lookup("BucketMetadata") } }), r.struct("ColdArchiveArchivedLeaf", [["index", r.lookup("Uint32")], ["archivedEntry", r.lookup("LedgerEntry")]]), r.struct("ColdArchiveDeletedLeaf", [["index", r.lookup("Uint32")], ["deletedKey", r.lookup("LedgerKey")]]), r.struct("ColdArchiveBoundaryLeaf", [["index", r.lookup("Uint32")], ["isLowerBound", r.bool()]]), r.struct("ColdArchiveHashEntry", [["index", r.lookup("Uint32")], ["level", r.lookup("Uint32")], ["hash", r.lookup("Hash")]]), r.union("ColdArchiveBucketEntry", { switchOn: r.lookup("ColdArchiveBucketEntryType"), switchName: "type", switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]], arms: { metaEntry: r.lookup("BucketMetadata"), archivedLeaf: r.lookup("ColdArchiveArchivedLeaf"), deletedLeaf: r.lookup("ColdArchiveDeletedLeaf"), boundaryLeaf: r.lookup("ColdArchiveBoundaryLeaf"), hashEntry: r.lookup("ColdArchiveHashEntry") } }), r.typedef("UpgradeType", r.varOpaque(128)), r.enum("StellarValueType", { stellarValueBasic: 0, stellarValueSigned: 1 }), r.struct("LedgerCloseValueSignature", [["nodeId", r.lookup("NodeId")], ["signature", r.lookup("Signature")]]), r.union("StellarValueExt", { switchOn: r.lookup("StellarValueType"), switchName: "v", switches: [["stellarValueBasic", r.void()], ["stellarValueSigned", "lcValueSignature"]], arms: { lcValueSignature: r.lookup("LedgerCloseValueSignature") } }), r.struct("StellarValue", [["txSetHash", r.lookup("Hash")], ["closeTime", r.lookup("TimePoint")], ["upgrades", r.varArray(r.lookup("UpgradeType"), 6)], ["ext", r.lookup("StellarValueExt")]]), r.const("MASK_LEDGER_HEADER_FLAGS", 7), r.enum("LedgerHeaderFlags", { disableLiquidityPoolTradingFlag: 1, disableLiquidityPoolDepositFlag: 2, disableLiquidityPoolWithdrawalFlag: 4 }), r.union("LedgerHeaderExtensionV1Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("LedgerHeaderExtensionV1", [["flags", r.lookup("Uint32")], ["ext", r.lookup("LedgerHeaderExtensionV1Ext")]]), r.union("LedgerHeaderExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("LedgerHeaderExtensionV1") } }), r.struct("LedgerHeader", [["ledgerVersion", r.lookup("Uint32")], ["previousLedgerHash", r.lookup("Hash")], ["scpValue", r.lookup("StellarValue")], ["txSetResultHash", r.lookup("Hash")], ["bucketListHash", r.lookup("Hash")], ["ledgerSeq", r.lookup("Uint32")], ["totalCoins", r.lookup("Int64")], ["feePool", r.lookup("Int64")], ["inflationSeq", r.lookup("Uint32")], ["idPool", r.lookup("Uint64")], ["baseFee", r.lookup("Uint32")], ["baseReserve", r.lookup("Uint32")], ["maxTxSetSize", r.lookup("Uint32")], ["skipList", r.array(r.lookup("Hash"), 4)], ["ext", r.lookup("LedgerHeaderExt")]]), r.enum("LedgerUpgradeType", { ledgerUpgradeVersion: 1, ledgerUpgradeBaseFee: 2, ledgerUpgradeMaxTxSetSize: 3, ledgerUpgradeBaseReserve: 4, ledgerUpgradeFlags: 5, ledgerUpgradeConfig: 6, ledgerUpgradeMaxSorobanTxSetSize: 7 }), r.struct("ConfigUpgradeSetKey", [["contractId", r.lookup("Hash")], ["contentHash", r.lookup("Hash")]]), r.union("LedgerUpgrade", { switchOn: r.lookup("LedgerUpgradeType"), switchName: "type", switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]], arms: { newLedgerVersion: r.lookup("Uint32"), newBaseFee: r.lookup("Uint32"), newMaxTxSetSize: r.lookup("Uint32"), newBaseReserve: r.lookup("Uint32"), newFlags: r.lookup("Uint32"), newConfig: r.lookup("ConfigUpgradeSetKey"), newMaxSorobanTxSetSize: r.lookup("Uint32") } }), r.struct("ConfigUpgradeSet", [["updatedEntry", r.varArray(r.lookup("ConfigSettingEntry"), 2147483647)]]), r.enum("TxSetComponentType", { txsetCompTxsMaybeDiscountedFee: 0 }), r.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", r.option(r.lookup("Int64"))], ["txes", r.varArray(r.lookup("TransactionEnvelope"), 2147483647)]]), r.union("TxSetComponent", { switchOn: r.lookup("TxSetComponentType"), switchName: "type", switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]], arms: { txsMaybeDiscountedFee: r.lookup("TxSetComponentTxsMaybeDiscountedFee") } }), r.union("TransactionPhase", { switchOn: r.int(), switchName: "v", switches: [[0, "v0Components"]], arms: { v0Components: r.varArray(r.lookup("TxSetComponent"), 2147483647) } }), r.struct("TransactionSet", [["previousLedgerHash", r.lookup("Hash")], ["txes", r.varArray(r.lookup("TransactionEnvelope"), 2147483647)]]), r.struct("TransactionSetV1", [["previousLedgerHash", r.lookup("Hash")], ["phases", r.varArray(r.lookup("TransactionPhase"), 2147483647)]]), r.union("GeneralizedTransactionSet", { switchOn: r.int(), switchName: "v", switches: [[1, "v1TxSet"]], arms: { v1TxSet: r.lookup("TransactionSetV1") } }), r.struct("TransactionResultPair", [["transactionHash", r.lookup("Hash")], ["result", r.lookup("TransactionResult")]]), r.struct("TransactionResultSet", [["results", r.varArray(r.lookup("TransactionResultPair"), 2147483647)]]), r.union("TransactionHistoryEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "generalizedTxSet"]], arms: { generalizedTxSet: r.lookup("GeneralizedTransactionSet") } }), r.struct("TransactionHistoryEntry", [["ledgerSeq", r.lookup("Uint32")], ["txSet", r.lookup("TransactionSet")], ["ext", r.lookup("TransactionHistoryEntryExt")]]), r.union("TransactionHistoryResultEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("TransactionHistoryResultEntry", [["ledgerSeq", r.lookup("Uint32")], ["txResultSet", r.lookup("TransactionResultSet")], ["ext", r.lookup("TransactionHistoryResultEntryExt")]]), r.union("LedgerHeaderHistoryEntryExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("LedgerHeaderHistoryEntry", [["hash", r.lookup("Hash")], ["header", r.lookup("LedgerHeader")], ["ext", r.lookup("LedgerHeaderHistoryEntryExt")]]), r.struct("LedgerScpMessages", [["ledgerSeq", r.lookup("Uint32")], ["messages", r.varArray(r.lookup("ScpEnvelope"), 2147483647)]]), r.struct("ScpHistoryEntryV0", [["quorumSets", r.varArray(r.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", r.lookup("LedgerScpMessages")]]), r.union("ScpHistoryEntry", { switchOn: r.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: r.lookup("ScpHistoryEntryV0") } }), r.enum("LedgerEntryChangeType", { ledgerEntryCreated: 0, ledgerEntryUpdated: 1, ledgerEntryRemoved: 2, ledgerEntryState: 3 }), r.union("LedgerEntryChange", { switchOn: r.lookup("LedgerEntryChangeType"), switchName: "type", switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]], arms: { created: r.lookup("LedgerEntry"), updated: r.lookup("LedgerEntry"), removed: r.lookup("LedgerKey"), state: r.lookup("LedgerEntry") } }), r.typedef("LedgerEntryChanges", r.varArray(r.lookup("LedgerEntryChange"), 2147483647)), r.struct("OperationMeta", [["changes", r.lookup("LedgerEntryChanges")]]), r.struct("TransactionMetaV1", [["txChanges", r.lookup("LedgerEntryChanges")], ["operations", r.varArray(r.lookup("OperationMeta"), 2147483647)]]), r.struct("TransactionMetaV2", [["txChangesBefore", r.lookup("LedgerEntryChanges")], ["operations", r.varArray(r.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", r.lookup("LedgerEntryChanges")]]), r.enum("ContractEventType", { system: 0, contract: 1, diagnostic: 2 }), r.struct("ContractEventV0", [["topics", r.varArray(r.lookup("ScVal"), 2147483647)], ["data", r.lookup("ScVal")]]), r.union("ContractEventBody", { switchOn: r.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: r.lookup("ContractEventV0") } }), r.struct("ContractEvent", [["ext", r.lookup("ExtensionPoint")], ["contractId", r.option(r.lookup("Hash"))], ["type", r.lookup("ContractEventType")], ["body", r.lookup("ContractEventBody")]]), r.struct("DiagnosticEvent", [["inSuccessfulContractCall", r.bool()], ["event", r.lookup("ContractEvent")]]), r.typedef("DiagnosticEvents", r.varArray(r.lookup("DiagnosticEvent"), 2147483647)), r.struct("SorobanTransactionMetaExtV1", [["ext", r.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", r.lookup("Int64")], ["totalRefundableResourceFeeCharged", r.lookup("Int64")], ["rentFeeCharged", r.lookup("Int64")]]), r.union("SorobanTransactionMetaExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("SorobanTransactionMetaExtV1") } }), r.struct("SorobanTransactionMeta", [["ext", r.lookup("SorobanTransactionMetaExt")], ["events", r.varArray(r.lookup("ContractEvent"), 2147483647)], ["returnValue", r.lookup("ScVal")], ["diagnosticEvents", r.varArray(r.lookup("DiagnosticEvent"), 2147483647)]]), r.struct("TransactionMetaV3", [["ext", r.lookup("ExtensionPoint")], ["txChangesBefore", r.lookup("LedgerEntryChanges")], ["operations", r.varArray(r.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", r.lookup("LedgerEntryChanges")], ["sorobanMeta", r.option(r.lookup("SorobanTransactionMeta"))]]), r.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", r.lookup("ScVal")], ["events", r.varArray(r.lookup("ContractEvent"), 2147483647)]]), r.union("TransactionMeta", { switchOn: r.int(), switchName: "v", switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]], arms: { operations: r.varArray(r.lookup("OperationMeta"), 2147483647), v1: r.lookup("TransactionMetaV1"), v2: r.lookup("TransactionMetaV2"), v3: r.lookup("TransactionMetaV3") } }), r.struct("TransactionResultMeta", [["result", r.lookup("TransactionResultPair")], ["feeProcessing", r.lookup("LedgerEntryChanges")], ["txApplyProcessing", r.lookup("TransactionMeta")]]), r.struct("UpgradeEntryMeta", [["upgrade", r.lookup("LedgerUpgrade")], ["changes", r.lookup("LedgerEntryChanges")]]), r.struct("LedgerCloseMetaV0", [["ledgerHeader", r.lookup("LedgerHeaderHistoryEntry")], ["txSet", r.lookup("TransactionSet")], ["txProcessing", r.varArray(r.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", r.varArray(r.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", r.varArray(r.lookup("ScpHistoryEntry"), 2147483647)]]), r.struct("LedgerCloseMetaExtV1", [["ext", r.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", r.lookup("Int64")]]), r.union("LedgerCloseMetaExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "v1"]], arms: { v1: r.lookup("LedgerCloseMetaExtV1") } }), r.struct("LedgerCloseMetaV1", [["ext", r.lookup("LedgerCloseMetaExt")], ["ledgerHeader", r.lookup("LedgerHeaderHistoryEntry")], ["txSet", r.lookup("GeneralizedTransactionSet")], ["txProcessing", r.varArray(r.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", r.varArray(r.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", r.varArray(r.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", r.lookup("Uint64")], ["evictedTemporaryLedgerKeys", r.varArray(r.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", r.varArray(r.lookup("LedgerEntry"), 2147483647)]]), r.union("LedgerCloseMeta", { switchOn: r.int(), switchName: "v", switches: [[0, "v0"], [1, "v1"]], arms: { v0: r.lookup("LedgerCloseMetaV0"), v1: r.lookup("LedgerCloseMetaV1") } }), r.enum("ErrorCode", { errMisc: 0, errData: 1, errConf: 2, errAuth: 3, errLoad: 4 }), r.struct("Error", [["code", r.lookup("ErrorCode")], ["msg", r.string(100)]]), r.struct("SendMore", [["numMessages", r.lookup("Uint32")]]), r.struct("SendMoreExtended", [["numMessages", r.lookup("Uint32")], ["numBytes", r.lookup("Uint32")]]), r.struct("AuthCert", [["pubkey", r.lookup("Curve25519Public")], ["expiration", r.lookup("Uint64")], ["sig", r.lookup("Signature")]]), r.struct("Hello", [["ledgerVersion", r.lookup("Uint32")], ["overlayVersion", r.lookup("Uint32")], ["overlayMinVersion", r.lookup("Uint32")], ["networkId", r.lookup("Hash")], ["versionStr", r.string(100)], ["listeningPort", r.int()], ["peerId", r.lookup("NodeId")], ["cert", r.lookup("AuthCert")], ["nonce", r.lookup("Uint256")]]), r.const("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200), r.struct("Auth", [["flags", r.int()]]), r.enum("IpAddrType", { iPv4: 0, iPv6: 1 }), r.union("PeerAddressIp", { switchOn: r.lookup("IpAddrType"), switchName: "type", switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]], arms: { ipv4: r.opaque(4), ipv6: r.opaque(16) } }), r.struct("PeerAddress", [["ip", r.lookup("PeerAddressIp")], ["port", r.lookup("Uint32")], ["numFailures", r.lookup("Uint32")]]), r.enum("MessageType", { errorMsg: 0, auth: 2, dontHave: 3, getPeers: 4, peers: 5, getTxSet: 6, txSet: 7, generalizedTxSet: 17, transaction: 8, getScpQuorumset: 9, scpQuorumset: 10, scpMessage: 11, getScpState: 12, hello: 13, surveyRequest: 14, surveyResponse: 15, sendMore: 16, sendMoreExtended: 20, floodAdvert: 18, floodDemand: 19, timeSlicedSurveyRequest: 21, timeSlicedSurveyResponse: 22, timeSlicedSurveyStartCollecting: 23, timeSlicedSurveyStopCollecting: 24 }), r.struct("DontHave", [["type", r.lookup("MessageType")], ["reqHash", r.lookup("Uint256")]]), r.enum("SurveyMessageCommandType", { surveyTopology: 0, timeSlicedSurveyTopology: 1 }), r.enum("SurveyMessageResponseType", { surveyTopologyResponseV0: 0, surveyTopologyResponseV1: 1, surveyTopologyResponseV2: 2 }), r.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", r.lookup("NodeId")], ["nonce", r.lookup("Uint32")], ["ledgerNum", r.lookup("Uint32")]]), r.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", r.lookup("Signature")], ["startCollecting", r.lookup("TimeSlicedSurveyStartCollectingMessage")]]), r.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", r.lookup("NodeId")], ["nonce", r.lookup("Uint32")], ["ledgerNum", r.lookup("Uint32")]]), r.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", r.lookup("Signature")], ["stopCollecting", r.lookup("TimeSlicedSurveyStopCollectingMessage")]]), r.struct("SurveyRequestMessage", [["surveyorPeerId", r.lookup("NodeId")], ["surveyedPeerId", r.lookup("NodeId")], ["ledgerNum", r.lookup("Uint32")], ["encryptionKey", r.lookup("Curve25519Public")], ["commandType", r.lookup("SurveyMessageCommandType")]]), r.struct("TimeSlicedSurveyRequestMessage", [["request", r.lookup("SurveyRequestMessage")], ["nonce", r.lookup("Uint32")], ["inboundPeersIndex", r.lookup("Uint32")], ["outboundPeersIndex", r.lookup("Uint32")]]), r.struct("SignedSurveyRequestMessage", [["requestSignature", r.lookup("Signature")], ["request", r.lookup("SurveyRequestMessage")]]), r.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", r.lookup("Signature")], ["request", r.lookup("TimeSlicedSurveyRequestMessage")]]), r.typedef("EncryptedBody", r.varOpaque(64e3)), r.struct("SurveyResponseMessage", [["surveyorPeerId", r.lookup("NodeId")], ["surveyedPeerId", r.lookup("NodeId")], ["ledgerNum", r.lookup("Uint32")], ["commandType", r.lookup("SurveyMessageCommandType")], ["encryptedBody", r.lookup("EncryptedBody")]]), r.struct("TimeSlicedSurveyResponseMessage", [["response", r.lookup("SurveyResponseMessage")], ["nonce", r.lookup("Uint32")]]), r.struct("SignedSurveyResponseMessage", [["responseSignature", r.lookup("Signature")], ["response", r.lookup("SurveyResponseMessage")]]), r.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", r.lookup("Signature")], ["response", r.lookup("TimeSlicedSurveyResponseMessage")]]), r.struct("PeerStats", [["id", r.lookup("NodeId")], ["versionStr", r.string(100)], ["messagesRead", r.lookup("Uint64")], ["messagesWritten", r.lookup("Uint64")], ["bytesRead", r.lookup("Uint64")], ["bytesWritten", r.lookup("Uint64")], ["secondsConnected", r.lookup("Uint64")], ["uniqueFloodBytesRecv", r.lookup("Uint64")], ["duplicateFloodBytesRecv", r.lookup("Uint64")], ["uniqueFetchBytesRecv", r.lookup("Uint64")], ["duplicateFetchBytesRecv", r.lookup("Uint64")], ["uniqueFloodMessageRecv", r.lookup("Uint64")], ["duplicateFloodMessageRecv", r.lookup("Uint64")], ["uniqueFetchMessageRecv", r.lookup("Uint64")], ["duplicateFetchMessageRecv", r.lookup("Uint64")]]), r.typedef("PeerStatList", r.varArray(r.lookup("PeerStats"), 25)), r.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", r.lookup("Uint32")], ["droppedAuthenticatedPeers", r.lookup("Uint32")], ["totalInboundPeerCount", r.lookup("Uint32")], ["totalOutboundPeerCount", r.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", r.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", r.lookup("Uint32")], ["lostSyncCount", r.lookup("Uint32")], ["isValidator", r.bool()], ["maxInboundPeerCount", r.lookup("Uint32")], ["maxOutboundPeerCount", r.lookup("Uint32")]]), r.struct("TimeSlicedPeerData", [["peerStats", r.lookup("PeerStats")], ["averageLatencyMs", r.lookup("Uint32")]]), r.typedef("TimeSlicedPeerDataList", r.varArray(r.lookup("TimeSlicedPeerData"), 25)), r.struct("TopologyResponseBodyV0", [["inboundPeers", r.lookup("PeerStatList")], ["outboundPeers", r.lookup("PeerStatList")], ["totalInboundPeerCount", r.lookup("Uint32")], ["totalOutboundPeerCount", r.lookup("Uint32")]]), r.struct("TopologyResponseBodyV1", [["inboundPeers", r.lookup("PeerStatList")], ["outboundPeers", r.lookup("PeerStatList")], ["totalInboundPeerCount", r.lookup("Uint32")], ["totalOutboundPeerCount", r.lookup("Uint32")], ["maxInboundPeerCount", r.lookup("Uint32")], ["maxOutboundPeerCount", r.lookup("Uint32")]]), r.struct("TopologyResponseBodyV2", [["inboundPeers", r.lookup("TimeSlicedPeerDataList")], ["outboundPeers", r.lookup("TimeSlicedPeerDataList")], ["nodeData", r.lookup("TimeSlicedNodeData")]]), r.union("SurveyResponseBody", { switchOn: r.lookup("SurveyMessageResponseType"), switchName: "type", switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]], arms: { topologyResponseBodyV0: r.lookup("TopologyResponseBodyV0"), topologyResponseBodyV1: r.lookup("TopologyResponseBodyV1"), topologyResponseBodyV2: r.lookup("TopologyResponseBodyV2") } }), r.const("TX_ADVERT_VECTOR_MAX_SIZE", 1e3), r.typedef("TxAdvertVector", r.varArray(r.lookup("Hash"), r.lookup("TX_ADVERT_VECTOR_MAX_SIZE"))), r.struct("FloodAdvert", [["txHashes", r.lookup("TxAdvertVector")]]), r.const("TX_DEMAND_VECTOR_MAX_SIZE", 1e3), r.typedef("TxDemandVector", r.varArray(r.lookup("Hash"), r.lookup("TX_DEMAND_VECTOR_MAX_SIZE"))), r.struct("FloodDemand", [["txHashes", r.lookup("TxDemandVector")]]), r.union("StellarMessage", { switchOn: r.lookup("MessageType"), switchName: "type", switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", r.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]], arms: { error: r.lookup("Error"), hello: r.lookup("Hello"), auth: r.lookup("Auth"), dontHave: r.lookup("DontHave"), peers: r.varArray(r.lookup("PeerAddress"), 100), txSetHash: r.lookup("Uint256"), txSet: r.lookup("TransactionSet"), generalizedTxSet: r.lookup("GeneralizedTransactionSet"), transaction: r.lookup("TransactionEnvelope"), signedSurveyRequestMessage: r.lookup("SignedSurveyRequestMessage"), signedSurveyResponseMessage: r.lookup("SignedSurveyResponseMessage"), signedTimeSlicedSurveyRequestMessage: r.lookup("SignedTimeSlicedSurveyRequestMessage"), signedTimeSlicedSurveyResponseMessage: r.lookup("SignedTimeSlicedSurveyResponseMessage"), signedTimeSlicedSurveyStartCollectingMessage: r.lookup("SignedTimeSlicedSurveyStartCollectingMessage"), signedTimeSlicedSurveyStopCollectingMessage: r.lookup("SignedTimeSlicedSurveyStopCollectingMessage"), qSetHash: r.lookup("Uint256"), qSet: r.lookup("ScpQuorumSet"), envelope: r.lookup("ScpEnvelope"), getScpLedgerSeq: r.lookup("Uint32"), sendMoreMessage: r.lookup("SendMore"), sendMoreExtendedMessage: r.lookup("SendMoreExtended"), floodAdvert: r.lookup("FloodAdvert"), floodDemand: r.lookup("FloodDemand") } }), r.struct("AuthenticatedMessageV0", [["sequence", r.lookup("Uint64")], ["message", r.lookup("StellarMessage")], ["mac", r.lookup("HmacSha256Mac")]]), r.union("AuthenticatedMessage", { switchOn: r.lookup("Uint32"), switchName: "v", switches: [[0, "v0"]], arms: { v0: r.lookup("AuthenticatedMessageV0") } }), r.const("MAX_OPS_PER_TX", 100), r.union("LiquidityPoolParameters", { switchOn: r.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: r.lookup("LiquidityPoolConstantProductParameters") } }), r.struct("MuxedAccountMed25519", [["id", r.lookup("Uint64")], ["ed25519", r.lookup("Uint256")]]), r.union("MuxedAccount", { switchOn: r.lookup("CryptoKeyType"), switchName: "type", switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]], arms: { ed25519: r.lookup("Uint256"), med25519: r.lookup("MuxedAccountMed25519") } }), r.struct("DecoratedSignature", [["hint", r.lookup("SignatureHint")], ["signature", r.lookup("Signature")]]), r.enum("OperationType", { createAccount: 0, payment: 1, pathPaymentStrictReceive: 2, manageSellOffer: 3, createPassiveSellOffer: 4, setOptions: 5, changeTrust: 6, allowTrust: 7, accountMerge: 8, inflation: 9, manageData: 10, bumpSequence: 11, manageBuyOffer: 12, pathPaymentStrictSend: 13, createClaimableBalance: 14, claimClaimableBalance: 15, beginSponsoringFutureReserves: 16, endSponsoringFutureReserves: 17, revokeSponsorship: 18, clawback: 19, clawbackClaimableBalance: 20, setTrustLineFlags: 21, liquidityPoolDeposit: 22, liquidityPoolWithdraw: 23, invokeHostFunction: 24, extendFootprintTtl: 25, restoreFootprint: 26 }), r.struct("CreateAccountOp", [["destination", r.lookup("AccountId")], ["startingBalance", r.lookup("Int64")]]), r.struct("PaymentOp", [["destination", r.lookup("MuxedAccount")], ["asset", r.lookup("Asset")], ["amount", r.lookup("Int64")]]), r.struct("PathPaymentStrictReceiveOp", [["sendAsset", r.lookup("Asset")], ["sendMax", r.lookup("Int64")], ["destination", r.lookup("MuxedAccount")], ["destAsset", r.lookup("Asset")], ["destAmount", r.lookup("Int64")], ["path", r.varArray(r.lookup("Asset"), 5)]]), r.struct("PathPaymentStrictSendOp", [["sendAsset", r.lookup("Asset")], ["sendAmount", r.lookup("Int64")], ["destination", r.lookup("MuxedAccount")], ["destAsset", r.lookup("Asset")], ["destMin", r.lookup("Int64")], ["path", r.varArray(r.lookup("Asset"), 5)]]), r.struct("ManageSellOfferOp", [["selling", r.lookup("Asset")], ["buying", r.lookup("Asset")], ["amount", r.lookup("Int64")], ["price", r.lookup("Price")], ["offerId", r.lookup("Int64")]]), r.struct("ManageBuyOfferOp", [["selling", r.lookup("Asset")], ["buying", r.lookup("Asset")], ["buyAmount", r.lookup("Int64")], ["price", r.lookup("Price")], ["offerId", r.lookup("Int64")]]), r.struct("CreatePassiveSellOfferOp", [["selling", r.lookup("Asset")], ["buying", r.lookup("Asset")], ["amount", r.lookup("Int64")], ["price", r.lookup("Price")]]), r.struct("SetOptionsOp", [["inflationDest", r.option(r.lookup("AccountId"))], ["clearFlags", r.option(r.lookup("Uint32"))], ["setFlags", r.option(r.lookup("Uint32"))], ["masterWeight", r.option(r.lookup("Uint32"))], ["lowThreshold", r.option(r.lookup("Uint32"))], ["medThreshold", r.option(r.lookup("Uint32"))], ["highThreshold", r.option(r.lookup("Uint32"))], ["homeDomain", r.option(r.lookup("String32"))], ["signer", r.option(r.lookup("Signer"))]]), r.union("ChangeTrustAsset", { switchOn: r.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", r.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]], arms: { alphaNum4: r.lookup("AlphaNum4"), alphaNum12: r.lookup("AlphaNum12"), liquidityPool: r.lookup("LiquidityPoolParameters") } }), r.struct("ChangeTrustOp", [["line", r.lookup("ChangeTrustAsset")], ["limit", r.lookup("Int64")]]), r.struct("AllowTrustOp", [["trustor", r.lookup("AccountId")], ["asset", r.lookup("AssetCode")], ["authorize", r.lookup("Uint32")]]), r.struct("ManageDataOp", [["dataName", r.lookup("String64")], ["dataValue", r.option(r.lookup("DataValue"))]]), r.struct("BumpSequenceOp", [["bumpTo", r.lookup("SequenceNumber")]]), r.struct("CreateClaimableBalanceOp", [["asset", r.lookup("Asset")], ["amount", r.lookup("Int64")], ["claimants", r.varArray(r.lookup("Claimant"), 10)]]), r.struct("ClaimClaimableBalanceOp", [["balanceId", r.lookup("ClaimableBalanceId")]]), r.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", r.lookup("AccountId")]]), r.enum("RevokeSponsorshipType", { revokeSponsorshipLedgerEntry: 0, revokeSponsorshipSigner: 1 }), r.struct("RevokeSponsorshipOpSigner", [["accountId", r.lookup("AccountId")], ["signerKey", r.lookup("SignerKey")]]), r.union("RevokeSponsorshipOp", { switchOn: r.lookup("RevokeSponsorshipType"), switchName: "type", switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]], arms: { ledgerKey: r.lookup("LedgerKey"), signer: r.lookup("RevokeSponsorshipOpSigner") } }), r.struct("ClawbackOp", [["asset", r.lookup("Asset")], ["from", r.lookup("MuxedAccount")], ["amount", r.lookup("Int64")]]), r.struct("ClawbackClaimableBalanceOp", [["balanceId", r.lookup("ClaimableBalanceId")]]), r.struct("SetTrustLineFlagsOp", [["trustor", r.lookup("AccountId")], ["asset", r.lookup("Asset")], ["clearFlags", r.lookup("Uint32")], ["setFlags", r.lookup("Uint32")]]), r.const("LIQUIDITY_POOL_FEE_V18", 30), r.struct("LiquidityPoolDepositOp", [["liquidityPoolId", r.lookup("PoolId")], ["maxAmountA", r.lookup("Int64")], ["maxAmountB", r.lookup("Int64")], ["minPrice", r.lookup("Price")], ["maxPrice", r.lookup("Price")]]), r.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", r.lookup("PoolId")], ["amount", r.lookup("Int64")], ["minAmountA", r.lookup("Int64")], ["minAmountB", r.lookup("Int64")]]), r.enum("HostFunctionType", { hostFunctionTypeInvokeContract: 0, hostFunctionTypeCreateContract: 1, hostFunctionTypeUploadContractWasm: 2, hostFunctionTypeCreateContractV2: 3 }), r.enum("ContractIdPreimageType", { contractIdPreimageFromAddress: 0, contractIdPreimageFromAsset: 1 }), r.struct("ContractIdPreimageFromAddress", [["address", r.lookup("ScAddress")], ["salt", r.lookup("Uint256")]]), r.union("ContractIdPreimage", { switchOn: r.lookup("ContractIdPreimageType"), switchName: "type", switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]], arms: { fromAddress: r.lookup("ContractIdPreimageFromAddress"), fromAsset: r.lookup("Asset") } }), r.struct("CreateContractArgs", [["contractIdPreimage", r.lookup("ContractIdPreimage")], ["executable", r.lookup("ContractExecutable")]]), r.struct("CreateContractArgsV2", [["contractIdPreimage", r.lookup("ContractIdPreimage")], ["executable", r.lookup("ContractExecutable")], ["constructorArgs", r.varArray(r.lookup("ScVal"), 2147483647)]]), r.struct("InvokeContractArgs", [["contractAddress", r.lookup("ScAddress")], ["functionName", r.lookup("ScSymbol")], ["args", r.varArray(r.lookup("ScVal"), 2147483647)]]), r.union("HostFunction", { switchOn: r.lookup("HostFunctionType"), switchName: "type", switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]], arms: { invokeContract: r.lookup("InvokeContractArgs"), createContract: r.lookup("CreateContractArgs"), wasm: r.varOpaque(), createContractV2: r.lookup("CreateContractArgsV2") } }), r.enum("SorobanAuthorizedFunctionType", { sorobanAuthorizedFunctionTypeContractFn: 0, sorobanAuthorizedFunctionTypeCreateContractHostFn: 1, sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2 }), r.union("SorobanAuthorizedFunction", { switchOn: r.lookup("SorobanAuthorizedFunctionType"), switchName: "type", switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]], arms: { contractFn: r.lookup("InvokeContractArgs"), createContractHostFn: r.lookup("CreateContractArgs"), createContractV2HostFn: r.lookup("CreateContractArgsV2") } }), r.struct("SorobanAuthorizedInvocation", [["function", r.lookup("SorobanAuthorizedFunction")], ["subInvocations", r.varArray(r.lookup("SorobanAuthorizedInvocation"), 2147483647)]]), r.struct("SorobanAddressCredentials", [["address", r.lookup("ScAddress")], ["nonce", r.lookup("Int64")], ["signatureExpirationLedger", r.lookup("Uint32")], ["signature", r.lookup("ScVal")]]), r.enum("SorobanCredentialsType", { sorobanCredentialsSourceAccount: 0, sorobanCredentialsAddress: 1 }), r.union("SorobanCredentials", { switchOn: r.lookup("SorobanCredentialsType"), switchName: "type", switches: [["sorobanCredentialsSourceAccount", r.void()], ["sorobanCredentialsAddress", "address"]], arms: { address: r.lookup("SorobanAddressCredentials") } }), r.struct("SorobanAuthorizationEntry", [["credentials", r.lookup("SorobanCredentials")], ["rootInvocation", r.lookup("SorobanAuthorizedInvocation")]]), r.struct("InvokeHostFunctionOp", [["hostFunction", r.lookup("HostFunction")], ["auth", r.varArray(r.lookup("SorobanAuthorizationEntry"), 2147483647)]]), r.struct("ExtendFootprintTtlOp", [["ext", r.lookup("ExtensionPoint")], ["extendTo", r.lookup("Uint32")]]), r.struct("RestoreFootprintOp", [["ext", r.lookup("ExtensionPoint")]]), r.union("OperationBody", { switchOn: r.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", r.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", r.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]], arms: { createAccountOp: r.lookup("CreateAccountOp"), paymentOp: r.lookup("PaymentOp"), pathPaymentStrictReceiveOp: r.lookup("PathPaymentStrictReceiveOp"), manageSellOfferOp: r.lookup("ManageSellOfferOp"), createPassiveSellOfferOp: r.lookup("CreatePassiveSellOfferOp"), setOptionsOp: r.lookup("SetOptionsOp"), changeTrustOp: r.lookup("ChangeTrustOp"), allowTrustOp: r.lookup("AllowTrustOp"), destination: r.lookup("MuxedAccount"), manageDataOp: r.lookup("ManageDataOp"), bumpSequenceOp: r.lookup("BumpSequenceOp"), manageBuyOfferOp: r.lookup("ManageBuyOfferOp"), pathPaymentStrictSendOp: r.lookup("PathPaymentStrictSendOp"), createClaimableBalanceOp: r.lookup("CreateClaimableBalanceOp"), claimClaimableBalanceOp: r.lookup("ClaimClaimableBalanceOp"), beginSponsoringFutureReservesOp: r.lookup("BeginSponsoringFutureReservesOp"), revokeSponsorshipOp: r.lookup("RevokeSponsorshipOp"), clawbackOp: r.lookup("ClawbackOp"), clawbackClaimableBalanceOp: r.lookup("ClawbackClaimableBalanceOp"), setTrustLineFlagsOp: r.lookup("SetTrustLineFlagsOp"), liquidityPoolDepositOp: r.lookup("LiquidityPoolDepositOp"), liquidityPoolWithdrawOp: r.lookup("LiquidityPoolWithdrawOp"), invokeHostFunctionOp: r.lookup("InvokeHostFunctionOp"), extendFootprintTtlOp: r.lookup("ExtendFootprintTtlOp"), restoreFootprintOp: r.lookup("RestoreFootprintOp") } }), r.struct("Operation", [["sourceAccount", r.option(r.lookup("MuxedAccount"))], ["body", r.lookup("OperationBody")]]), r.struct("HashIdPreimageOperationId", [["sourceAccount", r.lookup("AccountId")], ["seqNum", r.lookup("SequenceNumber")], ["opNum", r.lookup("Uint32")]]), r.struct("HashIdPreimageRevokeId", [["sourceAccount", r.lookup("AccountId")], ["seqNum", r.lookup("SequenceNumber")], ["opNum", r.lookup("Uint32")], ["liquidityPoolId", r.lookup("PoolId")], ["asset", r.lookup("Asset")]]), r.struct("HashIdPreimageContractId", [["networkId", r.lookup("Hash")], ["contractIdPreimage", r.lookup("ContractIdPreimage")]]), r.struct("HashIdPreimageSorobanAuthorization", [["networkId", r.lookup("Hash")], ["nonce", r.lookup("Int64")], ["signatureExpirationLedger", r.lookup("Uint32")], ["invocation", r.lookup("SorobanAuthorizedInvocation")]]), r.union("HashIdPreimage", { switchOn: r.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]], arms: { operationId: r.lookup("HashIdPreimageOperationId"), revokeId: r.lookup("HashIdPreimageRevokeId"), contractId: r.lookup("HashIdPreimageContractId"), sorobanAuthorization: r.lookup("HashIdPreimageSorobanAuthorization") } }), r.enum("MemoType", { memoNone: 0, memoText: 1, memoId: 2, memoHash: 3, memoReturn: 4 }), r.union("Memo", { switchOn: r.lookup("MemoType"), switchName: "type", switches: [["memoNone", r.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]], arms: { text: r.string(28), id: r.lookup("Uint64"), hash: r.lookup("Hash"), retHash: r.lookup("Hash") } }), r.struct("TimeBounds", [["minTime", r.lookup("TimePoint")], ["maxTime", r.lookup("TimePoint")]]), r.struct("LedgerBounds", [["minLedger", r.lookup("Uint32")], ["maxLedger", r.lookup("Uint32")]]), r.struct("PreconditionsV2", [["timeBounds", r.option(r.lookup("TimeBounds"))], ["ledgerBounds", r.option(r.lookup("LedgerBounds"))], ["minSeqNum", r.option(r.lookup("SequenceNumber"))], ["minSeqAge", r.lookup("Duration")], ["minSeqLedgerGap", r.lookup("Uint32")], ["extraSigners", r.varArray(r.lookup("SignerKey"), 2)]]), r.enum("PreconditionType", { precondNone: 0, precondTime: 1, precondV2: 2 }), r.union("Preconditions", { switchOn: r.lookup("PreconditionType"), switchName: "type", switches: [["precondNone", r.void()], ["precondTime", "timeBounds"], ["precondV2", "v2"]], arms: { timeBounds: r.lookup("TimeBounds"), v2: r.lookup("PreconditionsV2") } }), r.struct("LedgerFootprint", [["readOnly", r.varArray(r.lookup("LedgerKey"), 2147483647)], ["readWrite", r.varArray(r.lookup("LedgerKey"), 2147483647)]]), r.enum("ArchivalProofType", { existence: 0, nonexistence: 1 }), r.struct("ArchivalProofNode", [["index", r.lookup("Uint32")], ["hash", r.lookup("Hash")]]), r.typedef("ProofLevel", r.varArray(r.lookup("ArchivalProofNode"), 2147483647)), r.struct("NonexistenceProofBody", [["entriesToProve", r.varArray(r.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", r.varArray(r.lookup("ProofLevel"), 2147483647)]]), r.struct("ExistenceProofBody", [["keysToProve", r.varArray(r.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", r.varArray(r.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", r.varArray(r.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", r.varArray(r.lookup("ProofLevel"), 2147483647)]]), r.union("ArchivalProofBody", { switchOn: r.lookup("ArchivalProofType"), switchName: "t", switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]], arms: { nonexistenceProof: r.lookup("NonexistenceProofBody"), existenceProof: r.lookup("ExistenceProofBody") } }), r.struct("ArchivalProof", [["epoch", r.lookup("Uint32")], ["body", r.lookup("ArchivalProofBody")]]), r.struct("SorobanResources", [["footprint", r.lookup("LedgerFootprint")], ["instructions", r.lookup("Uint32")], ["readBytes", r.lookup("Uint32")], ["writeBytes", r.lookup("Uint32")]]), r.struct("SorobanTransactionData", [["ext", r.lookup("ExtensionPoint")], ["resources", r.lookup("SorobanResources")], ["resourceFee", r.lookup("Int64")]]), r.union("TransactionV0Ext", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("TransactionV0", [["sourceAccountEd25519", r.lookup("Uint256")], ["fee", r.lookup("Uint32")], ["seqNum", r.lookup("SequenceNumber")], ["timeBounds", r.option(r.lookup("TimeBounds"))], ["memo", r.lookup("Memo")], ["operations", r.varArray(r.lookup("Operation"), r.lookup("MAX_OPS_PER_TX"))], ["ext", r.lookup("TransactionV0Ext")]]), r.struct("TransactionV0Envelope", [["tx", r.lookup("TransactionV0")], ["signatures", r.varArray(r.lookup("DecoratedSignature"), 20)]]), r.union("TransactionExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()], [1, "sorobanData"]], arms: { sorobanData: r.lookup("SorobanTransactionData") } }), r.struct("Transaction", [["sourceAccount", r.lookup("MuxedAccount")], ["fee", r.lookup("Uint32")], ["seqNum", r.lookup("SequenceNumber")], ["cond", r.lookup("Preconditions")], ["memo", r.lookup("Memo")], ["operations", r.varArray(r.lookup("Operation"), r.lookup("MAX_OPS_PER_TX"))], ["ext", r.lookup("TransactionExt")]]), r.struct("TransactionV1Envelope", [["tx", r.lookup("Transaction")], ["signatures", r.varArray(r.lookup("DecoratedSignature"), 20)]]), r.union("FeeBumpTransactionInnerTx", { switchOn: r.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "v1"]], arms: { v1: r.lookup("TransactionV1Envelope") } }), r.union("FeeBumpTransactionExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("FeeBumpTransaction", [["feeSource", r.lookup("MuxedAccount")], ["fee", r.lookup("Int64")], ["innerTx", r.lookup("FeeBumpTransactionInnerTx")], ["ext", r.lookup("FeeBumpTransactionExt")]]), r.struct("FeeBumpTransactionEnvelope", [["tx", r.lookup("FeeBumpTransaction")], ["signatures", r.varArray(r.lookup("DecoratedSignature"), 20)]]), r.union("TransactionEnvelope", { switchOn: r.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { v0: r.lookup("TransactionV0Envelope"), v1: r.lookup("TransactionV1Envelope"), feeBump: r.lookup("FeeBumpTransactionEnvelope") } }), r.union("TransactionSignaturePayloadTaggedTransaction", { switchOn: r.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { tx: r.lookup("Transaction"), feeBump: r.lookup("FeeBumpTransaction") } }), r.struct("TransactionSignaturePayload", [["networkId", r.lookup("Hash")], ["taggedTransaction", r.lookup("TransactionSignaturePayloadTaggedTransaction")]]), r.enum("ClaimAtomType", { claimAtomTypeV0: 0, claimAtomTypeOrderBook: 1, claimAtomTypeLiquidityPool: 2 }), r.struct("ClaimOfferAtomV0", [["sellerEd25519", r.lookup("Uint256")], ["offerId", r.lookup("Int64")], ["assetSold", r.lookup("Asset")], ["amountSold", r.lookup("Int64")], ["assetBought", r.lookup("Asset")], ["amountBought", r.lookup("Int64")]]), r.struct("ClaimOfferAtom", [["sellerId", r.lookup("AccountId")], ["offerId", r.lookup("Int64")], ["assetSold", r.lookup("Asset")], ["amountSold", r.lookup("Int64")], ["assetBought", r.lookup("Asset")], ["amountBought", r.lookup("Int64")]]), r.struct("ClaimLiquidityAtom", [["liquidityPoolId", r.lookup("PoolId")], ["assetSold", r.lookup("Asset")], ["amountSold", r.lookup("Int64")], ["assetBought", r.lookup("Asset")], ["amountBought", r.lookup("Int64")]]), r.union("ClaimAtom", { switchOn: r.lookup("ClaimAtomType"), switchName: "type", switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]], arms: { v0: r.lookup("ClaimOfferAtomV0"), orderBook: r.lookup("ClaimOfferAtom"), liquidityPool: r.lookup("ClaimLiquidityAtom") } }), r.enum("CreateAccountResultCode", { createAccountSuccess: 0, createAccountMalformed: -1, createAccountUnderfunded: -2, createAccountLowReserve: -3, createAccountAlreadyExist: -4 }), r.union("CreateAccountResult", { switchOn: r.lookup("CreateAccountResultCode"), switchName: "code", switches: [["createAccountSuccess", r.void()], ["createAccountMalformed", r.void()], ["createAccountUnderfunded", r.void()], ["createAccountLowReserve", r.void()], ["createAccountAlreadyExist", r.void()]], arms: {} }), r.enum("PaymentResultCode", { paymentSuccess: 0, paymentMalformed: -1, paymentUnderfunded: -2, paymentSrcNoTrust: -3, paymentSrcNotAuthorized: -4, paymentNoDestination: -5, paymentNoTrust: -6, paymentNotAuthorized: -7, paymentLineFull: -8, paymentNoIssuer: -9 }), r.union("PaymentResult", { switchOn: r.lookup("PaymentResultCode"), switchName: "code", switches: [["paymentSuccess", r.void()], ["paymentMalformed", r.void()], ["paymentUnderfunded", r.void()], ["paymentSrcNoTrust", r.void()], ["paymentSrcNotAuthorized", r.void()], ["paymentNoDestination", r.void()], ["paymentNoTrust", r.void()], ["paymentNotAuthorized", r.void()], ["paymentLineFull", r.void()], ["paymentNoIssuer", r.void()]], arms: {} }), r.enum("PathPaymentStrictReceiveResultCode", { pathPaymentStrictReceiveSuccess: 0, pathPaymentStrictReceiveMalformed: -1, pathPaymentStrictReceiveUnderfunded: -2, pathPaymentStrictReceiveSrcNoTrust: -3, pathPaymentStrictReceiveSrcNotAuthorized: -4, pathPaymentStrictReceiveNoDestination: -5, pathPaymentStrictReceiveNoTrust: -6, pathPaymentStrictReceiveNotAuthorized: -7, pathPaymentStrictReceiveLineFull: -8, pathPaymentStrictReceiveNoIssuer: -9, pathPaymentStrictReceiveTooFewOffers: -10, pathPaymentStrictReceiveOfferCrossSelf: -11, pathPaymentStrictReceiveOverSendmax: -12 }), r.struct("SimplePaymentResult", [["destination", r.lookup("AccountId")], ["asset", r.lookup("Asset")], ["amount", r.lookup("Int64")]]), r.struct("PathPaymentStrictReceiveResultSuccess", [["offers", r.varArray(r.lookup("ClaimAtom"), 2147483647)], ["last", r.lookup("SimplePaymentResult")]]), r.union("PathPaymentStrictReceiveResult", { switchOn: r.lookup("PathPaymentStrictReceiveResultCode"), switchName: "code", switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", r.void()], ["pathPaymentStrictReceiveUnderfunded", r.void()], ["pathPaymentStrictReceiveSrcNoTrust", r.void()], ["pathPaymentStrictReceiveSrcNotAuthorized", r.void()], ["pathPaymentStrictReceiveNoDestination", r.void()], ["pathPaymentStrictReceiveNoTrust", r.void()], ["pathPaymentStrictReceiveNotAuthorized", r.void()], ["pathPaymentStrictReceiveLineFull", r.void()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", r.void()], ["pathPaymentStrictReceiveOfferCrossSelf", r.void()], ["pathPaymentStrictReceiveOverSendmax", r.void()]], arms: { success: r.lookup("PathPaymentStrictReceiveResultSuccess"), noIssuer: r.lookup("Asset") } }), r.enum("PathPaymentStrictSendResultCode", { pathPaymentStrictSendSuccess: 0, pathPaymentStrictSendMalformed: -1, pathPaymentStrictSendUnderfunded: -2, pathPaymentStrictSendSrcNoTrust: -3, pathPaymentStrictSendSrcNotAuthorized: -4, pathPaymentStrictSendNoDestination: -5, pathPaymentStrictSendNoTrust: -6, pathPaymentStrictSendNotAuthorized: -7, pathPaymentStrictSendLineFull: -8, pathPaymentStrictSendNoIssuer: -9, pathPaymentStrictSendTooFewOffers: -10, pathPaymentStrictSendOfferCrossSelf: -11, pathPaymentStrictSendUnderDestmin: -12 }), r.struct("PathPaymentStrictSendResultSuccess", [["offers", r.varArray(r.lookup("ClaimAtom"), 2147483647)], ["last", r.lookup("SimplePaymentResult")]]), r.union("PathPaymentStrictSendResult", { switchOn: r.lookup("PathPaymentStrictSendResultCode"), switchName: "code", switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", r.void()], ["pathPaymentStrictSendUnderfunded", r.void()], ["pathPaymentStrictSendSrcNoTrust", r.void()], ["pathPaymentStrictSendSrcNotAuthorized", r.void()], ["pathPaymentStrictSendNoDestination", r.void()], ["pathPaymentStrictSendNoTrust", r.void()], ["pathPaymentStrictSendNotAuthorized", r.void()], ["pathPaymentStrictSendLineFull", r.void()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", r.void()], ["pathPaymentStrictSendOfferCrossSelf", r.void()], ["pathPaymentStrictSendUnderDestmin", r.void()]], arms: { success: r.lookup("PathPaymentStrictSendResultSuccess"), noIssuer: r.lookup("Asset") } }), r.enum("ManageSellOfferResultCode", { manageSellOfferSuccess: 0, manageSellOfferMalformed: -1, manageSellOfferSellNoTrust: -2, manageSellOfferBuyNoTrust: -3, manageSellOfferSellNotAuthorized: -4, manageSellOfferBuyNotAuthorized: -5, manageSellOfferLineFull: -6, manageSellOfferUnderfunded: -7, manageSellOfferCrossSelf: -8, manageSellOfferSellNoIssuer: -9, manageSellOfferBuyNoIssuer: -10, manageSellOfferNotFound: -11, manageSellOfferLowReserve: -12 }), r.enum("ManageOfferEffect", { manageOfferCreated: 0, manageOfferUpdated: 1, manageOfferDeleted: 2 }), r.union("ManageOfferSuccessResultOffer", { switchOn: r.lookup("ManageOfferEffect"), switchName: "effect", switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", r.void()]], arms: { offer: r.lookup("OfferEntry") } }), r.struct("ManageOfferSuccessResult", [["offersClaimed", r.varArray(r.lookup("ClaimAtom"), 2147483647)], ["offer", r.lookup("ManageOfferSuccessResultOffer")]]), r.union("ManageSellOfferResult", { switchOn: r.lookup("ManageSellOfferResultCode"), switchName: "code", switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", r.void()], ["manageSellOfferSellNoTrust", r.void()], ["manageSellOfferBuyNoTrust", r.void()], ["manageSellOfferSellNotAuthorized", r.void()], ["manageSellOfferBuyNotAuthorized", r.void()], ["manageSellOfferLineFull", r.void()], ["manageSellOfferUnderfunded", r.void()], ["manageSellOfferCrossSelf", r.void()], ["manageSellOfferSellNoIssuer", r.void()], ["manageSellOfferBuyNoIssuer", r.void()], ["manageSellOfferNotFound", r.void()], ["manageSellOfferLowReserve", r.void()]], arms: { success: r.lookup("ManageOfferSuccessResult") } }), r.enum("ManageBuyOfferResultCode", { manageBuyOfferSuccess: 0, manageBuyOfferMalformed: -1, manageBuyOfferSellNoTrust: -2, manageBuyOfferBuyNoTrust: -3, manageBuyOfferSellNotAuthorized: -4, manageBuyOfferBuyNotAuthorized: -5, manageBuyOfferLineFull: -6, manageBuyOfferUnderfunded: -7, manageBuyOfferCrossSelf: -8, manageBuyOfferSellNoIssuer: -9, manageBuyOfferBuyNoIssuer: -10, manageBuyOfferNotFound: -11, manageBuyOfferLowReserve: -12 }), r.union("ManageBuyOfferResult", { switchOn: r.lookup("ManageBuyOfferResultCode"), switchName: "code", switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", r.void()], ["manageBuyOfferSellNoTrust", r.void()], ["manageBuyOfferBuyNoTrust", r.void()], ["manageBuyOfferSellNotAuthorized", r.void()], ["manageBuyOfferBuyNotAuthorized", r.void()], ["manageBuyOfferLineFull", r.void()], ["manageBuyOfferUnderfunded", r.void()], ["manageBuyOfferCrossSelf", r.void()], ["manageBuyOfferSellNoIssuer", r.void()], ["manageBuyOfferBuyNoIssuer", r.void()], ["manageBuyOfferNotFound", r.void()], ["manageBuyOfferLowReserve", r.void()]], arms: { success: r.lookup("ManageOfferSuccessResult") } }), r.enum("SetOptionsResultCode", { setOptionsSuccess: 0, setOptionsLowReserve: -1, setOptionsTooManySigners: -2, setOptionsBadFlags: -3, setOptionsInvalidInflation: -4, setOptionsCantChange: -5, setOptionsUnknownFlag: -6, setOptionsThresholdOutOfRange: -7, setOptionsBadSigner: -8, setOptionsInvalidHomeDomain: -9, setOptionsAuthRevocableRequired: -10 }), r.union("SetOptionsResult", { switchOn: r.lookup("SetOptionsResultCode"), switchName: "code", switches: [["setOptionsSuccess", r.void()], ["setOptionsLowReserve", r.void()], ["setOptionsTooManySigners", r.void()], ["setOptionsBadFlags", r.void()], ["setOptionsInvalidInflation", r.void()], ["setOptionsCantChange", r.void()], ["setOptionsUnknownFlag", r.void()], ["setOptionsThresholdOutOfRange", r.void()], ["setOptionsBadSigner", r.void()], ["setOptionsInvalidHomeDomain", r.void()], ["setOptionsAuthRevocableRequired", r.void()]], arms: {} }), r.enum("ChangeTrustResultCode", { changeTrustSuccess: 0, changeTrustMalformed: -1, changeTrustNoIssuer: -2, changeTrustInvalidLimit: -3, changeTrustLowReserve: -4, changeTrustSelfNotAllowed: -5, changeTrustTrustLineMissing: -6, changeTrustCannotDelete: -7, changeTrustNotAuthMaintainLiabilities: -8 }), r.union("ChangeTrustResult", { switchOn: r.lookup("ChangeTrustResultCode"), switchName: "code", switches: [["changeTrustSuccess", r.void()], ["changeTrustMalformed", r.void()], ["changeTrustNoIssuer", r.void()], ["changeTrustInvalidLimit", r.void()], ["changeTrustLowReserve", r.void()], ["changeTrustSelfNotAllowed", r.void()], ["changeTrustTrustLineMissing", r.void()], ["changeTrustCannotDelete", r.void()], ["changeTrustNotAuthMaintainLiabilities", r.void()]], arms: {} }), r.enum("AllowTrustResultCode", { allowTrustSuccess: 0, allowTrustMalformed: -1, allowTrustNoTrustLine: -2, allowTrustTrustNotRequired: -3, allowTrustCantRevoke: -4, allowTrustSelfNotAllowed: -5, allowTrustLowReserve: -6 }), r.union("AllowTrustResult", { switchOn: r.lookup("AllowTrustResultCode"), switchName: "code", switches: [["allowTrustSuccess", r.void()], ["allowTrustMalformed", r.void()], ["allowTrustNoTrustLine", r.void()], ["allowTrustTrustNotRequired", r.void()], ["allowTrustCantRevoke", r.void()], ["allowTrustSelfNotAllowed", r.void()], ["allowTrustLowReserve", r.void()]], arms: {} }), r.enum("AccountMergeResultCode", { accountMergeSuccess: 0, accountMergeMalformed: -1, accountMergeNoAccount: -2, accountMergeImmutableSet: -3, accountMergeHasSubEntries: -4, accountMergeSeqnumTooFar: -5, accountMergeDestFull: -6, accountMergeIsSponsor: -7 }), r.union("AccountMergeResult", { switchOn: r.lookup("AccountMergeResultCode"), switchName: "code", switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", r.void()], ["accountMergeNoAccount", r.void()], ["accountMergeImmutableSet", r.void()], ["accountMergeHasSubEntries", r.void()], ["accountMergeSeqnumTooFar", r.void()], ["accountMergeDestFull", r.void()], ["accountMergeIsSponsor", r.void()]], arms: { sourceAccountBalance: r.lookup("Int64") } }), r.enum("InflationResultCode", { inflationSuccess: 0, inflationNotTime: -1 }), r.struct("InflationPayout", [["destination", r.lookup("AccountId")], ["amount", r.lookup("Int64")]]), r.union("InflationResult", { switchOn: r.lookup("InflationResultCode"), switchName: "code", switches: [["inflationSuccess", "payouts"], ["inflationNotTime", r.void()]], arms: { payouts: r.varArray(r.lookup("InflationPayout"), 2147483647) } }), r.enum("ManageDataResultCode", { manageDataSuccess: 0, manageDataNotSupportedYet: -1, manageDataNameNotFound: -2, manageDataLowReserve: -3, manageDataInvalidName: -4 }), r.union("ManageDataResult", { switchOn: r.lookup("ManageDataResultCode"), switchName: "code", switches: [["manageDataSuccess", r.void()], ["manageDataNotSupportedYet", r.void()], ["manageDataNameNotFound", r.void()], ["manageDataLowReserve", r.void()], ["manageDataInvalidName", r.void()]], arms: {} }), r.enum("BumpSequenceResultCode", { bumpSequenceSuccess: 0, bumpSequenceBadSeq: -1 }), r.union("BumpSequenceResult", { switchOn: r.lookup("BumpSequenceResultCode"), switchName: "code", switches: [["bumpSequenceSuccess", r.void()], ["bumpSequenceBadSeq", r.void()]], arms: {} }), r.enum("CreateClaimableBalanceResultCode", { createClaimableBalanceSuccess: 0, createClaimableBalanceMalformed: -1, createClaimableBalanceLowReserve: -2, createClaimableBalanceNoTrust: -3, createClaimableBalanceNotAuthorized: -4, createClaimableBalanceUnderfunded: -5 }), r.union("CreateClaimableBalanceResult", { switchOn: r.lookup("CreateClaimableBalanceResultCode"), switchName: "code", switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", r.void()], ["createClaimableBalanceLowReserve", r.void()], ["createClaimableBalanceNoTrust", r.void()], ["createClaimableBalanceNotAuthorized", r.void()], ["createClaimableBalanceUnderfunded", r.void()]], arms: { balanceId: r.lookup("ClaimableBalanceId") } }), r.enum("ClaimClaimableBalanceResultCode", { claimClaimableBalanceSuccess: 0, claimClaimableBalanceDoesNotExist: -1, claimClaimableBalanceCannotClaim: -2, claimClaimableBalanceLineFull: -3, claimClaimableBalanceNoTrust: -4, claimClaimableBalanceNotAuthorized: -5 }), r.union("ClaimClaimableBalanceResult", { switchOn: r.lookup("ClaimClaimableBalanceResultCode"), switchName: "code", switches: [["claimClaimableBalanceSuccess", r.void()], ["claimClaimableBalanceDoesNotExist", r.void()], ["claimClaimableBalanceCannotClaim", r.void()], ["claimClaimableBalanceLineFull", r.void()], ["claimClaimableBalanceNoTrust", r.void()], ["claimClaimableBalanceNotAuthorized", r.void()]], arms: {} }), r.enum("BeginSponsoringFutureReservesResultCode", { beginSponsoringFutureReservesSuccess: 0, beginSponsoringFutureReservesMalformed: -1, beginSponsoringFutureReservesAlreadySponsored: -2, beginSponsoringFutureReservesRecursive: -3 }), r.union("BeginSponsoringFutureReservesResult", { switchOn: r.lookup("BeginSponsoringFutureReservesResultCode"), switchName: "code", switches: [["beginSponsoringFutureReservesSuccess", r.void()], ["beginSponsoringFutureReservesMalformed", r.void()], ["beginSponsoringFutureReservesAlreadySponsored", r.void()], ["beginSponsoringFutureReservesRecursive", r.void()]], arms: {} }), r.enum("EndSponsoringFutureReservesResultCode", { endSponsoringFutureReservesSuccess: 0, endSponsoringFutureReservesNotSponsored: -1 }), r.union("EndSponsoringFutureReservesResult", { switchOn: r.lookup("EndSponsoringFutureReservesResultCode"), switchName: "code", switches: [["endSponsoringFutureReservesSuccess", r.void()], ["endSponsoringFutureReservesNotSponsored", r.void()]], arms: {} }), r.enum("RevokeSponsorshipResultCode", { revokeSponsorshipSuccess: 0, revokeSponsorshipDoesNotExist: -1, revokeSponsorshipNotSponsor: -2, revokeSponsorshipLowReserve: -3, revokeSponsorshipOnlyTransferable: -4, revokeSponsorshipMalformed: -5 }), r.union("RevokeSponsorshipResult", { switchOn: r.lookup("RevokeSponsorshipResultCode"), switchName: "code", switches: [["revokeSponsorshipSuccess", r.void()], ["revokeSponsorshipDoesNotExist", r.void()], ["revokeSponsorshipNotSponsor", r.void()], ["revokeSponsorshipLowReserve", r.void()], ["revokeSponsorshipOnlyTransferable", r.void()], ["revokeSponsorshipMalformed", r.void()]], arms: {} }), r.enum("ClawbackResultCode", { clawbackSuccess: 0, clawbackMalformed: -1, clawbackNotClawbackEnabled: -2, clawbackNoTrust: -3, clawbackUnderfunded: -4 }), r.union("ClawbackResult", { switchOn: r.lookup("ClawbackResultCode"), switchName: "code", switches: [["clawbackSuccess", r.void()], ["clawbackMalformed", r.void()], ["clawbackNotClawbackEnabled", r.void()], ["clawbackNoTrust", r.void()], ["clawbackUnderfunded", r.void()]], arms: {} }), r.enum("ClawbackClaimableBalanceResultCode", { clawbackClaimableBalanceSuccess: 0, clawbackClaimableBalanceDoesNotExist: -1, clawbackClaimableBalanceNotIssuer: -2, clawbackClaimableBalanceNotClawbackEnabled: -3 }), r.union("ClawbackClaimableBalanceResult", { switchOn: r.lookup("ClawbackClaimableBalanceResultCode"), switchName: "code", switches: [["clawbackClaimableBalanceSuccess", r.void()], ["clawbackClaimableBalanceDoesNotExist", r.void()], ["clawbackClaimableBalanceNotIssuer", r.void()], ["clawbackClaimableBalanceNotClawbackEnabled", r.void()]], arms: {} }), r.enum("SetTrustLineFlagsResultCode", { setTrustLineFlagsSuccess: 0, setTrustLineFlagsMalformed: -1, setTrustLineFlagsNoTrustLine: -2, setTrustLineFlagsCantRevoke: -3, setTrustLineFlagsInvalidState: -4, setTrustLineFlagsLowReserve: -5 }), r.union("SetTrustLineFlagsResult", { switchOn: r.lookup("SetTrustLineFlagsResultCode"), switchName: "code", switches: [["setTrustLineFlagsSuccess", r.void()], ["setTrustLineFlagsMalformed", r.void()], ["setTrustLineFlagsNoTrustLine", r.void()], ["setTrustLineFlagsCantRevoke", r.void()], ["setTrustLineFlagsInvalidState", r.void()], ["setTrustLineFlagsLowReserve", r.void()]], arms: {} }), r.enum("LiquidityPoolDepositResultCode", { liquidityPoolDepositSuccess: 0, liquidityPoolDepositMalformed: -1, liquidityPoolDepositNoTrust: -2, liquidityPoolDepositNotAuthorized: -3, liquidityPoolDepositUnderfunded: -4, liquidityPoolDepositLineFull: -5, liquidityPoolDepositBadPrice: -6, liquidityPoolDepositPoolFull: -7 }), r.union("LiquidityPoolDepositResult", { switchOn: r.lookup("LiquidityPoolDepositResultCode"), switchName: "code", switches: [["liquidityPoolDepositSuccess", r.void()], ["liquidityPoolDepositMalformed", r.void()], ["liquidityPoolDepositNoTrust", r.void()], ["liquidityPoolDepositNotAuthorized", r.void()], ["liquidityPoolDepositUnderfunded", r.void()], ["liquidityPoolDepositLineFull", r.void()], ["liquidityPoolDepositBadPrice", r.void()], ["liquidityPoolDepositPoolFull", r.void()]], arms: {} }), r.enum("LiquidityPoolWithdrawResultCode", { liquidityPoolWithdrawSuccess: 0, liquidityPoolWithdrawMalformed: -1, liquidityPoolWithdrawNoTrust: -2, liquidityPoolWithdrawUnderfunded: -3, liquidityPoolWithdrawLineFull: -4, liquidityPoolWithdrawUnderMinimum: -5 }), r.union("LiquidityPoolWithdrawResult", { switchOn: r.lookup("LiquidityPoolWithdrawResultCode"), switchName: "code", switches: [["liquidityPoolWithdrawSuccess", r.void()], ["liquidityPoolWithdrawMalformed", r.void()], ["liquidityPoolWithdrawNoTrust", r.void()], ["liquidityPoolWithdrawUnderfunded", r.void()], ["liquidityPoolWithdrawLineFull", r.void()], ["liquidityPoolWithdrawUnderMinimum", r.void()]], arms: {} }), r.enum("InvokeHostFunctionResultCode", { invokeHostFunctionSuccess: 0, invokeHostFunctionMalformed: -1, invokeHostFunctionTrapped: -2, invokeHostFunctionResourceLimitExceeded: -3, invokeHostFunctionEntryArchived: -4, invokeHostFunctionInsufficientRefundableFee: -5 }), r.union("InvokeHostFunctionResult", { switchOn: r.lookup("InvokeHostFunctionResultCode"), switchName: "code", switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", r.void()], ["invokeHostFunctionTrapped", r.void()], ["invokeHostFunctionResourceLimitExceeded", r.void()], ["invokeHostFunctionEntryArchived", r.void()], ["invokeHostFunctionInsufficientRefundableFee", r.void()]], arms: { success: r.lookup("Hash") } }), r.enum("ExtendFootprintTtlResultCode", { extendFootprintTtlSuccess: 0, extendFootprintTtlMalformed: -1, extendFootprintTtlResourceLimitExceeded: -2, extendFootprintTtlInsufficientRefundableFee: -3 }), r.union("ExtendFootprintTtlResult", { switchOn: r.lookup("ExtendFootprintTtlResultCode"), switchName: "code", switches: [["extendFootprintTtlSuccess", r.void()], ["extendFootprintTtlMalformed", r.void()], ["extendFootprintTtlResourceLimitExceeded", r.void()], ["extendFootprintTtlInsufficientRefundableFee", r.void()]], arms: {} }), r.enum("RestoreFootprintResultCode", { restoreFootprintSuccess: 0, restoreFootprintMalformed: -1, restoreFootprintResourceLimitExceeded: -2, restoreFootprintInsufficientRefundableFee: -3 }), r.union("RestoreFootprintResult", { switchOn: r.lookup("RestoreFootprintResultCode"), switchName: "code", switches: [["restoreFootprintSuccess", r.void()], ["restoreFootprintMalformed", r.void()], ["restoreFootprintResourceLimitExceeded", r.void()], ["restoreFootprintInsufficientRefundableFee", r.void()]], arms: {} }), r.enum("OperationResultCode", { opInner: 0, opBadAuth: -1, opNoAccount: -2, opNotSupported: -3, opTooManySubentries: -4, opExceededWorkLimit: -5, opTooManySponsoring: -6 }), r.union("OperationResultTr", { switchOn: r.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]], arms: { createAccountResult: r.lookup("CreateAccountResult"), paymentResult: r.lookup("PaymentResult"), pathPaymentStrictReceiveResult: r.lookup("PathPaymentStrictReceiveResult"), manageSellOfferResult: r.lookup("ManageSellOfferResult"), createPassiveSellOfferResult: r.lookup("ManageSellOfferResult"), setOptionsResult: r.lookup("SetOptionsResult"), changeTrustResult: r.lookup("ChangeTrustResult"), allowTrustResult: r.lookup("AllowTrustResult"), accountMergeResult: r.lookup("AccountMergeResult"), inflationResult: r.lookup("InflationResult"), manageDataResult: r.lookup("ManageDataResult"), bumpSeqResult: r.lookup("BumpSequenceResult"), manageBuyOfferResult: r.lookup("ManageBuyOfferResult"), pathPaymentStrictSendResult: r.lookup("PathPaymentStrictSendResult"), createClaimableBalanceResult: r.lookup("CreateClaimableBalanceResult"), claimClaimableBalanceResult: r.lookup("ClaimClaimableBalanceResult"), beginSponsoringFutureReservesResult: r.lookup("BeginSponsoringFutureReservesResult"), endSponsoringFutureReservesResult: r.lookup("EndSponsoringFutureReservesResult"), revokeSponsorshipResult: r.lookup("RevokeSponsorshipResult"), clawbackResult: r.lookup("ClawbackResult"), clawbackClaimableBalanceResult: r.lookup("ClawbackClaimableBalanceResult"), setTrustLineFlagsResult: r.lookup("SetTrustLineFlagsResult"), liquidityPoolDepositResult: r.lookup("LiquidityPoolDepositResult"), liquidityPoolWithdrawResult: r.lookup("LiquidityPoolWithdrawResult"), invokeHostFunctionResult: r.lookup("InvokeHostFunctionResult"), extendFootprintTtlResult: r.lookup("ExtendFootprintTtlResult"), restoreFootprintResult: r.lookup("RestoreFootprintResult") } }), r.union("OperationResult", { switchOn: r.lookup("OperationResultCode"), switchName: "code", switches: [["opInner", "tr"], ["opBadAuth", r.void()], ["opNoAccount", r.void()], ["opNotSupported", r.void()], ["opTooManySubentries", r.void()], ["opExceededWorkLimit", r.void()], ["opTooManySponsoring", r.void()]], arms: { tr: r.lookup("OperationResultTr") } }), r.enum("TransactionResultCode", { txFeeBumpInnerSuccess: 1, txSuccess: 0, txFailed: -1, txTooEarly: -2, txTooLate: -3, txMissingOperation: -4, txBadSeq: -5, txBadAuth: -6, txInsufficientBalance: -7, txNoAccount: -8, txInsufficientFee: -9, txBadAuthExtra: -10, txInternalError: -11, txNotSupported: -12, txFeeBumpInnerFailed: -13, txBadSponsorship: -14, txBadMinSeqAgeOrGap: -15, txMalformed: -16, txSorobanInvalid: -17 }), r.union("InnerTransactionResultResult", { switchOn: r.lookup("TransactionResultCode"), switchName: "code", switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", r.void()], ["txTooLate", r.void()], ["txMissingOperation", r.void()], ["txBadSeq", r.void()], ["txBadAuth", r.void()], ["txInsufficientBalance", r.void()], ["txNoAccount", r.void()], ["txInsufficientFee", r.void()], ["txBadAuthExtra", r.void()], ["txInternalError", r.void()], ["txNotSupported", r.void()], ["txBadSponsorship", r.void()], ["txBadMinSeqAgeOrGap", r.void()], ["txMalformed", r.void()], ["txSorobanInvalid", r.void()]], arms: { results: r.varArray(r.lookup("OperationResult"), 2147483647) } }), r.union("InnerTransactionResultExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("InnerTransactionResult", [["feeCharged", r.lookup("Int64")], ["result", r.lookup("InnerTransactionResultResult")], ["ext", r.lookup("InnerTransactionResultExt")]]), r.struct("InnerTransactionResultPair", [["transactionHash", r.lookup("Hash")], ["result", r.lookup("InnerTransactionResult")]]), r.union("TransactionResultResult", { switchOn: r.lookup("TransactionResultCode"), switchName: "code", switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", r.void()], ["txTooLate", r.void()], ["txMissingOperation", r.void()], ["txBadSeq", r.void()], ["txBadAuth", r.void()], ["txInsufficientBalance", r.void()], ["txNoAccount", r.void()], ["txInsufficientFee", r.void()], ["txBadAuthExtra", r.void()], ["txInternalError", r.void()], ["txNotSupported", r.void()], ["txBadSponsorship", r.void()], ["txBadMinSeqAgeOrGap", r.void()], ["txMalformed", r.void()], ["txSorobanInvalid", r.void()]], arms: { innerResultPair: r.lookup("InnerTransactionResultPair"), results: r.varArray(r.lookup("OperationResult"), 2147483647) } }), r.union("TransactionResultExt", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.struct("TransactionResult", [["feeCharged", r.lookup("Int64")], ["result", r.lookup("TransactionResultResult")], ["ext", r.lookup("TransactionResultExt")]]), r.typedef("Hash", r.opaque(32)), r.typedef("Uint256", r.opaque(32)), r.typedef("Uint32", r.uint()), r.typedef("Int32", r.int()), r.typedef("Uint64", r.uhyper()), r.typedef("Int64", r.hyper()), r.typedef("TimePoint", r.lookup("Uint64")), r.typedef("Duration", r.lookup("Uint64")), r.union("ExtensionPoint", { switchOn: r.int(), switchName: "v", switches: [[0, r.void()]], arms: {} }), r.enum("CryptoKeyType", { keyTypeEd25519: 0, keyTypePreAuthTx: 1, keyTypeHashX: 2, keyTypeEd25519SignedPayload: 3, keyTypeMuxedEd25519: 256 }), r.enum("PublicKeyType", { publicKeyTypeEd25519: 0 }), r.enum("SignerKeyType", { signerKeyTypeEd25519: 0, signerKeyTypePreAuthTx: 1, signerKeyTypeHashX: 2, signerKeyTypeEd25519SignedPayload: 3 }), r.union("PublicKey", { switchOn: r.lookup("PublicKeyType"), switchName: "type", switches: [["publicKeyTypeEd25519", "ed25519"]], arms: { ed25519: r.lookup("Uint256") } }), r.struct("SignerKeyEd25519SignedPayload", [["ed25519", r.lookup("Uint256")], ["payload", r.varOpaque(64)]]), r.union("SignerKey", { switchOn: r.lookup("SignerKeyType"), switchName: "type", switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]], arms: { ed25519: r.lookup("Uint256"), preAuthTx: r.lookup("Uint256"), hashX: r.lookup("Uint256"), ed25519SignedPayload: r.lookup("SignerKeyEd25519SignedPayload") } }), r.typedef("Signature", r.varOpaque(64)), r.typedef("SignatureHint", r.opaque(4)), r.typedef("NodeId", r.lookup("PublicKey")), r.typedef("AccountId", r.lookup("PublicKey")), r.struct("Curve25519Secret", [["key", r.opaque(32)]]), r.struct("Curve25519Public", [["key", r.opaque(32)]]), r.struct("HmacSha256Key", [["key", r.opaque(32)]]), r.struct("HmacSha256Mac", [["mac", r.opaque(32)]]), r.struct("ShortHashSeed", [["seed", r.opaque(16)]]), r.enum("BinaryFuseFilterType", { binaryFuseFilter8Bit: 0, binaryFuseFilter16Bit: 1, binaryFuseFilter32Bit: 2 }), r.struct("SerializedBinaryFuseFilter", [["type", r.lookup("BinaryFuseFilterType")], ["inputHashSeed", r.lookup("ShortHashSeed")], ["filterSeed", r.lookup("ShortHashSeed")], ["segmentLength", r.lookup("Uint32")], ["segementLengthMask", r.lookup("Uint32")], ["segmentCount", r.lookup("Uint32")], ["segmentCountLength", r.lookup("Uint32")], ["fingerprintLength", r.lookup("Uint32")], ["fingerprints", r.varOpaque()]]), r.enum("ScValType", { scvBool: 0, scvVoid: 1, scvError: 2, scvU32: 3, scvI32: 4, scvU64: 5, scvI64: 6, scvTimepoint: 7, scvDuration: 8, scvU128: 9, scvI128: 10, scvU256: 11, scvI256: 12, scvBytes: 13, scvString: 14, scvSymbol: 15, scvVec: 16, scvMap: 17, scvAddress: 18, scvContractInstance: 19, scvLedgerKeyContractInstance: 20, scvLedgerKeyNonce: 21 }), r.enum("ScErrorType", { sceContract: 0, sceWasmVm: 1, sceContext: 2, sceStorage: 3, sceObject: 4, sceCrypto: 5, sceEvents: 6, sceBudget: 7, sceValue: 8, sceAuth: 9 }), r.enum("ScErrorCode", { scecArithDomain: 0, scecIndexBounds: 1, scecInvalidInput: 2, scecMissingValue: 3, scecExistingValue: 4, scecExceededLimit: 5, scecInvalidAction: 6, scecInternalError: 7, scecUnexpectedType: 8, scecUnexpectedSize: 9 }), r.union("ScError", { switchOn: r.lookup("ScErrorType"), switchName: "type", switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]], arms: { contractCode: r.lookup("Uint32"), code: r.lookup("ScErrorCode") } }), r.struct("UInt128Parts", [["hi", r.lookup("Uint64")], ["lo", r.lookup("Uint64")]]), r.struct("Int128Parts", [["hi", r.lookup("Int64")], ["lo", r.lookup("Uint64")]]), r.struct("UInt256Parts", [["hiHi", r.lookup("Uint64")], ["hiLo", r.lookup("Uint64")], ["loHi", r.lookup("Uint64")], ["loLo", r.lookup("Uint64")]]), r.struct("Int256Parts", [["hiHi", r.lookup("Int64")], ["hiLo", r.lookup("Uint64")], ["loHi", r.lookup("Uint64")], ["loLo", r.lookup("Uint64")]]), r.enum("ContractExecutableType", { contractExecutableWasm: 0, contractExecutableStellarAsset: 1 }), r.union("ContractExecutable", { switchOn: r.lookup("ContractExecutableType"), switchName: "type", switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", r.void()]], arms: { wasmHash: r.lookup("Hash") } }), r.enum("ScAddressType", { scAddressTypeAccount: 0, scAddressTypeContract: 1 }), r.union("ScAddress", { switchOn: r.lookup("ScAddressType"), switchName: "type", switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]], arms: { accountId: r.lookup("AccountId"), contractId: r.lookup("Hash") } }), r.const("SCSYMBOL_LIMIT", 32), r.typedef("ScVec", r.varArray(r.lookup("ScVal"), 2147483647)), r.typedef("ScMap", r.varArray(r.lookup("ScMapEntry"), 2147483647)), r.typedef("ScBytes", r.varOpaque()), r.typedef("ScString", r.string()), r.typedef("ScSymbol", r.string(32)), r.struct("ScNonceKey", [["nonce", r.lookup("Int64")]]), r.struct("ScContractInstance", [["executable", r.lookup("ContractExecutable")], ["storage", r.option(r.lookup("ScMap"))]]), r.union("ScVal", { switchOn: r.lookup("ScValType"), switchName: "type", switches: [["scvBool", "b"], ["scvVoid", r.void()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", r.void()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]], arms: { b: r.bool(), error: r.lookup("ScError"), u32: r.lookup("Uint32"), i32: r.lookup("Int32"), u64: r.lookup("Uint64"), i64: r.lookup("Int64"), timepoint: r.lookup("TimePoint"), duration: r.lookup("Duration"), u128: r.lookup("UInt128Parts"), i128: r.lookup("Int128Parts"), u256: r.lookup("UInt256Parts"), i256: r.lookup("Int256Parts"), bytes: r.lookup("ScBytes"), str: r.lookup("ScString"), sym: r.lookup("ScSymbol"), vec: r.option(r.lookup("ScVec")), map: r.option(r.lookup("ScMap")), address: r.lookup("ScAddress"), nonceKey: r.lookup("ScNonceKey"), instance: r.lookup("ScContractInstance") } }), r.struct("ScMapEntry", [["key", r.lookup("ScVal")], ["val", r.lookup("ScVal")]]), r.enum("ScEnvMetaKind", { scEnvMetaKindInterfaceVersion: 0 }), r.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", r.lookup("Uint32")], ["preRelease", r.lookup("Uint32")]]), r.union("ScEnvMetaEntry", { switchOn: r.lookup("ScEnvMetaKind"), switchName: "kind", switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]], arms: { interfaceVersion: r.lookup("ScEnvMetaEntryInterfaceVersion") } }), r.struct("ScMetaV0", [["key", r.string()], ["val", r.string()]]), r.enum("ScMetaKind", { scMetaV0: 0 }), r.union("ScMetaEntry", { switchOn: r.lookup("ScMetaKind"), switchName: "kind", switches: [["scMetaV0", "v0"]], arms: { v0: r.lookup("ScMetaV0") } }), r.const("SC_SPEC_DOC_LIMIT", 1024), r.enum("ScSpecType", { scSpecTypeVal: 0, scSpecTypeBool: 1, scSpecTypeVoid: 2, scSpecTypeError: 3, scSpecTypeU32: 4, scSpecTypeI32: 5, scSpecTypeU64: 6, scSpecTypeI64: 7, scSpecTypeTimepoint: 8, scSpecTypeDuration: 9, scSpecTypeU128: 10, scSpecTypeI128: 11, scSpecTypeU256: 12, scSpecTypeI256: 13, scSpecTypeBytes: 14, scSpecTypeString: 16, scSpecTypeSymbol: 17, scSpecTypeAddress: 19, scSpecTypeOption: 1e3, scSpecTypeResult: 1001, scSpecTypeVec: 1002, scSpecTypeMap: 1004, scSpecTypeTuple: 1005, scSpecTypeBytesN: 1006, scSpecTypeUdt: 2e3 }), r.struct("ScSpecTypeOption", [["valueType", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecTypeResult", [["okType", r.lookup("ScSpecTypeDef")], ["errorType", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecTypeVec", [["elementType", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecTypeMap", [["keyType", r.lookup("ScSpecTypeDef")], ["valueType", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecTypeTuple", [["valueTypes", r.varArray(r.lookup("ScSpecTypeDef"), 12)]]), r.struct("ScSpecTypeBytesN", [["n", r.lookup("Uint32")]]), r.struct("ScSpecTypeUdt", [["name", r.string(60)]]), r.union("ScSpecTypeDef", { switchOn: r.lookup("ScSpecType"), switchName: "type", switches: [["scSpecTypeVal", r.void()], ["scSpecTypeBool", r.void()], ["scSpecTypeVoid", r.void()], ["scSpecTypeError", r.void()], ["scSpecTypeU32", r.void()], ["scSpecTypeI32", r.void()], ["scSpecTypeU64", r.void()], ["scSpecTypeI64", r.void()], ["scSpecTypeTimepoint", r.void()], ["scSpecTypeDuration", r.void()], ["scSpecTypeU128", r.void()], ["scSpecTypeI128", r.void()], ["scSpecTypeU256", r.void()], ["scSpecTypeI256", r.void()], ["scSpecTypeBytes", r.void()], ["scSpecTypeString", r.void()], ["scSpecTypeSymbol", r.void()], ["scSpecTypeAddress", r.void()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]], arms: { option: r.lookup("ScSpecTypeOption"), result: r.lookup("ScSpecTypeResult"), vec: r.lookup("ScSpecTypeVec"), map: r.lookup("ScSpecTypeMap"), tuple: r.lookup("ScSpecTypeTuple"), bytesN: r.lookup("ScSpecTypeBytesN"), udt: r.lookup("ScSpecTypeUdt") } }), r.struct("ScSpecUdtStructFieldV0", [["doc", r.string(m)], ["name", r.string(30)], ["type", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecUdtStructV0", [["doc", r.string(m)], ["lib", r.string(80)], ["name", r.string(60)], ["fields", r.varArray(r.lookup("ScSpecUdtStructFieldV0"), 40)]]), r.struct("ScSpecUdtUnionCaseVoidV0", [["doc", r.string(m)], ["name", r.string(60)]]), r.struct("ScSpecUdtUnionCaseTupleV0", [["doc", r.string(m)], ["name", r.string(60)], ["type", r.varArray(r.lookup("ScSpecTypeDef"), 12)]]), r.enum("ScSpecUdtUnionCaseV0Kind", { scSpecUdtUnionCaseVoidV0: 0, scSpecUdtUnionCaseTupleV0: 1 }), r.union("ScSpecUdtUnionCaseV0", { switchOn: r.lookup("ScSpecUdtUnionCaseV0Kind"), switchName: "kind", switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]], arms: { voidCase: r.lookup("ScSpecUdtUnionCaseVoidV0"), tupleCase: r.lookup("ScSpecUdtUnionCaseTupleV0") } }), r.struct("ScSpecUdtUnionV0", [["doc", r.string(m)], ["lib", r.string(80)], ["name", r.string(60)], ["cases", r.varArray(r.lookup("ScSpecUdtUnionCaseV0"), 50)]]), r.struct("ScSpecUdtEnumCaseV0", [["doc", r.string(m)], ["name", r.string(60)], ["value", r.lookup("Uint32")]]), r.struct("ScSpecUdtEnumV0", [["doc", r.string(m)], ["lib", r.string(80)], ["name", r.string(60)], ["cases", r.varArray(r.lookup("ScSpecUdtEnumCaseV0"), 50)]]), r.struct("ScSpecUdtErrorEnumCaseV0", [["doc", r.string(m)], ["name", r.string(60)], ["value", r.lookup("Uint32")]]), r.struct("ScSpecUdtErrorEnumV0", [["doc", r.string(m)], ["lib", r.string(80)], ["name", r.string(60)], ["cases", r.varArray(r.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]), r.struct("ScSpecFunctionInputV0", [["doc", r.string(m)], ["name", r.string(30)], ["type", r.lookup("ScSpecTypeDef")]]), r.struct("ScSpecFunctionV0", [["doc", r.string(m)], ["name", r.lookup("ScSymbol")], ["inputs", r.varArray(r.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", r.varArray(r.lookup("ScSpecTypeDef"), 1)]]), r.enum("ScSpecEntryKind", { scSpecEntryFunctionV0: 0, scSpecEntryUdtStructV0: 1, scSpecEntryUdtUnionV0: 2, scSpecEntryUdtEnumV0: 3, scSpecEntryUdtErrorEnumV0: 4 }), r.union("ScSpecEntry", { switchOn: r.lookup("ScSpecEntryKind"), switchName: "kind", switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]], arms: { functionV0: r.lookup("ScSpecFunctionV0"), udtStructV0: r.lookup("ScSpecUdtStructV0"), udtUnionV0: r.lookup("ScSpecUdtUnionV0"), udtEnumV0: r.lookup("ScSpecUdtEnumV0"), udtErrorEnumV0: r.lookup("ScSpecUdtErrorEnumV0") } }), r.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", r.lookup("Uint32")]]), r.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", r.lookup("Int64")], ["txMaxInstructions", r.lookup("Int64")], ["feeRatePerInstructionsIncrement", r.lookup("Int64")], ["txMemoryLimit", r.lookup("Uint32")]]), r.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", r.lookup("Uint32")], ["ledgerMaxReadBytes", r.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", r.lookup("Uint32")], ["ledgerMaxWriteBytes", r.lookup("Uint32")], ["txMaxReadLedgerEntries", r.lookup("Uint32")], ["txMaxReadBytes", r.lookup("Uint32")], ["txMaxWriteLedgerEntries", r.lookup("Uint32")], ["txMaxWriteBytes", r.lookup("Uint32")], ["feeReadLedgerEntry", r.lookup("Int64")], ["feeWriteLedgerEntry", r.lookup("Int64")], ["feeRead1Kb", r.lookup("Int64")], ["bucketListTargetSizeBytes", r.lookup("Int64")], ["writeFee1KbBucketListLow", r.lookup("Int64")], ["writeFee1KbBucketListHigh", r.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", r.lookup("Uint32")]]), r.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", r.lookup("Int64")]]), r.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", r.lookup("Uint32")], ["feeContractEvents1Kb", r.lookup("Int64")]]), r.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", r.lookup("Uint32")], ["txMaxSizeBytes", r.lookup("Uint32")], ["feeTxSize1Kb", r.lookup("Int64")]]), r.enum("ContractCostType", { wasmInsnExec: 0, memAlloc: 1, memCpy: 2, memCmp: 3, dispatchHostFunction: 4, visitObject: 5, valSer: 6, valDeser: 7, computeSha256Hash: 8, computeEd25519PubKey: 9, verifyEd25519Sig: 10, vmInstantiation: 11, vmCachedInstantiation: 12, invokeVmFunction: 13, computeKeccak256Hash: 14, decodeEcdsaCurve256Sig: 15, recoverEcdsaSecp256k1Key: 16, int256AddSub: 17, int256Mul: 18, int256Div: 19, int256Pow: 20, int256Shift: 21, chaCha20DrawBytes: 22, parseWasmInstructions: 23, parseWasmFunctions: 24, parseWasmGlobals: 25, parseWasmTableEntries: 26, parseWasmTypes: 27, parseWasmDataSegments: 28, parseWasmElemSegments: 29, parseWasmImports: 30, parseWasmExports: 31, parseWasmDataSegmentBytes: 32, instantiateWasmInstructions: 33, instantiateWasmFunctions: 34, instantiateWasmGlobals: 35, instantiateWasmTableEntries: 36, instantiateWasmTypes: 37, instantiateWasmDataSegments: 38, instantiateWasmElemSegments: 39, instantiateWasmImports: 40, instantiateWasmExports: 41, instantiateWasmDataSegmentBytes: 42, sec1DecodePointUncompressed: 43, verifyEcdsaSecp256r1Sig: 44, bls12381EncodeFp: 45, bls12381DecodeFp: 46, bls12381G1CheckPointOnCurve: 47, bls12381G1CheckPointInSubgroup: 48, bls12381G2CheckPointOnCurve: 49, bls12381G2CheckPointInSubgroup: 50, bls12381G1ProjectiveToAffine: 51, bls12381G2ProjectiveToAffine: 52, bls12381G1Add: 53, bls12381G1Mul: 54, bls12381G1Msm: 55, bls12381MapFpToG1: 56, bls12381HashToG1: 57, bls12381G2Add: 58, bls12381G2Mul: 59, bls12381G2Msm: 60, bls12381MapFp2ToG2: 61, bls12381HashToG2: 62, bls12381Pairing: 63, bls12381FrFromU256: 64, bls12381FrToU256: 65, bls12381FrAddSub: 66, bls12381FrMul: 67, bls12381FrPow: 68, bls12381FrInv: 69 }), r.struct("ContractCostParamEntry", [["ext", r.lookup("ExtensionPoint")], ["constTerm", r.lookup("Int64")], ["linearTerm", r.lookup("Int64")]]), r.struct("StateArchivalSettings", [["maxEntryTtl", r.lookup("Uint32")], ["minTemporaryTtl", r.lookup("Uint32")], ["minPersistentTtl", r.lookup("Uint32")], ["persistentRentRateDenominator", r.lookup("Int64")], ["tempRentRateDenominator", r.lookup("Int64")], ["maxEntriesToArchive", r.lookup("Uint32")], ["bucketListSizeWindowSampleSize", r.lookup("Uint32")], ["bucketListWindowSamplePeriod", r.lookup("Uint32")], ["evictionScanSize", r.lookup("Uint32")], ["startingEvictionScanLevel", r.lookup("Uint32")]]), r.struct("EvictionIterator", [["bucketListLevel", r.lookup("Uint32")], ["isCurrBucket", r.bool()], ["bucketFileOffset", r.lookup("Uint64")]]), r.const("CONTRACT_COST_COUNT_LIMIT", 1024), r.typedef("ContractCostParams", r.varArray(r.lookup("ContractCostParamEntry"), r.lookup("CONTRACT_COST_COUNT_LIMIT"))), r.enum("ConfigSettingId", { configSettingContractMaxSizeBytes: 0, configSettingContractComputeV0: 1, configSettingContractLedgerCostV0: 2, configSettingContractHistoricalDataV0: 3, configSettingContractEventsV0: 4, configSettingContractBandwidthV0: 5, configSettingContractCostParamsCpuInstructions: 6, configSettingContractCostParamsMemoryBytes: 7, configSettingContractDataKeySizeBytes: 8, configSettingContractDataEntrySizeBytes: 9, configSettingStateArchival: 10, configSettingContractExecutionLanes: 11, configSettingBucketlistSizeWindow: 12, configSettingEvictionIterator: 13 }), r.union("ConfigSettingEntry", { switchOn: r.lookup("ConfigSettingId"), switchName: "configSettingId", switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]], arms: { contractMaxSizeBytes: r.lookup("Uint32"), contractCompute: r.lookup("ConfigSettingContractComputeV0"), contractLedgerCost: r.lookup("ConfigSettingContractLedgerCostV0"), contractHistoricalData: r.lookup("ConfigSettingContractHistoricalDataV0"), contractEvents: r.lookup("ConfigSettingContractEventsV0"), contractBandwidth: r.lookup("ConfigSettingContractBandwidthV0"), contractCostParamsCpuInsns: r.lookup("ContractCostParams"), contractCostParamsMemBytes: r.lookup("ContractCostParams"), contractDataKeySizeBytes: r.lookup("Uint32"), contractDataEntrySizeBytes: r.lookup("Uint32"), stateArchivalSettings: r.lookup("StateArchivalSettings"), contractExecutionLanes: r.lookup("ConfigSettingContractExecutionLanesV0"), bucketListSizeWindow: r.varArray(r.lookup("Uint64"), 2147483647), evictionIterator: r.lookup("EvictionIterator") } });
        });
        o.default = f;
      }, 8002: (t) => {
        t.exports = Math.min;
      }, 8068: (t) => {
        t.exports = SyntaxError;
      }, 8184: (t, o, u) => {
        var c, h = u(6556), f = u(9721)(/^\s*(?:function)?\*/), r = u(9092)(), m = u(3628), g = h("Object.prototype.toString"), a = h("Function.prototype.toString");
        t.exports = function(l) {
          if (typeof l != "function") return false;
          if (f(a(l))) return true;
          if (!r) return g(l) === "[object GeneratorFunction]";
          if (!m) return false;
          if (c === void 0) {
            var d = function() {
              if (!r) return false;
              try {
                return Function("return function*() {}")();
              } catch {
              }
            }();
            c = !!d && m(d);
          }
          return m(l) === c;
        };
      }, 8242: (t, o, u) => {
        u.r(o), u.d(o, { Api: () => {
        } });
      }, 8287: (t, o, u) => {
        const c = u(7526), h = u(251), f = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        o.Buffer = g, o.SlowBuffer = function(x) {
          return +x != x && (x = 0), g.alloc(+x);
        }, o.INSPECT_MAX_BYTES = 50;
        const r = 2147483647;
        function m(x) {
          if (x > r) throw new RangeError('The value "' + x + '" is invalid for option "size"');
          const O = new Uint8Array(x);
          return Object.setPrototypeOf(O, g.prototype), O;
        }
        function g(x, O, V) {
          if (typeof x == "number") {
            if (typeof O == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return d(x);
          }
          return a(x, O, V);
        }
        function a(x, O, V) {
          if (typeof x == "string") return function(p, A) {
            if (typeof A == "string" && A !== "" || (A = "utf8"), !g.isEncoding(A)) throw new TypeError("Unknown encoding: " + A);
            const U = 0 | R(p, A);
            let Q = m(U);
            const se = Q.write(p, A);
            return se !== U && (Q = Q.slice(0, se)), Q;
          }(x, O);
          if (ArrayBuffer.isView(x)) return function(p) {
            if (_e(p, Uint8Array)) {
              const A = new Uint8Array(p);
              return S(A.buffer, A.byteOffset, A.byteLength);
            }
            return b(p);
          }(x);
          if (x == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x);
          if (_e(x, ArrayBuffer) || x && _e(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (_e(x, SharedArrayBuffer) || x && _e(x.buffer, SharedArrayBuffer))) return S(x, O, V);
          if (typeof x == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
          const N = x.valueOf && x.valueOf();
          if (N != null && N !== x) return g.from(N, O, V);
          const C = function(p) {
            if (g.isBuffer(p)) {
              const A = 0 | E(p.length), U = m(A);
              return U.length === 0 || p.copy(U, 0, 0, A), U;
            }
            if (p.length !== void 0) return typeof p.length != "number" || Be(p.length) ? m(0) : b(p);
            if (p.type === "Buffer" && Array.isArray(p.data)) return b(p.data);
          }(x);
          if (C) return C;
          if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function") return g.from(x[Symbol.toPrimitive]("string"), O, V);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x);
        }
        function l(x) {
          if (typeof x != "number") throw new TypeError('"size" argument must be of type number');
          if (x < 0) throw new RangeError('The value "' + x + '" is invalid for option "size"');
        }
        function d(x) {
          return l(x), m(x < 0 ? 0 : 0 | E(x));
        }
        function b(x) {
          const O = x.length < 0 ? 0 : 0 | E(x.length), V = m(O);
          for (let N = 0; N < O; N += 1) V[N] = 255 & x[N];
          return V;
        }
        function S(x, O, V) {
          if (O < 0 || x.byteLength < O) throw new RangeError('"offset" is outside of buffer bounds');
          if (x.byteLength < O + (V || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let N;
          return N = O === void 0 && V === void 0 ? new Uint8Array(x) : V === void 0 ? new Uint8Array(x, O) : new Uint8Array(x, O, V), Object.setPrototypeOf(N, g.prototype), N;
        }
        function E(x) {
          if (x >= r) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + r.toString(16) + " bytes");
          return 0 | x;
        }
        function R(x, O) {
          if (g.isBuffer(x)) return x.length;
          if (ArrayBuffer.isView(x) || _e(x, ArrayBuffer)) return x.byteLength;
          if (typeof x != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x);
          const V = x.length, N = arguments.length > 2 && arguments[2] === true;
          if (!N && V === 0) return 0;
          let C = false;
          for (; ; ) switch (O) {
            case "ascii":
            case "latin1":
            case "binary":
              return V;
            case "utf8":
            case "utf-8":
              return Oe(x).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * V;
            case "hex":
              return V >>> 1;
            case "base64":
              return xe(x).length;
            default:
              if (C) return N ? -1 : Oe(x).length;
              O = ("" + O).toLowerCase(), C = true;
          }
        }
        function k(x, O, V) {
          let N = false;
          if ((O === void 0 || O < 0) && (O = 0), O > this.length || ((V === void 0 || V > this.length) && (V = this.length), V <= 0) || (V >>>= 0) <= (O >>>= 0)) return "";
          for (x || (x = "utf8"); ; ) switch (x) {
            case "hex":
              return G(this, O, V);
            case "utf8":
            case "utf-8":
              return j(this, O, V);
            case "ascii":
              return Y(this, O, V);
            case "latin1":
            case "binary":
              return te(this, O, V);
            case "base64":
              return L(this, O, V);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return K(this, O, V);
            default:
              if (N) throw new TypeError("Unknown encoding: " + x);
              x = (x + "").toLowerCase(), N = true;
          }
        }
        function w(x, O, V) {
          const N = x[O];
          x[O] = x[V], x[V] = N;
        }
        function F(x, O, V, N, C) {
          if (x.length === 0) return -1;
          if (typeof V == "string" ? (N = V, V = 0) : V > 2147483647 ? V = 2147483647 : V < -2147483648 && (V = -2147483648), Be(V = +V) && (V = C ? 0 : x.length - 1), V < 0 && (V = x.length + V), V >= x.length) {
            if (C) return -1;
            V = x.length - 1;
          } else if (V < 0) {
            if (!C) return -1;
            V = 0;
          }
          if (typeof O == "string" && (O = g.from(O, N)), g.isBuffer(O)) return O.length === 0 ? -1 : I(x, O, V, N, C);
          if (typeof O == "number") return O &= 255, typeof Uint8Array.prototype.indexOf == "function" ? C ? Uint8Array.prototype.indexOf.call(x, O, V) : Uint8Array.prototype.lastIndexOf.call(x, O, V) : I(x, [O], V, N, C);
          throw new TypeError("val must be string, number or Buffer");
        }
        function I(x, O, V, N, C) {
          let p, A = 1, U = x.length, Q = O.length;
          if (N !== void 0 && ((N = String(N).toLowerCase()) === "ucs2" || N === "ucs-2" || N === "utf16le" || N === "utf-16le")) {
            if (x.length < 2 || O.length < 2) return -1;
            A = 2, U /= 2, Q /= 2, V /= 2;
          }
          function se(X, de) {
            return A === 1 ? X[de] : X.readUInt16BE(de * A);
          }
          if (C) {
            let X = -1;
            for (p = V; p < U; p++) if (se(x, p) === se(O, X === -1 ? 0 : p - X)) {
              if (X === -1 && (X = p), p - X + 1 === Q) return X * A;
            } else X !== -1 && (p -= p - X), X = -1;
          } else for (V + Q > U && (V = U - Q), p = V; p >= 0; p--) {
            let X = true;
            for (let de = 0; de < Q; de++) if (se(x, p + de) !== se(O, de)) {
              X = false;
              break;
            }
            if (X) return p;
          }
          return -1;
        }
        function q(x, O, V, N) {
          V = Number(V) || 0;
          const C = x.length - V;
          N ? (N = Number(N)) > C && (N = C) : N = C;
          const p = O.length;
          let A;
          for (N > p / 2 && (N = p / 2), A = 0; A < N; ++A) {
            const U = parseInt(O.substr(2 * A, 2), 16);
            if (Be(U)) return A;
            x[V + A] = U;
          }
          return A;
        }
        function D(x, O, V, N) {
          return Ve(Oe(O, x.length - V), x, V, N);
        }
        function H(x, O, V, N) {
          return Ve(function(C) {
            const p = [];
            for (let A = 0; A < C.length; ++A) p.push(255 & C.charCodeAt(A));
            return p;
          }(O), x, V, N);
        }
        function _(x, O, V, N) {
          return Ve(xe(O), x, V, N);
        }
        function T(x, O, V, N) {
          return Ve(function(C, p) {
            let A, U, Q;
            const se = [];
            for (let X = 0; X < C.length && !((p -= 2) < 0); ++X) A = C.charCodeAt(X), U = A >> 8, Q = A % 256, se.push(Q), se.push(U);
            return se;
          }(O, x.length - V), x, V, N);
        }
        function L(x, O, V) {
          return O === 0 && V === x.length ? c.fromByteArray(x) : c.fromByteArray(x.slice(O, V));
        }
        function j(x, O, V) {
          V = Math.min(x.length, V);
          const N = [];
          let C = O;
          for (; C < V; ) {
            const p = x[C];
            let A = null, U = p > 239 ? 4 : p > 223 ? 3 : p > 191 ? 2 : 1;
            if (C + U <= V) {
              let Q, se, X, de;
              switch (U) {
                case 1:
                  p < 128 && (A = p);
                  break;
                case 2:
                  Q = x[C + 1], (192 & Q) == 128 && (de = (31 & p) << 6 | 63 & Q, de > 127 && (A = de));
                  break;
                case 3:
                  Q = x[C + 1], se = x[C + 2], (192 & Q) == 128 && (192 & se) == 128 && (de = (15 & p) << 12 | (63 & Q) << 6 | 63 & se, de > 2047 && (de < 55296 || de > 57343) && (A = de));
                  break;
                case 4:
                  Q = x[C + 1], se = x[C + 2], X = x[C + 3], (192 & Q) == 128 && (192 & se) == 128 && (192 & X) == 128 && (de = (15 & p) << 18 | (63 & Q) << 12 | (63 & se) << 6 | 63 & X, de > 65535 && de < 1114112 && (A = de));
              }
            }
            A === null ? (A = 65533, U = 1) : A > 65535 && (A -= 65536, N.push(A >>> 10 & 1023 | 55296), A = 56320 | 1023 & A), N.push(A), C += U;
          }
          return function(p) {
            const A = p.length;
            if (A <= z) return String.fromCharCode.apply(String, p);
            let U = "", Q = 0;
            for (; Q < A; ) U += String.fromCharCode.apply(String, p.slice(Q, Q += z));
            return U;
          }(N);
        }
        o.kMaxLength = r, g.TYPED_ARRAY_SUPPORT = function() {
          try {
            const x = new Uint8Array(1), O = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(O, Uint8Array.prototype), Object.setPrototypeOf(x, O), x.foo() === 42;
          } catch {
            return false;
          }
        }(), g.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(g.prototype, "parent", { enumerable: true, get: function() {
          if (g.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(g.prototype, "offset", { enumerable: true, get: function() {
          if (g.isBuffer(this)) return this.byteOffset;
        } }), g.poolSize = 8192, g.from = function(x, O, V) {
          return a(x, O, V);
        }, Object.setPrototypeOf(g.prototype, Uint8Array.prototype), Object.setPrototypeOf(g, Uint8Array), g.alloc = function(x, O, V) {
          return function(N, C, p) {
            return l(N), N <= 0 ? m(N) : C !== void 0 ? typeof p == "string" ? m(N).fill(C, p) : m(N).fill(C) : m(N);
          }(x, O, V);
        }, g.allocUnsafe = function(x) {
          return d(x);
        }, g.allocUnsafeSlow = function(x) {
          return d(x);
        }, g.isBuffer = function(x) {
          return x != null && x._isBuffer === true && x !== g.prototype;
        }, g.compare = function(x, O) {
          if (_e(x, Uint8Array) && (x = g.from(x, x.offset, x.byteLength)), _e(O, Uint8Array) && (O = g.from(O, O.offset, O.byteLength)), !g.isBuffer(x) || !g.isBuffer(O)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (x === O) return 0;
          let V = x.length, N = O.length;
          for (let C = 0, p = Math.min(V, N); C < p; ++C) if (x[C] !== O[C]) {
            V = x[C], N = O[C];
            break;
          }
          return V < N ? -1 : N < V ? 1 : 0;
        }, g.isEncoding = function(x) {
          switch (String(x).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, g.concat = function(x, O) {
          if (!Array.isArray(x)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (x.length === 0) return g.alloc(0);
          let V;
          if (O === void 0) for (O = 0, V = 0; V < x.length; ++V) O += x[V].length;
          const N = g.allocUnsafe(O);
          let C = 0;
          for (V = 0; V < x.length; ++V) {
            let p = x[V];
            if (_e(p, Uint8Array)) C + p.length > N.length ? (g.isBuffer(p) || (p = g.from(p)), p.copy(N, C)) : Uint8Array.prototype.set.call(N, p, C);
            else {
              if (!g.isBuffer(p)) throw new TypeError('"list" argument must be an Array of Buffers');
              p.copy(N, C);
            }
            C += p.length;
          }
          return N;
        }, g.byteLength = R, g.prototype._isBuffer = true, g.prototype.swap16 = function() {
          const x = this.length;
          if (x % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let O = 0; O < x; O += 2) w(this, O, O + 1);
          return this;
        }, g.prototype.swap32 = function() {
          const x = this.length;
          if (x % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let O = 0; O < x; O += 4) w(this, O, O + 3), w(this, O + 1, O + 2);
          return this;
        }, g.prototype.swap64 = function() {
          const x = this.length;
          if (x % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let O = 0; O < x; O += 8) w(this, O, O + 7), w(this, O + 1, O + 6), w(this, O + 2, O + 5), w(this, O + 3, O + 4);
          return this;
        }, g.prototype.toString = function() {
          const x = this.length;
          return x === 0 ? "" : arguments.length === 0 ? j(this, 0, x) : k.apply(this, arguments);
        }, g.prototype.toLocaleString = g.prototype.toString, g.prototype.equals = function(x) {
          if (!g.isBuffer(x)) throw new TypeError("Argument must be a Buffer");
          return this === x || g.compare(this, x) === 0;
        }, g.prototype.inspect = function() {
          let x = "";
          const O = o.INSPECT_MAX_BYTES;
          return x = this.toString("hex", 0, O).replace(/(.{2})/g, "$1 ").trim(), this.length > O && (x += " ... "), "<Buffer " + x + ">";
        }, f && (g.prototype[f] = g.prototype.inspect), g.prototype.compare = function(x, O, V, N, C) {
          if (_e(x, Uint8Array) && (x = g.from(x, x.offset, x.byteLength)), !g.isBuffer(x)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x);
          if (O === void 0 && (O = 0), V === void 0 && (V = x ? x.length : 0), N === void 0 && (N = 0), C === void 0 && (C = this.length), O < 0 || V > x.length || N < 0 || C > this.length) throw new RangeError("out of range index");
          if (N >= C && O >= V) return 0;
          if (N >= C) return -1;
          if (O >= V) return 1;
          if (this === x) return 0;
          let p = (C >>>= 0) - (N >>>= 0), A = (V >>>= 0) - (O >>>= 0);
          const U = Math.min(p, A), Q = this.slice(N, C), se = x.slice(O, V);
          for (let X = 0; X < U; ++X) if (Q[X] !== se[X]) {
            p = Q[X], A = se[X];
            break;
          }
          return p < A ? -1 : A < p ? 1 : 0;
        }, g.prototype.includes = function(x, O, V) {
          return this.indexOf(x, O, V) !== -1;
        }, g.prototype.indexOf = function(x, O, V) {
          return F(this, x, O, V, true);
        }, g.prototype.lastIndexOf = function(x, O, V) {
          return F(this, x, O, V, false);
        }, g.prototype.write = function(x, O, V, N) {
          if (O === void 0) N = "utf8", V = this.length, O = 0;
          else if (V === void 0 && typeof O == "string") N = O, V = this.length, O = 0;
          else {
            if (!isFinite(O)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            O >>>= 0, isFinite(V) ? (V >>>= 0, N === void 0 && (N = "utf8")) : (N = V, V = void 0);
          }
          const C = this.length - O;
          if ((V === void 0 || V > C) && (V = C), x.length > 0 && (V < 0 || O < 0) || O > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          N || (N = "utf8");
          let p = false;
          for (; ; ) switch (N) {
            case "hex":
              return q(this, x, O, V);
            case "utf8":
            case "utf-8":
              return D(this, x, O, V);
            case "ascii":
            case "latin1":
            case "binary":
              return H(this, x, O, V);
            case "base64":
              return _(this, x, O, V);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return T(this, x, O, V);
            default:
              if (p) throw new TypeError("Unknown encoding: " + N);
              N = ("" + N).toLowerCase(), p = true;
          }
        }, g.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const z = 4096;
        function Y(x, O, V) {
          let N = "";
          V = Math.min(x.length, V);
          for (let C = O; C < V; ++C) N += String.fromCharCode(127 & x[C]);
          return N;
        }
        function te(x, O, V) {
          let N = "";
          V = Math.min(x.length, V);
          for (let C = O; C < V; ++C) N += String.fromCharCode(x[C]);
          return N;
        }
        function G(x, O, V) {
          const N = x.length;
          (!O || O < 0) && (O = 0), (!V || V < 0 || V > N) && (V = N);
          let C = "";
          for (let p = O; p < V; ++p) C += Qe[x[p]];
          return C;
        }
        function K(x, O, V) {
          const N = x.slice(O, V);
          let C = "";
          for (let p = 0; p < N.length - 1; p += 2) C += String.fromCharCode(N[p] + 256 * N[p + 1]);
          return C;
        }
        function J(x, O, V) {
          if (x % 1 != 0 || x < 0) throw new RangeError("offset is not uint");
          if (x + O > V) throw new RangeError("Trying to access beyond buffer length");
        }
        function B(x, O, V, N, C, p) {
          if (!g.isBuffer(x)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (O > C || O < p) throw new RangeError('"value" argument is out of bounds');
          if (V + N > x.length) throw new RangeError("Index out of range");
        }
        function Z(x, O, V, N, C) {
          ne(O, N, C, x, V, 7);
          let p = Number(O & BigInt(4294967295));
          x[V++] = p, p >>= 8, x[V++] = p, p >>= 8, x[V++] = p, p >>= 8, x[V++] = p;
          let A = Number(O >> BigInt(32) & BigInt(4294967295));
          return x[V++] = A, A >>= 8, x[V++] = A, A >>= 8, x[V++] = A, A >>= 8, x[V++] = A, V;
        }
        function ie(x, O, V, N, C) {
          ne(O, N, C, x, V, 7);
          let p = Number(O & BigInt(4294967295));
          x[V + 7] = p, p >>= 8, x[V + 6] = p, p >>= 8, x[V + 5] = p, p >>= 8, x[V + 4] = p;
          let A = Number(O >> BigInt(32) & BigInt(4294967295));
          return x[V + 3] = A, A >>= 8, x[V + 2] = A, A >>= 8, x[V + 1] = A, A >>= 8, x[V] = A, V + 8;
        }
        function $(x, O, V, N, C, p) {
          if (V + N > x.length) throw new RangeError("Index out of range");
          if (V < 0) throw new RangeError("Index out of range");
        }
        function oe(x, O, V, N, C) {
          return O = +O, V >>>= 0, C || $(x, 0, V, 4), h.write(x, O, V, N, 23, 4), V + 4;
        }
        function ce(x, O, V, N, C) {
          return O = +O, V >>>= 0, C || $(x, 0, V, 8), h.write(x, O, V, N, 52, 8), V + 8;
        }
        g.prototype.slice = function(x, O) {
          const V = this.length;
          (x = ~~x) < 0 ? (x += V) < 0 && (x = 0) : x > V && (x = V), (O = O === void 0 ? V : ~~O) < 0 ? (O += V) < 0 && (O = 0) : O > V && (O = V), O < x && (O = x);
          const N = this.subarray(x, O);
          return Object.setPrototypeOf(N, g.prototype), N;
        }, g.prototype.readUintLE = g.prototype.readUIntLE = function(x, O, V) {
          x >>>= 0, O >>>= 0, V || J(x, O, this.length);
          let N = this[x], C = 1, p = 0;
          for (; ++p < O && (C *= 256); ) N += this[x + p] * C;
          return N;
        }, g.prototype.readUintBE = g.prototype.readUIntBE = function(x, O, V) {
          x >>>= 0, O >>>= 0, V || J(x, O, this.length);
          let N = this[x + --O], C = 1;
          for (; O > 0 && (C *= 256); ) N += this[x + --O] * C;
          return N;
        }, g.prototype.readUint8 = g.prototype.readUInt8 = function(x, O) {
          return x >>>= 0, O || J(x, 1, this.length), this[x];
        }, g.prototype.readUint16LE = g.prototype.readUInt16LE = function(x, O) {
          return x >>>= 0, O || J(x, 2, this.length), this[x] | this[x + 1] << 8;
        }, g.prototype.readUint16BE = g.prototype.readUInt16BE = function(x, O) {
          return x >>>= 0, O || J(x, 2, this.length), this[x] << 8 | this[x + 1];
        }, g.prototype.readUint32LE = g.prototype.readUInt32LE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + 16777216 * this[x + 3];
        }, g.prototype.readUint32BE = g.prototype.readUInt32BE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), 16777216 * this[x] + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
        }, g.prototype.readBigUInt64LE = ee(function(x) {
          ge(x >>>= 0, "offset");
          const O = this[x], V = this[x + 7];
          O !== void 0 && V !== void 0 || Te(x, this.length - 8);
          const N = O + 256 * this[++x] + 65536 * this[++x] + this[++x] * 2 ** 24, C = this[++x] + 256 * this[++x] + 65536 * this[++x] + V * 2 ** 24;
          return BigInt(N) + (BigInt(C) << BigInt(32));
        }), g.prototype.readBigUInt64BE = ee(function(x) {
          ge(x >>>= 0, "offset");
          const O = this[x], V = this[x + 7];
          O !== void 0 && V !== void 0 || Te(x, this.length - 8);
          const N = O * 2 ** 24 + 65536 * this[++x] + 256 * this[++x] + this[++x], C = this[++x] * 2 ** 24 + 65536 * this[++x] + 256 * this[++x] + V;
          return (BigInt(N) << BigInt(32)) + BigInt(C);
        }), g.prototype.readIntLE = function(x, O, V) {
          x >>>= 0, O >>>= 0, V || J(x, O, this.length);
          let N = this[x], C = 1, p = 0;
          for (; ++p < O && (C *= 256); ) N += this[x + p] * C;
          return C *= 128, N >= C && (N -= Math.pow(2, 8 * O)), N;
        }, g.prototype.readIntBE = function(x, O, V) {
          x >>>= 0, O >>>= 0, V || J(x, O, this.length);
          let N = O, C = 1, p = this[x + --N];
          for (; N > 0 && (C *= 256); ) p += this[x + --N] * C;
          return C *= 128, p >= C && (p -= Math.pow(2, 8 * O)), p;
        }, g.prototype.readInt8 = function(x, O) {
          return x >>>= 0, O || J(x, 1, this.length), 128 & this[x] ? -1 * (255 - this[x] + 1) : this[x];
        }, g.prototype.readInt16LE = function(x, O) {
          x >>>= 0, O || J(x, 2, this.length);
          const V = this[x] | this[x + 1] << 8;
          return 32768 & V ? 4294901760 | V : V;
        }, g.prototype.readInt16BE = function(x, O) {
          x >>>= 0, O || J(x, 2, this.length);
          const V = this[x + 1] | this[x] << 8;
          return 32768 & V ? 4294901760 | V : V;
        }, g.prototype.readInt32LE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
        }, g.prototype.readInt32BE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
        }, g.prototype.readBigInt64LE = ee(function(x) {
          ge(x >>>= 0, "offset");
          const O = this[x], V = this[x + 7];
          O !== void 0 && V !== void 0 || Te(x, this.length - 8);
          const N = this[x + 4] + 256 * this[x + 5] + 65536 * this[x + 6] + (V << 24);
          return (BigInt(N) << BigInt(32)) + BigInt(O + 256 * this[++x] + 65536 * this[++x] + this[++x] * 16777216);
        }), g.prototype.readBigInt64BE = ee(function(x) {
          ge(x >>>= 0, "offset");
          const O = this[x], V = this[x + 7];
          O !== void 0 && V !== void 0 || Te(x, this.length - 8);
          const N = (O << 24) + 65536 * this[++x] + 256 * this[++x] + this[++x];
          return (BigInt(N) << BigInt(32)) + BigInt(this[++x] * 16777216 + 65536 * this[++x] + 256 * this[++x] + V);
        }), g.prototype.readFloatLE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), h.read(this, x, true, 23, 4);
        }, g.prototype.readFloatBE = function(x, O) {
          return x >>>= 0, O || J(x, 4, this.length), h.read(this, x, false, 23, 4);
        }, g.prototype.readDoubleLE = function(x, O) {
          return x >>>= 0, O || J(x, 8, this.length), h.read(this, x, true, 52, 8);
        }, g.prototype.readDoubleBE = function(x, O) {
          return x >>>= 0, O || J(x, 8, this.length), h.read(this, x, false, 52, 8);
        }, g.prototype.writeUintLE = g.prototype.writeUIntLE = function(x, O, V, N) {
          x = +x, O >>>= 0, V >>>= 0, !N && B(this, x, O, V, Math.pow(2, 8 * V) - 1, 0);
          let C = 1, p = 0;
          for (this[O] = 255 & x; ++p < V && (C *= 256); ) this[O + p] = x / C & 255;
          return O + V;
        }, g.prototype.writeUintBE = g.prototype.writeUIntBE = function(x, O, V, N) {
          x = +x, O >>>= 0, V >>>= 0, !N && B(this, x, O, V, Math.pow(2, 8 * V) - 1, 0);
          let C = V - 1, p = 1;
          for (this[O + C] = 255 & x; --C >= 0 && (p *= 256); ) this[O + C] = x / p & 255;
          return O + V;
        }, g.prototype.writeUint8 = g.prototype.writeUInt8 = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 1, 255, 0), this[O] = 255 & x, O + 1;
        }, g.prototype.writeUint16LE = g.prototype.writeUInt16LE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 2, 65535, 0), this[O] = 255 & x, this[O + 1] = x >>> 8, O + 2;
        }, g.prototype.writeUint16BE = g.prototype.writeUInt16BE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 2, 65535, 0), this[O] = x >>> 8, this[O + 1] = 255 & x, O + 2;
        }, g.prototype.writeUint32LE = g.prototype.writeUInt32LE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 4, 4294967295, 0), this[O + 3] = x >>> 24, this[O + 2] = x >>> 16, this[O + 1] = x >>> 8, this[O] = 255 & x, O + 4;
        }, g.prototype.writeUint32BE = g.prototype.writeUInt32BE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 4, 4294967295, 0), this[O] = x >>> 24, this[O + 1] = x >>> 16, this[O + 2] = x >>> 8, this[O + 3] = 255 & x, O + 4;
        }, g.prototype.writeBigUInt64LE = ee(function(x, O = 0) {
          return Z(this, x, O, BigInt(0), BigInt("0xffffffffffffffff"));
        }), g.prototype.writeBigUInt64BE = ee(function(x, O = 0) {
          return ie(this, x, O, BigInt(0), BigInt("0xffffffffffffffff"));
        }), g.prototype.writeIntLE = function(x, O, V, N) {
          if (x = +x, O >>>= 0, !N) {
            const U = Math.pow(2, 8 * V - 1);
            B(this, x, O, V, U - 1, -U);
          }
          let C = 0, p = 1, A = 0;
          for (this[O] = 255 & x; ++C < V && (p *= 256); ) x < 0 && A === 0 && this[O + C - 1] !== 0 && (A = 1), this[O + C] = (x / p | 0) - A & 255;
          return O + V;
        }, g.prototype.writeIntBE = function(x, O, V, N) {
          if (x = +x, O >>>= 0, !N) {
            const U = Math.pow(2, 8 * V - 1);
            B(this, x, O, V, U - 1, -U);
          }
          let C = V - 1, p = 1, A = 0;
          for (this[O + C] = 255 & x; --C >= 0 && (p *= 256); ) x < 0 && A === 0 && this[O + C + 1] !== 0 && (A = 1), this[O + C] = (x / p | 0) - A & 255;
          return O + V;
        }, g.prototype.writeInt8 = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[O] = 255 & x, O + 1;
        }, g.prototype.writeInt16LE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 2, 32767, -32768), this[O] = 255 & x, this[O + 1] = x >>> 8, O + 2;
        }, g.prototype.writeInt16BE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 2, 32767, -32768), this[O] = x >>> 8, this[O + 1] = 255 & x, O + 2;
        }, g.prototype.writeInt32LE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 4, 2147483647, -2147483648), this[O] = 255 & x, this[O + 1] = x >>> 8, this[O + 2] = x >>> 16, this[O + 3] = x >>> 24, O + 4;
        }, g.prototype.writeInt32BE = function(x, O, V) {
          return x = +x, O >>>= 0, V || B(this, x, O, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[O] = x >>> 24, this[O + 1] = x >>> 16, this[O + 2] = x >>> 8, this[O + 3] = 255 & x, O + 4;
        }, g.prototype.writeBigInt64LE = ee(function(x, O = 0) {
          return Z(this, x, O, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), g.prototype.writeBigInt64BE = ee(function(x, O = 0) {
          return ie(this, x, O, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), g.prototype.writeFloatLE = function(x, O, V) {
          return oe(this, x, O, true, V);
        }, g.prototype.writeFloatBE = function(x, O, V) {
          return oe(this, x, O, false, V);
        }, g.prototype.writeDoubleLE = function(x, O, V) {
          return ce(this, x, O, true, V);
        }, g.prototype.writeDoubleBE = function(x, O, V) {
          return ce(this, x, O, false, V);
        }, g.prototype.copy = function(x, O, V, N) {
          if (!g.isBuffer(x)) throw new TypeError("argument should be a Buffer");
          if (V || (V = 0), N || N === 0 || (N = this.length), O >= x.length && (O = x.length), O || (O = 0), N > 0 && N < V && (N = V), N === V || x.length === 0 || this.length === 0) return 0;
          if (O < 0) throw new RangeError("targetStart out of bounds");
          if (V < 0 || V >= this.length) throw new RangeError("Index out of range");
          if (N < 0) throw new RangeError("sourceEnd out of bounds");
          N > this.length && (N = this.length), x.length - O < N - V && (N = x.length - O + V);
          const C = N - V;
          return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(O, V, N) : Uint8Array.prototype.set.call(x, this.subarray(V, N), O), C;
        }, g.prototype.fill = function(x, O, V, N) {
          if (typeof x == "string") {
            if (typeof O == "string" ? (N = O, O = 0, V = this.length) : typeof V == "string" && (N = V, V = this.length), N !== void 0 && typeof N != "string") throw new TypeError("encoding must be a string");
            if (typeof N == "string" && !g.isEncoding(N)) throw new TypeError("Unknown encoding: " + N);
            if (x.length === 1) {
              const p = x.charCodeAt(0);
              (N === "utf8" && p < 128 || N === "latin1") && (x = p);
            }
          } else typeof x == "number" ? x &= 255 : typeof x == "boolean" && (x = Number(x));
          if (O < 0 || this.length < O || this.length < V) throw new RangeError("Out of range index");
          if (V <= O) return this;
          let C;
          if (O >>>= 0, V = V === void 0 ? this.length : V >>> 0, x || (x = 0), typeof x == "number") for (C = O; C < V; ++C) this[C] = x;
          else {
            const p = g.isBuffer(x) ? x : g.from(x, N), A = p.length;
            if (A === 0) throw new TypeError('The value "' + x + '" is invalid for argument "value"');
            for (C = 0; C < V - O; ++C) this[C + O] = p[C % A];
          }
          return this;
        };
        const ye = {};
        function ae(x, O, V) {
          ye[x] = class extends V {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: O.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${x}]`, this.stack, delete this.name;
            }
            get code() {
              return x;
            }
            set code(N) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: N, writable: true });
            }
            toString() {
              return `${this.name} [${x}]: ${this.message}`;
            }
          };
        }
        function ue(x) {
          let O = "", V = x.length;
          const N = x[0] === "-" ? 1 : 0;
          for (; V >= N + 4; V -= 3) O = `_${x.slice(V - 3, V)}${O}`;
          return `${x.slice(0, V)}${O}`;
        }
        function ne(x, O, V, N, C, p) {
          if (x > V || x < O) {
            const A = typeof O == "bigint" ? "n" : "";
            let U;
            throw U = O === 0 || O === BigInt(0) ? `>= 0${A} and < 2${A} ** ${8 * (p + 1)}${A}` : `>= -(2${A} ** ${8 * (p + 1) - 1}${A}) and < 2 ** ${8 * (p + 1) - 1}${A}`, new ye.ERR_OUT_OF_RANGE("value", U, x);
          }
          (function(A, U, Q) {
            ge(U, "offset"), A[U] !== void 0 && A[U + Q] !== void 0 || Te(U, A.length - (Q + 1));
          })(N, C, p);
        }
        function ge(x, O) {
          if (typeof x != "number") throw new ye.ERR_INVALID_ARG_TYPE(O, "number", x);
        }
        function Te(x, O, V) {
          throw Math.floor(x) !== x ? (ge(x, V), new ye.ERR_OUT_OF_RANGE("offset", "an integer", x)) : O < 0 ? new ye.ERR_BUFFER_OUT_OF_BOUNDS() : new ye.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${O}`, x);
        }
        ae("ERR_BUFFER_OUT_OF_BOUNDS", function(x) {
          return x ? `${x} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), ae("ERR_INVALID_ARG_TYPE", function(x, O) {
          return `The "${x}" argument must be of type number. Received type ${typeof O}`;
        }, TypeError), ae("ERR_OUT_OF_RANGE", function(x, O, V) {
          let N = `The value of "${x}" is out of range.`, C = V;
          return Number.isInteger(V) && Math.abs(V) > 4294967296 ? C = ue(String(V)) : typeof V == "bigint" && (C = String(V), (V > BigInt(2) ** BigInt(32) || V < -(BigInt(2) ** BigInt(32))) && (C = ue(C)), C += "n"), N += ` It must be ${O}. Received ${C}`, N;
        }, RangeError);
        const pe = /[^+/0-9A-Za-z-_]/g;
        function Oe(x, O) {
          let V;
          O = O || 1 / 0;
          const N = x.length;
          let C = null;
          const p = [];
          for (let A = 0; A < N; ++A) {
            if (V = x.charCodeAt(A), V > 55295 && V < 57344) {
              if (!C) {
                if (V > 56319) {
                  (O -= 3) > -1 && p.push(239, 191, 189);
                  continue;
                }
                if (A + 1 === N) {
                  (O -= 3) > -1 && p.push(239, 191, 189);
                  continue;
                }
                C = V;
                continue;
              }
              if (V < 56320) {
                (O -= 3) > -1 && p.push(239, 191, 189), C = V;
                continue;
              }
              V = 65536 + (C - 55296 << 10 | V - 56320);
            } else C && (O -= 3) > -1 && p.push(239, 191, 189);
            if (C = null, V < 128) {
              if ((O -= 1) < 0) break;
              p.push(V);
            } else if (V < 2048) {
              if ((O -= 2) < 0) break;
              p.push(V >> 6 | 192, 63 & V | 128);
            } else if (V < 65536) {
              if ((O -= 3) < 0) break;
              p.push(V >> 12 | 224, V >> 6 & 63 | 128, 63 & V | 128);
            } else {
              if (!(V < 1114112)) throw new Error("Invalid code point");
              if ((O -= 4) < 0) break;
              p.push(V >> 18 | 240, V >> 12 & 63 | 128, V >> 6 & 63 | 128, 63 & V | 128);
            }
          }
          return p;
        }
        function xe(x) {
          return c.toByteArray(function(O) {
            if ((O = (O = O.split("=")[0]).trim().replace(pe, "")).length < 2) return "";
            for (; O.length % 4 != 0; ) O += "=";
            return O;
          }(x));
        }
        function Ve(x, O, V, N) {
          let C;
          for (C = 0; C < N && !(C + V >= O.length || C >= x.length); ++C) O[C + V] = x[C];
          return C;
        }
        function _e(x, O) {
          return x instanceof O || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === O.name;
        }
        function Be(x) {
          return x != x;
        }
        const Qe = function() {
          const x = "0123456789abcdef", O = new Array(256);
          for (let V = 0; V < 16; ++V) {
            const N = 16 * V;
            for (let C = 0; C < 16; ++C) O[N + C] = x[V] + x[C];
          }
          return O;
        }();
        function ee(x) {
          return typeof BigInt > "u" ? P : x;
        }
        function P() {
          throw new Error("BigInt not supported");
        }
      }, 8399: (t, o, u) => {
        (o = t.exports = u(5412)).Stream = o, o.Readable = o, o.Writable = u(6708), o.Duplex = u(5382), o.Transform = u(4610), o.PassThrough = u(3600), o.finished = u(6238), o.pipeline = u(7758);
      }, 8549: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), Object.defineProperty(o, "Int128", { enumerable: true, get: function() {
          return r.Int128;
        } }), Object.defineProperty(o, "Int256", { enumerable: true, get: function() {
          return m.Int256;
        } }), Object.defineProperty(o, "ScInt", { enumerable: true, get: function() {
          return g.ScInt;
        } }), Object.defineProperty(o, "Uint128", { enumerable: true, get: function() {
          return h.Uint128;
        } }), Object.defineProperty(o, "Uint256", { enumerable: true, get: function() {
          return f.Uint256;
        } }), Object.defineProperty(o, "XdrLargeInt", { enumerable: true, get: function() {
          return c.XdrLargeInt;
        } }), o.scValToBigInt = function(a) {
          var l = c.XdrLargeInt.getType(a.switch().name);
          switch (a.switch().name) {
            case "scvU32":
            case "scvI32":
              return BigInt(a.value());
            case "scvU64":
            case "scvI64":
              return new c.XdrLargeInt(l, a.value()).toBigInt();
            case "scvU128":
            case "scvI128":
              return new c.XdrLargeInt(l, [a.value().lo(), a.value().hi()]).toBigInt();
            case "scvU256":
            case "scvI256":
              return new c.XdrLargeInt(l, [a.value().loLo(), a.value().loHi(), a.value().hiLo(), a.value().hiHi()]).toBigInt();
            default:
              throw TypeError("expected integer type, got ".concat(a.switch()));
          }
        };
        var c = u(7429), h = u(6272), f = u(8672), r = u(5487), m = u(4063), g = u(3317);
      }, 8636: (t, o, u) => {
        var c = u(920), h = u(7720), f = u(4765), r = Object.prototype.hasOwnProperty, m = { brackets: function(k) {
          return k + "[]";
        }, comma: "comma", indices: function(k, w) {
          return k + "[" + w + "]";
        }, repeat: function(k) {
          return k;
        } }, g = Array.isArray, a = Array.prototype.push, l = function(k, w) {
          a.apply(k, g(w) ? w : [w]);
        }, d = Date.prototype.toISOString, b = f.default, S = { addQueryPrefix: false, allowDots: false, allowEmptyArrays: false, arrayFormat: "indices", charset: "utf-8", charsetSentinel: false, commaRoundTrip: false, delimiter: "&", encode: true, encodeDotInKeys: false, encoder: h.encode, encodeValuesOnly: false, filter: void 0, format: b, formatter: f.formatters[b], indices: false, serializeDate: function(k) {
          return d.call(k);
        }, skipNulls: false, strictNullHandling: false }, E = {}, R = function k(w, F, I, q, D, H, _, T, L, j, z, Y, te, G, K, J, B, Z) {
          for (var ie, $ = w, oe = Z, ce = 0, ye = false; (oe = oe.get(E)) !== void 0 && !ye; ) {
            var ae = oe.get(w);
            if (ce += 1, ae !== void 0) {
              if (ae === ce) throw new RangeError("Cyclic object value");
              ye = true;
            }
            oe.get(E) === void 0 && (ce = 0);
          }
          if (typeof j == "function" ? $ = j(F, $) : $ instanceof Date ? $ = te($) : I === "comma" && g($) && ($ = h.maybeMap($, function(ee) {
            return ee instanceof Date ? te(ee) : ee;
          })), $ === null) {
            if (H) return L && !J ? L(F, S.encoder, B, "key", G) : F;
            $ = "";
          }
          if (typeof (ie = $) == "string" || typeof ie == "number" || typeof ie == "boolean" || typeof ie == "symbol" || typeof ie == "bigint" || h.isBuffer($)) return L ? [K(J ? F : L(F, S.encoder, B, "key", G)) + "=" + K(L($, S.encoder, B, "value", G))] : [K(F) + "=" + K(String($))];
          var ue, ne = [];
          if ($ === void 0) return ne;
          if (I === "comma" && g($)) J && L && ($ = h.maybeMap($, L)), ue = [{ value: $.length > 0 ? $.join(",") || null : void 0 }];
          else if (g(j)) ue = j;
          else {
            var ge = Object.keys($);
            ue = z ? ge.sort(z) : ge;
          }
          var Te = T ? String(F).replace(/\./g, "%2E") : String(F), pe = q && g($) && $.length === 1 ? Te + "[]" : Te;
          if (D && g($) && $.length === 0) return pe + "[]";
          for (var Oe = 0; Oe < ue.length; ++Oe) {
            var xe = ue[Oe], Ve = typeof xe == "object" && xe && xe.value !== void 0 ? xe.value : $[xe];
            if (!_ || Ve !== null) {
              var _e = Y && T ? String(xe).replace(/\./g, "%2E") : String(xe), Be = g($) ? typeof I == "function" ? I(pe, _e) : pe : pe + (Y ? "." + _e : "[" + _e + "]");
              Z.set(w, ce);
              var Qe = c();
              Qe.set(E, Z), l(ne, k(Ve, Be, I, q, D, H, _, T, I === "comma" && J && g($) ? null : L, j, z, Y, te, G, K, J, B, Qe));
            }
          }
          return ne;
        };
        t.exports = function(k, w) {
          var F, I = k, q = function(G) {
            if (!G) return S;
            if (G.allowEmptyArrays !== void 0 && typeof G.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
            if (G.encodeDotInKeys !== void 0 && typeof G.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
            if (G.encoder !== null && G.encoder !== void 0 && typeof G.encoder != "function") throw new TypeError("Encoder has to be a function.");
            var K = G.charset || S.charset;
            if (G.charset !== void 0 && G.charset !== "utf-8" && G.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            var J = f.default;
            if (G.format !== void 0) {
              if (!r.call(f.formatters, G.format)) throw new TypeError("Unknown format option provided.");
              J = G.format;
            }
            var B, Z = f.formatters[J], ie = S.filter;
            if ((typeof G.filter == "function" || g(G.filter)) && (ie = G.filter), B = G.arrayFormat in m ? G.arrayFormat : "indices" in G ? G.indices ? "indices" : "repeat" : S.arrayFormat, "commaRoundTrip" in G && typeof G.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
            var $ = G.allowDots === void 0 ? G.encodeDotInKeys === true || S.allowDots : !!G.allowDots;
            return { addQueryPrefix: typeof G.addQueryPrefix == "boolean" ? G.addQueryPrefix : S.addQueryPrefix, allowDots: $, allowEmptyArrays: typeof G.allowEmptyArrays == "boolean" ? !!G.allowEmptyArrays : S.allowEmptyArrays, arrayFormat: B, charset: K, charsetSentinel: typeof G.charsetSentinel == "boolean" ? G.charsetSentinel : S.charsetSentinel, commaRoundTrip: !!G.commaRoundTrip, delimiter: G.delimiter === void 0 ? S.delimiter : G.delimiter, encode: typeof G.encode == "boolean" ? G.encode : S.encode, encodeDotInKeys: typeof G.encodeDotInKeys == "boolean" ? G.encodeDotInKeys : S.encodeDotInKeys, encoder: typeof G.encoder == "function" ? G.encoder : S.encoder, encodeValuesOnly: typeof G.encodeValuesOnly == "boolean" ? G.encodeValuesOnly : S.encodeValuesOnly, filter: ie, format: J, formatter: Z, serializeDate: typeof G.serializeDate == "function" ? G.serializeDate : S.serializeDate, skipNulls: typeof G.skipNulls == "boolean" ? G.skipNulls : S.skipNulls, sort: typeof G.sort == "function" ? G.sort : null, strictNullHandling: typeof G.strictNullHandling == "boolean" ? G.strictNullHandling : S.strictNullHandling };
          }(w);
          typeof q.filter == "function" ? I = (0, q.filter)("", I) : g(q.filter) && (F = q.filter);
          var D = [];
          if (typeof I != "object" || I === null) return "";
          var H = m[q.arrayFormat], _ = H === "comma" && q.commaRoundTrip;
          F || (F = Object.keys(I)), q.sort && F.sort(q.sort);
          for (var T = c(), L = 0; L < F.length; ++L) {
            var j = F[L], z = I[j];
            q.skipNulls && z === null || l(D, R(z, j, H, _, q.allowEmptyArrays, q.strictNullHandling, q.skipNulls, q.encodeDotInKeys, q.encode ? q.encoder : null, q.filter, q.sort, q.allowDots, q.serializeDate, q.format, q.formatter, q.encodeValuesOnly, q.charset, T));
          }
          var Y = D.join(q.delimiter), te = q.addQueryPrefix === true ? "?" : "";
          return q.charsetSentinel && (q.charset === "iso-8859-1" ? te += "utf8=%26%2310003%3B&" : te += "utf8=%E2%9C%93&"), Y.length > 0 ? te + Y : "";
        };
      }, 8648: (t) => {
        t.exports = typeof Reflect < "u" && Reflect.getPrototypeOf || null;
      }, 8672: (t, o, u) => {
        function c(d) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(b) {
            return typeof b;
          } : function(b) {
            return b && typeof Symbol == "function" && b.constructor === Symbol && b !== Symbol.prototype ? "symbol" : typeof b;
          }, c(d);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.Uint256 = void 0;
        var h = u(3740);
        function f(d, b) {
          for (var S = 0; S < b.length; S++) {
            var E = b[S];
            E.enumerable = E.enumerable || false, E.configurable = true, "value" in E && (E.writable = true), Object.defineProperty(d, r(E.key), E);
          }
        }
        function r(d) {
          var b = function(S, E) {
            if (c(S) != "object" || !S) return S;
            var R = S[Symbol.toPrimitive];
            if (R !== void 0) {
              var k = R.call(S, E);
              if (c(k) != "object") return k;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(S);
          }(d, "string");
          return c(b) == "symbol" ? b : b + "";
        }
        function m(d, b, S) {
          return b = a(b), function(E, R) {
            if (R && (c(R) == "object" || typeof R == "function")) return R;
            if (R !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(k) {
              if (k === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return k;
            }(E);
          }(d, g() ? Reflect.construct(b, S || [], a(d).constructor) : b.apply(d, S));
        }
        function g() {
          try {
            var d = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (g = function() {
            return !!d;
          })();
        }
        function a(d) {
          return a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(b) {
            return b.__proto__ || Object.getPrototypeOf(b);
          }, a(d);
        }
        function l(d, b) {
          return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(S, E) {
            return S.__proto__ = E, S;
          }, l(d, b);
        }
        (o.Uint256 = function(d) {
          function b() {
            (function(I, q) {
              if (!(I instanceof q)) throw new TypeError("Cannot call a class as a function");
            })(this, b);
            for (var k = arguments.length, w = new Array(k), F = 0; F < k; F++) w[F] = arguments[F];
            return m(this, b, [w]);
          }
          return function(k, w) {
            if (typeof w != "function" && w !== null) throw new TypeError("Super expression must either be null or a function");
            k.prototype = Object.create(w && w.prototype, { constructor: { value: k, writable: true, configurable: true } }), Object.defineProperty(k, "prototype", { writable: false }), w && l(k, w);
          }(b, d), S = b, (E = [{ key: "unsigned", get: function() {
            return true;
          } }, { key: "size", get: function() {
            return 256;
          } }]) && f(S.prototype, E), R && f(S, R), Object.defineProperty(S, "prototype", { writable: false }), S;
          var S, E, R;
        }(h.LargeInt)).defineIntBoundaries();
      }, 8680: (t, o, u) => {
        u.d(o, { X: () => r });
        var c = u(356), h = u(4076), f = u(784);
        function r(m, g) {
          if ("innerTransaction" in m) return r(m.innerTransaction, g);
          if (!function(k) {
            if (k.operations.length !== 1) return false;
            switch (k.operations[0].type) {
              case "invokeHostFunction":
              case "extendFootprintTtl":
              case "restoreFootprint":
                return true;
              default:
                return false;
            }
          }(m)) throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
          var a = (0, f.jr)(g);
          if (!h.j.isSimulationSuccess(a)) throw new Error("simulation incorrect: ".concat(JSON.stringify(a)));
          var l = parseInt(m.fee) || 0, d = parseInt(a.minResourceFee) || 0, b = c.TransactionBuilder.cloneFrom(m, { fee: (l + d).toString(), sorobanData: a.transactionData.build(), networkPassphrase: m.networkPassphrase });
          if (m.operations[0].type === "invokeHostFunction") {
            var S;
            b.clearOperations();
            var E = m.operations[0], R = (S = E.auth) !== null && S !== void 0 ? S : [];
            b.addOperation(c.Operation.invokeHostFunction({ source: E.source, func: E.func, auth: R.length > 0 ? R : a.result.auth }));
          }
          return b;
        }
      }, 8732: (t, o, u) => {
        function c(R) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
            return typeof k;
          } : function(k) {
            return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
          }, c(R);
        }
        function h(R, k) {
          for (var w = 0; w < k.length; w++) {
            var F = k[w];
            F.enumerable = F.enumerable || false, F.configurable = true, "value" in F && (F.writable = true), Object.defineProperty(R, g(F.key), F);
          }
        }
        function f(R, k) {
          var w = Object.keys(R);
          if (Object.getOwnPropertySymbols) {
            var F = Object.getOwnPropertySymbols(R);
            k && (F = F.filter(function(I) {
              return Object.getOwnPropertyDescriptor(R, I).enumerable;
            })), w.push.apply(w, F);
          }
          return w;
        }
        function r(R) {
          for (var k = 1; k < arguments.length; k++) {
            var w = arguments[k] != null ? arguments[k] : {};
            k % 2 ? f(Object(w), true).forEach(function(F) {
              m(R, F, w[F]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(R, Object.getOwnPropertyDescriptors(w)) : f(Object(w)).forEach(function(F) {
              Object.defineProperty(R, F, Object.getOwnPropertyDescriptor(w, F));
            });
          }
          return R;
        }
        function m(R, k, w) {
          return (k = g(k)) in R ? Object.defineProperty(R, k, { value: w, enumerable: true, configurable: true, writable: true }) : R[k] = w, R;
        }
        function g(R) {
          var k = function(w, F) {
            if (c(w) != "object" || !w) return w;
            var I = w[Symbol.toPrimitive];
            if (I !== void 0) {
              var q = I.call(w, F);
              if (c(q) != "object") return q;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (F === "string" ? String : Number)(w);
          }(R, "string");
          return c(k) == "symbol" ? k : k + "";
        }
        u.d(o, { T: () => E });
        var a, l, d, b = { allowHttp: false, timeout: 0 }, S = r({}, b), E = (a = function R() {
          (function(k, w) {
            if (!(k instanceof w)) throw new TypeError("Cannot call a class as a function");
          })(this, R);
        }, d = [{ key: "setAllowHttp", value: function(R) {
          S.allowHttp = R;
        } }, { key: "setTimeout", value: function(R) {
          S.timeout = R;
        } }, { key: "isAllowHttp", value: function() {
          return S.allowHttp;
        } }, { key: "getTimeout", value: function() {
          return S.timeout;
        } }, { key: "setDefault", value: function() {
          S = r({}, b);
        } }], (l = null) && h(a.prototype, l), d && h(a, d), Object.defineProperty(a, "prototype", { writable: false }), a);
      }, 8733: (t, o, u) => {
        var c;
        u.r(o), u.d(o, { AccountResponse: () => R, AxiosClient: () => xe, HorizonApi: () => c, SERVER_TIME_MAP: () => Te, Server: () => la, ServerApi: () => f, default: () => Rn, getCurrentServerTime: () => Ve }), function(Ie) {
          var ve = function(pt) {
            return pt.constantProduct = "constant_product", pt;
          }({});
          Ie.LiquidityPoolType = ve;
          var he = function(pt) {
            return pt.createAccount = "create_account", pt.payment = "payment", pt.pathPayment = "path_payment_strict_receive", pt.createPassiveOffer = "create_passive_sell_offer", pt.manageOffer = "manage_sell_offer", pt.setOptions = "set_options", pt.changeTrust = "change_trust", pt.allowTrust = "allow_trust", pt.accountMerge = "account_merge", pt.inflation = "inflation", pt.manageData = "manage_data", pt.bumpSequence = "bump_sequence", pt.manageBuyOffer = "manage_buy_offer", pt.pathPaymentStrictSend = "path_payment_strict_send", pt.createClaimableBalance = "create_claimable_balance", pt.claimClaimableBalance = "claim_claimable_balance", pt.beginSponsoringFutureReserves = "begin_sponsoring_future_reserves", pt.endSponsoringFutureReserves = "end_sponsoring_future_reserves", pt.revokeSponsorship = "revoke_sponsorship", pt.clawback = "clawback", pt.clawbackClaimableBalance = "clawback_claimable_balance", pt.setTrustLineFlags = "set_trust_line_flags", pt.liquidityPoolDeposit = "liquidity_pool_deposit", pt.liquidityPoolWithdraw = "liquidity_pool_withdraw", pt.invokeHostFunction = "invoke_host_function", pt.bumpFootprintExpiration = "bump_footprint_expiration", pt.restoreFootprint = "restore_footprint", pt;
          }({});
          Ie.OperationResponseType = he;
          var ke = function(pt) {
            return pt[pt.createAccount = 0] = "createAccount", pt[pt.payment = 1] = "payment", pt[pt.pathPayment = 2] = "pathPayment", pt[pt.createPassiveOffer = 3] = "createPassiveOffer", pt[pt.manageOffer = 4] = "manageOffer", pt[pt.setOptions = 5] = "setOptions", pt[pt.changeTrust = 6] = "changeTrust", pt[pt.allowTrust = 7] = "allowTrust", pt[pt.accountMerge = 8] = "accountMerge", pt[pt.inflation = 9] = "inflation", pt[pt.manageData = 10] = "manageData", pt[pt.bumpSequence = 11] = "bumpSequence", pt[pt.manageBuyOffer = 12] = "manageBuyOffer", pt[pt.pathPaymentStrictSend = 13] = "pathPaymentStrictSend", pt[pt.createClaimableBalance = 14] = "createClaimableBalance", pt[pt.claimClaimableBalance = 15] = "claimClaimableBalance", pt[pt.beginSponsoringFutureReserves = 16] = "beginSponsoringFutureReserves", pt[pt.endSponsoringFutureReserves = 17] = "endSponsoringFutureReserves", pt[pt.revokeSponsorship = 18] = "revokeSponsorship", pt[pt.clawback = 19] = "clawback", pt[pt.clawbackClaimableBalance = 20] = "clawbackClaimableBalance", pt[pt.setTrustLineFlags = 21] = "setTrustLineFlags", pt[pt.liquidityPoolDeposit = 22] = "liquidityPoolDeposit", pt[pt.liquidityPoolWithdraw = 23] = "liquidityPoolWithdraw", pt[pt.invokeHostFunction = 24] = "invokeHostFunction", pt[pt.bumpFootprintExpiration = 25] = "bumpFootprintExpiration", pt[pt.restoreFootprint = 26] = "restoreFootprint", pt;
          }({});
          Ie.OperationResponseTypeI = ke;
          var ht = function(pt) {
            return pt.TX_FAILED = "tx_failed", pt.TX_BAD_SEQ = "tx_bad_seq", pt.TX_BAD_AUTH = "tx_bad_auth", pt.TX_BAD_AUTH_EXTRA = "tx_bad_auth_extra", pt.TX_FEE_BUMP_INNER_SUCCESS = "tx_fee_bump_inner_success", pt.TX_FEE_BUMP_INNER_FAILED = "tx_fee_bump_inner_failed", pt.TX_NOT_SUPPORTED = "tx_not_supported", pt.TX_SUCCESS = "tx_success", pt.TX_TOO_EARLY = "tx_too_early", pt.TX_TOO_LATE = "tx_too_late", pt.TX_MISSING_OPERATION = "tx_missing_operation", pt.TX_INSUFFICIENT_BALANCE = "tx_insufficient_balance", pt.TX_NO_SOURCE_ACCOUNT = "tx_no_source_account", pt.TX_INSUFFICIENT_FEE = "tx_insufficient_fee", pt.TX_INTERNAL_ERROR = "tx_internal_error", pt;
          }({});
          Ie.TransactionFailedResultCodes = ht;
        }(c || (c = {}));
        var h, f, r = ((h = {})[h.account_created = 0] = "account_created", h[h.account_removed = 1] = "account_removed", h[h.account_credited = 2] = "account_credited", h[h.account_debited = 3] = "account_debited", h[h.account_thresholds_updated = 4] = "account_thresholds_updated", h[h.account_home_domain_updated = 5] = "account_home_domain_updated", h[h.account_flags_updated = 6] = "account_flags_updated", h[h.account_inflation_destination_updated = 7] = "account_inflation_destination_updated", h[h.signer_created = 10] = "signer_created", h[h.signer_removed = 11] = "signer_removed", h[h.signer_updated = 12] = "signer_updated", h[h.trustline_created = 20] = "trustline_created", h[h.trustline_removed = 21] = "trustline_removed", h[h.trustline_updated = 22] = "trustline_updated", h[h.trustline_authorized = 23] = "trustline_authorized", h[h.trustline_deauthorized = 24] = "trustline_deauthorized", h[h.trustline_authorized_to_maintain_liabilities = 25] = "trustline_authorized_to_maintain_liabilities", h[h.trustline_flags_updated = 26] = "trustline_flags_updated", h[h.offer_created = 30] = "offer_created", h[h.offer_removed = 31] = "offer_removed", h[h.offer_updated = 32] = "offer_updated", h[h.trade = 33] = "trade", h[h.data_created = 40] = "data_created", h[h.data_removed = 41] = "data_removed", h[h.data_updated = 42] = "data_updated", h[h.sequence_bumped = 43] = "sequence_bumped", h[h.claimable_balance_created = 50] = "claimable_balance_created", h[h.claimable_balance_claimant_created = 51] = "claimable_balance_claimant_created", h[h.claimable_balance_claimed = 52] = "claimable_balance_claimed", h[h.account_sponsorship_created = 60] = "account_sponsorship_created", h[h.account_sponsorship_updated = 61] = "account_sponsorship_updated", h[h.account_sponsorship_removed = 62] = "account_sponsorship_removed", h[h.trustline_sponsorship_created = 63] = "trustline_sponsorship_created", h[h.trustline_sponsorship_updated = 64] = "trustline_sponsorship_updated", h[h.trustline_sponsorship_removed = 65] = "trustline_sponsorship_removed", h[h.data_sponsorship_created = 66] = "data_sponsorship_created", h[h.data_sponsorship_updated = 67] = "data_sponsorship_updated", h[h.data_sponsorship_removed = 68] = "data_sponsorship_removed", h[h.claimable_balance_sponsorship_created = 69] = "claimable_balance_sponsorship_created", h[h.claimable_balance_sponsorship_updated = 70] = "claimable_balance_sponsorship_updated", h[h.claimable_balance_sponsorship_removed = 71] = "claimable_balance_sponsorship_removed", h[h.signer_sponsorship_created = 72] = "signer_sponsorship_created", h[h.signer_sponsorship_updated = 73] = "signer_sponsorship_updated", h[h.signer_sponsorship_removed = 74] = "signer_sponsorship_removed", h[h.claimable_balance_clawed_back = 80] = "claimable_balance_clawed_back", h[h.liquidity_pool_deposited = 90] = "liquidity_pool_deposited", h[h.liquidity_pool_withdrew = 91] = "liquidity_pool_withdrew", h[h.liquidity_pool_trade = 92] = "liquidity_pool_trade", h[h.liquidity_pool_created = 93] = "liquidity_pool_created", h[h.liquidity_pool_removed = 94] = "liquidity_pool_removed", h[h.liquidity_pool_revoked = 95] = "liquidity_pool_revoked", h[h.contract_credited = 96] = "contract_credited", h[h.contract_debited = 97] = "contract_debited", h);
        (function(Ie) {
          Ie.EffectType = r;
          var ve = function(he) {
            return he.all = "all", he.liquidityPools = "liquidity_pool", he.orderbook = "orderbook", he;
          }({});
          Ie.TradeType = ve, c.OperationResponseType, c.OperationResponseTypeI;
        })(f || (f = {}));
        var m = u(356);
        function g(Ie) {
          return g = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, g(Ie);
        }
        function a(Ie, ve) {
          return function(he) {
            if (Array.isArray(he)) return he;
          }(Ie) || function(he, ke) {
            var ht = he == null ? null : typeof Symbol < "u" && he[Symbol.iterator] || he["@@iterator"];
            if (ht != null) {
              var pt, Pr, cn, on, sn = [], Nn = true, Vn = false;
              try {
                if (cn = (ht = ht.call(he)).next, ke !== 0) for (; !(Nn = (pt = cn.call(ht)).done) && (sn.push(pt.value), sn.length !== ke); Nn = true) ;
              } catch (ln) {
                Vn = true, Pr = ln;
              } finally {
                try {
                  if (!Nn && ht.return != null && (on = ht.return(), Object(on) !== on)) return;
                } finally {
                  if (Vn) throw Pr;
                }
              }
              return sn;
            }
          }(Ie, ve) || function(he, ke) {
            if (he) {
              if (typeof he == "string") return l(he, ke);
              var ht = {}.toString.call(he).slice(8, -1);
              return ht === "Object" && he.constructor && (ht = he.constructor.name), ht === "Map" || ht === "Set" ? Array.from(he) : ht === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ht) ? l(he, ke) : void 0;
            }
          }(Ie, ve) || function() {
            throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
          }();
        }
        function l(Ie, ve) {
          (ve == null || ve > Ie.length) && (ve = Ie.length);
          for (var he = 0, ke = Array(ve); he < ve; he++) ke[he] = Ie[he];
          return ke;
        }
        function d(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, b(ke.key), ke);
          }
        }
        function b(Ie) {
          var ve = function(he, ke) {
            if (g(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (g(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return g(ve) == "symbol" ? ve : ve + "";
        }
        var S, E, R = (S = function Ie(ve) {
          var he = this;
          (function(ke, ht) {
            if (!(ke instanceof ht)) throw new TypeError("Cannot call a class as a function");
          })(this, Ie), this._baseAccount = new m.Account(ve.account_id, ve.sequence), Object.entries(ve).forEach(function(ke) {
            var ht = a(ke, 2), pt = ht[0], Pr = ht[1];
            he[pt] = Pr;
          });
        }, (E = [{ key: "accountId", value: function() {
          return this._baseAccount.accountId();
        } }, { key: "sequenceNumber", value: function() {
          return this._baseAccount.sequenceNumber();
        } }, { key: "incrementSequenceNumber", value: function() {
          this._baseAccount.incrementSequenceNumber(), this.sequence = this._baseAccount.sequenceNumber();
        } }]) && d(S.prototype, E), Object.defineProperty(S, "prototype", { writable: false }), S), k = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, w = Math.ceil, F = Math.floor, I = "[BigNumber Error] ", q = I + "Number primitive has more than 15 significant digits: ", D = 1e14, H = 14, _ = 9007199254740991, T = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], L = 1e7, j = 1e9;
        function z(Ie) {
          var ve = 0 | Ie;
          return Ie > 0 || Ie === ve ? ve : ve - 1;
        }
        function Y(Ie) {
          for (var ve, he, ke = 1, ht = Ie.length, pt = Ie[0] + ""; ke < ht; ) {
            for (ve = Ie[ke++] + "", he = H - ve.length; he--; ve = "0" + ve) ;
            pt += ve;
          }
          for (ht = pt.length; pt.charCodeAt(--ht) === 48; ) ;
          return pt.slice(0, ht + 1 || 1);
        }
        function te(Ie, ve) {
          var he, ke, ht = Ie.c, pt = ve.c, Pr = Ie.s, cn = ve.s, on = Ie.e, sn = ve.e;
          if (!Pr || !cn) return null;
          if (he = ht && !ht[0], ke = pt && !pt[0], he || ke) return he ? ke ? 0 : -cn : Pr;
          if (Pr != cn) return Pr;
          if (he = Pr < 0, ke = on == sn, !ht || !pt) return ke ? 0 : !ht ^ he ? 1 : -1;
          if (!ke) return on > sn ^ he ? 1 : -1;
          for (cn = (on = ht.length) < (sn = pt.length) ? on : sn, Pr = 0; Pr < cn; Pr++) if (ht[Pr] != pt[Pr]) return ht[Pr] > pt[Pr] ^ he ? 1 : -1;
          return on == sn ? 0 : on > sn ^ he ? 1 : -1;
        }
        function G(Ie, ve, he, ke) {
          if (Ie < ve || Ie > he || Ie !== F(Ie)) throw Error(I + (ke || "Argument") + (typeof Ie == "number" ? Ie < ve || Ie > he ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(Ie));
        }
        function K(Ie) {
          var ve = Ie.c.length - 1;
          return z(Ie.e / H) == ve && Ie.c[ve] % 2 != 0;
        }
        function J(Ie, ve) {
          return (Ie.length > 1 ? Ie.charAt(0) + "." + Ie.slice(1) : Ie) + (ve < 0 ? "e" : "e+") + ve;
        }
        function B(Ie, ve, he) {
          var ke, ht;
          if (ve < 0) {
            for (ht = he + "."; ++ve; ht += he) ;
            Ie = ht + Ie;
          } else if (++ve > (ke = Ie.length)) {
            for (ht = he, ve -= ke; --ve; ht += he) ;
            Ie += ht;
          } else ve < ke && (Ie = Ie.slice(0, ve) + "." + Ie.slice(ve));
          return Ie;
        }
        var Z = function Ie(ve) {
          var he, ke, ht, pt, Pr, cn, on, sn, Nn, Vn, ln = pr.prototype = { constructor: pr, toString: null, valueOf: null }, oi = new pr(1), Hn = 20, Tn = 4, xn = -7, Gn = 21, Kn = -1e7, Pn = 1e7, Xn = false, kt = 1, Kt = 0, lr = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, Er = "0123456789abcdefghijklmnopqrstuvwxyz", Rr = true;
          function pr(Fe, He) {
            var et, jt, At, qt, Jt, er, mr, Ar, xr = this;
            if (!(xr instanceof pr)) return new pr(Fe, He);
            if (He == null) {
              if (Fe && Fe._isBigNumber === true) return xr.s = Fe.s, void (!Fe.c || Fe.e > Pn ? xr.c = xr.e = null : Fe.e < Kn ? xr.c = [xr.e = 0] : (xr.e = Fe.e, xr.c = Fe.c.slice()));
              if ((er = typeof Fe == "number") && 0 * Fe == 0) {
                if (xr.s = 1 / Fe < 0 ? (Fe = -Fe, -1) : 1, Fe === ~~Fe) {
                  for (qt = 0, Jt = Fe; Jt >= 10; Jt /= 10, qt++) ;
                  return void (qt > Pn ? xr.c = xr.e = null : (xr.e = qt, xr.c = [Fe]));
                }
                Ar = String(Fe);
              } else {
                if (!k.test(Ar = String(Fe))) return ht(xr, Ar, er);
                xr.s = Ar.charCodeAt(0) == 45 ? (Ar = Ar.slice(1), -1) : 1;
              }
              (qt = Ar.indexOf(".")) > -1 && (Ar = Ar.replace(".", "")), (Jt = Ar.search(/e/i)) > 0 ? (qt < 0 && (qt = Jt), qt += +Ar.slice(Jt + 1), Ar = Ar.substring(0, Jt)) : qt < 0 && (qt = Ar.length);
            } else {
              if (G(He, 2, Er.length, "Base"), He == 10 && Rr) return mn(xr = new pr(Fe), Hn + xr.e + 1, Tn);
              if (Ar = String(Fe), er = typeof Fe == "number") {
                if (0 * Fe != 0) return ht(xr, Ar, er, He);
                if (xr.s = 1 / Fe < 0 ? (Ar = Ar.slice(1), -1) : 1, pr.DEBUG && Ar.replace(/^0\.0*|\./, "").length > 15) throw Error(q + Fe);
              } else xr.s = Ar.charCodeAt(0) === 45 ? (Ar = Ar.slice(1), -1) : 1;
              for (et = Er.slice(0, He), qt = Jt = 0, mr = Ar.length; Jt < mr; Jt++) if (et.indexOf(jt = Ar.charAt(Jt)) < 0) {
                if (jt == ".") {
                  if (Jt > qt) {
                    qt = mr;
                    continue;
                  }
                } else if (!At && (Ar == Ar.toUpperCase() && (Ar = Ar.toLowerCase()) || Ar == Ar.toLowerCase() && (Ar = Ar.toUpperCase()))) {
                  At = true, Jt = -1, qt = 0;
                  continue;
                }
                return ht(xr, String(Fe), er, He);
              }
              er = false, (qt = (Ar = ke(Ar, He, 10, xr.s)).indexOf(".")) > -1 ? Ar = Ar.replace(".", "") : qt = Ar.length;
            }
            for (Jt = 0; Ar.charCodeAt(Jt) === 48; Jt++) ;
            for (mr = Ar.length; Ar.charCodeAt(--mr) === 48; ) ;
            if (Ar = Ar.slice(Jt, ++mr)) {
              if (mr -= Jt, er && pr.DEBUG && mr > 15 && (Fe > _ || Fe !== F(Fe))) throw Error(q + xr.s * Fe);
              if ((qt = qt - Jt - 1) > Pn) xr.c = xr.e = null;
              else if (qt < Kn) xr.c = [xr.e = 0];
              else {
                if (xr.e = qt, xr.c = [], Jt = (qt + 1) % H, qt < 0 && (Jt += H), Jt < mr) {
                  for (Jt && xr.c.push(+Ar.slice(0, Jt)), mr -= H; Jt < mr; ) xr.c.push(+Ar.slice(Jt, Jt += H));
                  Jt = H - (Ar = Ar.slice(Jt)).length;
                } else Jt -= mr;
                for (; Jt--; Ar += "0") ;
                xr.c.push(+Ar);
              }
            } else xr.c = [xr.e = 0];
          }
          function tn(Fe, He, et, jt) {
            var At, qt, Jt, er, mr;
            if (et == null ? et = Tn : G(et, 0, 8), !Fe.c) return Fe.toString();
            if (At = Fe.c[0], Jt = Fe.e, He == null) mr = Y(Fe.c), mr = jt == 1 || jt == 2 && (Jt <= xn || Jt >= Gn) ? J(mr, Jt) : B(mr, Jt, "0");
            else if (qt = (Fe = mn(new pr(Fe), He, et)).e, er = (mr = Y(Fe.c)).length, jt == 1 || jt == 2 && (He <= qt || qt <= xn)) {
              for (; er < He; mr += "0", er++) ;
              mr = J(mr, qt);
            } else if (He -= Jt, mr = B(mr, qt, "0"), qt + 1 > er) {
              if (--He > 0) for (mr += "."; He--; mr += "0") ;
            } else if ((He += qt - er) > 0) for (qt + 1 == er && (mr += "."); He--; mr += "0") ;
            return Fe.s < 0 && At ? "-" + mr : mr;
          }
          function fn(Fe, He) {
            for (var et, jt, At = 1, qt = new pr(Fe[0]); At < Fe.length; At++) (!(jt = new pr(Fe[At])).s || (et = te(qt, jt)) === He || et === 0 && qt.s === He) && (qt = jt);
            return qt;
          }
          function rn(Fe, He, et) {
            for (var jt = 1, At = He.length; !He[--At]; He.pop()) ;
            for (At = He[0]; At >= 10; At /= 10, jt++) ;
            return (et = jt + et * H - 1) > Pn ? Fe.c = Fe.e = null : et < Kn ? Fe.c = [Fe.e = 0] : (Fe.e = et, Fe.c = He), Fe;
          }
          function mn(Fe, He, et, jt) {
            var At, qt, Jt, er, mr, Ar, xr, Jr = Fe.c, vn = T;
            if (Jr) {
              e: {
                for (At = 1, er = Jr[0]; er >= 10; er /= 10, At++) ;
                if ((qt = He - At) < 0) qt += H, Jt = He, mr = Jr[Ar = 0], xr = F(mr / vn[At - Jt - 1] % 10);
                else if ((Ar = w((qt + 1) / H)) >= Jr.length) {
                  if (!jt) break e;
                  for (; Jr.length <= Ar; Jr.push(0)) ;
                  mr = xr = 0, At = 1, Jt = (qt %= H) - H + 1;
                } else {
                  for (mr = er = Jr[Ar], At = 1; er >= 10; er /= 10, At++) ;
                  xr = (Jt = (qt %= H) - H + At) < 0 ? 0 : F(mr / vn[At - Jt - 1] % 10);
                }
                if (jt = jt || He < 0 || Jr[Ar + 1] != null || (Jt < 0 ? mr : mr % vn[At - Jt - 1]), jt = et < 4 ? (xr || jt) && (et == 0 || et == (Fe.s < 0 ? 3 : 2)) : xr > 5 || xr == 5 && (et == 4 || jt || et == 6 && (qt > 0 ? Jt > 0 ? mr / vn[At - Jt] : 0 : Jr[Ar - 1]) % 10 & 1 || et == (Fe.s < 0 ? 8 : 7)), He < 1 || !Jr[0]) return Jr.length = 0, jt ? (He -= Fe.e + 1, Jr[0] = vn[(H - He % H) % H], Fe.e = -He || 0) : Jr[0] = Fe.e = 0, Fe;
                if (qt == 0 ? (Jr.length = Ar, er = 1, Ar--) : (Jr.length = Ar + 1, er = vn[H - qt], Jr[Ar] = Jt > 0 ? F(mr / vn[At - Jt] % vn[Jt]) * er : 0), jt) for (; ; ) {
                  if (Ar == 0) {
                    for (qt = 1, Jt = Jr[0]; Jt >= 10; Jt /= 10, qt++) ;
                    for (Jt = Jr[0] += er, er = 1; Jt >= 10; Jt /= 10, er++) ;
                    qt != er && (Fe.e++, Jr[0] == D && (Jr[0] = 1));
                    break;
                  }
                  if (Jr[Ar] += er, Jr[Ar] != D) break;
                  Jr[Ar--] = 0, er = 1;
                }
                for (qt = Jr.length; Jr[--qt] === 0; Jr.pop()) ;
              }
              Fe.e > Pn ? Fe.c = Fe.e = null : Fe.e < Kn && (Fe.c = [Fe.e = 0]);
            }
            return Fe;
          }
          function pn(Fe) {
            var He, et = Fe.e;
            return et === null ? Fe.toString() : (He = Y(Fe.c), He = et <= xn || et >= Gn ? J(He, et) : B(He, et, "0"), Fe.s < 0 ? "-" + He : He);
          }
          return pr.clone = Ie, pr.ROUND_UP = 0, pr.ROUND_DOWN = 1, pr.ROUND_CEIL = 2, pr.ROUND_FLOOR = 3, pr.ROUND_HALF_UP = 4, pr.ROUND_HALF_DOWN = 5, pr.ROUND_HALF_EVEN = 6, pr.ROUND_HALF_CEIL = 7, pr.ROUND_HALF_FLOOR = 8, pr.EUCLID = 9, pr.config = pr.set = function(Fe) {
            var He, et;
            if (Fe != null) {
              if (typeof Fe != "object") throw Error(I + "Object expected: " + Fe);
              if (Fe.hasOwnProperty(He = "DECIMAL_PLACES") && (G(et = Fe[He], 0, j, He), Hn = et), Fe.hasOwnProperty(He = "ROUNDING_MODE") && (G(et = Fe[He], 0, 8, He), Tn = et), Fe.hasOwnProperty(He = "EXPONENTIAL_AT") && ((et = Fe[He]) && et.pop ? (G(et[0], -1e9, 0, He), G(et[1], 0, j, He), xn = et[0], Gn = et[1]) : (G(et, -1e9, j, He), xn = -(Gn = et < 0 ? -et : et))), Fe.hasOwnProperty(He = "RANGE")) if ((et = Fe[He]) && et.pop) G(et[0], -1e9, -1, He), G(et[1], 1, j, He), Kn = et[0], Pn = et[1];
              else {
                if (G(et, -1e9, j, He), !et) throw Error(I + He + " cannot be zero: " + et);
                Kn = -(Pn = et < 0 ? -et : et);
              }
              if (Fe.hasOwnProperty(He = "CRYPTO")) {
                if ((et = Fe[He]) !== !!et) throw Error(I + He + " not true or false: " + et);
                if (et) {
                  if (typeof crypto > "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Xn = !et, Error(I + "crypto unavailable");
                  Xn = et;
                } else Xn = et;
              }
              if (Fe.hasOwnProperty(He = "MODULO_MODE") && (G(et = Fe[He], 0, 9, He), kt = et), Fe.hasOwnProperty(He = "POW_PRECISION") && (G(et = Fe[He], 0, j, He), Kt = et), Fe.hasOwnProperty(He = "FORMAT")) {
                if (typeof (et = Fe[He]) != "object") throw Error(I + He + " not an object: " + et);
                lr = et;
              }
              if (Fe.hasOwnProperty(He = "ALPHABET")) {
                if (typeof (et = Fe[He]) != "string" || /^.?$|[+\-.\s]|(.).*\1/.test(et)) throw Error(I + He + " invalid: " + et);
                Rr = et.slice(0, 10) == "0123456789", Er = et;
              }
            }
            return { DECIMAL_PLACES: Hn, ROUNDING_MODE: Tn, EXPONENTIAL_AT: [xn, Gn], RANGE: [Kn, Pn], CRYPTO: Xn, MODULO_MODE: kt, POW_PRECISION: Kt, FORMAT: lr, ALPHABET: Er };
          }, pr.isBigNumber = function(Fe) {
            if (!Fe || Fe._isBigNumber !== true) return false;
            if (!pr.DEBUG) return true;
            var He, et, jt = Fe.c, At = Fe.e, qt = Fe.s;
            e: if ({}.toString.call(jt) == "[object Array]") {
              if ((qt === 1 || qt === -1) && At >= -1e9 && At <= j && At === F(At)) {
                if (jt[0] === 0) {
                  if (At === 0 && jt.length === 1) return true;
                  break e;
                }
                if ((He = (At + 1) % H) < 1 && (He += H), String(jt[0]).length == He) {
                  for (He = 0; He < jt.length; He++) if ((et = jt[He]) < 0 || et >= D || et !== F(et)) break e;
                  if (et !== 0) return true;
                }
              }
            } else if (jt === null && At === null && (qt === null || qt === 1 || qt === -1)) return true;
            throw Error(I + "Invalid BigNumber: " + Fe);
          }, pr.maximum = pr.max = function() {
            return fn(arguments, -1);
          }, pr.minimum = pr.min = function() {
            return fn(arguments, 1);
          }, pr.random = (pt = 9007199254740992, Pr = Math.random() * pt & 2097151 ? function() {
            return F(Math.random() * pt);
          } : function() {
            return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0);
          }, function(Fe) {
            var He, et, jt, At, qt, Jt = 0, er = [], mr = new pr(oi);
            if (Fe == null ? Fe = Hn : G(Fe, 0, j), At = w(Fe / H), Xn) if (crypto.getRandomValues) {
              for (He = crypto.getRandomValues(new Uint32Array(At *= 2)); Jt < At; ) (qt = 131072 * He[Jt] + (He[Jt + 1] >>> 11)) >= 9e15 ? (et = crypto.getRandomValues(new Uint32Array(2)), He[Jt] = et[0], He[Jt + 1] = et[1]) : (er.push(qt % 1e14), Jt += 2);
              Jt = At / 2;
            } else {
              if (!crypto.randomBytes) throw Xn = false, Error(I + "crypto unavailable");
              for (He = crypto.randomBytes(At *= 7); Jt < At; ) (qt = 281474976710656 * (31 & He[Jt]) + 1099511627776 * He[Jt + 1] + 4294967296 * He[Jt + 2] + 16777216 * He[Jt + 3] + (He[Jt + 4] << 16) + (He[Jt + 5] << 8) + He[Jt + 6]) >= 9e15 ? crypto.randomBytes(7).copy(He, Jt) : (er.push(qt % 1e14), Jt += 7);
              Jt = At / 7;
            }
            if (!Xn) for (; Jt < At; ) (qt = Pr()) < 9e15 && (er[Jt++] = qt % 1e14);
            for (At = er[--Jt], Fe %= H, At && Fe && (qt = T[H - Fe], er[Jt] = F(At / qt) * qt); er[Jt] === 0; er.pop(), Jt--) ;
            if (Jt < 0) er = [jt = 0];
            else {
              for (jt = -1; er[0] === 0; er.splice(0, 1), jt -= H) ;
              for (Jt = 1, qt = er[0]; qt >= 10; qt /= 10, Jt++) ;
              Jt < H && (jt -= H - Jt);
            }
            return mr.e = jt, mr.c = er, mr;
          }), pr.sum = function() {
            for (var Fe = 1, He = arguments, et = new pr(He[0]); Fe < He.length; ) et = et.plus(He[Fe++]);
            return et;
          }, ke = /* @__PURE__ */ function() {
            var Fe = "0123456789";
            function He(et, jt, At, qt) {
              for (var Jt, er, mr = [0], Ar = 0, xr = et.length; Ar < xr; ) {
                for (er = mr.length; er--; mr[er] *= jt) ;
                for (mr[0] += qt.indexOf(et.charAt(Ar++)), Jt = 0; Jt < mr.length; Jt++) mr[Jt] > At - 1 && (mr[Jt + 1] == null && (mr[Jt + 1] = 0), mr[Jt + 1] += mr[Jt] / At | 0, mr[Jt] %= At);
              }
              return mr.reverse();
            }
            return function(et, jt, At, qt, Jt) {
              var er, mr, Ar, xr, Jr, vn, _n, Dn, Zn = et.indexOf("."), ai = Hn, Ln = Tn;
              for (Zn >= 0 && (xr = Kt, Kt = 0, et = et.replace(".", ""), vn = (Dn = new pr(jt)).pow(et.length - Zn), Kt = xr, Dn.c = He(B(Y(vn.c), vn.e, "0"), 10, At, Fe), Dn.e = Dn.c.length), Ar = xr = (_n = He(et, jt, At, Jt ? (er = Er, Fe) : (er = Fe, Er))).length; _n[--xr] == 0; _n.pop()) ;
              if (!_n[0]) return er.charAt(0);
              if (Zn < 0 ? --Ar : (vn.c = _n, vn.e = Ar, vn.s = qt, _n = (vn = he(vn, Dn, ai, Ln, At)).c, Jr = vn.r, Ar = vn.e), Zn = _n[mr = Ar + ai + 1], xr = At / 2, Jr = Jr || mr < 0 || _n[mr + 1] != null, Jr = Ln < 4 ? (Zn != null || Jr) && (Ln == 0 || Ln == (vn.s < 0 ? 3 : 2)) : Zn > xr || Zn == xr && (Ln == 4 || Jr || Ln == 6 && 1 & _n[mr - 1] || Ln == (vn.s < 0 ? 8 : 7)), mr < 1 || !_n[0]) et = Jr ? B(er.charAt(1), -ai, er.charAt(0)) : er.charAt(0);
              else {
                if (_n.length = mr, Jr) for (--At; ++_n[--mr] > At; ) _n[mr] = 0, mr || (++Ar, _n = [1].concat(_n));
                for (xr = _n.length; !_n[--xr]; ) ;
                for (Zn = 0, et = ""; Zn <= xr; et += er.charAt(_n[Zn++])) ;
                et = B(et, Ar, er.charAt(0));
              }
              return et;
            };
          }(), he = /* @__PURE__ */ function() {
            function Fe(jt, At, qt) {
              var Jt, er, mr, Ar, xr = 0, Jr = jt.length, vn = At % L, _n = At / L | 0;
              for (jt = jt.slice(); Jr--; ) xr = ((er = vn * (mr = jt[Jr] % L) + (Jt = _n * mr + (Ar = jt[Jr] / L | 0) * vn) % L * L + xr) / qt | 0) + (Jt / L | 0) + _n * Ar, jt[Jr] = er % qt;
              return xr && (jt = [xr].concat(jt)), jt;
            }
            function He(jt, At, qt, Jt) {
              var er, mr;
              if (qt != Jt) mr = qt > Jt ? 1 : -1;
              else for (er = mr = 0; er < qt; er++) if (jt[er] != At[er]) {
                mr = jt[er] > At[er] ? 1 : -1;
                break;
              }
              return mr;
            }
            function et(jt, At, qt, Jt) {
              for (var er = 0; qt--; ) jt[qt] -= er, er = jt[qt] < At[qt] ? 1 : 0, jt[qt] = er * Jt + jt[qt] - At[qt];
              for (; !jt[0] && jt.length > 1; jt.splice(0, 1)) ;
            }
            return function(jt, At, qt, Jt, er) {
              var mr, Ar, xr, Jr, vn, _n, Dn, Zn, ai, Ln, zn, hi, Hs, Rc, Mc, Yi, ja, Di = jt.s == At.s ? 1 : -1, bi = jt.c, $n = At.c;
              if (!(bi && bi[0] && $n && $n[0])) return new pr(jt.s && At.s && (bi ? !$n || bi[0] != $n[0] : $n) ? bi && bi[0] == 0 || !$n ? 0 * Di : Di / 0 : NaN);
              for (ai = (Zn = new pr(Di)).c = [], Di = qt + (Ar = jt.e - At.e) + 1, er || (er = D, Ar = z(jt.e / H) - z(At.e / H), Di = Di / H | 0), xr = 0; $n[xr] == (bi[xr] || 0); xr++) ;
              if ($n[xr] > (bi[xr] || 0) && Ar--, Di < 0) ai.push(1), Jr = true;
              else {
                for (Rc = bi.length, Yi = $n.length, xr = 0, Di += 2, (vn = F(er / ($n[0] + 1))) > 1 && ($n = Fe($n, vn, er), bi = Fe(bi, vn, er), Yi = $n.length, Rc = bi.length), Hs = Yi, zn = (Ln = bi.slice(0, Yi)).length; zn < Yi; Ln[zn++] = 0) ;
                ja = $n.slice(), ja = [0].concat(ja), Mc = $n[0], $n[1] >= er / 2 && Mc++;
                do {
                  if (vn = 0, (mr = He($n, Ln, Yi, zn)) < 0) {
                    if (hi = Ln[0], Yi != zn && (hi = hi * er + (Ln[1] || 0)), (vn = F(hi / Mc)) > 1) for (vn >= er && (vn = er - 1), Dn = (_n = Fe($n, vn, er)).length, zn = Ln.length; He(_n, Ln, Dn, zn) == 1; ) vn--, et(_n, Yi < Dn ? ja : $n, Dn, er), Dn = _n.length, mr = 1;
                    else vn == 0 && (mr = vn = 1), Dn = (_n = $n.slice()).length;
                    if (Dn < zn && (_n = [0].concat(_n)), et(Ln, _n, zn, er), zn = Ln.length, mr == -1) for (; He($n, Ln, Yi, zn) < 1; ) vn++, et(Ln, Yi < zn ? ja : $n, zn, er), zn = Ln.length;
                  } else mr === 0 && (vn++, Ln = [0]);
                  ai[xr++] = vn, Ln[0] ? Ln[zn++] = bi[Hs] || 0 : (Ln = [bi[Hs]], zn = 1);
                } while ((Hs++ < Rc || Ln[0] != null) && Di--);
                Jr = Ln[0] != null, ai[0] || ai.splice(0, 1);
              }
              if (er == D) {
                for (xr = 1, Di = ai[0]; Di >= 10; Di /= 10, xr++) ;
                mn(Zn, qt + (Zn.e = xr + Ar * H - 1) + 1, Jt, Jr);
              } else Zn.e = Ar, Zn.r = +Jr;
              return Zn;
            };
          }(), cn = /^(-?)0([xbo])(?=\w[\w.]*$)/i, on = /^([^.]+)\.$/, sn = /^\.([^.]+)$/, Nn = /^-?(Infinity|NaN)$/, Vn = /^\s*\+(?=[\w.])|^\s+|\s+$/g, ht = function(Fe, He, et, jt) {
            var At, qt = et ? He : He.replace(Vn, "");
            if (Nn.test(qt)) Fe.s = isNaN(qt) ? null : qt < 0 ? -1 : 1;
            else {
              if (!et && (qt = qt.replace(cn, function(Jt, er, mr) {
                return At = (mr = mr.toLowerCase()) == "x" ? 16 : mr == "b" ? 2 : 8, jt && jt != At ? Jt : er;
              }), jt && (At = jt, qt = qt.replace(on, "$1").replace(sn, "0.$1")), He != qt)) return new pr(qt, At);
              if (pr.DEBUG) throw Error(I + "Not a" + (jt ? " base " + jt : "") + " number: " + He);
              Fe.s = null;
            }
            Fe.c = Fe.e = null;
          }, ln.absoluteValue = ln.abs = function() {
            var Fe = new pr(this);
            return Fe.s < 0 && (Fe.s = 1), Fe;
          }, ln.comparedTo = function(Fe, He) {
            return te(this, new pr(Fe, He));
          }, ln.decimalPlaces = ln.dp = function(Fe, He) {
            var et, jt, At, qt = this;
            if (Fe != null) return G(Fe, 0, j), He == null ? He = Tn : G(He, 0, 8), mn(new pr(qt), Fe + qt.e + 1, He);
            if (!(et = qt.c)) return null;
            if (jt = ((At = et.length - 1) - z(this.e / H)) * H, At = et[At]) for (; At % 10 == 0; At /= 10, jt--) ;
            return jt < 0 && (jt = 0), jt;
          }, ln.dividedBy = ln.div = function(Fe, He) {
            return he(this, new pr(Fe, He), Hn, Tn);
          }, ln.dividedToIntegerBy = ln.idiv = function(Fe, He) {
            return he(this, new pr(Fe, He), 0, 1);
          }, ln.exponentiatedBy = ln.pow = function(Fe, He) {
            var et, jt, At, qt, Jt, er, mr, Ar, xr = this;
            if ((Fe = new pr(Fe)).c && !Fe.isInteger()) throw Error(I + "Exponent not an integer: " + pn(Fe));
            if (He != null && (He = new pr(He)), Jt = Fe.e > 14, !xr.c || !xr.c[0] || xr.c[0] == 1 && !xr.e && xr.c.length == 1 || !Fe.c || !Fe.c[0]) return Ar = new pr(Math.pow(+pn(xr), Jt ? Fe.s * (2 - K(Fe)) : +pn(Fe))), He ? Ar.mod(He) : Ar;
            if (er = Fe.s < 0, He) {
              if (He.c ? !He.c[0] : !He.s) return new pr(NaN);
              (jt = !er && xr.isInteger() && He.isInteger()) && (xr = xr.mod(He));
            } else {
              if (Fe.e > 9 && (xr.e > 0 || xr.e < -1 || (xr.e == 0 ? xr.c[0] > 1 || Jt && xr.c[1] >= 24e7 : xr.c[0] < 8e13 || Jt && xr.c[0] <= 9999975e7))) return qt = xr.s < 0 && K(Fe) ? -0 : 0, xr.e > -1 && (qt = 1 / qt), new pr(er ? 1 / qt : qt);
              Kt && (qt = w(Kt / H + 2));
            }
            for (Jt ? (et = new pr(0.5), er && (Fe.s = 1), mr = K(Fe)) : mr = (At = Math.abs(+pn(Fe))) % 2, Ar = new pr(oi); ; ) {
              if (mr) {
                if (!(Ar = Ar.times(xr)).c) break;
                qt ? Ar.c.length > qt && (Ar.c.length = qt) : jt && (Ar = Ar.mod(He));
              }
              if (At) {
                if ((At = F(At / 2)) === 0) break;
                mr = At % 2;
              } else if (mn(Fe = Fe.times(et), Fe.e + 1, 1), Fe.e > 14) mr = K(Fe);
              else {
                if ((At = +pn(Fe)) == 0) break;
                mr = At % 2;
              }
              xr = xr.times(xr), qt ? xr.c && xr.c.length > qt && (xr.c.length = qt) : jt && (xr = xr.mod(He));
            }
            return jt ? Ar : (er && (Ar = oi.div(Ar)), He ? Ar.mod(He) : qt ? mn(Ar, Kt, Tn, void 0) : Ar);
          }, ln.integerValue = function(Fe) {
            var He = new pr(this);
            return Fe == null ? Fe = Tn : G(Fe, 0, 8), mn(He, He.e + 1, Fe);
          }, ln.isEqualTo = ln.eq = function(Fe, He) {
            return te(this, new pr(Fe, He)) === 0;
          }, ln.isFinite = function() {
            return !!this.c;
          }, ln.isGreaterThan = ln.gt = function(Fe, He) {
            return te(this, new pr(Fe, He)) > 0;
          }, ln.isGreaterThanOrEqualTo = ln.gte = function(Fe, He) {
            return (He = te(this, new pr(Fe, He))) === 1 || He === 0;
          }, ln.isInteger = function() {
            return !!this.c && z(this.e / H) > this.c.length - 2;
          }, ln.isLessThan = ln.lt = function(Fe, He) {
            return te(this, new pr(Fe, He)) < 0;
          }, ln.isLessThanOrEqualTo = ln.lte = function(Fe, He) {
            return (He = te(this, new pr(Fe, He))) === -1 || He === 0;
          }, ln.isNaN = function() {
            return !this.s;
          }, ln.isNegative = function() {
            return this.s < 0;
          }, ln.isPositive = function() {
            return this.s > 0;
          }, ln.isZero = function() {
            return !!this.c && this.c[0] == 0;
          }, ln.minus = function(Fe, He) {
            var et, jt, At, qt, Jt = this, er = Jt.s;
            if (He = (Fe = new pr(Fe, He)).s, !er || !He) return new pr(NaN);
            if (er != He) return Fe.s = -He, Jt.plus(Fe);
            var mr = Jt.e / H, Ar = Fe.e / H, xr = Jt.c, Jr = Fe.c;
            if (!mr || !Ar) {
              if (!xr || !Jr) return xr ? (Fe.s = -He, Fe) : new pr(Jr ? Jt : NaN);
              if (!xr[0] || !Jr[0]) return Jr[0] ? (Fe.s = -He, Fe) : new pr(xr[0] ? Jt : Tn == 3 ? -0 : 0);
            }
            if (mr = z(mr), Ar = z(Ar), xr = xr.slice(), er = mr - Ar) {
              for ((qt = er < 0) ? (er = -er, At = xr) : (Ar = mr, At = Jr), At.reverse(), He = er; He--; At.push(0)) ;
              At.reverse();
            } else for (jt = (qt = (er = xr.length) < (He = Jr.length)) ? er : He, er = He = 0; He < jt; He++) if (xr[He] != Jr[He]) {
              qt = xr[He] < Jr[He];
              break;
            }
            if (qt && (At = xr, xr = Jr, Jr = At, Fe.s = -Fe.s), (He = (jt = Jr.length) - (et = xr.length)) > 0) for (; He--; xr[et++] = 0) ;
            for (He = D - 1; jt > er; ) {
              if (xr[--jt] < Jr[jt]) {
                for (et = jt; et && !xr[--et]; xr[et] = He) ;
                --xr[et], xr[jt] += D;
              }
              xr[jt] -= Jr[jt];
            }
            for (; xr[0] == 0; xr.splice(0, 1), --Ar) ;
            return xr[0] ? rn(Fe, xr, Ar) : (Fe.s = Tn == 3 ? -1 : 1, Fe.c = [Fe.e = 0], Fe);
          }, ln.modulo = ln.mod = function(Fe, He) {
            var et, jt, At = this;
            return Fe = new pr(Fe, He), !At.c || !Fe.s || Fe.c && !Fe.c[0] ? new pr(NaN) : !Fe.c || At.c && !At.c[0] ? new pr(At) : (kt == 9 ? (jt = Fe.s, Fe.s = 1, et = he(At, Fe, 0, 3), Fe.s = jt, et.s *= jt) : et = he(At, Fe, 0, kt), (Fe = At.minus(et.times(Fe))).c[0] || kt != 1 || (Fe.s = At.s), Fe);
          }, ln.multipliedBy = ln.times = function(Fe, He) {
            var et, jt, At, qt, Jt, er, mr, Ar, xr, Jr, vn, _n, Dn, Zn, ai, Ln = this, zn = Ln.c, hi = (Fe = new pr(Fe, He)).c;
            if (!(zn && hi && zn[0] && hi[0])) return !Ln.s || !Fe.s || zn && !zn[0] && !hi || hi && !hi[0] && !zn ? Fe.c = Fe.e = Fe.s = null : (Fe.s *= Ln.s, zn && hi ? (Fe.c = [0], Fe.e = 0) : Fe.c = Fe.e = null), Fe;
            for (jt = z(Ln.e / H) + z(Fe.e / H), Fe.s *= Ln.s, (mr = zn.length) < (Jr = hi.length) && (Dn = zn, zn = hi, hi = Dn, At = mr, mr = Jr, Jr = At), At = mr + Jr, Dn = []; At--; Dn.push(0)) ;
            for (Zn = D, ai = L, At = Jr; --At >= 0; ) {
              for (et = 0, vn = hi[At] % ai, _n = hi[At] / ai | 0, qt = At + (Jt = mr); qt > At; ) et = ((Ar = vn * (Ar = zn[--Jt] % ai) + (er = _n * Ar + (xr = zn[Jt] / ai | 0) * vn) % ai * ai + Dn[qt] + et) / Zn | 0) + (er / ai | 0) + _n * xr, Dn[qt--] = Ar % Zn;
              Dn[qt] = et;
            }
            return et ? ++jt : Dn.splice(0, 1), rn(Fe, Dn, jt);
          }, ln.negated = function() {
            var Fe = new pr(this);
            return Fe.s = -Fe.s || null, Fe;
          }, ln.plus = function(Fe, He) {
            var et, jt = this, At = jt.s;
            if (He = (Fe = new pr(Fe, He)).s, !At || !He) return new pr(NaN);
            if (At != He) return Fe.s = -He, jt.minus(Fe);
            var qt = jt.e / H, Jt = Fe.e / H, er = jt.c, mr = Fe.c;
            if (!qt || !Jt) {
              if (!er || !mr) return new pr(At / 0);
              if (!er[0] || !mr[0]) return mr[0] ? Fe : new pr(er[0] ? jt : 0 * At);
            }
            if (qt = z(qt), Jt = z(Jt), er = er.slice(), At = qt - Jt) {
              for (At > 0 ? (Jt = qt, et = mr) : (At = -At, et = er), et.reverse(); At--; et.push(0)) ;
              et.reverse();
            }
            for ((At = er.length) - (He = mr.length) < 0 && (et = mr, mr = er, er = et, He = At), At = 0; He; ) At = (er[--He] = er[He] + mr[He] + At) / D | 0, er[He] = D === er[He] ? 0 : er[He] % D;
            return At && (er = [At].concat(er), ++Jt), rn(Fe, er, Jt);
          }, ln.precision = ln.sd = function(Fe, He) {
            var et, jt, At, qt = this;
            if (Fe != null && Fe !== !!Fe) return G(Fe, 1, j), He == null ? He = Tn : G(He, 0, 8), mn(new pr(qt), Fe, He);
            if (!(et = qt.c)) return null;
            if (jt = (At = et.length - 1) * H + 1, At = et[At]) {
              for (; At % 10 == 0; At /= 10, jt--) ;
              for (At = et[0]; At >= 10; At /= 10, jt++) ;
            }
            return Fe && qt.e + 1 > jt && (jt = qt.e + 1), jt;
          }, ln.shiftedBy = function(Fe) {
            return G(Fe, -9007199254740991, _), this.times("1e" + Fe);
          }, ln.squareRoot = ln.sqrt = function() {
            var Fe, He, et, jt, At, qt = this, Jt = qt.c, er = qt.s, mr = qt.e, Ar = Hn + 4, xr = new pr("0.5");
            if (er !== 1 || !Jt || !Jt[0]) return new pr(!er || er < 0 && (!Jt || Jt[0]) ? NaN : Jt ? qt : 1 / 0);
            if ((er = Math.sqrt(+pn(qt))) == 0 || er == 1 / 0 ? (((He = Y(Jt)).length + mr) % 2 == 0 && (He += "0"), er = Math.sqrt(+He), mr = z((mr + 1) / 2) - (mr < 0 || mr % 2), et = new pr(He = er == 1 / 0 ? "5e" + mr : (He = er.toExponential()).slice(0, He.indexOf("e") + 1) + mr)) : et = new pr(er + ""), et.c[0]) {
              for ((er = (mr = et.e) + Ar) < 3 && (er = 0); ; ) if (At = et, et = xr.times(At.plus(he(qt, At, Ar, 1))), Y(At.c).slice(0, er) === (He = Y(et.c)).slice(0, er)) {
                if (et.e < mr && --er, (He = He.slice(er - 3, er + 1)) != "9999" && (jt || He != "4999")) {
                  +He && (+He.slice(1) || He.charAt(0) != "5") || (mn(et, et.e + Hn + 2, 1), Fe = !et.times(et).eq(qt));
                  break;
                }
                if (!jt && (mn(At, At.e + Hn + 2, 0), At.times(At).eq(qt))) {
                  et = At;
                  break;
                }
                Ar += 4, er += 4, jt = 1;
              }
            }
            return mn(et, et.e + Hn + 1, Tn, Fe);
          }, ln.toExponential = function(Fe, He) {
            return Fe != null && (G(Fe, 0, j), Fe++), tn(this, Fe, He, 1);
          }, ln.toFixed = function(Fe, He) {
            return Fe != null && (G(Fe, 0, j), Fe = Fe + this.e + 1), tn(this, Fe, He);
          }, ln.toFormat = function(Fe, He, et) {
            var jt, At = this;
            if (et == null) Fe != null && He && typeof He == "object" ? (et = He, He = null) : Fe && typeof Fe == "object" ? (et = Fe, Fe = He = null) : et = lr;
            else if (typeof et != "object") throw Error(I + "Argument not an object: " + et);
            if (jt = At.toFixed(Fe, He), At.c) {
              var qt, Jt = jt.split("."), er = +et.groupSize, mr = +et.secondaryGroupSize, Ar = et.groupSeparator || "", xr = Jt[0], Jr = Jt[1], vn = At.s < 0, _n = vn ? xr.slice(1) : xr, Dn = _n.length;
              if (mr && (qt = er, er = mr, mr = qt, Dn -= qt), er > 0 && Dn > 0) {
                for (qt = Dn % er || er, xr = _n.substr(0, qt); qt < Dn; qt += er) xr += Ar + _n.substr(qt, er);
                mr > 0 && (xr += Ar + _n.slice(qt)), vn && (xr = "-" + xr);
              }
              jt = Jr ? xr + (et.decimalSeparator || "") + ((mr = +et.fractionGroupSize) ? Jr.replace(new RegExp("\\d{" + mr + "}\\B", "g"), "$&" + (et.fractionGroupSeparator || "")) : Jr) : xr;
            }
            return (et.prefix || "") + jt + (et.suffix || "");
          }, ln.toFraction = function(Fe) {
            var He, et, jt, At, qt, Jt, er, mr, Ar, xr, Jr, vn, _n = this, Dn = _n.c;
            if (Fe != null && (!(er = new pr(Fe)).isInteger() && (er.c || er.s !== 1) || er.lt(oi))) throw Error(I + "Argument " + (er.isInteger() ? "out of range: " : "not an integer: ") + pn(er));
            if (!Dn) return new pr(_n);
            for (He = new pr(oi), Ar = et = new pr(oi), jt = mr = new pr(oi), vn = Y(Dn), qt = He.e = vn.length - _n.e - 1, He.c[0] = T[(Jt = qt % H) < 0 ? H + Jt : Jt], Fe = !Fe || er.comparedTo(He) > 0 ? qt > 0 ? He : Ar : er, Jt = Pn, Pn = 1 / 0, er = new pr(vn), mr.c[0] = 0; xr = he(er, He, 0, 1), (At = et.plus(xr.times(jt))).comparedTo(Fe) != 1; ) et = jt, jt = At, Ar = mr.plus(xr.times(At = Ar)), mr = At, He = er.minus(xr.times(At = He)), er = At;
            return At = he(Fe.minus(et), jt, 0, 1), mr = mr.plus(At.times(Ar)), et = et.plus(At.times(jt)), mr.s = Ar.s = _n.s, Jr = he(Ar, jt, qt *= 2, Tn).minus(_n).abs().comparedTo(he(mr, et, qt, Tn).minus(_n).abs()) < 1 ? [Ar, jt] : [mr, et], Pn = Jt, Jr;
          }, ln.toNumber = function() {
            return +pn(this);
          }, ln.toPrecision = function(Fe, He) {
            return Fe != null && G(Fe, 1, j), tn(this, Fe, He, 2);
          }, ln.toString = function(Fe) {
            var He, et = this, jt = et.s, At = et.e;
            return At === null ? jt ? (He = "Infinity", jt < 0 && (He = "-" + He)) : He = "NaN" : (Fe == null ? He = At <= xn || At >= Gn ? J(Y(et.c), At) : B(Y(et.c), At, "0") : Fe === 10 && Rr ? He = B(Y((et = mn(new pr(et), Hn + At + 1, Tn)).c), et.e, "0") : (G(Fe, 2, Er.length, "Base"), He = ke(B(Y(et.c), At, "0"), 10, Fe, jt, true)), jt < 0 && et.c[0] && (He = "-" + He)), He;
          }, ln.valueOf = ln.toJSON = function() {
            return pn(this);
          }, ln._isBigNumber = true, ln[Symbol.toStringTag] = "BigNumber", ln[Symbol.for("nodejs.util.inspect.custom")] = ln.valueOf, ve != null && pr.set(ve), pr;
        }();
        const ie = Z;
        var $ = u(4193), oe = u.n($), ce = u(9127), ye = u.n(ce), ae = u(5976), ue = u(9983);
        function ne(Ie) {
          return ne = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, ne(Ie);
        }
        var ge = "13.2.0", Te = {}, pe = (0, ue.vt)({ headers: { "X-Client-Name": "js-stellar-sdk", "X-Client-Version": ge } });
        function Oe(Ie) {
          return Math.floor(Ie / 1e3);
        }
        pe.interceptors.response.use(function(Ie) {
          var ve = oe()(Ie.config.url).hostname(), he = 0;
          if (Ie.headers instanceof Headers) {
            var ke = Ie.headers.get("date");
            ke && (he = Oe(Date.parse(ke)));
          } else if (ne(Ie.headers) === "object" && "date" in Ie.headers) {
            var ht = Ie.headers;
            typeof ht.date == "string" && (he = Oe(Date.parse(ht.date)));
          }
          var pt = Oe((/* @__PURE__ */ new Date()).getTime());
          return Number.isNaN(he) || (Te[ve] = { serverTime: he, localTimeRecorded: pt }), Ie;
        });
        const xe = pe;
        function Ve(Ie) {
          var ve = Te[Ie];
          if (!ve || !ve.localTimeRecorded || !ve.serverTime) return null;
          var he = ve.serverTime, ke = ve.localTimeRecorded, ht = Oe((/* @__PURE__ */ new Date()).getTime());
          return ht - ke > 300 ? null : ht - ke + he;
        }
        function _e(Ie) {
          return _e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, _e(Ie);
        }
        function Be() {
          Be = function() {
            return ve;
          };
          var Ie, ve = {}, he = Object.prototype, ke = he.hasOwnProperty, ht = Object.defineProperty || function(Fe, He, et) {
            Fe[He] = et.value;
          }, pt = typeof Symbol == "function" ? Symbol : {}, Pr = pt.iterator || "@@iterator", cn = pt.asyncIterator || "@@asyncIterator", on = pt.toStringTag || "@@toStringTag";
          function sn(Fe, He, et) {
            return Object.defineProperty(Fe, He, { value: et, enumerable: true, configurable: true, writable: true }), Fe[He];
          }
          try {
            sn({}, "");
          } catch {
            sn = function(He, et, jt) {
              return He[et] = jt;
            };
          }
          function Nn(Fe, He, et, jt) {
            var At = He && He.prototype instanceof Gn ? He : Gn, qt = Object.create(At.prototype), Jt = new mn(jt || []);
            return ht(qt, "_invoke", { value: pr(Fe, et, Jt) }), qt;
          }
          function Vn(Fe, He, et) {
            try {
              return { type: "normal", arg: Fe.call(He, et) };
            } catch (jt) {
              return { type: "throw", arg: jt };
            }
          }
          ve.wrap = Nn;
          var ln = "suspendedStart", oi = "suspendedYield", Hn = "executing", Tn = "completed", xn = {};
          function Gn() {
          }
          function Kn() {
          }
          function Pn() {
          }
          var Xn = {};
          sn(Xn, Pr, function() {
            return this;
          });
          var kt = Object.getPrototypeOf, Kt = kt && kt(kt(pn([])));
          Kt && Kt !== he && ke.call(Kt, Pr) && (Xn = Kt);
          var lr = Pn.prototype = Gn.prototype = Object.create(Xn);
          function Er(Fe) {
            ["next", "throw", "return"].forEach(function(He) {
              sn(Fe, He, function(et) {
                return this._invoke(He, et);
              });
            });
          }
          function Rr(Fe, He) {
            function et(At, qt, Jt, er) {
              var mr = Vn(Fe[At], Fe, qt);
              if (mr.type !== "throw") {
                var Ar = mr.arg, xr = Ar.value;
                return xr && _e(xr) == "object" && ke.call(xr, "__await") ? He.resolve(xr.__await).then(function(Jr) {
                  et("next", Jr, Jt, er);
                }, function(Jr) {
                  et("throw", Jr, Jt, er);
                }) : He.resolve(xr).then(function(Jr) {
                  Ar.value = Jr, Jt(Ar);
                }, function(Jr) {
                  return et("throw", Jr, Jt, er);
                });
              }
              er(mr.arg);
            }
            var jt;
            ht(this, "_invoke", { value: function(At, qt) {
              function Jt() {
                return new He(function(er, mr) {
                  et(At, qt, er, mr);
                });
              }
              return jt = jt ? jt.then(Jt, Jt) : Jt();
            } });
          }
          function pr(Fe, He, et) {
            var jt = ln;
            return function(At, qt) {
              if (jt === Hn) throw Error("Generator is already running");
              if (jt === Tn) {
                if (At === "throw") throw qt;
                return { value: Ie, done: true };
              }
              for (et.method = At, et.arg = qt; ; ) {
                var Jt = et.delegate;
                if (Jt) {
                  var er = tn(Jt, et);
                  if (er) {
                    if (er === xn) continue;
                    return er;
                  }
                }
                if (et.method === "next") et.sent = et._sent = et.arg;
                else if (et.method === "throw") {
                  if (jt === ln) throw jt = Tn, et.arg;
                  et.dispatchException(et.arg);
                } else et.method === "return" && et.abrupt("return", et.arg);
                jt = Hn;
                var mr = Vn(Fe, He, et);
                if (mr.type === "normal") {
                  if (jt = et.done ? Tn : oi, mr.arg === xn) continue;
                  return { value: mr.arg, done: et.done };
                }
                mr.type === "throw" && (jt = Tn, et.method = "throw", et.arg = mr.arg);
              }
            };
          }
          function tn(Fe, He) {
            var et = He.method, jt = Fe.iterator[et];
            if (jt === Ie) return He.delegate = null, et === "throw" && Fe.iterator.return && (He.method = "return", He.arg = Ie, tn(Fe, He), He.method === "throw") || et !== "return" && (He.method = "throw", He.arg = new TypeError("The iterator does not provide a '" + et + "' method")), xn;
            var At = Vn(jt, Fe.iterator, He.arg);
            if (At.type === "throw") return He.method = "throw", He.arg = At.arg, He.delegate = null, xn;
            var qt = At.arg;
            return qt ? qt.done ? (He[Fe.resultName] = qt.value, He.next = Fe.nextLoc, He.method !== "return" && (He.method = "next", He.arg = Ie), He.delegate = null, xn) : qt : (He.method = "throw", He.arg = new TypeError("iterator result is not an object"), He.delegate = null, xn);
          }
          function fn(Fe) {
            var He = { tryLoc: Fe[0] };
            1 in Fe && (He.catchLoc = Fe[1]), 2 in Fe && (He.finallyLoc = Fe[2], He.afterLoc = Fe[3]), this.tryEntries.push(He);
          }
          function rn(Fe) {
            var He = Fe.completion || {};
            He.type = "normal", delete He.arg, Fe.completion = He;
          }
          function mn(Fe) {
            this.tryEntries = [{ tryLoc: "root" }], Fe.forEach(fn, this), this.reset(true);
          }
          function pn(Fe) {
            if (Fe || Fe === "") {
              var He = Fe[Pr];
              if (He) return He.call(Fe);
              if (typeof Fe.next == "function") return Fe;
              if (!isNaN(Fe.length)) {
                var et = -1, jt = function At() {
                  for (; ++et < Fe.length; ) if (ke.call(Fe, et)) return At.value = Fe[et], At.done = false, At;
                  return At.value = Ie, At.done = true, At;
                };
                return jt.next = jt;
              }
            }
            throw new TypeError(_e(Fe) + " is not iterable");
          }
          return Kn.prototype = Pn, ht(lr, "constructor", { value: Pn, configurable: true }), ht(Pn, "constructor", { value: Kn, configurable: true }), Kn.displayName = sn(Pn, on, "GeneratorFunction"), ve.isGeneratorFunction = function(Fe) {
            var He = typeof Fe == "function" && Fe.constructor;
            return !!He && (He === Kn || (He.displayName || He.name) === "GeneratorFunction");
          }, ve.mark = function(Fe) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Fe, Pn) : (Fe.__proto__ = Pn, sn(Fe, on, "GeneratorFunction")), Fe.prototype = Object.create(lr), Fe;
          }, ve.awrap = function(Fe) {
            return { __await: Fe };
          }, Er(Rr.prototype), sn(Rr.prototype, cn, function() {
            return this;
          }), ve.AsyncIterator = Rr, ve.async = function(Fe, He, et, jt, At) {
            At === void 0 && (At = Promise);
            var qt = new Rr(Nn(Fe, He, et, jt), At);
            return ve.isGeneratorFunction(He) ? qt : qt.next().then(function(Jt) {
              return Jt.done ? Jt.value : qt.next();
            });
          }, Er(lr), sn(lr, on, "Generator"), sn(lr, Pr, function() {
            return this;
          }), sn(lr, "toString", function() {
            return "[object Generator]";
          }), ve.keys = function(Fe) {
            var He = Object(Fe), et = [];
            for (var jt in He) et.push(jt);
            return et.reverse(), function At() {
              for (; et.length; ) {
                var qt = et.pop();
                if (qt in He) return At.value = qt, At.done = false, At;
              }
              return At.done = true, At;
            };
          }, ve.values = pn, mn.prototype = { constructor: mn, reset: function(Fe) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = Ie, this.done = false, this.delegate = null, this.method = "next", this.arg = Ie, this.tryEntries.forEach(rn), !Fe) for (var He in this) He.charAt(0) === "t" && ke.call(this, He) && !isNaN(+He.slice(1)) && (this[He] = Ie);
          }, stop: function() {
            this.done = true;
            var Fe = this.tryEntries[0].completion;
            if (Fe.type === "throw") throw Fe.arg;
            return this.rval;
          }, dispatchException: function(Fe) {
            if (this.done) throw Fe;
            var He = this;
            function et(mr, Ar) {
              return qt.type = "throw", qt.arg = Fe, He.next = mr, Ar && (He.method = "next", He.arg = Ie), !!Ar;
            }
            for (var jt = this.tryEntries.length - 1; jt >= 0; --jt) {
              var At = this.tryEntries[jt], qt = At.completion;
              if (At.tryLoc === "root") return et("end");
              if (At.tryLoc <= this.prev) {
                var Jt = ke.call(At, "catchLoc"), er = ke.call(At, "finallyLoc");
                if (Jt && er) {
                  if (this.prev < At.catchLoc) return et(At.catchLoc, true);
                  if (this.prev < At.finallyLoc) return et(At.finallyLoc);
                } else if (Jt) {
                  if (this.prev < At.catchLoc) return et(At.catchLoc, true);
                } else {
                  if (!er) throw Error("try statement without catch or finally");
                  if (this.prev < At.finallyLoc) return et(At.finallyLoc);
                }
              }
            }
          }, abrupt: function(Fe, He) {
            for (var et = this.tryEntries.length - 1; et >= 0; --et) {
              var jt = this.tryEntries[et];
              if (jt.tryLoc <= this.prev && ke.call(jt, "finallyLoc") && this.prev < jt.finallyLoc) {
                var At = jt;
                break;
              }
            }
            At && (Fe === "break" || Fe === "continue") && At.tryLoc <= He && He <= At.finallyLoc && (At = null);
            var qt = At ? At.completion : {};
            return qt.type = Fe, qt.arg = He, At ? (this.method = "next", this.next = At.finallyLoc, xn) : this.complete(qt);
          }, complete: function(Fe, He) {
            if (Fe.type === "throw") throw Fe.arg;
            return Fe.type === "break" || Fe.type === "continue" ? this.next = Fe.arg : Fe.type === "return" ? (this.rval = this.arg = Fe.arg, this.method = "return", this.next = "end") : Fe.type === "normal" && He && (this.next = He), xn;
          }, finish: function(Fe) {
            for (var He = this.tryEntries.length - 1; He >= 0; --He) {
              var et = this.tryEntries[He];
              if (et.finallyLoc === Fe) return this.complete(et.completion, et.afterLoc), rn(et), xn;
            }
          }, catch: function(Fe) {
            for (var He = this.tryEntries.length - 1; He >= 0; --He) {
              var et = this.tryEntries[He];
              if (et.tryLoc === Fe) {
                var jt = et.completion;
                if (jt.type === "throw") {
                  var At = jt.arg;
                  rn(et);
                }
                return At;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Fe, He, et) {
            return this.delegate = { iterator: pn(Fe), resultName: He, nextLoc: et }, this.method === "next" && (this.arg = Ie), xn;
          } }, ve;
        }
        function Qe(Ie, ve, he, ke, ht, pt, Pr) {
          try {
            var cn = Ie[pt](Pr), on = cn.value;
          } catch (sn) {
            return void he(sn);
          }
          cn.done ? ve(on) : Promise.resolve(on).then(ke, ht);
        }
        function ee(Ie) {
          return function() {
            var ve = this, he = arguments;
            return new Promise(function(ke, ht) {
              var pt = Ie.apply(ve, he);
              function Pr(on) {
                Qe(pt, ke, ht, Pr, cn, "next", on);
              }
              function cn(on) {
                Qe(pt, ke, ht, Pr, cn, "throw", on);
              }
              Pr(void 0);
            });
          };
        }
        function P(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, x(ke.key), ke);
          }
        }
        function x(Ie) {
          var ve = function(he, ke) {
            if (_e(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (_e(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return _e(ve) == "symbol" ? ve : ve + "";
        }
        var O, V, N, C, p = ["transaction"], A = u.g;
        O = (V = (N = A.EventSource) !== null && N !== void 0 ? N : (C = A.window) === null || C === void 0 ? void 0 : C.EventSource) !== null && V !== void 0 ? V : u(1731);
        var U, Q, se = function(Ie, ve, he) {
          return ve && P(Ie.prototype, ve), Object.defineProperty(Ie, "prototype", { writable: false }), Ie;
        }(function Ie(ve) {
          var he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          (function(ke, ht) {
            if (!(ke instanceof ht)) throw new TypeError("Cannot call a class as a function");
          })(this, Ie), this.url = ve.clone(), this.filter = [], this.originalSegments = this.url.segment() || [], this.neighborRoot = he;
        }, [{ key: "call", value: function() {
          var Ie = this;
          return this.checkFilter(), this._sendNormalRequest(this.url).then(function(ve) {
            return Ie._parseResponse(ve);
          });
        } }, { key: "stream", value: function() {
          var Ie, ve, he = this, ke = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (O === void 0) throw new Error("Streaming requires eventsource to be enabled. If you need this functionality, compile with USE_EVENTSOURCE=true.");
          this.checkFilter(), this.url.setQuery("X-Client-Name", "js-stellar-sdk"), this.url.setQuery("X-Client-Version", ge);
          var ht = function() {
            ve = setTimeout(function() {
              var Pr;
              (Pr = Ie) === null || Pr === void 0 || Pr.close(), Ie = pt();
            }, ke.reconnectTimeout || 15e3);
          }, pt = function() {
            try {
              Ie = new O(he.url.toString());
            } catch (Nn) {
              ke.onerror && ke.onerror(Nn);
            }
            if (ht(), !Ie) return Ie;
            var Pr = false, cn = function() {
              Pr || (clearTimeout(ve), Ie.close(), pt(), Pr = true);
            }, on = function(Nn) {
              if (Nn.type !== "close") {
                var Vn = Nn.data ? he._parseRecord(JSON.parse(Nn.data)) : Nn;
                Vn.paging_token && he.url.setQuery("cursor", Vn.paging_token), clearTimeout(ve), ht(), ke.onmessage !== void 0 && ke.onmessage(Vn);
              } else cn();
            }, sn = function(Nn) {
              ke.onerror && ke.onerror(Nn);
            };
            return Ie.addEventListener ? (Ie.addEventListener("message", on.bind(he)), Ie.addEventListener("error", sn.bind(he)), Ie.addEventListener("close", cn.bind(he))) : (Ie.onmessage = on.bind(he), Ie.onerror = sn.bind(he)), Ie;
          };
          return pt(), function() {
            var Pr;
            clearTimeout(ve), (Pr = Ie) === null || Pr === void 0 || Pr.close();
          };
        } }, { key: "cursor", value: function(Ie) {
          return this.url.setQuery("cursor", Ie), this;
        } }, { key: "limit", value: function(Ie) {
          return this.url.setQuery("limit", Ie.toString()), this;
        } }, { key: "order", value: function(Ie) {
          return this.url.setQuery("order", Ie), this;
        } }, { key: "join", value: function(Ie) {
          return this.url.setQuery("join", Ie), this;
        } }, { key: "forEndpoint", value: function(Ie, ve) {
          if (this.neighborRoot === "") throw new Error("Invalid usage: neighborRoot not set in constructor");
          return this.filter.push([Ie, ve, this.neighborRoot]), this;
        } }, { key: "checkFilter", value: function() {
          if (this.filter.length >= 2) throw new ae.v7("Too many filters specified", this.filter);
          if (this.filter.length === 1) {
            var Ie = this.originalSegments.concat(this.filter[0]);
            this.url.segment(Ie);
          }
        } }, { key: "_requestFnForLink", value: function(Ie) {
          var ve = this;
          return ee(Be().mark(function he() {
            var ke, ht, pt, Pr, cn = arguments;
            return Be().wrap(function(on) {
              for (; ; ) switch (on.prev = on.next) {
                case 0:
                  return ke = cn.length > 0 && cn[0] !== void 0 ? cn[0] : {}, Ie.templated ? (pt = ye()(Ie.href), ht = oe()(pt.expand(ke))) : ht = oe()(Ie.href), on.next = 4, ve._sendNormalRequest(ht);
                case 4:
                  return Pr = on.sent, on.abrupt("return", ve._parseResponse(Pr));
                case 6:
                case "end":
                  return on.stop();
              }
            }, he);
          }));
        } }, { key: "_parseRecord", value: function(Ie) {
          var ve = this;
          return Ie._links && Object.keys(Ie._links).forEach(function(he) {
            var ke = Ie._links[he], ht = false;
            if (Ie[he] !== void 0 && (Ie["".concat(he, "_attr")] = Ie[he], ht = true), ht && p.indexOf(he) >= 0) {
              var pt = ve._parseRecord(Ie[he]);
              Ie[he] = ee(Be().mark(function Pr() {
                return Be().wrap(function(cn) {
                  for (; ; ) switch (cn.prev = cn.next) {
                    case 0:
                      return cn.abrupt("return", pt);
                    case 1:
                    case "end":
                      return cn.stop();
                  }
                }, Pr);
              }));
            } else Ie[he] = ve._requestFnForLink(ke);
          }), Ie;
        } }, { key: "_sendNormalRequest", value: (Q = ee(Be().mark(function Ie(ve) {
          var he;
          return Be().wrap(function(ke) {
            for (; ; ) switch (ke.prev = ke.next) {
              case 0:
                return (he = ve).authority() === "" && (he = he.authority(this.url.authority())), he.protocol() === "" && (he = he.protocol(this.url.protocol())), ke.abrupt("return", pe.get(he.toString()).then(function(ht) {
                  return ht.data;
                }).catch(this._handleNetworkError));
              case 4:
              case "end":
                return ke.stop();
            }
          }, Ie, this);
        })), function(Ie) {
          return Q.apply(this, arguments);
        }) }, { key: "_parseResponse", value: function(Ie) {
          return Ie._embedded && Ie._embedded.records ? this._toCollectionPage(Ie) : this._parseRecord(Ie);
        } }, { key: "_toCollectionPage", value: function(Ie) {
          for (var ve, he, ke = this, ht = 0; ht < Ie._embedded.records.length; ht += 1) Ie._embedded.records[ht] = this._parseRecord(Ie._embedded.records[ht]);
          return { records: Ie._embedded.records, next: (he = ee(Be().mark(function pt() {
            var Pr;
            return Be().wrap(function(cn) {
              for (; ; ) switch (cn.prev = cn.next) {
                case 0:
                  return cn.next = 2, ke._sendNormalRequest(oe()(Ie._links.next.href));
                case 2:
                  return Pr = cn.sent, cn.abrupt("return", ke._toCollectionPage(Pr));
                case 4:
                case "end":
                  return cn.stop();
              }
            }, pt);
          })), function() {
            return he.apply(this, arguments);
          }), prev: (ve = ee(Be().mark(function pt() {
            var Pr;
            return Be().wrap(function(cn) {
              for (; ; ) switch (cn.prev = cn.next) {
                case 0:
                  return cn.next = 2, ke._sendNormalRequest(oe()(Ie._links.prev.href));
                case 2:
                  return Pr = cn.sent, cn.abrupt("return", ke._toCollectionPage(Pr));
                case 4:
                case "end":
                  return cn.stop();
              }
            }, pt);
          })), function() {
            return ve.apply(this, arguments);
          }) };
        } }, { key: "_handleNetworkError", value: (U = ee(Be().mark(function Ie(ve) {
          var he, ke;
          return Be().wrap(function(ht) {
            for (; ; ) switch (ht.prev = ht.next) {
              case 0:
                if (!ve.response || !ve.response.status) {
                  ht.next = 8;
                  break;
                }
                ht.t0 = ve.response.status, ht.next = ht.t0 === 404 ? 4 : 5;
                break;
              case 4:
                return ht.abrupt("return", Promise.reject(new ae.m_((he = ve.response.statusText) !== null && he !== void 0 ? he : "Not Found", ve.response.data)));
              case 5:
                return ht.abrupt("return", Promise.reject(new ae.Dr((ke = ve.response.statusText) !== null && ke !== void 0 ? ke : "Unknown", ve.response.data)));
              case 6:
                ht.next = 9;
                break;
              case 8:
                return ht.abrupt("return", Promise.reject(new Error(ve.message)));
              case 9:
              case "end":
                return ht.stop();
            }
          }, Ie);
        })), function(Ie) {
          return U.apply(this, arguments);
        }) }]), X = u(8732);
        function de(Ie) {
          return de = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, de(Ie);
        }
        function tt(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Ne(ke.key), ke);
          }
        }
        function Ne(Ie) {
          var ve = function(he, ke) {
            if (de(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (de(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return de(ve) == "symbol" ? ve : ve + "";
        }
        function ut(Ie, ve, he) {
          return ve = Et(ve), function(ke, ht) {
            if (ht && (de(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Ze() ? Reflect.construct(ve, he || [], Et(Ie).constructor) : ve.apply(Ie, he));
        }
        function Ze() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Ze = function() {
            return !!Ie;
          })();
        }
        function Et(Ie) {
          return Et = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Et(Ie);
        }
        function rr(Ie, ve) {
          return rr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, rr(Ie, ve);
        }
        var je = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = ut(this, ve, [he])).url.segment("accounts"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && rr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && tt(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "accountId", value: function(he) {
            var ke = new se(this.url.clone());
            return ke.filter.push([he]), ke;
          } }, { key: "forSigner", value: function(he) {
            return this.url.setQuery("signer", he), this;
          } }, { key: "forAsset", value: function(he) {
            return this.url.setQuery("asset", "".concat(he)), this;
          } }, { key: "sponsor", value: function(he) {
            return this.url.setQuery("sponsor", he), this;
          } }, { key: "forLiquidityPool", value: function(he) {
            return this.url.setQuery("liquidity_pool", he), this;
          } }]);
        }(se);
        function Ge(Ie) {
          return Ge = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Ge(Ie);
        }
        function at(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Ae(ke.key), ke);
          }
        }
        function Ae(Ie) {
          var ve = function(he, ke) {
            if (Ge(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Ge(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Ge(ve) == "symbol" ? ve : ve + "";
        }
        function qe(Ie, ve, he) {
          return ve = Dt(ve), function(ke, ht) {
            if (ht && (Ge(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Ft() ? Reflect.construct(ve, he || [], Dt(Ie).constructor) : ve.apply(Ie, he));
        }
        function Ft() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Ft = function() {
            return !!Ie;
          })();
        }
        function Dt(Ie) {
          return Dt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Dt(Ie);
        }
        function wr(Ie, ve) {
          return wr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, wr(Ie, ve);
        }
        var Nt = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = qe(this, ve, [he])).url.segment("assets"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && wr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && at(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "forCode", value: function(he) {
            return this.url.setQuery("asset_code", he), this;
          } }, { key: "forIssuer", value: function(he) {
            return this.url.setQuery("asset_issuer", he), this;
          } }]);
        }(se);
        function yr(Ie) {
          return yr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, yr(Ie);
        }
        function Ur(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Pe(ke.key), ke);
          }
        }
        function Pe(Ie) {
          var ve = function(he, ke) {
            if (yr(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (yr(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return yr(ve) == "symbol" ? ve : ve + "";
        }
        function $e(Ie, ve, he) {
          return ve = re(ve), function(ke, ht) {
            if (ht && (yr(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, le() ? Reflect.construct(ve, he || [], re(Ie).constructor) : ve.apply(Ie, he));
        }
        function le() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (le = function() {
            return !!Ie;
          })();
        }
        function re(Ie) {
          return re = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, re(Ie);
        }
        function Le(Ie, ve) {
          return Le = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Le(Ie, ve);
        }
        var nt = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = $e(this, ve, [he])).url.segment("claimable_balances"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Le(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && Ur(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "claimableBalance", value: function(he) {
            var ke = new se(this.url.clone());
            return ke.filter.push([he]), ke;
          } }, { key: "sponsor", value: function(he) {
            return this.url.setQuery("sponsor", he), this;
          } }, { key: "claimant", value: function(he) {
            return this.url.setQuery("claimant", he), this;
          } }, { key: "asset", value: function(he) {
            return this.url.setQuery("asset", he.toString()), this;
          } }]);
        }(se);
        function ft(Ie) {
          return ft = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, ft(Ie);
        }
        function zt(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, st(ke.key), ke);
          }
        }
        function st(Ie) {
          var ve = function(he, ke) {
            if (ft(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (ft(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return ft(ve) == "symbol" ? ve : ve + "";
        }
        function ct(Ie, ve, he) {
          return ve = Zt(ve), function(ke, ht) {
            if (ht && (ft(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, yt() ? Reflect.construct(ve, he || [], Zt(Ie).constructor) : ve.apply(Ie, he));
        }
        function yt() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (yt = function() {
            return !!Ie;
          })();
        }
        function Zt(Ie) {
          return Zt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Zt(Ie);
        }
        function Ct(Ie, ve) {
          return Ct = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Ct(Ie, ve);
        }
        var Lt = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = ct(this, ve, [he, "effects"])).url.segment("effects"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Ct(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && zt(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "forLedger", value: function(he) {
            return this.forEndpoint("ledgers", he.toString());
          } }, { key: "forTransaction", value: function(he) {
            return this.forEndpoint("transactions", he);
          } }, { key: "forOperation", value: function(he) {
            return this.forEndpoint("operations", he);
          } }, { key: "forLiquidityPool", value: function(he) {
            return this.forEndpoint("liquidity_pools", he);
          } }]);
        }(se);
        function Wt(Ie) {
          return Wt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Wt(Ie);
        }
        function vr(Ie, ve, he) {
          return ve = sr(ve), function(ke, ht) {
            if (ht && (Wt(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, ar() ? Reflect.construct(ve, he || [], sr(Ie).constructor) : ve.apply(Ie, he));
        }
        function ar() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (ar = function() {
            return !!Ie;
          })();
        }
        function sr(Ie) {
          return sr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, sr(Ie);
        }
        function gr(Ie, ve) {
          return gr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, gr(Ie, ve);
        }
        var Tr = function(Ie) {
          function ve(he, ke) {
            var ht;
            return function(pt, Pr) {
              if (!(pt instanceof Pr)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ht = vr(this, ve, [he])).url.segment("friendbot"), ht.url.setQuery("addr", ke), ht;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && gr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve);
        }(se);
        function Mr(Ie) {
          return Mr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Mr(Ie);
        }
        function Nr(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Lr(ke.key), ke);
          }
        }
        function Lr(Ie) {
          var ve = function(he, ke) {
            if (Mr(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Mr(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Mr(ve) == "symbol" ? ve : ve + "";
        }
        function jr(Ie, ve, he) {
          return ve = kr(ve), function(ke, ht) {
            if (ht && (Mr(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Hr() ? Reflect.construct(ve, he || [], kr(Ie).constructor) : ve.apply(Ie, he));
        }
        function Hr() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Hr = function() {
            return !!Ie;
          })();
        }
        function kr(Ie) {
          return kr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, kr(Ie);
        }
        function Xt(Ie, ve) {
          return Xt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Xt(Ie, ve);
        }
        var Qt = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = jr(this, ve, [he])).url.segment("ledgers"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Xt(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && Nr(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "ledger", value: function(he) {
            return this.filter.push(["ledgers", he.toString()]), this;
          } }]);
        }(se);
        function br(Ie) {
          return br = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, br(Ie);
        }
        function we(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, me(ke.key), ke);
          }
        }
        function me(Ie) {
          var ve = function(he, ke) {
            if (br(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (br(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return br(ve) == "symbol" ? ve : ve + "";
        }
        function ze(Ie, ve, he) {
          return ve = Tt(ve), function(ke, ht) {
            if (ht && (br(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, rt() ? Reflect.construct(ve, he || [], Tt(Ie).constructor) : ve.apply(Ie, he));
        }
        function rt() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (rt = function() {
            return !!Ie;
          })();
        }
        function Tt(Ie) {
          return Tt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Tt(Ie);
        }
        function Ot(Ie, ve) {
          return Ot = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Ot(Ie, ve);
        }
        var It = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = ze(this, ve, [he])).url.segment("liquidity_pools"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Ot(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && we(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "forAssets", value: function() {
            for (var he = arguments.length, ke = new Array(he), ht = 0; ht < he; ht++) ke[ht] = arguments[ht];
            var pt = ke.map(function(Pr) {
              return Pr.toString();
            }).join(",");
            return this.url.setQuery("reserves", pt), this;
          } }, { key: "forAccount", value: function(he) {
            return this.url.setQuery("account", he), this;
          } }, { key: "liquidityPoolId", value: function(he) {
            if (!he.match(/[a-fA-F0-9]{64}/)) throw new TypeError("".concat(he, " does not look like a liquidity pool ID"));
            var ke = new se(this.url.clone());
            return ke.filter.push([he.toLowerCase()]), ke;
          } }]);
        }(se);
        function We(Ie) {
          return We = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, We(Ie);
        }
        function mt(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Gt(ke.key), ke);
          }
        }
        function Gt(Ie) {
          var ve = function(he, ke) {
            if (We(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (We(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return We(ve) == "symbol" ? ve : ve + "";
        }
        function ir(Ie, ve, he) {
          return ve = hr(ve), function(ke, ht) {
            if (ht && (We(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, dr() ? Reflect.construct(ve, he || [], hr(Ie).constructor) : ve.apply(Ie, he));
        }
        function dr() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (dr = function() {
            return !!Ie;
          })();
        }
        function hr(Ie) {
          return hr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, hr(Ie);
        }
        function Fr(Ie, ve) {
          return Fr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Fr(Ie, ve);
        }
        var Gr = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = ir(this, ve, [he, "offers"])).url.segment("offers"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Fr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && mt(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "offer", value: function(he) {
            var ke = new se(this.url.clone());
            return ke.filter.push([he]), ke;
          } }, { key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "buying", value: function(he) {
            return he.isNative() ? this.url.setQuery("buying_asset_type", "native") : (this.url.setQuery("buying_asset_type", he.getAssetType()), this.url.setQuery("buying_asset_code", he.getCode()), this.url.setQuery("buying_asset_issuer", he.getIssuer())), this;
          } }, { key: "selling", value: function(he) {
            return he.isNative() ? this.url.setQuery("selling_asset_type", "native") : (this.url.setQuery("selling_asset_type", he.getAssetType()), this.url.setQuery("selling_asset_code", he.getCode()), this.url.setQuery("selling_asset_issuer", he.getIssuer())), this;
          } }, { key: "sponsor", value: function(he) {
            return this.url.setQuery("sponsor", he), this;
          } }, { key: "seller", value: function(he) {
            return this.url.setQuery("seller", he), this;
          } }]);
        }(se);
        function Br(Ie) {
          return Br = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Br(Ie);
        }
        function Dr(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Vr(ke.key), ke);
          }
        }
        function Vr(Ie) {
          var ve = function(he, ke) {
            if (Br(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Br(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Br(ve) == "symbol" ? ve : ve + "";
        }
        function be(Ie, ve, he) {
          return ve = Ue(ve), function(ke, ht) {
            if (ht && (Br(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Or() ? Reflect.construct(ve, he || [], Ue(Ie).constructor) : ve.apply(Ie, he));
        }
        function Or() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Or = function() {
            return !!Ie;
          })();
        }
        function Ue(Ie) {
          return Ue = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Ue(Ie);
        }
        function it(Ie, ve) {
          return it = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, it(Ie, ve);
        }
        var dt = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = be(this, ve, [he, "operations"])).url.segment("operations"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && it(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && Dr(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "operation", value: function(he) {
            var ke = new se(this.url.clone());
            return ke.filter.push([he]), ke;
          } }, { key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "forClaimableBalance", value: function(he) {
            return this.forEndpoint("claimable_balances", he);
          } }, { key: "forLedger", value: function(he) {
            return this.forEndpoint("ledgers", he.toString());
          } }, { key: "forTransaction", value: function(he) {
            return this.forEndpoint("transactions", he);
          } }, { key: "forLiquidityPool", value: function(he) {
            return this.forEndpoint("liquidity_pools", he);
          } }, { key: "includeFailed", value: function(he) {
            return this.url.setQuery("include_failed", he.toString()), this;
          } }]);
        }(se);
        function vt(Ie) {
          return vt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, vt(Ie);
        }
        function wt(Ie, ve, he) {
          return ve = Yt(ve), function(ke, ht) {
            if (ht && (vt(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Pt() ? Reflect.construct(ve, he || [], Yt(Ie).constructor) : ve.apply(Ie, he));
        }
        function Pt() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Pt = function() {
            return !!Ie;
          })();
        }
        function Yt(Ie) {
          return Yt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Yt(Ie);
        }
        function cr(Ie, ve) {
          return cr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, cr(Ie, ve);
        }
        var qr = function(Ie) {
          function ve(he, ke, ht) {
            var pt;
            return function(Pr, cn) {
              if (!(Pr instanceof cn)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (pt = wt(this, ve, [he])).url.segment("order_book"), ke.isNative() ? pt.url.setQuery("selling_asset_type", "native") : (pt.url.setQuery("selling_asset_type", ke.getAssetType()), pt.url.setQuery("selling_asset_code", ke.getCode()), pt.url.setQuery("selling_asset_issuer", ke.getIssuer())), ht.isNative() ? pt.url.setQuery("buying_asset_type", "native") : (pt.url.setQuery("buying_asset_type", ht.getAssetType()), pt.url.setQuery("buying_asset_code", ht.getCode()), pt.url.setQuery("buying_asset_issuer", ht.getIssuer())), pt;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && cr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve);
        }(se);
        function Vt(Ie) {
          return Vt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Vt(Ie);
        }
        function zr(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, en(ke.key), ke);
          }
        }
        function en(Ie) {
          var ve = function(he, ke) {
            if (Vt(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Vt(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Vt(ve) == "symbol" ? ve : ve + "";
        }
        function Me(Ie, ve, he) {
          return ve = Ke(ve), function(ke, ht) {
            if (ht && (Vt(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, De() ? Reflect.construct(ve, he || [], Ke(Ie).constructor) : ve.apply(Ie, he));
        }
        function De() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (De = function() {
            return !!Ie;
          })();
        }
        function Ke(Ie) {
          return Ke = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Ke(Ie);
        }
        function Bt(Ie, ve) {
          return Bt = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Bt(Ie, ve);
        }
        var St = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = Me(this, ve, [he, "payments"])).url.segment("payments"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Bt(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && zr(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "forLedger", value: function(he) {
            return this.forEndpoint("ledgers", he.toString());
          } }, { key: "forTransaction", value: function(he) {
            return this.forEndpoint("transactions", he);
          } }]);
        }(se);
        function ur(Ie) {
          return ur = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, ur(Ie);
        }
        function Cr(Ie, ve, he) {
          return ve = Zr(ve), function(ke, ht) {
            if (ht && (ur(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Wr() ? Reflect.construct(ve, he || [], Zr(Ie).constructor) : ve.apply(Ie, he));
        }
        function Wr() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Wr = function() {
            return !!Ie;
          })();
        }
        function Zr(Ie) {
          return Zr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Zr(Ie);
        }
        function dn(Ie, ve) {
          return dn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, dn(Ie, ve);
        }
        var wn = function(Ie) {
          function ve(he, ke, ht, pt) {
            var Pr;
            if (function(on, sn) {
              if (!(on instanceof sn)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (Pr = Cr(this, ve, [he])).url.segment("paths/strict-receive"), typeof ke == "string") Pr.url.setQuery("source_account", ke);
            else {
              var cn = ke.map(function(on) {
                return on.isNative() ? "native" : "".concat(on.getCode(), ":").concat(on.getIssuer());
              }).join(",");
              Pr.url.setQuery("source_assets", cn);
            }
            return Pr.url.setQuery("destination_amount", pt), ht.isNative() ? Pr.url.setQuery("destination_asset_type", "native") : (Pr.url.setQuery("destination_asset_type", ht.getAssetType()), Pr.url.setQuery("destination_asset_code", ht.getCode()), Pr.url.setQuery("destination_asset_issuer", ht.getIssuer())), Pr;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && dn(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve);
        }(se);
        function yn(Ie) {
          return yn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, yn(Ie);
        }
        function pi(Ie, ve, he) {
          return ve = Ni(ve), function(ke, ht) {
            if (ht && (yn(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Bi() ? Reflect.construct(ve, he || [], Ni(Ie).constructor) : ve.apply(Ie, he));
        }
        function Bi() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Bi = function() {
            return !!Ie;
          })();
        }
        function Ni(Ie) {
          return Ni = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Ni(Ie);
        }
        function Un(Ie, ve) {
          return Un = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, Un(Ie, ve);
        }
        var Xe = function(Ie) {
          function ve(he, ke, ht, pt) {
            var Pr;
            if (function(on, sn) {
              if (!(on instanceof sn)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (Pr = pi(this, ve, [he])).url.segment("paths/strict-send"), ke.isNative() ? Pr.url.setQuery("source_asset_type", "native") : (Pr.url.setQuery("source_asset_type", ke.getAssetType()), Pr.url.setQuery("source_asset_code", ke.getCode()), Pr.url.setQuery("source_asset_issuer", ke.getIssuer())), Pr.url.setQuery("source_amount", ht), typeof pt == "string") Pr.url.setQuery("destination_account", pt);
            else {
              var cn = pt.map(function(on) {
                return on.isNative() ? "native" : "".concat(on.getCode(), ":").concat(on.getIssuer());
              }).join(",");
              Pr.url.setQuery("destination_assets", cn);
            }
            return Pr;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && Un(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve);
        }(se);
        function Ye(Ie) {
          return Ye = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Ye(Ie);
        }
        function bt(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, xt(ke.key), ke);
          }
        }
        function xt(Ie) {
          var ve = function(he, ke) {
            if (Ye(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Ye(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Ye(ve) == "symbol" ? ve : ve + "";
        }
        function $t(Ie, ve, he) {
          return ve = M(ve), function(ke, ht) {
            if (ht && (Ye(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, fr() ? Reflect.construct(ve, he || [], M(Ie).constructor) : ve.apply(Ie, he));
        }
        function fr() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (fr = function() {
            return !!Ie;
          })();
        }
        function M(Ie) {
          return M = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, M(Ie);
        }
        function W(Ie, ve) {
          return W = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, W(Ie, ve);
        }
        var fe = [6e4, 3e5, 9e5, 36e5, 864e5, 6048e5], Se = function(Ie) {
          function ve(he, ke, ht, pt, Pr, cn, on) {
            var sn;
            if (function(Nn, Vn) {
              if (!(Nn instanceof Vn)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (sn = $t(this, ve, [he])).url.segment("trade_aggregations"), ke.isNative() ? sn.url.setQuery("base_asset_type", "native") : (sn.url.setQuery("base_asset_type", ke.getAssetType()), sn.url.setQuery("base_asset_code", ke.getCode()), sn.url.setQuery("base_asset_issuer", ke.getIssuer())), ht.isNative() ? sn.url.setQuery("counter_asset_type", "native") : (sn.url.setQuery("counter_asset_type", ht.getAssetType()), sn.url.setQuery("counter_asset_code", ht.getCode()), sn.url.setQuery("counter_asset_issuer", ht.getIssuer())), typeof pt != "number" || typeof Pr != "number") throw new ae.v7("Invalid time bounds", [pt, Pr]);
            if (sn.url.setQuery("start_time", pt.toString()), sn.url.setQuery("end_time", Pr.toString()), !sn.isValidResolution(cn)) throw new ae.v7("Invalid resolution", cn);
            if (sn.url.setQuery("resolution", cn.toString()), !sn.isValidOffset(on, cn)) throw new ae.v7("Invalid offset", on);
            return sn.url.setQuery("offset", on.toString()), sn;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && W(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && bt(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "isValidResolution", value: function(he) {
            return fe.some(function(ke) {
              return ke === he;
            });
          } }, { key: "isValidOffset", value: function(he, ke) {
            var ht = 36e5;
            return !(he > ke || he >= 24 * ht || he % ht != 0);
          } }]);
        }(se);
        function Ce(Ie) {
          return Ce = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Ce(Ie);
        }
        function Re(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Je(ke.key), ke);
          }
        }
        function Je(Ie) {
          var ve = function(he, ke) {
            if (Ce(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Ce(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Ce(ve) == "symbol" ? ve : ve + "";
        }
        function Ut(Ie, ve, he) {
          return ve = Ht(ve), function(ke, ht) {
            if (ht && (Ce(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, _t() ? Reflect.construct(ve, he || [], Ht(Ie).constructor) : ve.apply(Ie, he));
        }
        function _t() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (_t = function() {
            return !!Ie;
          })();
        }
        function Ht(Ie) {
          return Ht = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, Ht(Ie);
        }
        function tr(Ie, ve) {
          return tr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, tr(Ie, ve);
        }
        var Sr = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = Ut(this, ve, [he, "trades"])).url.segment("trades"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && tr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && Re(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "forAssetPair", value: function(he, ke) {
            return he.isNative() ? this.url.setQuery("base_asset_type", "native") : (this.url.setQuery("base_asset_type", he.getAssetType()), this.url.setQuery("base_asset_code", he.getCode()), this.url.setQuery("base_asset_issuer", he.getIssuer())), ke.isNative() ? this.url.setQuery("counter_asset_type", "native") : (this.url.setQuery("counter_asset_type", ke.getAssetType()), this.url.setQuery("counter_asset_code", ke.getCode()), this.url.setQuery("counter_asset_issuer", ke.getIssuer())), this;
          } }, { key: "forOffer", value: function(he) {
            return this.url.setQuery("offer_id", he), this;
          } }, { key: "forType", value: function(he) {
            return this.url.setQuery("trade_type", he), this;
          } }, { key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "forLiquidityPool", value: function(he) {
            return this.forEndpoint("liquidity_pools", he);
          } }]);
        }(se);
        function Ee(Ie) {
          return Ee = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Ee(Ie);
        }
        function ot(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, Mt(ke.key), ke);
          }
        }
        function Mt(Ie) {
          var ve = function(he, ke) {
            if (Ee(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Ee(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Ee(ve) == "symbol" ? ve : ve + "";
        }
        function gt(Ie, ve, he) {
          return ve = or(ve), function(ke, ht) {
            if (ht && (Ee(ht) == "object" || typeof ht == "function")) return ht;
            if (ht !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(pt) {
              if (pt === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return pt;
            }(ke);
          }(Ie, Rt() ? Reflect.construct(ve, he || [], or(Ie).constructor) : ve.apply(Ie, he));
        }
        function Rt() {
          try {
            var Ie = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (Rt = function() {
            return !!Ie;
          })();
        }
        function or(Ie) {
          return or = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(ve) {
            return ve.__proto__ || Object.getPrototypeOf(ve);
          }, or(Ie);
        }
        function nr(Ie, ve) {
          return nr = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(he, ke) {
            return he.__proto__ = ke, he;
          }, nr(Ie, ve);
        }
        var Qr = function(Ie) {
          function ve(he) {
            var ke;
            return function(ht, pt) {
              if (!(ht instanceof pt)) throw new TypeError("Cannot call a class as a function");
            }(this, ve), (ke = gt(this, ve, [he, "transactions"])).url.segment("transactions"), ke;
          }
          return function(he, ke) {
            if (typeof ke != "function" && ke !== null) throw new TypeError("Super expression must either be null or a function");
            he.prototype = Object.create(ke && ke.prototype, { constructor: { value: he, writable: true, configurable: true } }), Object.defineProperty(he, "prototype", { writable: false }), ke && nr(he, ke);
          }(ve, Ie), function(he, ke, ht) {
            return ke && ot(he.prototype, ke), Object.defineProperty(he, "prototype", { writable: false }), he;
          }(ve, [{ key: "transaction", value: function(he) {
            var ke = new se(this.url.clone());
            return ke.filter.push([he]), ke;
          } }, { key: "forAccount", value: function(he) {
            return this.forEndpoint("accounts", he);
          } }, { key: "forClaimableBalance", value: function(he) {
            return this.forEndpoint("claimable_balances", he);
          } }, { key: "forLedger", value: function(he) {
            return this.forEndpoint("ledgers", he.toString());
          } }, { key: "forLiquidityPool", value: function(he) {
            return this.forEndpoint("liquidity_pools", he);
          } }, { key: "includeFailed", value: function(he) {
            return this.url.setQuery("include_failed", he.toString()), this;
          } }]);
        }(se);
        function Xr(Ie) {
          return Xr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ve) {
            return typeof ve;
          } : function(ve) {
            return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
          }, Xr(Ie);
        }
        function Yr(Ie, ve) {
          var he = Object.keys(Ie);
          if (Object.getOwnPropertySymbols) {
            var ke = Object.getOwnPropertySymbols(Ie);
            ve && (ke = ke.filter(function(ht) {
              return Object.getOwnPropertyDescriptor(Ie, ht).enumerable;
            })), he.push.apply(he, ke);
          }
          return he;
        }
        function un(Ie) {
          for (var ve = 1; ve < arguments.length; ve++) {
            var he = arguments[ve] != null ? arguments[ve] : {};
            ve % 2 ? Yr(Object(he), true).forEach(function(ke) {
              Kr(Ie, ke, he[ke]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ie, Object.getOwnPropertyDescriptors(he)) : Yr(Object(he)).forEach(function(ke) {
              Object.defineProperty(Ie, ke, Object.getOwnPropertyDescriptor(he, ke));
            });
          }
          return Ie;
        }
        function Kr(Ie, ve, he) {
          return (ve = On(ve)) in Ie ? Object.defineProperty(Ie, ve, { value: he, enumerable: true, configurable: true, writable: true }) : Ie[ve] = he, Ie;
        }
        function Ir() {
          Ir = function() {
            return ve;
          };
          var Ie, ve = {}, he = Object.prototype, ke = he.hasOwnProperty, ht = Object.defineProperty || function(Fe, He, et) {
            Fe[He] = et.value;
          }, pt = typeof Symbol == "function" ? Symbol : {}, Pr = pt.iterator || "@@iterator", cn = pt.asyncIterator || "@@asyncIterator", on = pt.toStringTag || "@@toStringTag";
          function sn(Fe, He, et) {
            return Object.defineProperty(Fe, He, { value: et, enumerable: true, configurable: true, writable: true }), Fe[He];
          }
          try {
            sn({}, "");
          } catch {
            sn = function(He, et, jt) {
              return He[et] = jt;
            };
          }
          function Nn(Fe, He, et, jt) {
            var At = He && He.prototype instanceof Gn ? He : Gn, qt = Object.create(At.prototype), Jt = new mn(jt || []);
            return ht(qt, "_invoke", { value: pr(Fe, et, Jt) }), qt;
          }
          function Vn(Fe, He, et) {
            try {
              return { type: "normal", arg: Fe.call(He, et) };
            } catch (jt) {
              return { type: "throw", arg: jt };
            }
          }
          ve.wrap = Nn;
          var ln = "suspendedStart", oi = "suspendedYield", Hn = "executing", Tn = "completed", xn = {};
          function Gn() {
          }
          function Kn() {
          }
          function Pn() {
          }
          var Xn = {};
          sn(Xn, Pr, function() {
            return this;
          });
          var kt = Object.getPrototypeOf, Kt = kt && kt(kt(pn([])));
          Kt && Kt !== he && ke.call(Kt, Pr) && (Xn = Kt);
          var lr = Pn.prototype = Gn.prototype = Object.create(Xn);
          function Er(Fe) {
            ["next", "throw", "return"].forEach(function(He) {
              sn(Fe, He, function(et) {
                return this._invoke(He, et);
              });
            });
          }
          function Rr(Fe, He) {
            function et(At, qt, Jt, er) {
              var mr = Vn(Fe[At], Fe, qt);
              if (mr.type !== "throw") {
                var Ar = mr.arg, xr = Ar.value;
                return xr && Xr(xr) == "object" && ke.call(xr, "__await") ? He.resolve(xr.__await).then(function(Jr) {
                  et("next", Jr, Jt, er);
                }, function(Jr) {
                  et("throw", Jr, Jt, er);
                }) : He.resolve(xr).then(function(Jr) {
                  Ar.value = Jr, Jt(Ar);
                }, function(Jr) {
                  return et("throw", Jr, Jt, er);
                });
              }
              er(mr.arg);
            }
            var jt;
            ht(this, "_invoke", { value: function(At, qt) {
              function Jt() {
                return new He(function(er, mr) {
                  et(At, qt, er, mr);
                });
              }
              return jt = jt ? jt.then(Jt, Jt) : Jt();
            } });
          }
          function pr(Fe, He, et) {
            var jt = ln;
            return function(At, qt) {
              if (jt === Hn) throw Error("Generator is already running");
              if (jt === Tn) {
                if (At === "throw") throw qt;
                return { value: Ie, done: true };
              }
              for (et.method = At, et.arg = qt; ; ) {
                var Jt = et.delegate;
                if (Jt) {
                  var er = tn(Jt, et);
                  if (er) {
                    if (er === xn) continue;
                    return er;
                  }
                }
                if (et.method === "next") et.sent = et._sent = et.arg;
                else if (et.method === "throw") {
                  if (jt === ln) throw jt = Tn, et.arg;
                  et.dispatchException(et.arg);
                } else et.method === "return" && et.abrupt("return", et.arg);
                jt = Hn;
                var mr = Vn(Fe, He, et);
                if (mr.type === "normal") {
                  if (jt = et.done ? Tn : oi, mr.arg === xn) continue;
                  return { value: mr.arg, done: et.done };
                }
                mr.type === "throw" && (jt = Tn, et.method = "throw", et.arg = mr.arg);
              }
            };
          }
          function tn(Fe, He) {
            var et = He.method, jt = Fe.iterator[et];
            if (jt === Ie) return He.delegate = null, et === "throw" && Fe.iterator.return && (He.method = "return", He.arg = Ie, tn(Fe, He), He.method === "throw") || et !== "return" && (He.method = "throw", He.arg = new TypeError("The iterator does not provide a '" + et + "' method")), xn;
            var At = Vn(jt, Fe.iterator, He.arg);
            if (At.type === "throw") return He.method = "throw", He.arg = At.arg, He.delegate = null, xn;
            var qt = At.arg;
            return qt ? qt.done ? (He[Fe.resultName] = qt.value, He.next = Fe.nextLoc, He.method !== "return" && (He.method = "next", He.arg = Ie), He.delegate = null, xn) : qt : (He.method = "throw", He.arg = new TypeError("iterator result is not an object"), He.delegate = null, xn);
          }
          function fn(Fe) {
            var He = { tryLoc: Fe[0] };
            1 in Fe && (He.catchLoc = Fe[1]), 2 in Fe && (He.finallyLoc = Fe[2], He.afterLoc = Fe[3]), this.tryEntries.push(He);
          }
          function rn(Fe) {
            var He = Fe.completion || {};
            He.type = "normal", delete He.arg, Fe.completion = He;
          }
          function mn(Fe) {
            this.tryEntries = [{ tryLoc: "root" }], Fe.forEach(fn, this), this.reset(true);
          }
          function pn(Fe) {
            if (Fe || Fe === "") {
              var He = Fe[Pr];
              if (He) return He.call(Fe);
              if (typeof Fe.next == "function") return Fe;
              if (!isNaN(Fe.length)) {
                var et = -1, jt = function At() {
                  for (; ++et < Fe.length; ) if (ke.call(Fe, et)) return At.value = Fe[et], At.done = false, At;
                  return At.value = Ie, At.done = true, At;
                };
                return jt.next = jt;
              }
            }
            throw new TypeError(Xr(Fe) + " is not iterable");
          }
          return Kn.prototype = Pn, ht(lr, "constructor", { value: Pn, configurable: true }), ht(Pn, "constructor", { value: Kn, configurable: true }), Kn.displayName = sn(Pn, on, "GeneratorFunction"), ve.isGeneratorFunction = function(Fe) {
            var He = typeof Fe == "function" && Fe.constructor;
            return !!He && (He === Kn || (He.displayName || He.name) === "GeneratorFunction");
          }, ve.mark = function(Fe) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Fe, Pn) : (Fe.__proto__ = Pn, sn(Fe, on, "GeneratorFunction")), Fe.prototype = Object.create(lr), Fe;
          }, ve.awrap = function(Fe) {
            return { __await: Fe };
          }, Er(Rr.prototype), sn(Rr.prototype, cn, function() {
            return this;
          }), ve.AsyncIterator = Rr, ve.async = function(Fe, He, et, jt, At) {
            At === void 0 && (At = Promise);
            var qt = new Rr(Nn(Fe, He, et, jt), At);
            return ve.isGeneratorFunction(He) ? qt : qt.next().then(function(Jt) {
              return Jt.done ? Jt.value : qt.next();
            });
          }, Er(lr), sn(lr, on, "Generator"), sn(lr, Pr, function() {
            return this;
          }), sn(lr, "toString", function() {
            return "[object Generator]";
          }), ve.keys = function(Fe) {
            var He = Object(Fe), et = [];
            for (var jt in He) et.push(jt);
            return et.reverse(), function At() {
              for (; et.length; ) {
                var qt = et.pop();
                if (qt in He) return At.value = qt, At.done = false, At;
              }
              return At.done = true, At;
            };
          }, ve.values = pn, mn.prototype = { constructor: mn, reset: function(Fe) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = Ie, this.done = false, this.delegate = null, this.method = "next", this.arg = Ie, this.tryEntries.forEach(rn), !Fe) for (var He in this) He.charAt(0) === "t" && ke.call(this, He) && !isNaN(+He.slice(1)) && (this[He] = Ie);
          }, stop: function() {
            this.done = true;
            var Fe = this.tryEntries[0].completion;
            if (Fe.type === "throw") throw Fe.arg;
            return this.rval;
          }, dispatchException: function(Fe) {
            if (this.done) throw Fe;
            var He = this;
            function et(mr, Ar) {
              return qt.type = "throw", qt.arg = Fe, He.next = mr, Ar && (He.method = "next", He.arg = Ie), !!Ar;
            }
            for (var jt = this.tryEntries.length - 1; jt >= 0; --jt) {
              var At = this.tryEntries[jt], qt = At.completion;
              if (At.tryLoc === "root") return et("end");
              if (At.tryLoc <= this.prev) {
                var Jt = ke.call(At, "catchLoc"), er = ke.call(At, "finallyLoc");
                if (Jt && er) {
                  if (this.prev < At.catchLoc) return et(At.catchLoc, true);
                  if (this.prev < At.finallyLoc) return et(At.finallyLoc);
                } else if (Jt) {
                  if (this.prev < At.catchLoc) return et(At.catchLoc, true);
                } else {
                  if (!er) throw Error("try statement without catch or finally");
                  if (this.prev < At.finallyLoc) return et(At.finallyLoc);
                }
              }
            }
          }, abrupt: function(Fe, He) {
            for (var et = this.tryEntries.length - 1; et >= 0; --et) {
              var jt = this.tryEntries[et];
              if (jt.tryLoc <= this.prev && ke.call(jt, "finallyLoc") && this.prev < jt.finallyLoc) {
                var At = jt;
                break;
              }
            }
            At && (Fe === "break" || Fe === "continue") && At.tryLoc <= He && He <= At.finallyLoc && (At = null);
            var qt = At ? At.completion : {};
            return qt.type = Fe, qt.arg = He, At ? (this.method = "next", this.next = At.finallyLoc, xn) : this.complete(qt);
          }, complete: function(Fe, He) {
            if (Fe.type === "throw") throw Fe.arg;
            return Fe.type === "break" || Fe.type === "continue" ? this.next = Fe.arg : Fe.type === "return" ? (this.rval = this.arg = Fe.arg, this.method = "return", this.next = "end") : Fe.type === "normal" && He && (this.next = He), xn;
          }, finish: function(Fe) {
            for (var He = this.tryEntries.length - 1; He >= 0; --He) {
              var et = this.tryEntries[He];
              if (et.finallyLoc === Fe) return this.complete(et.completion, et.afterLoc), rn(et), xn;
            }
          }, catch: function(Fe) {
            for (var He = this.tryEntries.length - 1; He >= 0; --He) {
              var et = this.tryEntries[He];
              if (et.tryLoc === Fe) {
                var jt = et.completion;
                if (jt.type === "throw") {
                  var At = jt.arg;
                  rn(et);
                }
                return At;
              }
            }
            throw Error("illegal catch attempt");
          }, delegateYield: function(Fe, He, et) {
            return this.delegate = { iterator: pn(Fe), resultName: He, nextLoc: et }, this.method === "next" && (this.arg = Ie), xn;
          } }, ve;
        }
        function An(Ie, ve, he, ke, ht, pt, Pr) {
          try {
            var cn = Ie[pt](Pr), on = cn.value;
          } catch (sn) {
            return void he(sn);
          }
          cn.done ? ve(on) : Promise.resolve(on).then(ke, ht);
        }
        function En(Ie) {
          return function() {
            var ve = this, he = arguments;
            return new Promise(function(ke, ht) {
              var pt = Ie.apply(ve, he);
              function Pr(on) {
                An(pt, ke, ht, Pr, cn, "next", on);
              }
              function cn(on) {
                An(pt, ke, ht, Pr, cn, "throw", on);
              }
              Pr(void 0);
            });
          };
        }
        function Sn(Ie, ve) {
          for (var he = 0; he < ve.length; he++) {
            var ke = ve[he];
            ke.enumerable = ke.enumerable || false, ke.configurable = true, "value" in ke && (ke.writable = true), Object.defineProperty(Ie, On(ke.key), ke);
          }
        }
        function On(Ie) {
          var ve = function(he, ke) {
            if (Xr(he) != "object" || !he) return he;
            var ht = he[Symbol.toPrimitive];
            if (ht !== void 0) {
              var pt = ht.call(he, ke);
              if (Xr(pt) != "object") return pt;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(he);
          }(Ie, "string");
          return Xr(ve) == "symbol" ? ve : ve + "";
        }
        function gn(Ie) {
          return new ie(Ie).div(1e7).toString();
        }
        var Bn, jn, qn, Qn, ii, vi, uo, jo, la = function(Ie, ve, he) {
          return ve && Sn(Ie.prototype, ve), Object.defineProperty(Ie, "prototype", { writable: false }), Ie;
        }(function Ie(ve) {
          var he = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          (function(pt, Pr) {
            if (!(pt instanceof Pr)) throw new TypeError("Cannot call a class as a function");
          })(this, Ie), this.serverURL = oe()(ve);
          var ke = he.allowHttp === void 0 ? X.T.isAllowHttp() : he.allowHttp, ht = {};
          if (he.appName && (ht["X-App-Name"] = he.appName), he.appVersion && (ht["X-App-Version"] = he.appVersion), he.authToken && (ht["X-Auth-Token"] = he.authToken), he.headers && Object.assign(ht, he.headers), Object.keys(ht).length > 0 && xe.interceptors.request.use(function(pt) {
            return pt.headers = pt.headers || {}, pt.headers = Object.assign(pt.headers, ht), pt;
          }), this.serverURL.protocol() !== "https" && !ke) throw new Error("Cannot connect to insecure horizon server");
        }, [{ key: "fetchTimebounds", value: (jo = En(Ir().mark(function Ie(ve) {
          var he, ke, ht = arguments;
          return Ir().wrap(function(pt) {
            for (; ; ) switch (pt.prev = pt.next) {
              case 0:
                if (he = ht.length > 1 && ht[1] !== void 0 && ht[1], !(ke = Ve(this.serverURL.hostname()))) {
                  pt.next = 4;
                  break;
                }
                return pt.abrupt("return", { minTime: 0, maxTime: ke + ve });
              case 4:
                if (!he) {
                  pt.next = 6;
                  break;
                }
                return pt.abrupt("return", { minTime: 0, maxTime: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3) + ve });
              case 6:
                return pt.next = 8, xe.get(oe()(this.serverURL).toString());
              case 8:
                return pt.abrupt("return", this.fetchTimebounds(ve, true));
              case 9:
              case "end":
                return pt.stop();
            }
          }, Ie, this);
        })), function(Ie) {
          return jo.apply(this, arguments);
        }) }, { key: "fetchBaseFee", value: (uo = En(Ir().mark(function Ie() {
          var ve;
          return Ir().wrap(function(he) {
            for (; ; ) switch (he.prev = he.next) {
              case 0:
                return he.next = 2, this.feeStats();
              case 2:
                return ve = he.sent, he.abrupt("return", parseInt(ve.last_ledger_base_fee, 10) || 100);
              case 4:
              case "end":
                return he.stop();
            }
          }, Ie, this);
        })), function() {
          return uo.apply(this, arguments);
        }) }, { key: "feeStats", value: (vi = En(Ir().mark(function Ie() {
          var ve;
          return Ir().wrap(function(he) {
            for (; ; ) switch (he.prev = he.next) {
              case 0:
                return (ve = new se(oe()(this.serverURL))).filter.push(["fee_stats"]), he.abrupt("return", ve.call());
              case 3:
              case "end":
                return he.stop();
            }
          }, Ie, this);
        })), function() {
          return vi.apply(this, arguments);
        }) }, { key: "root", value: (ii = En(Ir().mark(function Ie() {
          var ve;
          return Ir().wrap(function(he) {
            for (; ; ) switch (he.prev = he.next) {
              case 0:
                return ve = new se(oe()(this.serverURL)), he.abrupt("return", ve.call());
              case 2:
              case "end":
                return he.stop();
            }
          }, Ie, this);
        })), function() {
          return ii.apply(this, arguments);
        }) }, { key: "submitTransaction", value: (Qn = En(Ir().mark(function Ie(ve) {
          var he, ke = arguments;
          return Ir().wrap(function(ht) {
            for (; ; ) switch (ht.prev = ht.next) {
              case 0:
                if ((ke.length > 1 && ke[1] !== void 0 ? ke[1] : { skipMemoRequiredCheck: false }).skipMemoRequiredCheck) {
                  ht.next = 4;
                  break;
                }
                return ht.next = 4, this.checkMemoRequired(ve);
              case 4:
                return he = encodeURIComponent(ve.toEnvelope().toXDR().toString("base64")), ht.abrupt("return", xe.post(oe()(this.serverURL).segment("transactions").toString(), "tx=".concat(he), { timeout: 6e4 }).then(function(pt) {
                  if (!pt.data.result_xdr) return pt.data;
                  var Pr, cn, on = m.xdr.TransactionResult.fromXDR(pt.data.result_xdr, "base64").result().value();
                  return on.length && (Pr = on.map(function(sn, Nn) {
                    if (sn.value().switch().name !== "manageBuyOffer" && sn.value().switch().name !== "manageSellOffer") return null;
                    cn = true;
                    var Vn, ln = new ie(0), oi = new ie(0), Hn = sn.value().value().success(), Tn = Hn.offersClaimed().map(function(Xn) {
                      var kt = Xn.value(), Kt = "";
                      switch (Xn.switch()) {
                        case m.xdr.ClaimAtomType.claimAtomTypeV0():
                          Kt = m.StrKey.encodeEd25519PublicKey(kt.sellerEd25519());
                          break;
                        case m.xdr.ClaimAtomType.claimAtomTypeOrderBook():
                          Kt = m.StrKey.encodeEd25519PublicKey(kt.sellerId().ed25519());
                          break;
                        default:
                          throw new Error("Invalid offer result type: ".concat(Xn.switch()));
                      }
                      var lr = new ie(kt.amountBought().toString()), Er = new ie(kt.amountSold().toString());
                      ln = ln.plus(Er), oi = oi.plus(lr);
                      var Rr = m.Asset.fromOperation(kt.assetSold()), pr = m.Asset.fromOperation(kt.assetBought()), tn = { type: Rr.getAssetType(), assetCode: Rr.getCode(), issuer: Rr.getIssuer() }, fn = { type: pr.getAssetType(), assetCode: pr.getCode(), issuer: pr.getIssuer() };
                      return { sellerId: Kt, offerId: kt.offerId().toString(), assetSold: tn, amountSold: gn(Er), assetBought: fn, amountBought: gn(lr) };
                    }), xn = Hn.offer().switch().name;
                    if (typeof Hn.offer().value == "function" && Hn.offer().value()) {
                      var Gn = Hn.offer().value();
                      Vn = { offerId: Gn.offerId().toString(), selling: {}, buying: {}, amount: gn(Gn.amount().toString()), price: { n: Gn.price().n(), d: Gn.price().d() } };
                      var Kn = m.Asset.fromOperation(Gn.selling());
                      Vn.selling = { type: Kn.getAssetType(), assetCode: Kn.getCode(), issuer: Kn.getIssuer() };
                      var Pn = m.Asset.fromOperation(Gn.buying());
                      Vn.buying = { type: Pn.getAssetType(), assetCode: Pn.getCode(), issuer: Pn.getIssuer() };
                    }
                    return { offersClaimed: Tn, effect: xn, operationIndex: Nn, currentOffer: Vn, amountBought: gn(ln), amountSold: gn(oi), isFullyOpen: !Tn.length && xn !== "manageOfferDeleted", wasPartiallyFilled: !!Tn.length && xn !== "manageOfferDeleted", wasImmediatelyFilled: !!Tn.length && xn === "manageOfferDeleted", wasImmediatelyDeleted: !Tn.length && xn === "manageOfferDeleted" };
                  }).filter(function(sn) {
                    return !!sn;
                  })), un(un({}, pt.data), {}, { offerResults: cn ? Pr : void 0 });
                }).catch(function(pt) {
                  return pt instanceof Error ? Promise.reject(pt) : Promise.reject(new ae.nS("Transaction submission failed. Server responded: ".concat(pt.status, " ").concat(pt.statusText), pt.data));
                }));
              case 6:
              case "end":
                return ht.stop();
            }
          }, Ie, this);
        })), function(Ie) {
          return Qn.apply(this, arguments);
        }) }, { key: "submitAsyncTransaction", value: (qn = En(Ir().mark(function Ie(ve) {
          var he, ke = arguments;
          return Ir().wrap(function(ht) {
            for (; ; ) switch (ht.prev = ht.next) {
              case 0:
                if ((ke.length > 1 && ke[1] !== void 0 ? ke[1] : { skipMemoRequiredCheck: false }).skipMemoRequiredCheck) {
                  ht.next = 4;
                  break;
                }
                return ht.next = 4, this.checkMemoRequired(ve);
              case 4:
                return he = encodeURIComponent(ve.toEnvelope().toXDR().toString("base64")), ht.abrupt("return", xe.post(oe()(this.serverURL).segment("transactions_async").toString(), "tx=".concat(he)).then(function(pt) {
                  return pt.data;
                }).catch(function(pt) {
                  return pt instanceof Error ? Promise.reject(pt) : Promise.reject(new ae.nS("Transaction submission failed. Server responded: ".concat(pt.status, " ").concat(pt.statusText), pt.data));
                }));
              case 6:
              case "end":
                return ht.stop();
            }
          }, Ie, this);
        })), function(Ie) {
          return qn.apply(this, arguments);
        }) }, { key: "accounts", value: function() {
          return new je(oe()(this.serverURL));
        } }, { key: "claimableBalances", value: function() {
          return new nt(oe()(this.serverURL));
        } }, { key: "ledgers", value: function() {
          return new Qt(oe()(this.serverURL));
        } }, { key: "transactions", value: function() {
          return new Qr(oe()(this.serverURL));
        } }, { key: "offers", value: function() {
          return new Gr(oe()(this.serverURL));
        } }, { key: "orderbook", value: function(Ie, ve) {
          return new qr(oe()(this.serverURL), Ie, ve);
        } }, { key: "trades", value: function() {
          return new Sr(oe()(this.serverURL));
        } }, { key: "operations", value: function() {
          return new dt(oe()(this.serverURL));
        } }, { key: "liquidityPools", value: function() {
          return new It(oe()(this.serverURL));
        } }, { key: "strictReceivePaths", value: function(Ie, ve, he) {
          return new wn(oe()(this.serverURL), Ie, ve, he);
        } }, { key: "strictSendPaths", value: function(Ie, ve, he) {
          return new Xe(oe()(this.serverURL), Ie, ve, he);
        } }, { key: "payments", value: function() {
          return new St(oe()(this.serverURL));
        } }, { key: "effects", value: function() {
          return new Lt(oe()(this.serverURL));
        } }, { key: "friendbot", value: function(Ie) {
          return new Tr(oe()(this.serverURL), Ie);
        } }, { key: "assets", value: function() {
          return new Nt(oe()(this.serverURL));
        } }, { key: "loadAccount", value: (jn = En(Ir().mark(function Ie(ve) {
          var he;
          return Ir().wrap(function(ke) {
            for (; ; ) switch (ke.prev = ke.next) {
              case 0:
                return ke.next = 2, this.accounts().accountId(ve).call();
              case 2:
                return he = ke.sent, ke.abrupt("return", new R(he));
              case 4:
              case "end":
                return ke.stop();
            }
          }, Ie, this);
        })), function(Ie) {
          return jn.apply(this, arguments);
        }) }, { key: "tradeAggregation", value: function(Ie, ve, he, ke, ht, pt) {
          return new Se(oe()(this.serverURL), Ie, ve, he, ke, ht, pt);
        } }, { key: "checkMemoRequired", value: (Bn = En(Ir().mark(function Ie(ve) {
          var he, ke, ht, pt;
          return Ir().wrap(function(Pr) {
            for (; ; ) switch (Pr.prev = Pr.next) {
              case 0:
                if (ve instanceof m.FeeBumpTransaction && (ve = ve.innerTransaction), ve.memo.type === "none") {
                  Pr.next = 3;
                  break;
                }
                return Pr.abrupt("return");
              case 3:
                he = /* @__PURE__ */ new Set(), ke = 0;
              case 5:
                if (!(ke < ve.operations.length)) {
                  Pr.next = 36;
                  break;
                }
                ht = ve.operations[ke], Pr.t0 = ht.type, Pr.next = Pr.t0 === "payment" || Pr.t0 === "pathPaymentStrictReceive" || Pr.t0 === "pathPaymentStrictSend" || Pr.t0 === "accountMerge" ? 10 : 11;
                break;
              case 10:
                return Pr.abrupt("break", 12);
              case 11:
                return Pr.abrupt("continue", 33);
              case 12:
                if (pt = ht.destination, !he.has(pt)) {
                  Pr.next = 15;
                  break;
                }
                return Pr.abrupt("continue", 33);
              case 15:
                if (he.add(pt), !pt.startsWith("M")) {
                  Pr.next = 18;
                  break;
                }
                return Pr.abrupt("continue", 33);
              case 18:
                return Pr.prev = 18, Pr.next = 21, this.loadAccount(pt);
              case 21:
                if (Pr.sent.data_attr["config.memo_required"] !== "MQ==") {
                  Pr.next = 24;
                  break;
                }
                throw new ae.Cu("account requires memo", pt, ke);
              case 24:
                Pr.next = 33;
                break;
              case 26:
                if (Pr.prev = 26, Pr.t1 = Pr.catch(18), !(Pr.t1 instanceof ae.Cu)) {
                  Pr.next = 30;
                  break;
                }
                throw Pr.t1;
              case 30:
                if (Pr.t1 instanceof ae.m_) {
                  Pr.next = 32;
                  break;
                }
                throw Pr.t1;
              case 32:
                return Pr.abrupt("continue", 33);
              case 33:
                ke += 1, Pr.next = 5;
                break;
              case 36:
              case "end":
                return Pr.stop();
            }
          }, Ie, this, [[18, 26]]);
        })), function(Ie) {
          return Bn.apply(this, arguments);
        }) }]);
        const Rn = (t = u.hmd(t)).exports;
      }, 8752: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.extendFootprintTtl = function(f) {
          var r;
          if (((r = f.extendTo) !== null && r !== void 0 ? r : -1) <= 0) throw new RangeError("extendTo has to be positive");
          var m = new h.default.ExtendFootprintTtlOp({ ext: new h.default.ExtensionPoint(0), extendTo: f.extendTo }), g = { body: h.default.OperationBody.extendFootprintTtl(m) };
          return this.setSourceAccount(g, f), new h.default.Operation(g);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 8835: (t, o, u) => {
        var c = u(1270);
        function h() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
        }
        var f = /^([a-z0-9.+-]+:)/i, r = /:[0-9]*$/, m = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, g = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), a = ["'"].concat(g), l = ["%", "/", "?", ";", "#"].concat(a), d = ["/", "?", "#"], b = /^[+a-z0-9A-Z_-]{0,63}$/, S = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, E = { javascript: true, "javascript:": true }, R = { javascript: true, "javascript:": true }, k = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, w = u(5373);
        function F(I, q, D) {
          if (I && typeof I == "object" && I instanceof h) return I;
          var H = new h();
          return H.parse(I, q, D), H;
        }
        h.prototype.parse = function(I, q, D) {
          if (typeof I != "string") throw new TypeError("Parameter 'url' must be a string, not " + typeof I);
          var H = I.indexOf("?"), _ = H !== -1 && H < I.indexOf("#") ? "?" : "#", T = I.split(_);
          T[0] = T[0].replace(/\\/g, "/");
          var L = I = T.join(_);
          if (L = L.trim(), !D && I.split("#").length === 1) {
            var j = m.exec(L);
            if (j) return this.path = L, this.href = L, this.pathname = j[1], j[2] ? (this.search = j[2], this.query = q ? w.parse(this.search.substr(1)) : this.search.substr(1)) : q && (this.search = "", this.query = {}), this;
          }
          var z = f.exec(L);
          if (z) {
            var Y = (z = z[0]).toLowerCase();
            this.protocol = Y, L = L.substr(z.length);
          }
          if (D || z || L.match(/^\/\/[^@/]+@[^@/]+/)) {
            var te = L.substr(0, 2) === "//";
            !te || z && R[z] || (L = L.substr(2), this.slashes = true);
          }
          if (!R[z] && (te || z && !k[z])) {
            for (var G, K, J = -1, B = 0; B < d.length; B++) (Z = L.indexOf(d[B])) !== -1 && (J === -1 || Z < J) && (J = Z);
            for ((K = J === -1 ? L.lastIndexOf("@") : L.lastIndexOf("@", J)) !== -1 && (G = L.slice(0, K), L = L.slice(K + 1), this.auth = decodeURIComponent(G)), J = -1, B = 0; B < l.length; B++) {
              var Z;
              (Z = L.indexOf(l[B])) !== -1 && (J === -1 || Z < J) && (J = Z);
            }
            J === -1 && (J = L.length), this.host = L.slice(0, J), L = L.slice(J), this.parseHost(), this.hostname = this.hostname || "";
            var ie = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ie) for (var $ = this.hostname.split(/\./), oe = (B = 0, $.length); B < oe; B++) {
              var ce = $[B];
              if (ce && !ce.match(b)) {
                for (var ye = "", ae = 0, ue = ce.length; ae < ue; ae++) ce.charCodeAt(ae) > 127 ? ye += "x" : ye += ce[ae];
                if (!ye.match(b)) {
                  var ne = $.slice(0, B), ge = $.slice(B + 1), Te = ce.match(S);
                  Te && (ne.push(Te[1]), ge.unshift(Te[2])), ge.length && (L = "/" + ge.join(".") + L), this.hostname = ne.join(".");
                  break;
                }
              }
            }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), ie || (this.hostname = c.toASCII(this.hostname));
            var pe = this.port ? ":" + this.port : "", Oe = this.hostname || "";
            this.host = Oe + pe, this.href += this.host, ie && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), L[0] !== "/" && (L = "/" + L));
          }
          if (!E[Y]) for (B = 0, oe = a.length; B < oe; B++) {
            var xe = a[B];
            if (L.indexOf(xe) !== -1) {
              var Ve = encodeURIComponent(xe);
              Ve === xe && (Ve = escape(xe)), L = L.split(xe).join(Ve);
            }
          }
          var _e = L.indexOf("#");
          _e !== -1 && (this.hash = L.substr(_e), L = L.slice(0, _e));
          var Be = L.indexOf("?");
          if (Be !== -1 ? (this.search = L.substr(Be), this.query = L.substr(Be + 1), q && (this.query = w.parse(this.query)), L = L.slice(0, Be)) : q && (this.search = "", this.query = {}), L && (this.pathname = L), k[Y] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            pe = this.pathname || "";
            var Qe = this.search || "";
            this.path = pe + Qe;
          }
          return this.href = this.format(), this;
        }, h.prototype.format = function() {
          var I = this.auth || "";
          I && (I = (I = encodeURIComponent(I)).replace(/%3A/i, ":"), I += "@");
          var q = this.protocol || "", D = this.pathname || "", H = this.hash || "", _ = false, T = "";
          this.host ? _ = I + this.host : this.hostname && (_ = I + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (_ += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (T = w.stringify(this.query, { arrayFormat: "repeat", addQueryPrefix: false }));
          var L = this.search || T && "?" + T || "";
          return q && q.substr(-1) !== ":" && (q += ":"), this.slashes || (!q || k[q]) && _ !== false ? (_ = "//" + (_ || ""), D && D.charAt(0) !== "/" && (D = "/" + D)) : _ || (_ = ""), H && H.charAt(0) !== "#" && (H = "#" + H), L && L.charAt(0) !== "?" && (L = "?" + L), q + _ + (D = D.replace(/[?#]/g, function(j) {
            return encodeURIComponent(j);
          })) + (L = L.replace("#", "%23")) + H;
        }, h.prototype.resolve = function(I) {
          return this.resolveObject(F(I, false, true)).format();
        }, h.prototype.resolveObject = function(I) {
          if (typeof I == "string") {
            var q = new h();
            q.parse(I, false, true), I = q;
          }
          for (var D = new h(), H = Object.keys(this), _ = 0; _ < H.length; _++) {
            var T = H[_];
            D[T] = this[T];
          }
          if (D.hash = I.hash, I.href === "") return D.href = D.format(), D;
          if (I.slashes && !I.protocol) {
            for (var L = Object.keys(I), j = 0; j < L.length; j++) {
              var z = L[j];
              z !== "protocol" && (D[z] = I[z]);
            }
            return k[D.protocol] && D.hostname && !D.pathname && (D.pathname = "/", D.path = D.pathname), D.href = D.format(), D;
          }
          if (I.protocol && I.protocol !== D.protocol) {
            if (!k[I.protocol]) {
              for (var Y = Object.keys(I), te = 0; te < Y.length; te++) {
                var G = Y[te];
                D[G] = I[G];
              }
              return D.href = D.format(), D;
            }
            if (D.protocol = I.protocol, I.host || R[I.protocol]) D.pathname = I.pathname;
            else {
              for (var K = (I.pathname || "").split("/"); K.length && !(I.host = K.shift()); ) ;
              I.host || (I.host = ""), I.hostname || (I.hostname = ""), K[0] !== "" && K.unshift(""), K.length < 2 && K.unshift(""), D.pathname = K.join("/");
            }
            if (D.search = I.search, D.query = I.query, D.host = I.host || "", D.auth = I.auth, D.hostname = I.hostname || I.host, D.port = I.port, D.pathname || D.search) {
              var J = D.pathname || "", B = D.search || "";
              D.path = J + B;
            }
            return D.slashes = D.slashes || I.slashes, D.href = D.format(), D;
          }
          var Z = D.pathname && D.pathname.charAt(0) === "/", ie = I.host || I.pathname && I.pathname.charAt(0) === "/", $ = ie || Z || D.host && I.pathname, oe = $, ce = D.pathname && D.pathname.split("/") || [], ye = (K = I.pathname && I.pathname.split("/") || [], D.protocol && !k[D.protocol]);
          if (ye && (D.hostname = "", D.port = null, D.host && (ce[0] === "" ? ce[0] = D.host : ce.unshift(D.host)), D.host = "", I.protocol && (I.hostname = null, I.port = null, I.host && (K[0] === "" ? K[0] = I.host : K.unshift(I.host)), I.host = null), $ = $ && (K[0] === "" || ce[0] === "")), ie) D.host = I.host || I.host === "" ? I.host : D.host, D.hostname = I.hostname || I.hostname === "" ? I.hostname : D.hostname, D.search = I.search, D.query = I.query, ce = K;
          else if (K.length) ce || (ce = []), ce.pop(), ce = ce.concat(K), D.search = I.search, D.query = I.query;
          else if (I.search != null) return ye && (D.host = ce.shift(), D.hostname = D.host, (Te = !!(D.host && D.host.indexOf("@") > 0) && D.host.split("@")) && (D.auth = Te.shift(), D.hostname = Te.shift(), D.host = D.hostname)), D.search = I.search, D.query = I.query, D.pathname === null && D.search === null || (D.path = (D.pathname ? D.pathname : "") + (D.search ? D.search : "")), D.href = D.format(), D;
          if (!ce.length) return D.pathname = null, D.search ? D.path = "/" + D.search : D.path = null, D.href = D.format(), D;
          for (var ae = ce.slice(-1)[0], ue = (D.host || I.host || ce.length > 1) && (ae === "." || ae === "..") || ae === "", ne = 0, ge = ce.length; ge >= 0; ge--) (ae = ce[ge]) === "." ? ce.splice(ge, 1) : ae === ".." ? (ce.splice(ge, 1), ne++) : ne && (ce.splice(ge, 1), ne--);
          if (!$ && !oe) for (; ne--; ne) ce.unshift("..");
          !$ || ce[0] === "" || ce[0] && ce[0].charAt(0) === "/" || ce.unshift(""), ue && ce.join("/").substr(-1) !== "/" && ce.push("");
          var Te, pe = ce[0] === "" || ce[0] && ce[0].charAt(0) === "/";
          return ye && (D.hostname = pe ? "" : ce.length ? ce.shift() : "", D.host = D.hostname, (Te = !!(D.host && D.host.indexOf("@") > 0) && D.host.split("@")) && (D.auth = Te.shift(), D.hostname = Te.shift(), D.host = D.hostname)), ($ = $ || D.host && ce.length) && !pe && ce.unshift(""), ce.length > 0 ? D.pathname = ce.join("/") : (D.pathname = null, D.path = null), D.pathname === null && D.search === null || (D.path = (D.pathname ? D.pathname : "") + (D.search ? D.search : "")), D.auth = I.auth || D.auth, D.slashes = D.slashes || I.slashes, D.href = D.format(), D;
        }, h.prototype.parseHost = function() {
          var I = this.host, q = r.exec(I);
          q && ((q = q[0]) !== ":" && (this.port = q.substr(1)), I = I.substr(0, I.length - q.length)), I && (this.hostname = I);
        }, o.parse = F, o.resolve = function(I, q) {
          return F(I, false, true).resolve(q);
        }, o.resolveObject = function(I, q) {
          return I ? F(I, false, true).resolveObject(q) : q;
        }, o.format = function(I) {
          return typeof I == "string" && (I = F(I)), I instanceof h ? I.format() : h.prototype.format.call(I);
        }, o.Url = h;
      }, 8859: (t, o, u) => {
        var c = typeof Map == "function" && Map.prototype, h = Object.getOwnPropertyDescriptor && c ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, f = c && h && typeof h.get == "function" ? h.get : null, r = c && Map.prototype.forEach, m = typeof Set == "function" && Set.prototype, g = Object.getOwnPropertyDescriptor && m ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, a = m && g && typeof g.get == "function" ? g.get : null, l = m && Set.prototype.forEach, d = typeof WeakMap == "function" && WeakMap.prototype ? WeakMap.prototype.has : null, b = typeof WeakSet == "function" && WeakSet.prototype ? WeakSet.prototype.has : null, S = typeof WeakRef == "function" && WeakRef.prototype ? WeakRef.prototype.deref : null, E = Boolean.prototype.valueOf, R = Object.prototype.toString, k = Function.prototype.toString, w = String.prototype.match, F = String.prototype.slice, I = String.prototype.replace, q = String.prototype.toUpperCase, D = String.prototype.toLowerCase, H = RegExp.prototype.test, _ = Array.prototype.concat, T = Array.prototype.join, L = Array.prototype.slice, j = Math.floor, z = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Y = Object.getOwnPropertySymbols, te = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, G = typeof Symbol == "function" && typeof Symbol.iterator == "object", K = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === G || true) ? Symbol.toStringTag : null, J = Object.prototype.propertyIsEnumerable, B = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(N) {
          return N.__proto__;
        } : null);
        function Z(N, C) {
          if (N === 1 / 0 || N === -1 / 0 || N != N || N && N > -1e3 && N < 1e3 || H.call(/e/, C)) return C;
          var p = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
          if (typeof N == "number") {
            var A = N < 0 ? -j(-N) : j(N);
            if (A !== N) {
              var U = String(A), Q = F.call(C, U.length + 1);
              return I.call(U, p, "$&_") + "." + I.call(I.call(Q, /([0-9]{3})/g, "$&_"), /_$/, "");
            }
          }
          return I.call(C, p, "$&_");
        }
        var ie = u(2634), $ = ie.custom, oe = pe($) ? $ : null, ce = { __proto__: null, double: '"', single: "'" }, ye = { __proto__: null, double: /(["\\])/g, single: /(['\\])/g };
        function ae(N, C, p) {
          var A = p.quoteStyle || C, U = ce[A];
          return U + N + U;
        }
        function ue(N) {
          return I.call(String(N), /"/g, "&quot;");
        }
        function ne(N) {
          return !K || !(typeof N == "object" && (K in N || N[K] !== void 0));
        }
        function ge(N) {
          return Ve(N) === "[object Array]" && ne(N);
        }
        function Te(N) {
          return Ve(N) === "[object RegExp]" && ne(N);
        }
        function pe(N) {
          if (G) return N && typeof N == "object" && N instanceof Symbol;
          if (typeof N == "symbol") return true;
          if (!N || typeof N != "object" || !te) return false;
          try {
            return te.call(N), true;
          } catch {
          }
          return false;
        }
        t.exports = function N(C, p, A, U) {
          var Q = p || {};
          if (xe(Q, "quoteStyle") && !xe(ce, Q.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
          if (xe(Q, "maxStringLength") && (typeof Q.maxStringLength == "number" ? Q.maxStringLength < 0 && Q.maxStringLength !== 1 / 0 : Q.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
          var se = !xe(Q, "customInspect") || Q.customInspect;
          if (typeof se != "boolean" && se !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
          if (xe(Q, "indent") && Q.indent !== null && Q.indent !== "	" && !(parseInt(Q.indent, 10) === Q.indent && Q.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
          if (xe(Q, "numericSeparator") && typeof Q.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
          var X = Q.numericSeparator;
          if (C === void 0) return "undefined";
          if (C === null) return "null";
          if (typeof C == "boolean") return C ? "true" : "false";
          if (typeof C == "string") return Be(C, Q);
          if (typeof C == "number") {
            if (C === 0) return 1 / 0 / C > 0 ? "0" : "-0";
            var de = String(C);
            return X ? Z(C, de) : de;
          }
          if (typeof C == "bigint") {
            var tt = String(C) + "n";
            return X ? Z(C, tt) : tt;
          }
          var Ne = Q.depth === void 0 ? 5 : Q.depth;
          if (A === void 0 && (A = 0), A >= Ne && Ne > 0 && typeof C == "object") return ge(C) ? "[Array]" : "[Object]";
          var ut = function(le, re) {
            var Le;
            if (le.indent === "	") Le = "	";
            else {
              if (!(typeof le.indent == "number" && le.indent > 0)) return null;
              Le = T.call(Array(le.indent + 1), " ");
            }
            return { base: Le, prev: T.call(Array(re + 1), Le) };
          }(Q, A);
          if (U === void 0) U = [];
          else if (_e(U, C) >= 0) return "[Circular]";
          function Ze(le, re, Le) {
            if (re && (U = L.call(U)).push(re), Le) {
              var nt = { depth: Q.depth };
              return xe(Q, "quoteStyle") && (nt.quoteStyle = Q.quoteStyle), N(le, nt, A + 1, U);
            }
            return N(le, Q, A + 1, U);
          }
          if (typeof C == "function" && !Te(C)) {
            var Et = function(le) {
              if (le.name) return le.name;
              var re = w.call(k.call(le), /^function\s*([\w$]+)/);
              return re ? re[1] : null;
            }(C), rr = V(C, Ze);
            return "[Function" + (Et ? ": " + Et : " (anonymous)") + "]" + (rr.length > 0 ? " { " + T.call(rr, ", ") + " }" : "");
          }
          if (pe(C)) {
            var je = G ? I.call(String(C), /^(Symbol\(.*\))_[^)]*$/, "$1") : te.call(C);
            return typeof C != "object" || G ? je : ee(je);
          }
          if (function(le) {
            return !le || typeof le != "object" ? false : typeof HTMLElement < "u" && le instanceof HTMLElement ? true : typeof le.nodeName == "string" && typeof le.getAttribute == "function";
          }(C)) {
            for (var Ge = "<" + D.call(String(C.nodeName)), at = C.attributes || [], Ae = 0; Ae < at.length; Ae++) Ge += " " + at[Ae].name + "=" + ae(ue(at[Ae].value), "double", Q);
            return Ge += ">", C.childNodes && C.childNodes.length && (Ge += "..."), Ge += "</" + D.call(String(C.nodeName)) + ">";
          }
          if (ge(C)) {
            if (C.length === 0) return "[]";
            var qe = V(C, Ze);
            return ut && !function(le) {
              for (var re = 0; re < le.length; re++) if (_e(le[re], `
`) >= 0) return false;
              return true;
            }(qe) ? "[" + O(qe, ut) + "]" : "[ " + T.call(qe, ", ") + " ]";
          }
          if (function(le) {
            return Ve(le) === "[object Error]" && ne(le);
          }(C)) {
            var Ft = V(C, Ze);
            return "cause" in Error.prototype || !("cause" in C) || J.call(C, "cause") ? Ft.length === 0 ? "[" + String(C) + "]" : "{ [" + String(C) + "] " + T.call(Ft, ", ") + " }" : "{ [" + String(C) + "] " + T.call(_.call("[cause]: " + Ze(C.cause), Ft), ", ") + " }";
          }
          if (typeof C == "object" && se) {
            if (oe && typeof C[oe] == "function" && ie) return ie(C, { depth: Ne - A });
            if (se !== "symbol" && typeof C.inspect == "function") return C.inspect();
          }
          if (function(le) {
            if (!f || !le || typeof le != "object") return false;
            try {
              f.call(le);
              try {
                a.call(le);
              } catch {
                return true;
              }
              return le instanceof Map;
            } catch {
            }
            return false;
          }(C)) {
            var Dt = [];
            return r && r.call(C, function(le, re) {
              Dt.push(Ze(re, C, true) + " => " + Ze(le, C));
            }), x("Map", f.call(C), Dt, ut);
          }
          if (function(le) {
            if (!a || !le || typeof le != "object") return false;
            try {
              a.call(le);
              try {
                f.call(le);
              } catch {
                return true;
              }
              return le instanceof Set;
            } catch {
            }
            return false;
          }(C)) {
            var wr = [];
            return l && l.call(C, function(le) {
              wr.push(Ze(le, C));
            }), x("Set", a.call(C), wr, ut);
          }
          if (function(le) {
            if (!d || !le || typeof le != "object") return false;
            try {
              d.call(le, d);
              try {
                b.call(le, b);
              } catch {
                return true;
              }
              return le instanceof WeakMap;
            } catch {
            }
            return false;
          }(C)) return P("WeakMap");
          if (function(le) {
            if (!b || !le || typeof le != "object") return false;
            try {
              b.call(le, b);
              try {
                d.call(le, d);
              } catch {
                return true;
              }
              return le instanceof WeakSet;
            } catch {
            }
            return false;
          }(C)) return P("WeakSet");
          if (function(le) {
            if (!S || !le || typeof le != "object") return false;
            try {
              return S.call(le), true;
            } catch {
            }
            return false;
          }(C)) return P("WeakRef");
          if (function(le) {
            return Ve(le) === "[object Number]" && ne(le);
          }(C)) return ee(Ze(Number(C)));
          if (function(le) {
            if (!le || typeof le != "object" || !z) return false;
            try {
              return z.call(le), true;
            } catch {
            }
            return false;
          }(C)) return ee(Ze(z.call(C)));
          if (function(le) {
            return Ve(le) === "[object Boolean]" && ne(le);
          }(C)) return ee(E.call(C));
          if (function(le) {
            return Ve(le) === "[object String]" && ne(le);
          }(C)) return ee(Ze(String(C)));
          if (typeof window < "u" && C === window) return "{ [object Window] }";
          if (typeof globalThis < "u" && C === globalThis || u.g !== void 0 && C === u.g) return "{ [object globalThis] }";
          if (!function(le) {
            return Ve(le) === "[object Date]" && ne(le);
          }(C) && !Te(C)) {
            var Nt = V(C, Ze), yr = B ? B(C) === Object.prototype : C instanceof Object || C.constructor === Object, Ur = C instanceof Object ? "" : "null prototype", Pe = !yr && K && Object(C) === C && K in C ? F.call(Ve(C), 8, -1) : Ur ? "Object" : "", $e = (yr || typeof C.constructor != "function" ? "" : C.constructor.name ? C.constructor.name + " " : "") + (Pe || Ur ? "[" + T.call(_.call([], Pe || [], Ur || []), ": ") + "] " : "");
            return Nt.length === 0 ? $e + "{}" : ut ? $e + "{" + O(Nt, ut) + "}" : $e + "{ " + T.call(Nt, ", ") + " }";
          }
          return String(C);
        };
        var Oe = Object.prototype.hasOwnProperty || function(N) {
          return N in this;
        };
        function xe(N, C) {
          return Oe.call(N, C);
        }
        function Ve(N) {
          return R.call(N);
        }
        function _e(N, C) {
          if (N.indexOf) return N.indexOf(C);
          for (var p = 0, A = N.length; p < A; p++) if (N[p] === C) return p;
          return -1;
        }
        function Be(N, C) {
          if (N.length > C.maxStringLength) {
            var p = N.length - C.maxStringLength, A = "... " + p + " more character" + (p > 1 ? "s" : "");
            return Be(F.call(N, 0, C.maxStringLength), C) + A;
          }
          var U = ye[C.quoteStyle || "single"];
          return U.lastIndex = 0, ae(I.call(I.call(N, U, "\\$1"), /[\x00-\x1f]/g, Qe), "single", C);
        }
        function Qe(N) {
          var C = N.charCodeAt(0), p = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[C];
          return p ? "\\" + p : "\\x" + (C < 16 ? "0" : "") + q.call(C.toString(16));
        }
        function ee(N) {
          return "Object(" + N + ")";
        }
        function P(N) {
          return N + " { ? }";
        }
        function x(N, C, p, A) {
          return N + " (" + C + ") {" + (A ? O(p, A) : T.call(p, ", ")) + "}";
        }
        function O(N, C) {
          if (N.length === 0) return "";
          var p = `
` + C.prev + C.base;
          return p + T.call(N, "," + p) + `
` + C.prev;
        }
        function V(N, C) {
          var p = ge(N), A = [];
          if (p) {
            A.length = N.length;
            for (var U = 0; U < N.length; U++) A[U] = xe(N, U) ? C(N[U], N) : "";
          }
          var Q, se = typeof Y == "function" ? Y(N) : [];
          if (G) {
            Q = {};
            for (var X = 0; X < se.length; X++) Q["$" + se[X]] = se[X];
          }
          for (var de in N) xe(N, de) && (p && String(Number(de)) === de && de < N.length || G && Q["$" + de] instanceof Symbol || (H.call(/[^\w$]/, de) ? A.push(C(de, N) + ": " + C(N[de], N)) : A.push(de + ": " + C(N[de], N))));
          if (typeof Y == "function") for (var tt = 0; tt < se.length; tt++) J.call(N, se[tt]) && A.push("[" + C(se[tt]) + "]: " + C(N[se[tt]], N));
          return A;
        }
      }, 8968: (t) => {
        t.exports = Math.floor;
      }, 9032: (t, o, u) => {
        var c = u(7244), h = u(8184), f = u(5767), r = u(5680);
        function m(B) {
          return B.call.bind(B);
        }
        var g = typeof BigInt < "u", a = typeof Symbol < "u", l = m(Object.prototype.toString), d = m(Number.prototype.valueOf), b = m(String.prototype.valueOf), S = m(Boolean.prototype.valueOf);
        if (g) var E = m(BigInt.prototype.valueOf);
        if (a) var R = m(Symbol.prototype.valueOf);
        function k(B, Z) {
          if (typeof B != "object") return false;
          try {
            return Z(B), true;
          } catch {
            return false;
          }
        }
        function w(B) {
          return l(B) === "[object Map]";
        }
        function F(B) {
          return l(B) === "[object Set]";
        }
        function I(B) {
          return l(B) === "[object WeakMap]";
        }
        function q(B) {
          return l(B) === "[object WeakSet]";
        }
        function D(B) {
          return l(B) === "[object ArrayBuffer]";
        }
        function H(B) {
          return typeof ArrayBuffer < "u" && (D.working ? D(B) : B instanceof ArrayBuffer);
        }
        function _(B) {
          return l(B) === "[object DataView]";
        }
        function T(B) {
          return typeof DataView < "u" && (_.working ? _(B) : B instanceof DataView);
        }
        o.isArgumentsObject = c, o.isGeneratorFunction = h, o.isTypedArray = r, o.isPromise = function(B) {
          return typeof Promise < "u" && B instanceof Promise || B !== null && typeof B == "object" && typeof B.then == "function" && typeof B.catch == "function";
        }, o.isArrayBufferView = function(B) {
          return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(B) : r(B) || T(B);
        }, o.isUint8Array = function(B) {
          return f(B) === "Uint8Array";
        }, o.isUint8ClampedArray = function(B) {
          return f(B) === "Uint8ClampedArray";
        }, o.isUint16Array = function(B) {
          return f(B) === "Uint16Array";
        }, o.isUint32Array = function(B) {
          return f(B) === "Uint32Array";
        }, o.isInt8Array = function(B) {
          return f(B) === "Int8Array";
        }, o.isInt16Array = function(B) {
          return f(B) === "Int16Array";
        }, o.isInt32Array = function(B) {
          return f(B) === "Int32Array";
        }, o.isFloat32Array = function(B) {
          return f(B) === "Float32Array";
        }, o.isFloat64Array = function(B) {
          return f(B) === "Float64Array";
        }, o.isBigInt64Array = function(B) {
          return f(B) === "BigInt64Array";
        }, o.isBigUint64Array = function(B) {
          return f(B) === "BigUint64Array";
        }, w.working = typeof Map < "u" && w(/* @__PURE__ */ new Map()), o.isMap = function(B) {
          return typeof Map < "u" && (w.working ? w(B) : B instanceof Map);
        }, F.working = typeof Set < "u" && F(/* @__PURE__ */ new Set()), o.isSet = function(B) {
          return typeof Set < "u" && (F.working ? F(B) : B instanceof Set);
        }, I.working = typeof WeakMap < "u" && I(/* @__PURE__ */ new WeakMap()), o.isWeakMap = function(B) {
          return typeof WeakMap < "u" && (I.working ? I(B) : B instanceof WeakMap);
        }, q.working = typeof WeakSet < "u" && q(/* @__PURE__ */ new WeakSet()), o.isWeakSet = function(B) {
          return q(B);
        }, D.working = typeof ArrayBuffer < "u" && D(new ArrayBuffer()), o.isArrayBuffer = H, _.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && _(new DataView(new ArrayBuffer(1), 0, 1)), o.isDataView = T;
        var L = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
        function j(B) {
          return l(B) === "[object SharedArrayBuffer]";
        }
        function z(B) {
          return L !== void 0 && (j.working === void 0 && (j.working = j(new L())), j.working ? j(B) : B instanceof L);
        }
        function Y(B) {
          return k(B, d);
        }
        function te(B) {
          return k(B, b);
        }
        function G(B) {
          return k(B, S);
        }
        function K(B) {
          return g && k(B, E);
        }
        function J(B) {
          return a && k(B, R);
        }
        o.isSharedArrayBuffer = z, o.isAsyncFunction = function(B) {
          return l(B) === "[object AsyncFunction]";
        }, o.isMapIterator = function(B) {
          return l(B) === "[object Map Iterator]";
        }, o.isSetIterator = function(B) {
          return l(B) === "[object Set Iterator]";
        }, o.isGeneratorObject = function(B) {
          return l(B) === "[object Generator]";
        }, o.isWebAssemblyCompiledModule = function(B) {
          return l(B) === "[object WebAssembly.Module]";
        }, o.isNumberObject = Y, o.isStringObject = te, o.isBooleanObject = G, o.isBigIntObject = K, o.isSymbolObject = J, o.isBoxedPrimitive = function(B) {
          return Y(B) || te(B) || G(B) || K(B) || J(B);
        }, o.isAnyArrayBuffer = function(B) {
          return typeof Uint8Array < "u" && (H(B) || z(B));
        }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(B) {
          Object.defineProperty(o, B, { enumerable: false, value: function() {
            throw new Error(B + " is not supported in userland");
          } });
        });
      }, 9073: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.createPassiveSellOffer = function(f) {
          var r = {};
          if (r.selling = f.selling.toXDRObject(), r.buying = f.buying.toXDRObject(), !this.isValidAmount(f.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
          if (r.amount = this._toXDRAmount(f.amount), f.price === void 0) throw new TypeError("price argument is required");
          r.price = this._toXDRPrice(f.price);
          var m = new h.default.CreatePassiveSellOfferOp(r), g = {};
          return g.body = h.default.OperationBody.createPassiveSellOffer(m), this.setSourceAccount(g, f), new h.default.Operation(g);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 9092: (t, o, u) => {
        var c = u(1333);
        t.exports = function() {
          return c() && !!Symbol.toStringTag;
        };
      }, 9127: function(t, o, u) {
        var c, h, f;
        (function(r, m) {
          t.exports ? t.exports = m(u(4193)) : (h = [u(4193)], (f = typeof (c = m) == "function" ? c.apply(o, h) : c) === void 0 || (t.exports = f));
        })(0, function(r, m) {
          var g = m && m.URITemplate, a = Object.prototype.hasOwnProperty;
          function l(E) {
            return l._cache[E] ? l._cache[E] : this instanceof l ? (this.expression = E, l._cache[E] = this, this) : new l(E);
          }
          function d(E) {
            this.data = E, this.cache = {};
          }
          var b = l.prototype, S = { "": { prefix: "", separator: ",", named: false, empty_name_separator: false, encode: "encode" }, "+": { prefix: "", separator: ",", named: false, empty_name_separator: false, encode: "encodeReserved" }, "#": { prefix: "#", separator: ",", named: false, empty_name_separator: false, encode: "encodeReserved" }, ".": { prefix: ".", separator: ".", named: false, empty_name_separator: false, encode: "encode" }, "/": { prefix: "/", separator: "/", named: false, empty_name_separator: false, encode: "encode" }, ";": { prefix: ";", separator: ";", named: true, empty_name_separator: false, encode: "encode" }, "?": { prefix: "?", separator: "&", named: true, empty_name_separator: true, encode: "encode" }, "&": { prefix: "&", separator: "&", named: true, empty_name_separator: true, encode: "encode" } };
          return l._cache = {}, l.EXPRESSION_PATTERN = /\{([^a-zA-Z0-9%_]?)([^\}]+)(\}|$)/g, l.VARIABLE_PATTERN = /^([^*:.](?:\.?[^*:.])*)((\*)|:(\d+))?$/, l.VARIABLE_NAME_PATTERN = /[^a-zA-Z0-9%_.]/, l.LITERAL_PATTERN = /[<>{}"`^| \\]/, l.expand = function(E, R, k) {
            var w, F, I, q = S[E.operator], D = q.named ? "Named" : "Unnamed", H = E.variables, _ = [];
            for (I = 0; F = H[I]; I++) {
              if ((w = R.get(F.name)).type === 0 && k && k.strict) throw new Error('Missing expansion value for variable "' + F.name + '"');
              if (w.val.length) {
                if (w.type > 1 && F.maxlength) throw new Error('Invalid expression: Prefix modifier not applicable to variable "' + F.name + '"');
                _.push(l["expand" + D](w, q, F.explode, F.explode && q.separator || ",", F.maxlength, F.name));
              } else w.type && _.push("");
            }
            return _.length ? q.prefix + _.join(q.separator) : "";
          }, l.expandNamed = function(E, R, k, w, F, I) {
            var q, D, H, _ = "", T = R.encode, L = R.empty_name_separator, j = !E[T].length, z = E.type === 2 ? "" : r[T](I);
            for (D = 0, H = E.val.length; D < H; D++) F ? (q = r[T](E.val[D][1].substring(0, F)), E.type === 2 && (z = r[T](E.val[D][0].substring(0, F)))) : j ? (q = r[T](E.val[D][1]), E.type === 2 ? (z = r[T](E.val[D][0]), E[T].push([z, q])) : E[T].push([void 0, q])) : (q = E[T][D][1], E.type === 2 && (z = E[T][D][0])), _ && (_ += w), k ? _ += z + (L || q ? "=" : "") + q : (D || (_ += r[T](I) + (L || q ? "=" : "")), E.type === 2 && (_ += z + ","), _ += q);
            return _;
          }, l.expandUnnamed = function(E, R, k, w, F) {
            var I, q, D, H = "", _ = R.encode, T = R.empty_name_separator, L = !E[_].length;
            for (q = 0, D = E.val.length; q < D; q++) F ? I = r[_](E.val[q][1].substring(0, F)) : L ? (I = r[_](E.val[q][1]), E[_].push([E.type === 2 ? r[_](E.val[q][0]) : void 0, I])) : I = E[_][q][1], H && (H += w), E.type === 2 && (H += F ? r[_](E.val[q][0].substring(0, F)) : E[_][q][0], H += k ? T || I ? "=" : "" : ","), H += I;
            return H;
          }, l.noConflict = function() {
            return m.URITemplate === l && (m.URITemplate = g), l;
          }, b.expand = function(E, R) {
            var k = "";
            this.parts && this.parts.length || this.parse(), E instanceof d || (E = new d(E));
            for (var w = 0, F = this.parts.length; w < F; w++) k += typeof this.parts[w] == "string" ? this.parts[w] : l.expand(this.parts[w], E, R);
            return k;
          }, b.parse = function() {
            var E, R, k, w = this.expression, F = l.EXPRESSION_PATTERN, I = l.VARIABLE_PATTERN, q = l.VARIABLE_NAME_PATTERN, D = l.LITERAL_PATTERN, H = [], _ = 0, T = function(z) {
              if (z.match(D)) throw new Error('Invalid Literal "' + z + '"');
              return z;
            };
            for (F.lastIndex = 0; ; ) {
              if ((R = F.exec(w)) === null) {
                H.push(T(w.substring(_)));
                break;
              }
              if (H.push(T(w.substring(_, R.index))), _ = R.index + R[0].length, !S[R[1]]) throw new Error('Unknown Operator "' + R[1] + '" in "' + R[0] + '"');
              if (!R[3]) throw new Error('Unclosed Expression "' + R[0] + '"');
              for (var L = 0, j = (E = R[2].split(",")).length; L < j; L++) {
                if ((k = E[L].match(I)) === null) throw new Error('Invalid Variable "' + E[L] + '" in "' + R[0] + '"');
                if (k[1].match(q)) throw new Error('Invalid Variable Name "' + k[1] + '" in "' + R[0] + '"');
                E[L] = { name: k[1], explode: !!k[3], maxlength: k[4] && parseInt(k[4], 10) };
              }
              if (!E.length) throw new Error('Expression Missing Variable(s) "' + R[0] + '"');
              H.push({ expression: R[0], operator: R[1], variables: E });
            }
            return H.length || H.push(T(w)), this.parts = H, this;
          }, d.prototype.get = function(E) {
            var R, k, w, F = this.data, I = { type: 0, val: [], encode: [], encodeReserved: [] };
            if (this.cache[E] !== void 0) return this.cache[E];
            if (this.cache[E] = I, (w = String(Object.prototype.toString.call(F)) === "[object Function]" ? F(E) : String(Object.prototype.toString.call(F[E])) === "[object Function]" ? F[E](E) : F[E]) == null) return I;
            if (String(Object.prototype.toString.call(w)) === "[object Array]") {
              for (R = 0, k = w.length; R < k; R++) w[R] !== void 0 && w[R] !== null && I.val.push([void 0, String(w[R])]);
              I.val.length && (I.type = 3);
            } else if (String(Object.prototype.toString.call(w)) === "[object Object]") {
              for (R in w) a.call(w, R) && w[R] !== void 0 && w[R] !== null && I.val.push([R, String(w[R])]);
              I.val.length && (I.type = 2);
            } else I.type = 1, I.val.push([void 0, String(w)]);
            return I;
          }, r.expand = function(E, R) {
            var k = new l(E).expand(R);
            return new r(k);
          }, l;
        });
      }, 9152: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.hash = function(h) {
          var f = new c.sha256();
          return f.update(h, "utf8"), f.digest();
        };
        var c = u(2802);
      }, 9209: (t, o, u) => {
        var c = u(6578), h = typeof globalThis > "u" ? u.g : globalThis;
        t.exports = function() {
          for (var f = [], r = 0; r < c.length; r++) typeof h[c[r]] == "function" && (f[f.length] = c[r]);
          return f;
        };
      }, 9260: (t, o, u) => {
        var c = u(8287).Buffer;
        function h(w) {
          return h = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(F) {
            return typeof F;
          } : function(F) {
            return F && typeof Symbol == "function" && F.constructor === Symbol && F !== Symbol.prototype ? "symbol" : typeof F;
          }, h(w);
        }
        Object.defineProperty(o, "__esModule", { value: true }), o.FeeBumpTransaction = void 0;
        var f, r = (f = u(1918)) && f.__esModule ? f : { default: f }, m = u(9152), g = u(380), a = u(3758), l = u(6160);
        function d(w, F) {
          for (var I = 0; I < F.length; I++) {
            var q = F[I];
            q.enumerable = q.enumerable || false, q.configurable = true, "value" in q && (q.writable = true), Object.defineProperty(w, b(q.key), q);
          }
        }
        function b(w) {
          var F = function(I, q) {
            if (h(I) != "object" || !I) return I;
            var D = I[Symbol.toPrimitive];
            if (D !== void 0) {
              var H = D.call(I, q);
              if (h(H) != "object") return H;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(I);
          }(w, "string");
          return h(F) == "symbol" ? F : F + "";
        }
        function S(w, F, I) {
          return F = R(F), function(q, D) {
            if (D && (h(D) == "object" || typeof D == "function")) return D;
            if (D !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
            return function(H) {
              if (H === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return H;
            }(q);
          }(w, E() ? Reflect.construct(F, I || [], R(w).constructor) : F.apply(w, I));
        }
        function E() {
          try {
            var w = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            }));
          } catch {
          }
          return (E = function() {
            return !!w;
          })();
        }
        function R(w) {
          return R = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(F) {
            return F.__proto__ || Object.getPrototypeOf(F);
          }, R(w);
        }
        function k(w, F) {
          return k = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(I, q) {
            return I.__proto__ = q, I;
          }, k(w, F);
        }
        o.FeeBumpTransaction = function(w) {
          function F(I, q) {
            var D;
            if (function(Y, te) {
              if (!(Y instanceof te)) throw new TypeError("Cannot call a class as a function");
            }(this, F), typeof I == "string") {
              var H = c.from(I, "base64");
              I = r.default.TransactionEnvelope.fromXDR(H);
            }
            var _ = I.switch();
            if (_ !== r.default.EnvelopeType.envelopeTypeTxFeeBump()) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(_.name, "."));
            var T = I.value(), L = T.tx(), j = L.fee().toString();
            D = S(this, F, [L, (T.signatures() || []).slice(), j, q]);
            var z = r.default.TransactionEnvelope.envelopeTypeTx(L.innerTx().v1());
            return D._feeSource = (0, l.encodeMuxedAccountToAddress)(D.tx.feeSource()), D._innerTransaction = new g.Transaction(z, q), D;
          }
          return function(I, q) {
            if (typeof q != "function" && q !== null) throw new TypeError("Super expression must either be null or a function");
            I.prototype = Object.create(q && q.prototype, { constructor: { value: I, writable: true, configurable: true } }), Object.defineProperty(I, "prototype", { writable: false }), q && k(I, q);
          }(F, w), function(I, q, D) {
            return q && d(I.prototype, q), Object.defineProperty(I, "prototype", { writable: false }), I;
          }(F, [{ key: "innerTransaction", get: function() {
            return this._innerTransaction;
          } }, { key: "operations", get: function() {
            return this._innerTransaction.operations;
          } }, { key: "feeSource", get: function() {
            return this._feeSource;
          } }, { key: "signatureBase", value: function() {
            var I = new r.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
            return new r.default.TransactionSignaturePayload({ networkId: r.default.Hash.fromXDR((0, m.hash)(this.networkPassphrase)), taggedTransaction: I }).toXDR();
          } }, { key: "toEnvelope", value: function() {
            var I = new r.default.FeeBumpTransactionEnvelope({ tx: r.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()), signatures: this.signatures.slice() });
            return new r.default.TransactionEnvelope.envelopeTypeTxFeeBump(I);
          } }]);
        }(a.TransactionBase);
      }, 9290: (t) => {
        t.exports = RangeError;
      }, 9340: function(t, o, u) {
        var c;
        t = u.nmd(t), function() {
          o && o.nodeType, t && t.nodeType;
          var h = typeof u.g == "object" && u.g;
          h.global !== h && h.window !== h && h.self;
          var f, r = 2147483647, m = 36, g = /^xn--/, a = /[^\x20-\x7E]/, l = /[\x2E\u3002\uFF0E\uFF61]/g, d = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, b = Math.floor, S = String.fromCharCode;
          function E(_) {
            throw new RangeError(d[_]);
          }
          function R(_, T) {
            for (var L = _.length, j = []; L--; ) j[L] = T(_[L]);
            return j;
          }
          function k(_, T) {
            var L = _.split("@"), j = "";
            return L.length > 1 && (j = L[0] + "@", _ = L[1]), j + R((_ = _.replace(l, ".")).split("."), T).join(".");
          }
          function w(_) {
            for (var T, L, j = [], z = 0, Y = _.length; z < Y; ) (T = _.charCodeAt(z++)) >= 55296 && T <= 56319 && z < Y ? (64512 & (L = _.charCodeAt(z++))) == 56320 ? j.push(((1023 & T) << 10) + (1023 & L) + 65536) : (j.push(T), z--) : j.push(T);
            return j;
          }
          function F(_) {
            return R(_, function(T) {
              var L = "";
              return T > 65535 && (L += S((T -= 65536) >>> 10 & 1023 | 55296), T = 56320 | 1023 & T), L += S(T);
            }).join("");
          }
          function I(_, T) {
            return _ + 22 + 75 * (_ < 26) - ((T != 0) << 5);
          }
          function q(_, T, L) {
            var j = 0;
            for (_ = L ? b(_ / 700) : _ >> 1, _ += b(_ / T); _ > 455; j += m) _ = b(_ / 35);
            return b(j + 36 * _ / (_ + 38));
          }
          function D(_) {
            var T, L, j, z, Y, te, G, K, J, B, Z, ie = [], $ = _.length, oe = 0, ce = 128, ye = 72;
            for ((L = _.lastIndexOf("-")) < 0 && (L = 0), j = 0; j < L; ++j) _.charCodeAt(j) >= 128 && E("not-basic"), ie.push(_.charCodeAt(j));
            for (z = L > 0 ? L + 1 : 0; z < $; ) {
              for (Y = oe, te = 1, G = m; z >= $ && E("invalid-input"), ((K = (Z = _.charCodeAt(z++)) - 48 < 10 ? Z - 22 : Z - 65 < 26 ? Z - 65 : Z - 97 < 26 ? Z - 97 : m) >= m || K > b((r - oe) / te)) && E("overflow"), oe += K * te, !(K < (J = G <= ye ? 1 : G >= ye + 26 ? 26 : G - ye)); G += m) te > b(r / (B = m - J)) && E("overflow"), te *= B;
              ye = q(oe - Y, T = ie.length + 1, Y == 0), b(oe / T) > r - ce && E("overflow"), ce += b(oe / T), oe %= T, ie.splice(oe++, 0, ce);
            }
            return F(ie);
          }
          function H(_) {
            var T, L, j, z, Y, te, G, K, J, B, Z, ie, $, oe, ce, ye = [];
            for (ie = (_ = w(_)).length, T = 128, L = 0, Y = 72, te = 0; te < ie; ++te) (Z = _[te]) < 128 && ye.push(S(Z));
            for (j = z = ye.length, z && ye.push("-"); j < ie; ) {
              for (G = r, te = 0; te < ie; ++te) (Z = _[te]) >= T && Z < G && (G = Z);
              for (G - T > b((r - L) / ($ = j + 1)) && E("overflow"), L += (G - T) * $, T = G, te = 0; te < ie; ++te) if ((Z = _[te]) < T && ++L > r && E("overflow"), Z == T) {
                for (K = L, J = m; !(K < (B = J <= Y ? 1 : J >= Y + 26 ? 26 : J - Y)); J += m) ce = K - B, oe = m - B, ye.push(S(I(B + ce % oe, 0))), K = b(ce / oe);
                ye.push(S(I(K, 0))), Y = q(L, $, j == z), L = 0, ++j;
              }
              ++L, ++T;
            }
            return ye.join("");
          }
          f = { version: "1.3.2", ucs2: { decode: w, encode: F }, decode: D, encode: H, toASCII: function(_) {
            return k(_, function(T) {
              return a.test(T) ? "xn--" + H(T) : T;
            });
          }, toUnicode: function(_) {
            return k(_, function(T) {
              return g.test(T) ? D(T.slice(4).toLowerCase()) : T;
            });
          } }, (c = (function() {
            return f;
          }).call(o, u, o, t)) === void 0 || (t.exports = c);
        }();
      }, 9353: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.LiquidityPoolId = void 0;
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
        function f(g) {
          return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
            return typeof a;
          } : function(a) {
            return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
          }, f(g);
        }
        function r(g, a) {
          for (var l = 0; l < a.length; l++) {
            var d = a[l];
            d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(g, m(d.key), d);
          }
        }
        function m(g) {
          var a = function(l, d) {
            if (f(l) != "object" || !l) return l;
            var b = l[Symbol.toPrimitive];
            if (b !== void 0) {
              var S = b.call(l, d);
              if (f(S) != "object") return S;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(l);
          }(g, "string");
          return f(a) == "symbol" ? a : a + "";
        }
        o.LiquidityPoolId = function() {
          return function(g, a, l) {
            return a && r(g.prototype, a), l && r(g, l), Object.defineProperty(g, "prototype", { writable: false }), g;
          }(function g(a) {
            if (function(l, d) {
              if (!(l instanceof d)) throw new TypeError("Cannot call a class as a function");
            }(this, g), !a) throw new Error("liquidityPoolId cannot be empty");
            if (!/^[a-f0-9]{64}$/.test(a)) throw new Error("Liquidity pool ID is not a valid hash");
            this.liquidityPoolId = a;
          }, [{ key: "toXDRObject", value: function() {
            var g = h.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new h.default.TrustLineAsset("assetTypePoolShare", g);
          } }, { key: "getLiquidityPoolId", value: function() {
            return String(this.liquidityPoolId);
          } }, { key: "getAssetType", value: function() {
            return "liquidity_pool_shares";
          } }, { key: "equals", value: function(g) {
            return this.liquidityPoolId === g.getLiquidityPoolId();
          } }, { key: "toString", value: function() {
            return "liquidity_pool:".concat(this.liquidityPoolId);
          } }], [{ key: "fromOperation", value: function(g) {
            var a = g.switch();
            if (a === h.default.AssetType.assetTypePoolShare()) return new this(g.liquidityPoolId().toString("hex"));
            throw new Error("Invalid asset type: ".concat(a.name));
          } }]);
        }();
      }, 9383: (t) => {
        t.exports = Error;
      }, 9538: (t) => {
        t.exports = ReferenceError;
      }, 9600: (t) => {
        var o, u, c = Function.prototype.toString, h = typeof Reflect == "object" && Reflect !== null && Reflect.apply;
        if (typeof h == "function" && typeof Object.defineProperty == "function") try {
          o = Object.defineProperty({}, "length", { get: function() {
            throw u;
          } }), u = {}, h(function() {
            throw 42;
          }, null, o);
        } catch (S) {
          S !== u && (h = null);
        }
        else h = null;
        var f = /^\s*class\b/, r = function(S) {
          try {
            var E = c.call(S);
            return f.test(E);
          } catch {
            return false;
          }
        }, m = function(S) {
          try {
            return !r(S) && (c.call(S), true);
          } catch {
            return false;
          }
        }, g = Object.prototype.toString, a = typeof Symbol == "function" && !!Symbol.toStringTag, l = !(0 in [,]), d = function() {
          return false;
        };
        if (typeof document == "object") {
          var b = document.all;
          g.call(b) === g.call(document.all) && (d = function(S) {
            if ((l || !S) && (S === void 0 || typeof S == "object")) try {
              var E = g.call(S);
              return (E === "[object HTMLAllCollection]" || E === "[object HTML document.all class]" || E === "[object HTMLCollection]" || E === "[object Object]") && S("") == null;
            } catch {
            }
            return false;
          });
        }
        t.exports = h ? function(S) {
          if (d(S)) return true;
          if (!S || typeof S != "function" && typeof S != "object") return false;
          try {
            h(S, null, o);
          } catch (E) {
            if (E !== u) return false;
          }
          return !r(S) && m(S);
        } : function(S) {
          if (d(S)) return true;
          if (!S || typeof S != "function" && typeof S != "object") return false;
          if (a) return m(S);
          if (r(S)) return false;
          var E = g.call(S);
          return !(E !== "[object Function]" && E !== "[object GeneratorFunction]" && !/^\[object HTML/.test(E)) && m(S);
        };
      }, 9612: (t) => {
        t.exports = Object;
      }, 9675: (t) => {
        t.exports = TypeError;
      }, 9721: (t, o, u) => {
        var c = u(6556), h = u(4035), f = c("RegExp.prototype.exec"), r = u(9675);
        t.exports = function(m) {
          if (!h(m)) throw new r("`regex` must be a RegExp");
          return function(g) {
            return f(m, g) !== null;
          };
        };
      }, 9838: () => {
      }, 9845: (t, o, u) => {
        Object.defineProperty(o, "__esModule", { value: true }), o.liquidityPoolDeposit = function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = f.liquidityPoolId, m = f.maxAmountA, g = f.maxAmountB, a = f.minPrice, l = f.maxPrice, d = {};
          if (!r) throw new TypeError("liquidityPoolId argument is required");
          if (d.liquidityPoolId = h.default.PoolId.fromXDR(r, "hex"), !this.isValidAmount(m, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
          if (d.maxAmountA = this._toXDRAmount(m), !this.isValidAmount(g, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
          if (d.maxAmountB = this._toXDRAmount(g), a === void 0) throw new TypeError("minPrice argument is required");
          if (d.minPrice = this._toXDRPrice(a), l === void 0) throw new TypeError("maxPrice argument is required");
          d.maxPrice = this._toXDRPrice(l);
          var b = new h.default.LiquidityPoolDepositOp(d), S = { body: h.default.OperationBody.liquidityPoolDeposit(b) };
          return this.setSourceAccount(S, f), new h.default.Operation(S);
        };
        var c, h = (c = u(1918)) && c.__esModule ? c : { default: c };
      }, 9957: (t, o, u) => {
        var c = Function.prototype.call, h = Object.prototype.hasOwnProperty, f = u(6743);
        t.exports = f.call(c, h);
      }, 9983: (t, o, u) => {
        function c(b) {
          return c = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(S) {
            return typeof S;
          } : function(S) {
            return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
          }, c(b);
        }
        function h(b, S) {
          for (var E = 0; E < S.length; E++) {
            var R = S[E];
            R.enumerable = R.enumerable || false, R.configurable = true, "value" in R && (R.writable = true), Object.defineProperty(b, f(R.key), R);
          }
        }
        function f(b) {
          var S = function(E, R) {
            if (c(E) != "object" || !E) return E;
            var k = E[Symbol.toPrimitive];
            if (k !== void 0) {
              var w = k.call(E, R);
              if (c(w) != "object") return w;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(E);
          }(b, "string");
          return c(S) == "symbol" ? S : S + "";
        }
        u.d(o, { vt: () => l, ok: () => a }), r = function b(S) {
          var E, R = this;
          (function(k, w) {
            if (!(k instanceof w)) throw new TypeError("Cannot call a class as a function");
          })(this, b), this.promise = new Promise(function(k) {
            E = k;
          }), S(function(k) {
            R.reason = k, E();
          });
        }, (m = [{ key: "throwIfRequested", value: function() {
          if (this.reason) throw new Error(this.reason);
        } }]) && h(r.prototype, m), g && h(r, g), Object.defineProperty(r, "prototype", { writable: false });
        var r, m, g, a, l, d = u(6121);
        a = d.axiosClient, l = d.create;
      } }, s = {};
      function y(t) {
        var o = s[t];
        if (o !== void 0) return o.exports;
        var u = s[t] = { id: t, loaded: false, exports: {} };
        return i[t].call(u.exports, u, u.exports, y), u.loaded = true, u.exports;
      }
      return y.n = (t) => {
        var o = t && t.__esModule ? () => t.default : () => t;
        return y.d(o, { a: o }), o;
      }, y.d = (t, o) => {
        for (var u in o) y.o(o, u) && !y.o(t, u) && Object.defineProperty(t, u, { enumerable: true, get: o[u] });
      }, y.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), y.hmd = (t) => ((t = Object.create(t)).children || (t.children = []), Object.defineProperty(t, "exports", { enumerable: true, set: () => {
        throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: " + t.id);
      } }), t), y.o = (t, o) => Object.prototype.hasOwnProperty.call(t, o), y.r = (t) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
      }, y.nmd = (t) => (t.paths = [], t.children || (t.children = []), t), y(1924);
    })());
  }(Ic)), Ic.exports;
}
var Yn = fy(), nc = { exports: {} };
/*!
* jQuery JavaScript Library v3.7.1
* https://jquery.com/
*
* Copyright OpenJS Foundation and other contributors
* Released under the MIT license
* https://jquery.org/license
*
* Date: 2023-08-28T13:37Z
*/
var py = nc.exports, kf;
function hy() {
  return kf || (kf = 1, function(v) {
    (function(e, n) {
      v.exports = e.document ? n(e, true) : function(i) {
        if (!i.document) throw new Error("jQuery requires a window with a document");
        return n(i);
      };
    })(typeof window < "u" ? window : py, function(e, n) {
      var i = [], s = Object.getPrototypeOf, y = i.slice, t = i.flat ? function(M) {
        return i.flat.call(M);
      } : function(M) {
        return i.concat.apply([], M);
      }, o = i.push, u = i.indexOf, c = {}, h = c.toString, f = c.hasOwnProperty, r = f.toString, m = r.call(Object), g = {}, a = function(W) {
        return typeof W == "function" && typeof W.nodeType != "number" && typeof W.item != "function";
      }, l = function(W) {
        return W != null && W === W.window;
      }, d = e.document, b = { type: true, src: true, nonce: true, noModule: true };
      function S(M, W, fe) {
        fe = fe || d;
        var Se, Ce, Re = fe.createElement("script");
        if (Re.text = M, W) for (Se in b) Ce = W[Se] || W.getAttribute && W.getAttribute(Se), Ce && Re.setAttribute(Se, Ce);
        fe.head.appendChild(Re).parentNode.removeChild(Re);
      }
      function E(M) {
        return M == null ? M + "" : typeof M == "object" || typeof M == "function" ? c[h.call(M)] || "object" : typeof M;
      }
      var R = "3.7.1", k = /HTML$/i, w = function(M, W) {
        return new w.fn.init(M, W);
      };
      w.fn = w.prototype = { jquery: R, constructor: w, length: 0, toArray: function() {
        return y.call(this);
      }, get: function(M) {
        return M == null ? y.call(this) : M < 0 ? this[M + this.length] : this[M];
      }, pushStack: function(M) {
        var W = w.merge(this.constructor(), M);
        return W.prevObject = this, W;
      }, each: function(M) {
        return w.each(this, M);
      }, map: function(M) {
        return this.pushStack(w.map(this, function(W, fe) {
          return M.call(W, fe, W);
        }));
      }, slice: function() {
        return this.pushStack(y.apply(this, arguments));
      }, first: function() {
        return this.eq(0);
      }, last: function() {
        return this.eq(-1);
      }, even: function() {
        return this.pushStack(w.grep(this, function(M, W) {
          return (W + 1) % 2;
        }));
      }, odd: function() {
        return this.pushStack(w.grep(this, function(M, W) {
          return W % 2;
        }));
      }, eq: function(M) {
        var W = this.length, fe = +M + (M < 0 ? W : 0);
        return this.pushStack(fe >= 0 && fe < W ? [this[fe]] : []);
      }, end: function() {
        return this.prevObject || this.constructor();
      }, push: o, sort: i.sort, splice: i.splice }, w.extend = w.fn.extend = function() {
        var M, W, fe, Se, Ce, Re, Je = arguments[0] || {}, Ut = 1, _t = arguments.length, Ht = false;
        for (typeof Je == "boolean" && (Ht = Je, Je = arguments[Ut] || {}, Ut++), typeof Je != "object" && !a(Je) && (Je = {}), Ut === _t && (Je = this, Ut--); Ut < _t; Ut++) if ((M = arguments[Ut]) != null) for (W in M) Se = M[W], !(W === "__proto__" || Je === Se) && (Ht && Se && (w.isPlainObject(Se) || (Ce = Array.isArray(Se))) ? (fe = Je[W], Ce && !Array.isArray(fe) ? Re = [] : !Ce && !w.isPlainObject(fe) ? Re = {} : Re = fe, Ce = false, Je[W] = w.extend(Ht, Re, Se)) : Se !== void 0 && (Je[W] = Se));
        return Je;
      }, w.extend({ expando: "jQuery" + (R + Math.random()).replace(/\D/g, ""), isReady: true, error: function(M) {
        throw new Error(M);
      }, noop: function() {
      }, isPlainObject: function(M) {
        var W, fe;
        return !M || h.call(M) !== "[object Object]" ? false : (W = s(M), W ? (fe = f.call(W, "constructor") && W.constructor, typeof fe == "function" && r.call(fe) === m) : true);
      }, isEmptyObject: function(M) {
        var W;
        for (W in M) return false;
        return true;
      }, globalEval: function(M, W, fe) {
        S(M, { nonce: W && W.nonce }, fe);
      }, each: function(M, W) {
        var fe, Se = 0;
        if (F(M)) for (fe = M.length; Se < fe && W.call(M[Se], Se, M[Se]) !== false; Se++) ;
        else for (Se in M) if (W.call(M[Se], Se, M[Se]) === false) break;
        return M;
      }, text: function(M) {
        var W, fe = "", Se = 0, Ce = M.nodeType;
        if (!Ce) for (; W = M[Se++]; ) fe += w.text(W);
        return Ce === 1 || Ce === 11 ? M.textContent : Ce === 9 ? M.documentElement.textContent : Ce === 3 || Ce === 4 ? M.nodeValue : fe;
      }, makeArray: function(M, W) {
        var fe = W || [];
        return M != null && (F(Object(M)) ? w.merge(fe, typeof M == "string" ? [M] : M) : o.call(fe, M)), fe;
      }, inArray: function(M, W, fe) {
        return W == null ? -1 : u.call(W, M, fe);
      }, isXMLDoc: function(M) {
        var W = M && M.namespaceURI, fe = M && (M.ownerDocument || M).documentElement;
        return !k.test(W || fe && fe.nodeName || "HTML");
      }, merge: function(M, W) {
        for (var fe = +W.length, Se = 0, Ce = M.length; Se < fe; Se++) M[Ce++] = W[Se];
        return M.length = Ce, M;
      }, grep: function(M, W, fe) {
        for (var Se, Ce = [], Re = 0, Je = M.length, Ut = !fe; Re < Je; Re++) Se = !W(M[Re], Re), Se !== Ut && Ce.push(M[Re]);
        return Ce;
      }, map: function(M, W, fe) {
        var Se, Ce, Re = 0, Je = [];
        if (F(M)) for (Se = M.length; Re < Se; Re++) Ce = W(M[Re], Re, fe), Ce != null && Je.push(Ce);
        else for (Re in M) Ce = W(M[Re], Re, fe), Ce != null && Je.push(Ce);
        return t(Je);
      }, guid: 1, support: g }), typeof Symbol == "function" && (w.fn[Symbol.iterator] = i[Symbol.iterator]), w.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(M, W) {
        c["[object " + W + "]"] = W.toLowerCase();
      });
      function F(M) {
        var W = !!M && "length" in M && M.length, fe = E(M);
        return a(M) || l(M) ? false : fe === "array" || W === 0 || typeof W == "number" && W > 0 && W - 1 in M;
      }
      function I(M, W) {
        return M.nodeName && M.nodeName.toLowerCase() === W.toLowerCase();
      }
      var q = i.pop, D = i.sort, H = i.splice, _ = "[\\x20\\t\\r\\n\\f]", T = new RegExp("^" + _ + "+|((?:^|[^\\\\])(?:\\\\.)*)" + _ + "+$", "g");
      w.contains = function(M, W) {
        var fe = W && W.parentNode;
        return M === fe || !!(fe && fe.nodeType === 1 && (M.contains ? M.contains(fe) : M.compareDocumentPosition && M.compareDocumentPosition(fe) & 16));
      };
      var L = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function j(M, W) {
        return W ? M === "\0" ? "\uFFFD" : M.slice(0, -1) + "\\" + M.charCodeAt(M.length - 1).toString(16) + " " : "\\" + M;
      }
      w.escapeSelector = function(M) {
        return (M + "").replace(L, j);
      };
      var z = d, Y = o;
      (function() {
        var M, W, fe, Se, Ce, Re = Y, Je, Ut, _t, Ht, tr, Sr = w.expando, Ee = 0, ot = 0, Mt = Ie(), gt = Ie(), Rt = Ie(), or = Ie(), nr = function(kt, Kt) {
          return kt === Kt && (Ce = true), 0;
        }, Qr = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", Xr = "(?:\\\\[\\da-fA-F]{1,6}" + _ + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", Yr = "\\[" + _ + "*(" + Xr + ")(?:" + _ + "*([*^$|!~]?=)" + _ + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + Xr + "))|)" + _ + "*\\]", un = ":(" + Xr + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + Yr + ")*)|.*)\\)|)", Kr = new RegExp(_ + "+", "g"), Ir = new RegExp("^" + _ + "*," + _ + "*"), An = new RegExp("^" + _ + "*([>+~]|" + _ + ")" + _ + "*"), En = new RegExp(_ + "|>"), Sn = new RegExp(un), On = new RegExp("^" + Xr + "$"), gn = { ID: new RegExp("^#(" + Xr + ")"), CLASS: new RegExp("^\\.(" + Xr + ")"), TAG: new RegExp("^(" + Xr + "|[*])"), ATTR: new RegExp("^" + Yr), PSEUDO: new RegExp("^" + un), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + _ + "*(even|odd|(([+-]|)(\\d*)n|)" + _ + "*(?:([+-]|)" + _ + "*(\\d+)|))" + _ + "*\\)|)", "i"), bool: new RegExp("^(?:" + Qr + ")$", "i"), needsContext: new RegExp("^" + _ + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + _ + "*((?:-\\d)?\\d*)" + _ + "*\\)|)(?=[^-]|$)", "i") }, Bn = /^(?:input|select|textarea|button)$/i, jn = /^h\d$/i, qn = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Qn = /[+~]/, ii = new RegExp("\\\\[\\da-fA-F]{1,6}" + _ + "?|\\\\([^\\r\\n\\f])", "g"), vi = function(kt, Kt) {
          var lr = "0x" + kt.slice(1) - 65536;
          return Kt || (lr < 0 ? String.fromCharCode(lr + 65536) : String.fromCharCode(lr >> 10 | 55296, lr & 1023 | 56320));
        }, uo = function() {
          on();
        }, jo = ln(function(kt) {
          return kt.disabled === true && I(kt, "fieldset");
        }, { dir: "parentNode", next: "legend" });
        function la() {
          try {
            return Je.activeElement;
          } catch {
          }
        }
        try {
          Re.apply(i = y.call(z.childNodes), z.childNodes), i[z.childNodes.length].nodeType;
        } catch {
          Re = { apply: function(Kt, lr) {
            Y.apply(Kt, y.call(lr));
          }, call: function(Kt) {
            Y.apply(Kt, y.call(arguments, 1));
          } };
        }
        function Rn(kt, Kt, lr, Er) {
          var Rr, pr, tn, fn, rn, mn, pn, Fe = Kt && Kt.ownerDocument, He = Kt ? Kt.nodeType : 9;
          if (lr = lr || [], typeof kt != "string" || !kt || He !== 1 && He !== 9 && He !== 11) return lr;
          if (!Er && (on(Kt), Kt = Kt || Je, _t)) {
            if (He !== 11 && (rn = qn.exec(kt))) if (Rr = rn[1]) {
              if (He === 9) if (tn = Kt.getElementById(Rr)) {
                if (tn.id === Rr) return Re.call(lr, tn), lr;
              } else return lr;
              else if (Fe && (tn = Fe.getElementById(Rr)) && Rn.contains(Kt, tn) && tn.id === Rr) return Re.call(lr, tn), lr;
            } else {
              if (rn[2]) return Re.apply(lr, Kt.getElementsByTagName(kt)), lr;
              if ((Rr = rn[3]) && Kt.getElementsByClassName) return Re.apply(lr, Kt.getElementsByClassName(Rr)), lr;
            }
            if (!or[kt + " "] && (!Ht || !Ht.test(kt))) {
              if (pn = kt, Fe = Kt, He === 1 && (En.test(kt) || An.test(kt))) {
                for (Fe = Qn.test(kt) && cn(Kt.parentNode) || Kt, (Fe != Kt || !g.scope) && ((fn = Kt.getAttribute("id")) ? fn = w.escapeSelector(fn) : Kt.setAttribute("id", fn = Sr)), mn = Nn(kt), pr = mn.length; pr--; ) mn[pr] = (fn ? "#" + fn : ":scope") + " " + Vn(mn[pr]);
                pn = mn.join(",");
              }
              try {
                return Re.apply(lr, Fe.querySelectorAll(pn)), lr;
              } catch {
                or(kt, true);
              } finally {
                fn === Sr && Kt.removeAttribute("id");
              }
            }
          }
          return Xn(kt.replace(T, "$1"), Kt, lr, Er);
        }
        function Ie() {
          var kt = [];
          function Kt(lr, Er) {
            return kt.push(lr + " ") > W.cacheLength && delete Kt[kt.shift()], Kt[lr + " "] = Er;
          }
          return Kt;
        }
        function ve(kt) {
          return kt[Sr] = true, kt;
        }
        function he(kt) {
          var Kt = Je.createElement("fieldset");
          try {
            return !!kt(Kt);
          } catch {
            return false;
          } finally {
            Kt.parentNode && Kt.parentNode.removeChild(Kt), Kt = null;
          }
        }
        function ke(kt) {
          return function(Kt) {
            return I(Kt, "input") && Kt.type === kt;
          };
        }
        function ht(kt) {
          return function(Kt) {
            return (I(Kt, "input") || I(Kt, "button")) && Kt.type === kt;
          };
        }
        function pt(kt) {
          return function(Kt) {
            return "form" in Kt ? Kt.parentNode && Kt.disabled === false ? "label" in Kt ? "label" in Kt.parentNode ? Kt.parentNode.disabled === kt : Kt.disabled === kt : Kt.isDisabled === kt || Kt.isDisabled !== !kt && jo(Kt) === kt : Kt.disabled === kt : "label" in Kt ? Kt.disabled === kt : false;
          };
        }
        function Pr(kt) {
          return ve(function(Kt) {
            return Kt = +Kt, ve(function(lr, Er) {
              for (var Rr, pr = kt([], lr.length, Kt), tn = pr.length; tn--; ) lr[Rr = pr[tn]] && (lr[Rr] = !(Er[Rr] = lr[Rr]));
            });
          });
        }
        function cn(kt) {
          return kt && typeof kt.getElementsByTagName < "u" && kt;
        }
        function on(kt) {
          var Kt, lr = kt ? kt.ownerDocument || kt : z;
          return lr == Je || lr.nodeType !== 9 || !lr.documentElement || (Je = lr, Ut = Je.documentElement, _t = !w.isXMLDoc(Je), tr = Ut.matches || Ut.webkitMatchesSelector || Ut.msMatchesSelector, Ut.msMatchesSelector && z != Je && (Kt = Je.defaultView) && Kt.top !== Kt && Kt.addEventListener("unload", uo), g.getById = he(function(Er) {
            return Ut.appendChild(Er).id = w.expando, !Je.getElementsByName || !Je.getElementsByName(w.expando).length;
          }), g.disconnectedMatch = he(function(Er) {
            return tr.call(Er, "*");
          }), g.scope = he(function() {
            return Je.querySelectorAll(":scope");
          }), g.cssHas = he(function() {
            try {
              return Je.querySelector(":has(*,:jqfake)"), false;
            } catch {
              return true;
            }
          }), g.getById ? (W.filter.ID = function(Er) {
            var Rr = Er.replace(ii, vi);
            return function(pr) {
              return pr.getAttribute("id") === Rr;
            };
          }, W.find.ID = function(Er, Rr) {
            if (typeof Rr.getElementById < "u" && _t) {
              var pr = Rr.getElementById(Er);
              return pr ? [pr] : [];
            }
          }) : (W.filter.ID = function(Er) {
            var Rr = Er.replace(ii, vi);
            return function(pr) {
              var tn = typeof pr.getAttributeNode < "u" && pr.getAttributeNode("id");
              return tn && tn.value === Rr;
            };
          }, W.find.ID = function(Er, Rr) {
            if (typeof Rr.getElementById < "u" && _t) {
              var pr, tn, fn, rn = Rr.getElementById(Er);
              if (rn) {
                if (pr = rn.getAttributeNode("id"), pr && pr.value === Er) return [rn];
                for (fn = Rr.getElementsByName(Er), tn = 0; rn = fn[tn++]; ) if (pr = rn.getAttributeNode("id"), pr && pr.value === Er) return [rn];
              }
              return [];
            }
          }), W.find.TAG = function(Er, Rr) {
            return typeof Rr.getElementsByTagName < "u" ? Rr.getElementsByTagName(Er) : Rr.querySelectorAll(Er);
          }, W.find.CLASS = function(Er, Rr) {
            if (typeof Rr.getElementsByClassName < "u" && _t) return Rr.getElementsByClassName(Er);
          }, Ht = [], he(function(Er) {
            var Rr;
            Ut.appendChild(Er).innerHTML = "<a id='" + Sr + "' href='' disabled='disabled'></a><select id='" + Sr + "-\r\\' disabled='disabled'><option selected=''></option></select>", Er.querySelectorAll("[selected]").length || Ht.push("\\[" + _ + "*(?:value|" + Qr + ")"), Er.querySelectorAll("[id~=" + Sr + "-]").length || Ht.push("~="), Er.querySelectorAll("a#" + Sr + "+*").length || Ht.push(".#.+[+~]"), Er.querySelectorAll(":checked").length || Ht.push(":checked"), Rr = Je.createElement("input"), Rr.setAttribute("type", "hidden"), Er.appendChild(Rr).setAttribute("name", "D"), Ut.appendChild(Er).disabled = true, Er.querySelectorAll(":disabled").length !== 2 && Ht.push(":enabled", ":disabled"), Rr = Je.createElement("input"), Rr.setAttribute("name", ""), Er.appendChild(Rr), Er.querySelectorAll("[name='']").length || Ht.push("\\[" + _ + "*name" + _ + "*=" + _ + `*(?:''|"")`);
          }), g.cssHas || Ht.push(":has"), Ht = Ht.length && new RegExp(Ht.join("|")), nr = function(Er, Rr) {
            if (Er === Rr) return Ce = true, 0;
            var pr = !Er.compareDocumentPosition - !Rr.compareDocumentPosition;
            return pr || (pr = (Er.ownerDocument || Er) == (Rr.ownerDocument || Rr) ? Er.compareDocumentPosition(Rr) : 1, pr & 1 || !g.sortDetached && Rr.compareDocumentPosition(Er) === pr ? Er === Je || Er.ownerDocument == z && Rn.contains(z, Er) ? -1 : Rr === Je || Rr.ownerDocument == z && Rn.contains(z, Rr) ? 1 : Se ? u.call(Se, Er) - u.call(Se, Rr) : 0 : pr & 4 ? -1 : 1);
          }), Je;
        }
        Rn.matches = function(kt, Kt) {
          return Rn(kt, null, null, Kt);
        }, Rn.matchesSelector = function(kt, Kt) {
          if (on(kt), _t && !or[Kt + " "] && (!Ht || !Ht.test(Kt))) try {
            var lr = tr.call(kt, Kt);
            if (lr || g.disconnectedMatch || kt.document && kt.document.nodeType !== 11) return lr;
          } catch {
            or(Kt, true);
          }
          return Rn(Kt, Je, null, [kt]).length > 0;
        }, Rn.contains = function(kt, Kt) {
          return (kt.ownerDocument || kt) != Je && on(kt), w.contains(kt, Kt);
        }, Rn.attr = function(kt, Kt) {
          (kt.ownerDocument || kt) != Je && on(kt);
          var lr = W.attrHandle[Kt.toLowerCase()], Er = lr && f.call(W.attrHandle, Kt.toLowerCase()) ? lr(kt, Kt, !_t) : void 0;
          return Er !== void 0 ? Er : kt.getAttribute(Kt);
        }, Rn.error = function(kt) {
          throw new Error("Syntax error, unrecognized expression: " + kt);
        }, w.uniqueSort = function(kt) {
          var Kt, lr = [], Er = 0, Rr = 0;
          if (Ce = !g.sortStable, Se = !g.sortStable && y.call(kt, 0), D.call(kt, nr), Ce) {
            for (; Kt = kt[Rr++]; ) Kt === kt[Rr] && (Er = lr.push(Rr));
            for (; Er--; ) H.call(kt, lr[Er], 1);
          }
          return Se = null, kt;
        }, w.fn.uniqueSort = function() {
          return this.pushStack(w.uniqueSort(y.apply(this)));
        }, W = w.expr = { cacheLength: 50, createPseudo: ve, match: gn, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: true }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: true }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function(kt) {
          return kt[1] = kt[1].replace(ii, vi), kt[3] = (kt[3] || kt[4] || kt[5] || "").replace(ii, vi), kt[2] === "~=" && (kt[3] = " " + kt[3] + " "), kt.slice(0, 4);
        }, CHILD: function(kt) {
          return kt[1] = kt[1].toLowerCase(), kt[1].slice(0, 3) === "nth" ? (kt[3] || Rn.error(kt[0]), kt[4] = +(kt[4] ? kt[5] + (kt[6] || 1) : 2 * (kt[3] === "even" || kt[3] === "odd")), kt[5] = +(kt[7] + kt[8] || kt[3] === "odd")) : kt[3] && Rn.error(kt[0]), kt;
        }, PSEUDO: function(kt) {
          var Kt, lr = !kt[6] && kt[2];
          return gn.CHILD.test(kt[0]) ? null : (kt[3] ? kt[2] = kt[4] || kt[5] || "" : lr && Sn.test(lr) && (Kt = Nn(lr, true)) && (Kt = lr.indexOf(")", lr.length - Kt) - lr.length) && (kt[0] = kt[0].slice(0, Kt), kt[2] = lr.slice(0, Kt)), kt.slice(0, 3));
        } }, filter: { TAG: function(kt) {
          var Kt = kt.replace(ii, vi).toLowerCase();
          return kt === "*" ? function() {
            return true;
          } : function(lr) {
            return I(lr, Kt);
          };
        }, CLASS: function(kt) {
          var Kt = Mt[kt + " "];
          return Kt || (Kt = new RegExp("(^|" + _ + ")" + kt + "(" + _ + "|$)")) && Mt(kt, function(lr) {
            return Kt.test(typeof lr.className == "string" && lr.className || typeof lr.getAttribute < "u" && lr.getAttribute("class") || "");
          });
        }, ATTR: function(kt, Kt, lr) {
          return function(Er) {
            var Rr = Rn.attr(Er, kt);
            return Rr == null ? Kt === "!=" : Kt ? (Rr += "", Kt === "=" ? Rr === lr : Kt === "!=" ? Rr !== lr : Kt === "^=" ? lr && Rr.indexOf(lr) === 0 : Kt === "*=" ? lr && Rr.indexOf(lr) > -1 : Kt === "$=" ? lr && Rr.slice(-lr.length) === lr : Kt === "~=" ? (" " + Rr.replace(Kr, " ") + " ").indexOf(lr) > -1 : Kt === "|=" ? Rr === lr || Rr.slice(0, lr.length + 1) === lr + "-" : false) : true;
          };
        }, CHILD: function(kt, Kt, lr, Er, Rr) {
          var pr = kt.slice(0, 3) !== "nth", tn = kt.slice(-4) !== "last", fn = Kt === "of-type";
          return Er === 1 && Rr === 0 ? function(rn) {
            return !!rn.parentNode;
          } : function(rn, mn, pn) {
            var Fe, He, et, jt, At, qt = pr !== tn ? "nextSibling" : "previousSibling", Jt = rn.parentNode, er = fn && rn.nodeName.toLowerCase(), mr = !pn && !fn, Ar = false;
            if (Jt) {
              if (pr) {
                for (; qt; ) {
                  for (et = rn; et = et[qt]; ) if (fn ? I(et, er) : et.nodeType === 1) return false;
                  At = qt = kt === "only" && !At && "nextSibling";
                }
                return true;
              }
              if (At = [tn ? Jt.firstChild : Jt.lastChild], tn && mr) {
                for (He = Jt[Sr] || (Jt[Sr] = {}), Fe = He[kt] || [], jt = Fe[0] === Ee && Fe[1], Ar = jt && Fe[2], et = jt && Jt.childNodes[jt]; et = ++jt && et && et[qt] || (Ar = jt = 0) || At.pop(); ) if (et.nodeType === 1 && ++Ar && et === rn) {
                  He[kt] = [Ee, jt, Ar];
                  break;
                }
              } else if (mr && (He = rn[Sr] || (rn[Sr] = {}), Fe = He[kt] || [], jt = Fe[0] === Ee && Fe[1], Ar = jt), Ar === false) for (; (et = ++jt && et && et[qt] || (Ar = jt = 0) || At.pop()) && !((fn ? I(et, er) : et.nodeType === 1) && ++Ar && (mr && (He = et[Sr] || (et[Sr] = {}), He[kt] = [Ee, Ar]), et === rn)); ) ;
              return Ar -= Rr, Ar === Er || Ar % Er === 0 && Ar / Er >= 0;
            }
          };
        }, PSEUDO: function(kt, Kt) {
          var lr, Er = W.pseudos[kt] || W.setFilters[kt.toLowerCase()] || Rn.error("unsupported pseudo: " + kt);
          return Er[Sr] ? Er(Kt) : Er.length > 1 ? (lr = [kt, kt, "", Kt], W.setFilters.hasOwnProperty(kt.toLowerCase()) ? ve(function(Rr, pr) {
            for (var tn, fn = Er(Rr, Kt), rn = fn.length; rn--; ) tn = u.call(Rr, fn[rn]), Rr[tn] = !(pr[tn] = fn[rn]);
          }) : function(Rr) {
            return Er(Rr, 0, lr);
          }) : Er;
        } }, pseudos: { not: ve(function(kt) {
          var Kt = [], lr = [], Er = Pn(kt.replace(T, "$1"));
          return Er[Sr] ? ve(function(Rr, pr, tn, fn) {
            for (var rn, mn = Er(Rr, null, fn, []), pn = Rr.length; pn--; ) (rn = mn[pn]) && (Rr[pn] = !(pr[pn] = rn));
          }) : function(Rr, pr, tn) {
            return Kt[0] = Rr, Er(Kt, null, tn, lr), Kt[0] = null, !lr.pop();
          };
        }), has: ve(function(kt) {
          return function(Kt) {
            return Rn(kt, Kt).length > 0;
          };
        }), contains: ve(function(kt) {
          return kt = kt.replace(ii, vi), function(Kt) {
            return (Kt.textContent || w.text(Kt)).indexOf(kt) > -1;
          };
        }), lang: ve(function(kt) {
          return On.test(kt || "") || Rn.error("unsupported lang: " + kt), kt = kt.replace(ii, vi).toLowerCase(), function(Kt) {
            var lr;
            do
              if (lr = _t ? Kt.lang : Kt.getAttribute("xml:lang") || Kt.getAttribute("lang")) return lr = lr.toLowerCase(), lr === kt || lr.indexOf(kt + "-") === 0;
            while ((Kt = Kt.parentNode) && Kt.nodeType === 1);
            return false;
          };
        }), target: function(kt) {
          var Kt = e.location && e.location.hash;
          return Kt && Kt.slice(1) === kt.id;
        }, root: function(kt) {
          return kt === Ut;
        }, focus: function(kt) {
          return kt === la() && Je.hasFocus() && !!(kt.type || kt.href || ~kt.tabIndex);
        }, enabled: pt(false), disabled: pt(true), checked: function(kt) {
          return I(kt, "input") && !!kt.checked || I(kt, "option") && !!kt.selected;
        }, selected: function(kt) {
          return kt.parentNode && kt.parentNode.selectedIndex, kt.selected === true;
        }, empty: function(kt) {
          for (kt = kt.firstChild; kt; kt = kt.nextSibling) if (kt.nodeType < 6) return false;
          return true;
        }, parent: function(kt) {
          return !W.pseudos.empty(kt);
        }, header: function(kt) {
          return jn.test(kt.nodeName);
        }, input: function(kt) {
          return Bn.test(kt.nodeName);
        }, button: function(kt) {
          return I(kt, "input") && kt.type === "button" || I(kt, "button");
        }, text: function(kt) {
          var Kt;
          return I(kt, "input") && kt.type === "text" && ((Kt = kt.getAttribute("type")) == null || Kt.toLowerCase() === "text");
        }, first: Pr(function() {
          return [0];
        }), last: Pr(function(kt, Kt) {
          return [Kt - 1];
        }), eq: Pr(function(kt, Kt, lr) {
          return [lr < 0 ? lr + Kt : lr];
        }), even: Pr(function(kt, Kt) {
          for (var lr = 0; lr < Kt; lr += 2) kt.push(lr);
          return kt;
        }), odd: Pr(function(kt, Kt) {
          for (var lr = 1; lr < Kt; lr += 2) kt.push(lr);
          return kt;
        }), lt: Pr(function(kt, Kt, lr) {
          var Er;
          for (lr < 0 ? Er = lr + Kt : lr > Kt ? Er = Kt : Er = lr; --Er >= 0; ) kt.push(Er);
          return kt;
        }), gt: Pr(function(kt, Kt, lr) {
          for (var Er = lr < 0 ? lr + Kt : lr; ++Er < Kt; ) kt.push(Er);
          return kt;
        }) } }, W.pseudos.nth = W.pseudos.eq;
        for (M in { radio: true, checkbox: true, file: true, password: true, image: true }) W.pseudos[M] = ke(M);
        for (M in { submit: true, reset: true }) W.pseudos[M] = ht(M);
        function sn() {
        }
        sn.prototype = W.filters = W.pseudos, W.setFilters = new sn();
        function Nn(kt, Kt) {
          var lr, Er, Rr, pr, tn, fn, rn, mn = gt[kt + " "];
          if (mn) return Kt ? 0 : mn.slice(0);
          for (tn = kt, fn = [], rn = W.preFilter; tn; ) {
            (!lr || (Er = Ir.exec(tn))) && (Er && (tn = tn.slice(Er[0].length) || tn), fn.push(Rr = [])), lr = false, (Er = An.exec(tn)) && (lr = Er.shift(), Rr.push({ value: lr, type: Er[0].replace(T, " ") }), tn = tn.slice(lr.length));
            for (pr in W.filter) (Er = gn[pr].exec(tn)) && (!rn[pr] || (Er = rn[pr](Er))) && (lr = Er.shift(), Rr.push({ value: lr, type: pr, matches: Er }), tn = tn.slice(lr.length));
            if (!lr) break;
          }
          return Kt ? tn.length : tn ? Rn.error(kt) : gt(kt, fn).slice(0);
        }
        function Vn(kt) {
          for (var Kt = 0, lr = kt.length, Er = ""; Kt < lr; Kt++) Er += kt[Kt].value;
          return Er;
        }
        function ln(kt, Kt, lr) {
          var Er = Kt.dir, Rr = Kt.next, pr = Rr || Er, tn = lr && pr === "parentNode", fn = ot++;
          return Kt.first ? function(rn, mn, pn) {
            for (; rn = rn[Er]; ) if (rn.nodeType === 1 || tn) return kt(rn, mn, pn);
            return false;
          } : function(rn, mn, pn) {
            var Fe, He, et = [Ee, fn];
            if (pn) {
              for (; rn = rn[Er]; ) if ((rn.nodeType === 1 || tn) && kt(rn, mn, pn)) return true;
            } else for (; rn = rn[Er]; ) if (rn.nodeType === 1 || tn) if (He = rn[Sr] || (rn[Sr] = {}), Rr && I(rn, Rr)) rn = rn[Er] || rn;
            else {
              if ((Fe = He[pr]) && Fe[0] === Ee && Fe[1] === fn) return et[2] = Fe[2];
              if (He[pr] = et, et[2] = kt(rn, mn, pn)) return true;
            }
            return false;
          };
        }
        function oi(kt) {
          return kt.length > 1 ? function(Kt, lr, Er) {
            for (var Rr = kt.length; Rr--; ) if (!kt[Rr](Kt, lr, Er)) return false;
            return true;
          } : kt[0];
        }
        function Hn(kt, Kt, lr) {
          for (var Er = 0, Rr = Kt.length; Er < Rr; Er++) Rn(kt, Kt[Er], lr);
          return lr;
        }
        function Tn(kt, Kt, lr, Er, Rr) {
          for (var pr, tn = [], fn = 0, rn = kt.length, mn = Kt != null; fn < rn; fn++) (pr = kt[fn]) && (!lr || lr(pr, Er, Rr)) && (tn.push(pr), mn && Kt.push(fn));
          return tn;
        }
        function xn(kt, Kt, lr, Er, Rr, pr) {
          return Er && !Er[Sr] && (Er = xn(Er)), Rr && !Rr[Sr] && (Rr = xn(Rr, pr)), ve(function(tn, fn, rn, mn) {
            var pn, Fe, He, et, jt = [], At = [], qt = fn.length, Jt = tn || Hn(Kt || "*", rn.nodeType ? [rn] : rn, []), er = kt && (tn || !Kt) ? Tn(Jt, jt, kt, rn, mn) : Jt;
            if (lr ? (et = Rr || (tn ? kt : qt || Er) ? [] : fn, lr(er, et, rn, mn)) : et = er, Er) for (pn = Tn(et, At), Er(pn, [], rn, mn), Fe = pn.length; Fe--; ) (He = pn[Fe]) && (et[At[Fe]] = !(er[At[Fe]] = He));
            if (tn) {
              if (Rr || kt) {
                if (Rr) {
                  for (pn = [], Fe = et.length; Fe--; ) (He = et[Fe]) && pn.push(er[Fe] = He);
                  Rr(null, et = [], pn, mn);
                }
                for (Fe = et.length; Fe--; ) (He = et[Fe]) && (pn = Rr ? u.call(tn, He) : jt[Fe]) > -1 && (tn[pn] = !(fn[pn] = He));
              }
            } else et = Tn(et === fn ? et.splice(qt, et.length) : et), Rr ? Rr(null, fn, et, mn) : Re.apply(fn, et);
          });
        }
        function Gn(kt) {
          for (var Kt, lr, Er, Rr = kt.length, pr = W.relative[kt[0].type], tn = pr || W.relative[" "], fn = pr ? 1 : 0, rn = ln(function(Fe) {
            return Fe === Kt;
          }, tn, true), mn = ln(function(Fe) {
            return u.call(Kt, Fe) > -1;
          }, tn, true), pn = [function(Fe, He, et) {
            var jt = !pr && (et || He != fe) || ((Kt = He).nodeType ? rn(Fe, He, et) : mn(Fe, He, et));
            return Kt = null, jt;
          }]; fn < Rr; fn++) if (lr = W.relative[kt[fn].type]) pn = [ln(oi(pn), lr)];
          else {
            if (lr = W.filter[kt[fn].type].apply(null, kt[fn].matches), lr[Sr]) {
              for (Er = ++fn; Er < Rr && !W.relative[kt[Er].type]; Er++) ;
              return xn(fn > 1 && oi(pn), fn > 1 && Vn(kt.slice(0, fn - 1).concat({ value: kt[fn - 2].type === " " ? "*" : "" })).replace(T, "$1"), lr, fn < Er && Gn(kt.slice(fn, Er)), Er < Rr && Gn(kt = kt.slice(Er)), Er < Rr && Vn(kt));
            }
            pn.push(lr);
          }
          return oi(pn);
        }
        function Kn(kt, Kt) {
          var lr = Kt.length > 0, Er = kt.length > 0, Rr = function(pr, tn, fn, rn, mn) {
            var pn, Fe, He, et = 0, jt = "0", At = pr && [], qt = [], Jt = fe, er = pr || Er && W.find.TAG("*", mn), mr = Ee += Jt == null ? 1 : Math.random() || 0.1, Ar = er.length;
            for (mn && (fe = tn == Je || tn || mn); jt !== Ar && (pn = er[jt]) != null; jt++) {
              if (Er && pn) {
                for (Fe = 0, !tn && pn.ownerDocument != Je && (on(pn), fn = !_t); He = kt[Fe++]; ) if (He(pn, tn || Je, fn)) {
                  Re.call(rn, pn);
                  break;
                }
                mn && (Ee = mr);
              }
              lr && ((pn = !He && pn) && et--, pr && At.push(pn));
            }
            if (et += jt, lr && jt !== et) {
              for (Fe = 0; He = Kt[Fe++]; ) He(At, qt, tn, fn);
              if (pr) {
                if (et > 0) for (; jt--; ) At[jt] || qt[jt] || (qt[jt] = q.call(rn));
                qt = Tn(qt);
              }
              Re.apply(rn, qt), mn && !pr && qt.length > 0 && et + Kt.length > 1 && w.uniqueSort(rn);
            }
            return mn && (Ee = mr, fe = Jt), At;
          };
          return lr ? ve(Rr) : Rr;
        }
        function Pn(kt, Kt) {
          var lr, Er = [], Rr = [], pr = Rt[kt + " "];
          if (!pr) {
            for (Kt || (Kt = Nn(kt)), lr = Kt.length; lr--; ) pr = Gn(Kt[lr]), pr[Sr] ? Er.push(pr) : Rr.push(pr);
            pr = Rt(kt, Kn(Rr, Er)), pr.selector = kt;
          }
          return pr;
        }
        function Xn(kt, Kt, lr, Er) {
          var Rr, pr, tn, fn, rn, mn = typeof kt == "function" && kt, pn = !Er && Nn(kt = mn.selector || kt);
          if (lr = lr || [], pn.length === 1) {
            if (pr = pn[0] = pn[0].slice(0), pr.length > 2 && (tn = pr[0]).type === "ID" && Kt.nodeType === 9 && _t && W.relative[pr[1].type]) {
              if (Kt = (W.find.ID(tn.matches[0].replace(ii, vi), Kt) || [])[0], Kt) mn && (Kt = Kt.parentNode);
              else return lr;
              kt = kt.slice(pr.shift().value.length);
            }
            for (Rr = gn.needsContext.test(kt) ? 0 : pr.length; Rr-- && (tn = pr[Rr], !W.relative[fn = tn.type]); ) if ((rn = W.find[fn]) && (Er = rn(tn.matches[0].replace(ii, vi), Qn.test(pr[0].type) && cn(Kt.parentNode) || Kt))) {
              if (pr.splice(Rr, 1), kt = Er.length && Vn(pr), !kt) return Re.apply(lr, Er), lr;
              break;
            }
          }
          return (mn || Pn(kt, pn))(Er, Kt, !_t, lr, !Kt || Qn.test(kt) && cn(Kt.parentNode) || Kt), lr;
        }
        g.sortStable = Sr.split("").sort(nr).join("") === Sr, on(), g.sortDetached = he(function(kt) {
          return kt.compareDocumentPosition(Je.createElement("fieldset")) & 1;
        }), w.find = Rn, w.expr[":"] = w.expr.pseudos, w.unique = w.uniqueSort, Rn.compile = Pn, Rn.select = Xn, Rn.setDocument = on, Rn.tokenize = Nn, Rn.escape = w.escapeSelector, Rn.getText = w.text, Rn.isXML = w.isXMLDoc, Rn.selectors = w.expr, Rn.support = w.support, Rn.uniqueSort = w.uniqueSort;
      })();
      var te = function(M, W, fe) {
        for (var Se = [], Ce = fe !== void 0; (M = M[W]) && M.nodeType !== 9; ) if (M.nodeType === 1) {
          if (Ce && w(M).is(fe)) break;
          Se.push(M);
        }
        return Se;
      }, G = function(M, W) {
        for (var fe = []; M; M = M.nextSibling) M.nodeType === 1 && M !== W && fe.push(M);
        return fe;
      }, K = w.expr.match.needsContext, J = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function B(M, W, fe) {
        return a(W) ? w.grep(M, function(Se, Ce) {
          return !!W.call(Se, Ce, Se) !== fe;
        }) : W.nodeType ? w.grep(M, function(Se) {
          return Se === W !== fe;
        }) : typeof W != "string" ? w.grep(M, function(Se) {
          return u.call(W, Se) > -1 !== fe;
        }) : w.filter(W, M, fe);
      }
      w.filter = function(M, W, fe) {
        var Se = W[0];
        return fe && (M = ":not(" + M + ")"), W.length === 1 && Se.nodeType === 1 ? w.find.matchesSelector(Se, M) ? [Se] : [] : w.find.matches(M, w.grep(W, function(Ce) {
          return Ce.nodeType === 1;
        }));
      }, w.fn.extend({ find: function(M) {
        var W, fe, Se = this.length, Ce = this;
        if (typeof M != "string") return this.pushStack(w(M).filter(function() {
          for (W = 0; W < Se; W++) if (w.contains(Ce[W], this)) return true;
        }));
        for (fe = this.pushStack([]), W = 0; W < Se; W++) w.find(M, Ce[W], fe);
        return Se > 1 ? w.uniqueSort(fe) : fe;
      }, filter: function(M) {
        return this.pushStack(B(this, M || [], false));
      }, not: function(M) {
        return this.pushStack(B(this, M || [], true));
      }, is: function(M) {
        return !!B(this, typeof M == "string" && K.test(M) ? w(M) : M || [], false).length;
      } });
      var Z, ie = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, $ = w.fn.init = function(M, W, fe) {
        var Se, Ce;
        if (!M) return this;
        if (fe = fe || Z, typeof M == "string") if (M[0] === "<" && M[M.length - 1] === ">" && M.length >= 3 ? Se = [null, M, null] : Se = ie.exec(M), Se && (Se[1] || !W)) if (Se[1]) {
          if (W = W instanceof w ? W[0] : W, w.merge(this, w.parseHTML(Se[1], W && W.nodeType ? W.ownerDocument || W : d, true)), J.test(Se[1]) && w.isPlainObject(W)) for (Se in W) a(this[Se]) ? this[Se](W[Se]) : this.attr(Se, W[Se]);
          return this;
        } else return Ce = d.getElementById(Se[2]), Ce && (this[0] = Ce, this.length = 1), this;
        else return !W || W.jquery ? (W || fe).find(M) : this.constructor(W).find(M);
        else {
          if (M.nodeType) return this[0] = M, this.length = 1, this;
          if (a(M)) return fe.ready !== void 0 ? fe.ready(M) : M(w);
        }
        return w.makeArray(M, this);
      };
      $.prototype = w.fn, Z = w(d);
      var oe = /^(?:parents|prev(?:Until|All))/, ce = { children: true, contents: true, next: true, prev: true };
      w.fn.extend({ has: function(M) {
        var W = w(M, this), fe = W.length;
        return this.filter(function() {
          for (var Se = 0; Se < fe; Se++) if (w.contains(this, W[Se])) return true;
        });
      }, closest: function(M, W) {
        var fe, Se = 0, Ce = this.length, Re = [], Je = typeof M != "string" && w(M);
        if (!K.test(M)) {
          for (; Se < Ce; Se++) for (fe = this[Se]; fe && fe !== W; fe = fe.parentNode) if (fe.nodeType < 11 && (Je ? Je.index(fe) > -1 : fe.nodeType === 1 && w.find.matchesSelector(fe, M))) {
            Re.push(fe);
            break;
          }
        }
        return this.pushStack(Re.length > 1 ? w.uniqueSort(Re) : Re);
      }, index: function(M) {
        return M ? typeof M == "string" ? u.call(w(M), this[0]) : u.call(this, M.jquery ? M[0] : M) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }, add: function(M, W) {
        return this.pushStack(w.uniqueSort(w.merge(this.get(), w(M, W))));
      }, addBack: function(M) {
        return this.add(M == null ? this.prevObject : this.prevObject.filter(M));
      } });
      function ye(M, W) {
        for (; (M = M[W]) && M.nodeType !== 1; ) ;
        return M;
      }
      w.each({ parent: function(M) {
        var W = M.parentNode;
        return W && W.nodeType !== 11 ? W : null;
      }, parents: function(M) {
        return te(M, "parentNode");
      }, parentsUntil: function(M, W, fe) {
        return te(M, "parentNode", fe);
      }, next: function(M) {
        return ye(M, "nextSibling");
      }, prev: function(M) {
        return ye(M, "previousSibling");
      }, nextAll: function(M) {
        return te(M, "nextSibling");
      }, prevAll: function(M) {
        return te(M, "previousSibling");
      }, nextUntil: function(M, W, fe) {
        return te(M, "nextSibling", fe);
      }, prevUntil: function(M, W, fe) {
        return te(M, "previousSibling", fe);
      }, siblings: function(M) {
        return G((M.parentNode || {}).firstChild, M);
      }, children: function(M) {
        return G(M.firstChild);
      }, contents: function(M) {
        return M.contentDocument != null && s(M.contentDocument) ? M.contentDocument : (I(M, "template") && (M = M.content || M), w.merge([], M.childNodes));
      } }, function(M, W) {
        w.fn[M] = function(fe, Se) {
          var Ce = w.map(this, W, fe);
          return M.slice(-5) !== "Until" && (Se = fe), Se && typeof Se == "string" && (Ce = w.filter(Se, Ce)), this.length > 1 && (ce[M] || w.uniqueSort(Ce), oe.test(M) && Ce.reverse()), this.pushStack(Ce);
        };
      });
      var ae = /[^\x20\t\r\n\f]+/g;
      function ue(M) {
        var W = {};
        return w.each(M.match(ae) || [], function(fe, Se) {
          W[Se] = true;
        }), W;
      }
      w.Callbacks = function(M) {
        M = typeof M == "string" ? ue(M) : w.extend({}, M);
        var W, fe, Se, Ce, Re = [], Je = [], Ut = -1, _t = function() {
          for (Ce = Ce || M.once, Se = W = true; Je.length; Ut = -1) for (fe = Je.shift(); ++Ut < Re.length; ) Re[Ut].apply(fe[0], fe[1]) === false && M.stopOnFalse && (Ut = Re.length, fe = false);
          M.memory || (fe = false), W = false, Ce && (fe ? Re = [] : Re = "");
        }, Ht = { add: function() {
          return Re && (fe && !W && (Ut = Re.length - 1, Je.push(fe)), function tr(Sr) {
            w.each(Sr, function(Ee, ot) {
              a(ot) ? (!M.unique || !Ht.has(ot)) && Re.push(ot) : ot && ot.length && E(ot) !== "string" && tr(ot);
            });
          }(arguments), fe && !W && _t()), this;
        }, remove: function() {
          return w.each(arguments, function(tr, Sr) {
            for (var Ee; (Ee = w.inArray(Sr, Re, Ee)) > -1; ) Re.splice(Ee, 1), Ee <= Ut && Ut--;
          }), this;
        }, has: function(tr) {
          return tr ? w.inArray(tr, Re) > -1 : Re.length > 0;
        }, empty: function() {
          return Re && (Re = []), this;
        }, disable: function() {
          return Ce = Je = [], Re = fe = "", this;
        }, disabled: function() {
          return !Re;
        }, lock: function() {
          return Ce = Je = [], !fe && !W && (Re = fe = ""), this;
        }, locked: function() {
          return !!Ce;
        }, fireWith: function(tr, Sr) {
          return Ce || (Sr = Sr || [], Sr = [tr, Sr.slice ? Sr.slice() : Sr], Je.push(Sr), W || _t()), this;
        }, fire: function() {
          return Ht.fireWith(this, arguments), this;
        }, fired: function() {
          return !!Se;
        } };
        return Ht;
      };
      function ne(M) {
        return M;
      }
      function ge(M) {
        throw M;
      }
      function Te(M, W, fe, Se) {
        var Ce;
        try {
          M && a(Ce = M.promise) ? Ce.call(M).done(W).fail(fe) : M && a(Ce = M.then) ? Ce.call(M, W, fe) : W.apply(void 0, [M].slice(Se));
        } catch (Re) {
          fe.apply(void 0, [Re]);
        }
      }
      w.extend({ Deferred: function(M) {
        var W = [["notify", "progress", w.Callbacks("memory"), w.Callbacks("memory"), 2], ["resolve", "done", w.Callbacks("once memory"), w.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", w.Callbacks("once memory"), w.Callbacks("once memory"), 1, "rejected"]], fe = "pending", Se = { state: function() {
          return fe;
        }, always: function() {
          return Ce.done(arguments).fail(arguments), this;
        }, catch: function(Re) {
          return Se.then(null, Re);
        }, pipe: function() {
          var Re = arguments;
          return w.Deferred(function(Je) {
            w.each(W, function(Ut, _t) {
              var Ht = a(Re[_t[4]]) && Re[_t[4]];
              Ce[_t[1]](function() {
                var tr = Ht && Ht.apply(this, arguments);
                tr && a(tr.promise) ? tr.promise().progress(Je.notify).done(Je.resolve).fail(Je.reject) : Je[_t[0] + "With"](this, Ht ? [tr] : arguments);
              });
            }), Re = null;
          }).promise();
        }, then: function(Re, Je, Ut) {
          var _t = 0;
          function Ht(tr, Sr, Ee, ot) {
            return function() {
              var Mt = this, gt = arguments, Rt = function() {
                var nr, Qr;
                if (!(tr < _t)) {
                  if (nr = Ee.apply(Mt, gt), nr === Sr.promise()) throw new TypeError("Thenable self-resolution");
                  Qr = nr && (typeof nr == "object" || typeof nr == "function") && nr.then, a(Qr) ? ot ? Qr.call(nr, Ht(_t, Sr, ne, ot), Ht(_t, Sr, ge, ot)) : (_t++, Qr.call(nr, Ht(_t, Sr, ne, ot), Ht(_t, Sr, ge, ot), Ht(_t, Sr, ne, Sr.notifyWith))) : (Ee !== ne && (Mt = void 0, gt = [nr]), (ot || Sr.resolveWith)(Mt, gt));
                }
              }, or = ot ? Rt : function() {
                try {
                  Rt();
                } catch (nr) {
                  w.Deferred.exceptionHook && w.Deferred.exceptionHook(nr, or.error), tr + 1 >= _t && (Ee !== ge && (Mt = void 0, gt = [nr]), Sr.rejectWith(Mt, gt));
                }
              };
              tr ? or() : (w.Deferred.getErrorHook ? or.error = w.Deferred.getErrorHook() : w.Deferred.getStackHook && (or.error = w.Deferred.getStackHook()), e.setTimeout(or));
            };
          }
          return w.Deferred(function(tr) {
            W[0][3].add(Ht(0, tr, a(Ut) ? Ut : ne, tr.notifyWith)), W[1][3].add(Ht(0, tr, a(Re) ? Re : ne)), W[2][3].add(Ht(0, tr, a(Je) ? Je : ge));
          }).promise();
        }, promise: function(Re) {
          return Re != null ? w.extend(Re, Se) : Se;
        } }, Ce = {};
        return w.each(W, function(Re, Je) {
          var Ut = Je[2], _t = Je[5];
          Se[Je[1]] = Ut.add, _t && Ut.add(function() {
            fe = _t;
          }, W[3 - Re][2].disable, W[3 - Re][3].disable, W[0][2].lock, W[0][3].lock), Ut.add(Je[3].fire), Ce[Je[0]] = function() {
            return Ce[Je[0] + "With"](this === Ce ? void 0 : this, arguments), this;
          }, Ce[Je[0] + "With"] = Ut.fireWith;
        }), Se.promise(Ce), M && M.call(Ce, Ce), Ce;
      }, when: function(M) {
        var W = arguments.length, fe = W, Se = Array(fe), Ce = y.call(arguments), Re = w.Deferred(), Je = function(Ut) {
          return function(_t) {
            Se[Ut] = this, Ce[Ut] = arguments.length > 1 ? y.call(arguments) : _t, --W || Re.resolveWith(Se, Ce);
          };
        };
        if (W <= 1 && (Te(M, Re.done(Je(fe)).resolve, Re.reject, !W), Re.state() === "pending" || a(Ce[fe] && Ce[fe].then))) return Re.then();
        for (; fe--; ) Te(Ce[fe], Je(fe), Re.reject);
        return Re.promise();
      } });
      var pe = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      w.Deferred.exceptionHook = function(M, W) {
        e.console && e.console.warn && M && pe.test(M.name) && e.console.warn("jQuery.Deferred exception: " + M.message, M.stack, W);
      }, w.readyException = function(M) {
        e.setTimeout(function() {
          throw M;
        });
      };
      var Oe = w.Deferred();
      w.fn.ready = function(M) {
        return Oe.then(M).catch(function(W) {
          w.readyException(W);
        }), this;
      }, w.extend({ isReady: false, readyWait: 1, ready: function(M) {
        (M === true ? --w.readyWait : w.isReady) || (w.isReady = true, !(M !== true && --w.readyWait > 0) && Oe.resolveWith(d, [w]));
      } }), w.ready.then = Oe.then;
      function xe() {
        d.removeEventListener("DOMContentLoaded", xe), e.removeEventListener("load", xe), w.ready();
      }
      d.readyState === "complete" || d.readyState !== "loading" && !d.documentElement.doScroll ? e.setTimeout(w.ready) : (d.addEventListener("DOMContentLoaded", xe), e.addEventListener("load", xe));
      var Ve = function(M, W, fe, Se, Ce, Re, Je) {
        var Ut = 0, _t = M.length, Ht = fe == null;
        if (E(fe) === "object") {
          Ce = true;
          for (Ut in fe) Ve(M, W, Ut, fe[Ut], true, Re, Je);
        } else if (Se !== void 0 && (Ce = true, a(Se) || (Je = true), Ht && (Je ? (W.call(M, Se), W = null) : (Ht = W, W = function(tr, Sr, Ee) {
          return Ht.call(w(tr), Ee);
        })), W)) for (; Ut < _t; Ut++) W(M[Ut], fe, Je ? Se : Se.call(M[Ut], Ut, W(M[Ut], fe)));
        return Ce ? M : Ht ? W.call(M) : _t ? W(M[0], fe) : Re;
      }, _e = /^-ms-/, Be = /-([a-z])/g;
      function Qe(M, W) {
        return W.toUpperCase();
      }
      function ee(M) {
        return M.replace(_e, "ms-").replace(Be, Qe);
      }
      var P = function(M) {
        return M.nodeType === 1 || M.nodeType === 9 || !+M.nodeType;
      };
      function x() {
        this.expando = w.expando + x.uid++;
      }
      x.uid = 1, x.prototype = { cache: function(M) {
        var W = M[this.expando];
        return W || (W = {}, P(M) && (M.nodeType ? M[this.expando] = W : Object.defineProperty(M, this.expando, { value: W, configurable: true }))), W;
      }, set: function(M, W, fe) {
        var Se, Ce = this.cache(M);
        if (typeof W == "string") Ce[ee(W)] = fe;
        else for (Se in W) Ce[ee(Se)] = W[Se];
        return Ce;
      }, get: function(M, W) {
        return W === void 0 ? this.cache(M) : M[this.expando] && M[this.expando][ee(W)];
      }, access: function(M, W, fe) {
        return W === void 0 || W && typeof W == "string" && fe === void 0 ? this.get(M, W) : (this.set(M, W, fe), fe !== void 0 ? fe : W);
      }, remove: function(M, W) {
        var fe, Se = M[this.expando];
        if (Se !== void 0) {
          if (W !== void 0) for (Array.isArray(W) ? W = W.map(ee) : (W = ee(W), W = W in Se ? [W] : W.match(ae) || []), fe = W.length; fe--; ) delete Se[W[fe]];
          (W === void 0 || w.isEmptyObject(Se)) && (M.nodeType ? M[this.expando] = void 0 : delete M[this.expando]);
        }
      }, hasData: function(M) {
        var W = M[this.expando];
        return W !== void 0 && !w.isEmptyObject(W);
      } };
      var O = new x(), V = new x(), N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, C = /[A-Z]/g;
      function p(M) {
        return M === "true" ? true : M === "false" ? false : M === "null" ? null : M === +M + "" ? +M : N.test(M) ? JSON.parse(M) : M;
      }
      function A(M, W, fe) {
        var Se;
        if (fe === void 0 && M.nodeType === 1) if (Se = "data-" + W.replace(C, "-$&").toLowerCase(), fe = M.getAttribute(Se), typeof fe == "string") {
          try {
            fe = p(fe);
          } catch {
          }
          V.set(M, W, fe);
        } else fe = void 0;
        return fe;
      }
      w.extend({ hasData: function(M) {
        return V.hasData(M) || O.hasData(M);
      }, data: function(M, W, fe) {
        return V.access(M, W, fe);
      }, removeData: function(M, W) {
        V.remove(M, W);
      }, _data: function(M, W, fe) {
        return O.access(M, W, fe);
      }, _removeData: function(M, W) {
        O.remove(M, W);
      } }), w.fn.extend({ data: function(M, W) {
        var fe, Se, Ce, Re = this[0], Je = Re && Re.attributes;
        if (M === void 0) {
          if (this.length && (Ce = V.get(Re), Re.nodeType === 1 && !O.get(Re, "hasDataAttrs"))) {
            for (fe = Je.length; fe--; ) Je[fe] && (Se = Je[fe].name, Se.indexOf("data-") === 0 && (Se = ee(Se.slice(5)), A(Re, Se, Ce[Se])));
            O.set(Re, "hasDataAttrs", true);
          }
          return Ce;
        }
        return typeof M == "object" ? this.each(function() {
          V.set(this, M);
        }) : Ve(this, function(Ut) {
          var _t;
          if (Re && Ut === void 0) return _t = V.get(Re, M), _t !== void 0 || (_t = A(Re, M), _t !== void 0) ? _t : void 0;
          this.each(function() {
            V.set(this, M, Ut);
          });
        }, null, W, arguments.length > 1, null, true);
      }, removeData: function(M) {
        return this.each(function() {
          V.remove(this, M);
        });
      } }), w.extend({ queue: function(M, W, fe) {
        var Se;
        if (M) return W = (W || "fx") + "queue", Se = O.get(M, W), fe && (!Se || Array.isArray(fe) ? Se = O.access(M, W, w.makeArray(fe)) : Se.push(fe)), Se || [];
      }, dequeue: function(M, W) {
        W = W || "fx";
        var fe = w.queue(M, W), Se = fe.length, Ce = fe.shift(), Re = w._queueHooks(M, W), Je = function() {
          w.dequeue(M, W);
        };
        Ce === "inprogress" && (Ce = fe.shift(), Se--), Ce && (W === "fx" && fe.unshift("inprogress"), delete Re.stop, Ce.call(M, Je, Re)), !Se && Re && Re.empty.fire();
      }, _queueHooks: function(M, W) {
        var fe = W + "queueHooks";
        return O.get(M, fe) || O.access(M, fe, { empty: w.Callbacks("once memory").add(function() {
          O.remove(M, [W + "queue", fe]);
        }) });
      } }), w.fn.extend({ queue: function(M, W) {
        var fe = 2;
        return typeof M != "string" && (W = M, M = "fx", fe--), arguments.length < fe ? w.queue(this[0], M) : W === void 0 ? this : this.each(function() {
          var Se = w.queue(this, M, W);
          w._queueHooks(this, M), M === "fx" && Se[0] !== "inprogress" && w.dequeue(this, M);
        });
      }, dequeue: function(M) {
        return this.each(function() {
          w.dequeue(this, M);
        });
      }, clearQueue: function(M) {
        return this.queue(M || "fx", []);
      }, promise: function(M, W) {
        var fe, Se = 1, Ce = w.Deferred(), Re = this, Je = this.length, Ut = function() {
          --Se || Ce.resolveWith(Re, [Re]);
        };
        for (typeof M != "string" && (W = M, M = void 0), M = M || "fx"; Je--; ) fe = O.get(Re[Je], M + "queueHooks"), fe && fe.empty && (Se++, fe.empty.add(Ut));
        return Ut(), Ce.promise(W);
      } });
      var U = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Q = new RegExp("^(?:([+-])=|)(" + U + ")([a-z%]*)$", "i"), se = ["Top", "Right", "Bottom", "Left"], X = d.documentElement, de = function(M) {
        return w.contains(M.ownerDocument, M);
      }, tt = { composed: true };
      X.getRootNode && (de = function(M) {
        return w.contains(M.ownerDocument, M) || M.getRootNode(tt) === M.ownerDocument;
      });
      var Ne = function(M, W) {
        return M = W || M, M.style.display === "none" || M.style.display === "" && de(M) && w.css(M, "display") === "none";
      };
      function ut(M, W, fe, Se) {
        var Ce, Re, Je = 20, Ut = Se ? function() {
          return Se.cur();
        } : function() {
          return w.css(M, W, "");
        }, _t = Ut(), Ht = fe && fe[3] || (w.cssNumber[W] ? "" : "px"), tr = M.nodeType && (w.cssNumber[W] || Ht !== "px" && +_t) && Q.exec(w.css(M, W));
        if (tr && tr[3] !== Ht) {
          for (_t = _t / 2, Ht = Ht || tr[3], tr = +_t || 1; Je--; ) w.style(M, W, tr + Ht), (1 - Re) * (1 - (Re = Ut() / _t || 0.5)) <= 0 && (Je = 0), tr = tr / Re;
          tr = tr * 2, w.style(M, W, tr + Ht), fe = fe || [];
        }
        return fe && (tr = +tr || +_t || 0, Ce = fe[1] ? tr + (fe[1] + 1) * fe[2] : +fe[2], Se && (Se.unit = Ht, Se.start = tr, Se.end = Ce)), Ce;
      }
      var Ze = {};
      function Et(M) {
        var W, fe = M.ownerDocument, Se = M.nodeName, Ce = Ze[Se];
        return Ce || (W = fe.body.appendChild(fe.createElement(Se)), Ce = w.css(W, "display"), W.parentNode.removeChild(W), Ce === "none" && (Ce = "block"), Ze[Se] = Ce, Ce);
      }
      function rr(M, W) {
        for (var fe, Se, Ce = [], Re = 0, Je = M.length; Re < Je; Re++) Se = M[Re], Se.style && (fe = Se.style.display, W ? (fe === "none" && (Ce[Re] = O.get(Se, "display") || null, Ce[Re] || (Se.style.display = "")), Se.style.display === "" && Ne(Se) && (Ce[Re] = Et(Se))) : fe !== "none" && (Ce[Re] = "none", O.set(Se, "display", fe)));
        for (Re = 0; Re < Je; Re++) Ce[Re] != null && (M[Re].style.display = Ce[Re]);
        return M;
      }
      w.fn.extend({ show: function() {
        return rr(this, true);
      }, hide: function() {
        return rr(this);
      }, toggle: function(M) {
        return typeof M == "boolean" ? M ? this.show() : this.hide() : this.each(function() {
          Ne(this) ? w(this).show() : w(this).hide();
        });
      } });
      var je = /^(?:checkbox|radio)$/i, Ge = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i, at = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var M = d.createDocumentFragment(), W = M.appendChild(d.createElement("div")), fe = d.createElement("input");
        fe.setAttribute("type", "radio"), fe.setAttribute("checked", "checked"), fe.setAttribute("name", "t"), W.appendChild(fe), g.checkClone = W.cloneNode(true).cloneNode(true).lastChild.checked, W.innerHTML = "<textarea>x</textarea>", g.noCloneChecked = !!W.cloneNode(true).lastChild.defaultValue, W.innerHTML = "<option></option>", g.option = !!W.lastChild;
      })();
      var Ae = { thead: [1, "<table>", "</table>"], col: [2, "<table><colgroup>", "</colgroup></table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: [0, "", ""] };
      Ae.tbody = Ae.tfoot = Ae.colgroup = Ae.caption = Ae.thead, Ae.th = Ae.td, g.option || (Ae.optgroup = Ae.option = [1, "<select multiple='multiple'>", "</select>"]);
      function qe(M, W) {
        var fe;
        return typeof M.getElementsByTagName < "u" ? fe = M.getElementsByTagName(W || "*") : typeof M.querySelectorAll < "u" ? fe = M.querySelectorAll(W || "*") : fe = [], W === void 0 || W && I(M, W) ? w.merge([M], fe) : fe;
      }
      function Ft(M, W) {
        for (var fe = 0, Se = M.length; fe < Se; fe++) O.set(M[fe], "globalEval", !W || O.get(W[fe], "globalEval"));
      }
      var Dt = /<|&#?\w+;/;
      function wr(M, W, fe, Se, Ce) {
        for (var Re, Je, Ut, _t, Ht, tr, Sr = W.createDocumentFragment(), Ee = [], ot = 0, Mt = M.length; ot < Mt; ot++) if (Re = M[ot], Re || Re === 0) if (E(Re) === "object") w.merge(Ee, Re.nodeType ? [Re] : Re);
        else if (!Dt.test(Re)) Ee.push(W.createTextNode(Re));
        else {
          for (Je = Je || Sr.appendChild(W.createElement("div")), Ut = (Ge.exec(Re) || ["", ""])[1].toLowerCase(), _t = Ae[Ut] || Ae._default, Je.innerHTML = _t[1] + w.htmlPrefilter(Re) + _t[2], tr = _t[0]; tr--; ) Je = Je.lastChild;
          w.merge(Ee, Je.childNodes), Je = Sr.firstChild, Je.textContent = "";
        }
        for (Sr.textContent = "", ot = 0; Re = Ee[ot++]; ) {
          if (Se && w.inArray(Re, Se) > -1) {
            Ce && Ce.push(Re);
            continue;
          }
          if (Ht = de(Re), Je = qe(Sr.appendChild(Re), "script"), Ht && Ft(Je), fe) for (tr = 0; Re = Je[tr++]; ) at.test(Re.type || "") && fe.push(Re);
        }
        return Sr;
      }
      var Nt = /^([^.]*)(?:\.(.+)|)/;
      function yr() {
        return true;
      }
      function Ur() {
        return false;
      }
      function Pe(M, W, fe, Se, Ce, Re) {
        var Je, Ut;
        if (typeof W == "object") {
          typeof fe != "string" && (Se = Se || fe, fe = void 0);
          for (Ut in W) Pe(M, Ut, fe, Se, W[Ut], Re);
          return M;
        }
        if (Se == null && Ce == null ? (Ce = fe, Se = fe = void 0) : Ce == null && (typeof fe == "string" ? (Ce = Se, Se = void 0) : (Ce = Se, Se = fe, fe = void 0)), Ce === false) Ce = Ur;
        else if (!Ce) return M;
        return Re === 1 && (Je = Ce, Ce = function(_t) {
          return w().off(_t), Je.apply(this, arguments);
        }, Ce.guid = Je.guid || (Je.guid = w.guid++)), M.each(function() {
          w.event.add(this, W, Ce, Se, fe);
        });
      }
      w.event = { global: {}, add: function(M, W, fe, Se, Ce) {
        var Re, Je, Ut, _t, Ht, tr, Sr, Ee, ot, Mt, gt, Rt = O.get(M);
        if (P(M)) for (fe.handler && (Re = fe, fe = Re.handler, Ce = Re.selector), Ce && w.find.matchesSelector(X, Ce), fe.guid || (fe.guid = w.guid++), (_t = Rt.events) || (_t = Rt.events = /* @__PURE__ */ Object.create(null)), (Je = Rt.handle) || (Je = Rt.handle = function(or) {
          return typeof w < "u" && w.event.triggered !== or.type ? w.event.dispatch.apply(M, arguments) : void 0;
        }), W = (W || "").match(ae) || [""], Ht = W.length; Ht--; ) Ut = Nt.exec(W[Ht]) || [], ot = gt = Ut[1], Mt = (Ut[2] || "").split(".").sort(), ot && (Sr = w.event.special[ot] || {}, ot = (Ce ? Sr.delegateType : Sr.bindType) || ot, Sr = w.event.special[ot] || {}, tr = w.extend({ type: ot, origType: gt, data: Se, handler: fe, guid: fe.guid, selector: Ce, needsContext: Ce && w.expr.match.needsContext.test(Ce), namespace: Mt.join(".") }, Re), (Ee = _t[ot]) || (Ee = _t[ot] = [], Ee.delegateCount = 0, (!Sr.setup || Sr.setup.call(M, Se, Mt, Je) === false) && M.addEventListener && M.addEventListener(ot, Je)), Sr.add && (Sr.add.call(M, tr), tr.handler.guid || (tr.handler.guid = fe.guid)), Ce ? Ee.splice(Ee.delegateCount++, 0, tr) : Ee.push(tr), w.event.global[ot] = true);
      }, remove: function(M, W, fe, Se, Ce) {
        var Re, Je, Ut, _t, Ht, tr, Sr, Ee, ot, Mt, gt, Rt = O.hasData(M) && O.get(M);
        if (!(!Rt || !(_t = Rt.events))) {
          for (W = (W || "").match(ae) || [""], Ht = W.length; Ht--; ) {
            if (Ut = Nt.exec(W[Ht]) || [], ot = gt = Ut[1], Mt = (Ut[2] || "").split(".").sort(), !ot) {
              for (ot in _t) w.event.remove(M, ot + W[Ht], fe, Se, true);
              continue;
            }
            for (Sr = w.event.special[ot] || {}, ot = (Se ? Sr.delegateType : Sr.bindType) || ot, Ee = _t[ot] || [], Ut = Ut[2] && new RegExp("(^|\\.)" + Mt.join("\\.(?:.*\\.|)") + "(\\.|$)"), Je = Re = Ee.length; Re--; ) tr = Ee[Re], (Ce || gt === tr.origType) && (!fe || fe.guid === tr.guid) && (!Ut || Ut.test(tr.namespace)) && (!Se || Se === tr.selector || Se === "**" && tr.selector) && (Ee.splice(Re, 1), tr.selector && Ee.delegateCount--, Sr.remove && Sr.remove.call(M, tr));
            Je && !Ee.length && ((!Sr.teardown || Sr.teardown.call(M, Mt, Rt.handle) === false) && w.removeEvent(M, ot, Rt.handle), delete _t[ot]);
          }
          w.isEmptyObject(_t) && O.remove(M, "handle events");
        }
      }, dispatch: function(M) {
        var W, fe, Se, Ce, Re, Je, Ut = new Array(arguments.length), _t = w.event.fix(M), Ht = (O.get(this, "events") || /* @__PURE__ */ Object.create(null))[_t.type] || [], tr = w.event.special[_t.type] || {};
        for (Ut[0] = _t, W = 1; W < arguments.length; W++) Ut[W] = arguments[W];
        if (_t.delegateTarget = this, !(tr.preDispatch && tr.preDispatch.call(this, _t) === false)) {
          for (Je = w.event.handlers.call(this, _t, Ht), W = 0; (Ce = Je[W++]) && !_t.isPropagationStopped(); ) for (_t.currentTarget = Ce.elem, fe = 0; (Re = Ce.handlers[fe++]) && !_t.isImmediatePropagationStopped(); ) (!_t.rnamespace || Re.namespace === false || _t.rnamespace.test(Re.namespace)) && (_t.handleObj = Re, _t.data = Re.data, Se = ((w.event.special[Re.origType] || {}).handle || Re.handler).apply(Ce.elem, Ut), Se !== void 0 && (_t.result = Se) === false && (_t.preventDefault(), _t.stopPropagation()));
          return tr.postDispatch && tr.postDispatch.call(this, _t), _t.result;
        }
      }, handlers: function(M, W) {
        var fe, Se, Ce, Re, Je, Ut = [], _t = W.delegateCount, Ht = M.target;
        if (_t && Ht.nodeType && !(M.type === "click" && M.button >= 1)) {
          for (; Ht !== this; Ht = Ht.parentNode || this) if (Ht.nodeType === 1 && !(M.type === "click" && Ht.disabled === true)) {
            for (Re = [], Je = {}, fe = 0; fe < _t; fe++) Se = W[fe], Ce = Se.selector + " ", Je[Ce] === void 0 && (Je[Ce] = Se.needsContext ? w(Ce, this).index(Ht) > -1 : w.find(Ce, this, null, [Ht]).length), Je[Ce] && Re.push(Se);
            Re.length && Ut.push({ elem: Ht, handlers: Re });
          }
        }
        return Ht = this, _t < W.length && Ut.push({ elem: Ht, handlers: W.slice(_t) }), Ut;
      }, addProp: function(M, W) {
        Object.defineProperty(w.Event.prototype, M, { enumerable: true, configurable: true, get: a(W) ? function() {
          if (this.originalEvent) return W(this.originalEvent);
        } : function() {
          if (this.originalEvent) return this.originalEvent[M];
        }, set: function(fe) {
          Object.defineProperty(this, M, { enumerable: true, configurable: true, writable: true, value: fe });
        } });
      }, fix: function(M) {
        return M[w.expando] ? M : new w.Event(M);
      }, special: { load: { noBubble: true }, click: { setup: function(M) {
        var W = this || M;
        return je.test(W.type) && W.click && I(W, "input") && $e(W, "click", true), false;
      }, trigger: function(M) {
        var W = this || M;
        return je.test(W.type) && W.click && I(W, "input") && $e(W, "click"), true;
      }, _default: function(M) {
        var W = M.target;
        return je.test(W.type) && W.click && I(W, "input") && O.get(W, "click") || I(W, "a");
      } }, beforeunload: { postDispatch: function(M) {
        M.result !== void 0 && M.originalEvent && (M.originalEvent.returnValue = M.result);
      } } } };
      function $e(M, W, fe) {
        if (!fe) {
          O.get(M, W) === void 0 && w.event.add(M, W, yr);
          return;
        }
        O.set(M, W, false), w.event.add(M, W, { namespace: false, handler: function(Se) {
          var Ce, Re = O.get(this, W);
          if (Se.isTrigger & 1 && this[W]) {
            if (Re) (w.event.special[W] || {}).delegateType && Se.stopPropagation();
            else if (Re = y.call(arguments), O.set(this, W, Re), this[W](), Ce = O.get(this, W), O.set(this, W, false), Re !== Ce) return Se.stopImmediatePropagation(), Se.preventDefault(), Ce;
          } else Re && (O.set(this, W, w.event.trigger(Re[0], Re.slice(1), this)), Se.stopPropagation(), Se.isImmediatePropagationStopped = yr);
        } });
      }
      w.removeEvent = function(M, W, fe) {
        M.removeEventListener && M.removeEventListener(W, fe);
      }, w.Event = function(M, W) {
        if (!(this instanceof w.Event)) return new w.Event(M, W);
        M && M.type ? (this.originalEvent = M, this.type = M.type, this.isDefaultPrevented = M.defaultPrevented || M.defaultPrevented === void 0 && M.returnValue === false ? yr : Ur, this.target = M.target && M.target.nodeType === 3 ? M.target.parentNode : M.target, this.currentTarget = M.currentTarget, this.relatedTarget = M.relatedTarget) : this.type = M, W && w.extend(this, W), this.timeStamp = M && M.timeStamp || Date.now(), this[w.expando] = true;
      }, w.Event.prototype = { constructor: w.Event, isDefaultPrevented: Ur, isPropagationStopped: Ur, isImmediatePropagationStopped: Ur, isSimulated: false, preventDefault: function() {
        var M = this.originalEvent;
        this.isDefaultPrevented = yr, M && !this.isSimulated && M.preventDefault();
      }, stopPropagation: function() {
        var M = this.originalEvent;
        this.isPropagationStopped = yr, M && !this.isSimulated && M.stopPropagation();
      }, stopImmediatePropagation: function() {
        var M = this.originalEvent;
        this.isImmediatePropagationStopped = yr, M && !this.isSimulated && M.stopImmediatePropagation(), this.stopPropagation();
      } }, w.each({ altKey: true, bubbles: true, cancelable: true, changedTouches: true, ctrlKey: true, detail: true, eventPhase: true, metaKey: true, pageX: true, pageY: true, shiftKey: true, view: true, char: true, code: true, charCode: true, key: true, keyCode: true, button: true, buttons: true, clientX: true, clientY: true, offsetX: true, offsetY: true, pointerId: true, pointerType: true, screenX: true, screenY: true, targetTouches: true, toElement: true, touches: true, which: true }, w.event.addProp), w.each({ focus: "focusin", blur: "focusout" }, function(M, W) {
        function fe(Se) {
          if (d.documentMode) {
            var Ce = O.get(this, "handle"), Re = w.event.fix(Se);
            Re.type = Se.type === "focusin" ? "focus" : "blur", Re.isSimulated = true, Ce(Se), Re.target === Re.currentTarget && Ce(Re);
          } else w.event.simulate(W, Se.target, w.event.fix(Se));
        }
        w.event.special[M] = { setup: function() {
          var Se;
          if ($e(this, M, true), d.documentMode) Se = O.get(this, W), Se || this.addEventListener(W, fe), O.set(this, W, (Se || 0) + 1);
          else return false;
        }, trigger: function() {
          return $e(this, M), true;
        }, teardown: function() {
          var Se;
          if (d.documentMode) Se = O.get(this, W) - 1, Se ? O.set(this, W, Se) : (this.removeEventListener(W, fe), O.remove(this, W));
          else return false;
        }, _default: function(Se) {
          return O.get(Se.target, M);
        }, delegateType: W }, w.event.special[W] = { setup: function() {
          var Se = this.ownerDocument || this.document || this, Ce = d.documentMode ? this : Se, Re = O.get(Ce, W);
          Re || (d.documentMode ? this.addEventListener(W, fe) : Se.addEventListener(M, fe, true)), O.set(Ce, W, (Re || 0) + 1);
        }, teardown: function() {
          var Se = this.ownerDocument || this.document || this, Ce = d.documentMode ? this : Se, Re = O.get(Ce, W) - 1;
          Re ? O.set(Ce, W, Re) : (d.documentMode ? this.removeEventListener(W, fe) : Se.removeEventListener(M, fe, true), O.remove(Ce, W));
        } };
      }), w.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function(M, W) {
        w.event.special[M] = { delegateType: W, bindType: W, handle: function(fe) {
          var Se, Ce = this, Re = fe.relatedTarget, Je = fe.handleObj;
          return (!Re || Re !== Ce && !w.contains(Ce, Re)) && (fe.type = Je.origType, Se = Je.handler.apply(this, arguments), fe.type = W), Se;
        } };
      }), w.fn.extend({ on: function(M, W, fe, Se) {
        return Pe(this, M, W, fe, Se);
      }, one: function(M, W, fe, Se) {
        return Pe(this, M, W, fe, Se, 1);
      }, off: function(M, W, fe) {
        var Se, Ce;
        if (M && M.preventDefault && M.handleObj) return Se = M.handleObj, w(M.delegateTarget).off(Se.namespace ? Se.origType + "." + Se.namespace : Se.origType, Se.selector, Se.handler), this;
        if (typeof M == "object") {
          for (Ce in M) this.off(Ce, W, M[Ce]);
          return this;
        }
        return (W === false || typeof W == "function") && (fe = W, W = void 0), fe === false && (fe = Ur), this.each(function() {
          w.event.remove(this, M, fe, W);
        });
      } });
      var le = /<script|<style|<link/i, re = /checked\s*(?:[^=]|=\s*.checked.)/i, Le = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function nt(M, W) {
        return I(M, "table") && I(W.nodeType !== 11 ? W : W.firstChild, "tr") && w(M).children("tbody")[0] || M;
      }
      function ft(M) {
        return M.type = (M.getAttribute("type") !== null) + "/" + M.type, M;
      }
      function zt(M) {
        return (M.type || "").slice(0, 5) === "true/" ? M.type = M.type.slice(5) : M.removeAttribute("type"), M;
      }
      function st(M, W) {
        var fe, Se, Ce, Re, Je, Ut, _t;
        if (W.nodeType === 1) {
          if (O.hasData(M) && (Re = O.get(M), _t = Re.events, _t)) {
            O.remove(W, "handle events");
            for (Ce in _t) for (fe = 0, Se = _t[Ce].length; fe < Se; fe++) w.event.add(W, Ce, _t[Ce][fe]);
          }
          V.hasData(M) && (Je = V.access(M), Ut = w.extend({}, Je), V.set(W, Ut));
        }
      }
      function ct(M, W) {
        var fe = W.nodeName.toLowerCase();
        fe === "input" && je.test(M.type) ? W.checked = M.checked : (fe === "input" || fe === "textarea") && (W.defaultValue = M.defaultValue);
      }
      function yt(M, W, fe, Se) {
        W = t(W);
        var Ce, Re, Je, Ut, _t, Ht, tr = 0, Sr = M.length, Ee = Sr - 1, ot = W[0], Mt = a(ot);
        if (Mt || Sr > 1 && typeof ot == "string" && !g.checkClone && re.test(ot)) return M.each(function(gt) {
          var Rt = M.eq(gt);
          Mt && (W[0] = ot.call(this, gt, Rt.html())), yt(Rt, W, fe, Se);
        });
        if (Sr && (Ce = wr(W, M[0].ownerDocument, false, M, Se), Re = Ce.firstChild, Ce.childNodes.length === 1 && (Ce = Re), Re || Se)) {
          for (Je = w.map(qe(Ce, "script"), ft), Ut = Je.length; tr < Sr; tr++) _t = Ce, tr !== Ee && (_t = w.clone(_t, true, true), Ut && w.merge(Je, qe(_t, "script"))), fe.call(M[tr], _t, tr);
          if (Ut) for (Ht = Je[Je.length - 1].ownerDocument, w.map(Je, zt), tr = 0; tr < Ut; tr++) _t = Je[tr], at.test(_t.type || "") && !O.access(_t, "globalEval") && w.contains(Ht, _t) && (_t.src && (_t.type || "").toLowerCase() !== "module" ? w._evalUrl && !_t.noModule && w._evalUrl(_t.src, { nonce: _t.nonce || _t.getAttribute("nonce") }, Ht) : S(_t.textContent.replace(Le, ""), _t, Ht));
        }
        return M;
      }
      function Zt(M, W, fe) {
        for (var Se, Ce = W ? w.filter(W, M) : M, Re = 0; (Se = Ce[Re]) != null; Re++) !fe && Se.nodeType === 1 && w.cleanData(qe(Se)), Se.parentNode && (fe && de(Se) && Ft(qe(Se, "script")), Se.parentNode.removeChild(Se));
        return M;
      }
      w.extend({ htmlPrefilter: function(M) {
        return M;
      }, clone: function(M, W, fe) {
        var Se, Ce, Re, Je, Ut = M.cloneNode(true), _t = de(M);
        if (!g.noCloneChecked && (M.nodeType === 1 || M.nodeType === 11) && !w.isXMLDoc(M)) for (Je = qe(Ut), Re = qe(M), Se = 0, Ce = Re.length; Se < Ce; Se++) ct(Re[Se], Je[Se]);
        if (W) if (fe) for (Re = Re || qe(M), Je = Je || qe(Ut), Se = 0, Ce = Re.length; Se < Ce; Se++) st(Re[Se], Je[Se]);
        else st(M, Ut);
        return Je = qe(Ut, "script"), Je.length > 0 && Ft(Je, !_t && qe(M, "script")), Ut;
      }, cleanData: function(M) {
        for (var W, fe, Se, Ce = w.event.special, Re = 0; (fe = M[Re]) !== void 0; Re++) if (P(fe)) {
          if (W = fe[O.expando]) {
            if (W.events) for (Se in W.events) Ce[Se] ? w.event.remove(fe, Se) : w.removeEvent(fe, Se, W.handle);
            fe[O.expando] = void 0;
          }
          fe[V.expando] && (fe[V.expando] = void 0);
        }
      } }), w.fn.extend({ detach: function(M) {
        return Zt(this, M, true);
      }, remove: function(M) {
        return Zt(this, M);
      }, text: function(M) {
        return Ve(this, function(W) {
          return W === void 0 ? w.text(this) : this.empty().each(function() {
            (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) && (this.textContent = W);
          });
        }, null, M, arguments.length);
      }, append: function() {
        return yt(this, arguments, function(M) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var W = nt(this, M);
            W.appendChild(M);
          }
        });
      }, prepend: function() {
        return yt(this, arguments, function(M) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var W = nt(this, M);
            W.insertBefore(M, W.firstChild);
          }
        });
      }, before: function() {
        return yt(this, arguments, function(M) {
          this.parentNode && this.parentNode.insertBefore(M, this);
        });
      }, after: function() {
        return yt(this, arguments, function(M) {
          this.parentNode && this.parentNode.insertBefore(M, this.nextSibling);
        });
      }, empty: function() {
        for (var M, W = 0; (M = this[W]) != null; W++) M.nodeType === 1 && (w.cleanData(qe(M, false)), M.textContent = "");
        return this;
      }, clone: function(M, W) {
        return M = M ?? false, W = W ?? M, this.map(function() {
          return w.clone(this, M, W);
        });
      }, html: function(M) {
        return Ve(this, function(W) {
          var fe = this[0] || {}, Se = 0, Ce = this.length;
          if (W === void 0 && fe.nodeType === 1) return fe.innerHTML;
          if (typeof W == "string" && !le.test(W) && !Ae[(Ge.exec(W) || ["", ""])[1].toLowerCase()]) {
            W = w.htmlPrefilter(W);
            try {
              for (; Se < Ce; Se++) fe = this[Se] || {}, fe.nodeType === 1 && (w.cleanData(qe(fe, false)), fe.innerHTML = W);
              fe = 0;
            } catch {
            }
          }
          fe && this.empty().append(W);
        }, null, M, arguments.length);
      }, replaceWith: function() {
        var M = [];
        return yt(this, arguments, function(W) {
          var fe = this.parentNode;
          w.inArray(this, M) < 0 && (w.cleanData(qe(this)), fe && fe.replaceChild(W, this));
        }, M);
      } }), w.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(M, W) {
        w.fn[M] = function(fe) {
          for (var Se, Ce = [], Re = w(fe), Je = Re.length - 1, Ut = 0; Ut <= Je; Ut++) Se = Ut === Je ? this : this.clone(true), w(Re[Ut])[W](Se), o.apply(Ce, Se.get());
          return this.pushStack(Ce);
        };
      });
      var Ct = new RegExp("^(" + U + ")(?!px)[a-z%]+$", "i"), Lt = /^--/, Wt = function(M) {
        var W = M.ownerDocument.defaultView;
        return (!W || !W.opener) && (W = e), W.getComputedStyle(M);
      }, vr = function(M, W, fe) {
        var Se, Ce, Re = {};
        for (Ce in W) Re[Ce] = M.style[Ce], M.style[Ce] = W[Ce];
        Se = fe.call(M);
        for (Ce in W) M.style[Ce] = Re[Ce];
        return Se;
      }, ar = new RegExp(se.join("|"), "i");
      (function() {
        function M() {
          if (Ht) {
            _t.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", Ht.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", X.appendChild(_t).appendChild(Ht);
            var tr = e.getComputedStyle(Ht);
            fe = tr.top !== "1%", Ut = W(tr.marginLeft) === 12, Ht.style.right = "60%", Re = W(tr.right) === 36, Se = W(tr.width) === 36, Ht.style.position = "absolute", Ce = W(Ht.offsetWidth / 3) === 12, X.removeChild(_t), Ht = null;
          }
        }
        function W(tr) {
          return Math.round(parseFloat(tr));
        }
        var fe, Se, Ce, Re, Je, Ut, _t = d.createElement("div"), Ht = d.createElement("div");
        Ht.style && (Ht.style.backgroundClip = "content-box", Ht.cloneNode(true).style.backgroundClip = "", g.clearCloneStyle = Ht.style.backgroundClip === "content-box", w.extend(g, { boxSizingReliable: function() {
          return M(), Se;
        }, pixelBoxStyles: function() {
          return M(), Re;
        }, pixelPosition: function() {
          return M(), fe;
        }, reliableMarginLeft: function() {
          return M(), Ut;
        }, scrollboxSize: function() {
          return M(), Ce;
        }, reliableTrDimensions: function() {
          var tr, Sr, Ee, ot;
          return Je == null && (tr = d.createElement("table"), Sr = d.createElement("tr"), Ee = d.createElement("div"), tr.style.cssText = "position:absolute;left:-11111px;border-collapse:separate", Sr.style.cssText = "box-sizing:content-box;border:1px solid", Sr.style.height = "1px", Ee.style.height = "9px", Ee.style.display = "block", X.appendChild(tr).appendChild(Sr).appendChild(Ee), ot = e.getComputedStyle(Sr), Je = parseInt(ot.height, 10) + parseInt(ot.borderTopWidth, 10) + parseInt(ot.borderBottomWidth, 10) === Sr.offsetHeight, X.removeChild(tr)), Je;
        } }));
      })();
      function sr(M, W, fe) {
        var Se, Ce, Re, Je, Ut = Lt.test(W), _t = M.style;
        return fe = fe || Wt(M), fe && (Je = fe.getPropertyValue(W) || fe[W], Ut && Je && (Je = Je.replace(T, "$1") || void 0), Je === "" && !de(M) && (Je = w.style(M, W)), !g.pixelBoxStyles() && Ct.test(Je) && ar.test(W) && (Se = _t.width, Ce = _t.minWidth, Re = _t.maxWidth, _t.minWidth = _t.maxWidth = _t.width = Je, Je = fe.width, _t.width = Se, _t.minWidth = Ce, _t.maxWidth = Re)), Je !== void 0 ? Je + "" : Je;
      }
      function gr(M, W) {
        return { get: function() {
          if (M()) {
            delete this.get;
            return;
          }
          return (this.get = W).apply(this, arguments);
        } };
      }
      var Tr = ["Webkit", "Moz", "ms"], Mr = d.createElement("div").style, Nr = {};
      function Lr(M) {
        for (var W = M[0].toUpperCase() + M.slice(1), fe = Tr.length; fe--; ) if (M = Tr[fe] + W, M in Mr) return M;
      }
      function jr(M) {
        var W = w.cssProps[M] || Nr[M];
        return W || (M in Mr ? M : Nr[M] = Lr(M) || M);
      }
      var Hr = /^(none|table(?!-c[ea]).+)/, kr = { position: "absolute", visibility: "hidden", display: "block" }, Xt = { letterSpacing: "0", fontWeight: "400" };
      function Qt(M, W, fe) {
        var Se = Q.exec(W);
        return Se ? Math.max(0, Se[2] - (fe || 0)) + (Se[3] || "px") : W;
      }
      function br(M, W, fe, Se, Ce, Re) {
        var Je = W === "width" ? 1 : 0, Ut = 0, _t = 0, Ht = 0;
        if (fe === (Se ? "border" : "content")) return 0;
        for (; Je < 4; Je += 2) fe === "margin" && (Ht += w.css(M, fe + se[Je], true, Ce)), Se ? (fe === "content" && (_t -= w.css(M, "padding" + se[Je], true, Ce)), fe !== "margin" && (_t -= w.css(M, "border" + se[Je] + "Width", true, Ce))) : (_t += w.css(M, "padding" + se[Je], true, Ce), fe !== "padding" ? _t += w.css(M, "border" + se[Je] + "Width", true, Ce) : Ut += w.css(M, "border" + se[Je] + "Width", true, Ce));
        return !Se && Re >= 0 && (_t += Math.max(0, Math.ceil(M["offset" + W[0].toUpperCase() + W.slice(1)] - Re - _t - Ut - 0.5)) || 0), _t + Ht;
      }
      function we(M, W, fe) {
        var Se = Wt(M), Ce = !g.boxSizingReliable() || fe, Re = Ce && w.css(M, "boxSizing", false, Se) === "border-box", Je = Re, Ut = sr(M, W, Se), _t = "offset" + W[0].toUpperCase() + W.slice(1);
        if (Ct.test(Ut)) {
          if (!fe) return Ut;
          Ut = "auto";
        }
        return (!g.boxSizingReliable() && Re || !g.reliableTrDimensions() && I(M, "tr") || Ut === "auto" || !parseFloat(Ut) && w.css(M, "display", false, Se) === "inline") && M.getClientRects().length && (Re = w.css(M, "boxSizing", false, Se) === "border-box", Je = _t in M, Je && (Ut = M[_t])), Ut = parseFloat(Ut) || 0, Ut + br(M, W, fe || (Re ? "border" : "content"), Je, Se, Ut) + "px";
      }
      w.extend({ cssHooks: { opacity: { get: function(M, W) {
        if (W) {
          var fe = sr(M, "opacity");
          return fe === "" ? "1" : fe;
        }
      } } }, cssNumber: { animationIterationCount: true, aspectRatio: true, borderImageSlice: true, columnCount: true, flexGrow: true, flexShrink: true, fontWeight: true, gridArea: true, gridColumn: true, gridColumnEnd: true, gridColumnStart: true, gridRow: true, gridRowEnd: true, gridRowStart: true, lineHeight: true, opacity: true, order: true, orphans: true, scale: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeMiterlimit: true, strokeOpacity: true }, cssProps: {}, style: function(M, W, fe, Se) {
        if (!(!M || M.nodeType === 3 || M.nodeType === 8 || !M.style)) {
          var Ce, Re, Je, Ut = ee(W), _t = Lt.test(W), Ht = M.style;
          if (_t || (W = jr(Ut)), Je = w.cssHooks[W] || w.cssHooks[Ut], fe !== void 0) {
            if (Re = typeof fe, Re === "string" && (Ce = Q.exec(fe)) && Ce[1] && (fe = ut(M, W, Ce), Re = "number"), fe == null || fe !== fe) return;
            Re === "number" && !_t && (fe += Ce && Ce[3] || (w.cssNumber[Ut] ? "" : "px")), !g.clearCloneStyle && fe === "" && W.indexOf("background") === 0 && (Ht[W] = "inherit"), (!Je || !("set" in Je) || (fe = Je.set(M, fe, Se)) !== void 0) && (_t ? Ht.setProperty(W, fe) : Ht[W] = fe);
          } else return Je && "get" in Je && (Ce = Je.get(M, false, Se)) !== void 0 ? Ce : Ht[W];
        }
      }, css: function(M, W, fe, Se) {
        var Ce, Re, Je, Ut = ee(W), _t = Lt.test(W);
        return _t || (W = jr(Ut)), Je = w.cssHooks[W] || w.cssHooks[Ut], Je && "get" in Je && (Ce = Je.get(M, true, fe)), Ce === void 0 && (Ce = sr(M, W, Se)), Ce === "normal" && W in Xt && (Ce = Xt[W]), fe === "" || fe ? (Re = parseFloat(Ce), fe === true || isFinite(Re) ? Re || 0 : Ce) : Ce;
      } }), w.each(["height", "width"], function(M, W) {
        w.cssHooks[W] = { get: function(fe, Se, Ce) {
          if (Se) return Hr.test(w.css(fe, "display")) && (!fe.getClientRects().length || !fe.getBoundingClientRect().width) ? vr(fe, kr, function() {
            return we(fe, W, Ce);
          }) : we(fe, W, Ce);
        }, set: function(fe, Se, Ce) {
          var Re, Je = Wt(fe), Ut = !g.scrollboxSize() && Je.position === "absolute", _t = Ut || Ce, Ht = _t && w.css(fe, "boxSizing", false, Je) === "border-box", tr = Ce ? br(fe, W, Ce, Ht, Je) : 0;
          return Ht && Ut && (tr -= Math.ceil(fe["offset" + W[0].toUpperCase() + W.slice(1)] - parseFloat(Je[W]) - br(fe, W, "border", false, Je) - 0.5)), tr && (Re = Q.exec(Se)) && (Re[3] || "px") !== "px" && (fe.style[W] = Se, Se = w.css(fe, W)), Qt(fe, Se, tr);
        } };
      }), w.cssHooks.marginLeft = gr(g.reliableMarginLeft, function(M, W) {
        if (W) return (parseFloat(sr(M, "marginLeft")) || M.getBoundingClientRect().left - vr(M, { marginLeft: 0 }, function() {
          return M.getBoundingClientRect().left;
        })) + "px";
      }), w.each({ margin: "", padding: "", border: "Width" }, function(M, W) {
        w.cssHooks[M + W] = { expand: function(fe) {
          for (var Se = 0, Ce = {}, Re = typeof fe == "string" ? fe.split(" ") : [fe]; Se < 4; Se++) Ce[M + se[Se] + W] = Re[Se] || Re[Se - 2] || Re[0];
          return Ce;
        } }, M !== "margin" && (w.cssHooks[M + W].set = Qt);
      }), w.fn.extend({ css: function(M, W) {
        return Ve(this, function(fe, Se, Ce) {
          var Re, Je, Ut = {}, _t = 0;
          if (Array.isArray(Se)) {
            for (Re = Wt(fe), Je = Se.length; _t < Je; _t++) Ut[Se[_t]] = w.css(fe, Se[_t], false, Re);
            return Ut;
          }
          return Ce !== void 0 ? w.style(fe, Se, Ce) : w.css(fe, Se);
        }, M, W, arguments.length > 1);
      } });
      function me(M, W, fe, Se, Ce) {
        return new me.prototype.init(M, W, fe, Se, Ce);
      }
      w.Tween = me, me.prototype = { constructor: me, init: function(M, W, fe, Se, Ce, Re) {
        this.elem = M, this.prop = fe, this.easing = Ce || w.easing._default, this.options = W, this.start = this.now = this.cur(), this.end = Se, this.unit = Re || (w.cssNumber[fe] ? "" : "px");
      }, cur: function() {
        var M = me.propHooks[this.prop];
        return M && M.get ? M.get(this) : me.propHooks._default.get(this);
      }, run: function(M) {
        var W, fe = me.propHooks[this.prop];
        return this.options.duration ? this.pos = W = w.easing[this.easing](M, this.options.duration * M, 0, 1, this.options.duration) : this.pos = W = M, this.now = (this.end - this.start) * W + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), fe && fe.set ? fe.set(this) : me.propHooks._default.set(this), this;
      } }, me.prototype.init.prototype = me.prototype, me.propHooks = { _default: { get: function(M) {
        var W;
        return M.elem.nodeType !== 1 || M.elem[M.prop] != null && M.elem.style[M.prop] == null ? M.elem[M.prop] : (W = w.css(M.elem, M.prop, ""), !W || W === "auto" ? 0 : W);
      }, set: function(M) {
        w.fx.step[M.prop] ? w.fx.step[M.prop](M) : M.elem.nodeType === 1 && (w.cssHooks[M.prop] || M.elem.style[jr(M.prop)] != null) ? w.style(M.elem, M.prop, M.now + M.unit) : M.elem[M.prop] = M.now;
      } } }, me.propHooks.scrollTop = me.propHooks.scrollLeft = { set: function(M) {
        M.elem.nodeType && M.elem.parentNode && (M.elem[M.prop] = M.now);
      } }, w.easing = { linear: function(M) {
        return M;
      }, swing: function(M) {
        return 0.5 - Math.cos(M * Math.PI) / 2;
      }, _default: "swing" }, w.fx = me.prototype.init, w.fx.step = {};
      var ze, rt, Tt = /^(?:toggle|show|hide)$/, Ot = /queueHooks$/;
      function It() {
        rt && (d.hidden === false && e.requestAnimationFrame ? e.requestAnimationFrame(It) : e.setTimeout(It, w.fx.interval), w.fx.tick());
      }
      function We() {
        return e.setTimeout(function() {
          ze = void 0;
        }), ze = Date.now();
      }
      function mt(M, W) {
        var fe, Se = 0, Ce = { height: M };
        for (W = W ? 1 : 0; Se < 4; Se += 2 - W) fe = se[Se], Ce["margin" + fe] = Ce["padding" + fe] = M;
        return W && (Ce.opacity = Ce.width = M), Ce;
      }
      function Gt(M, W, fe) {
        for (var Se, Ce = (hr.tweeners[W] || []).concat(hr.tweeners["*"]), Re = 0, Je = Ce.length; Re < Je; Re++) if (Se = Ce[Re].call(fe, W, M)) return Se;
      }
      function ir(M, W, fe) {
        var Se, Ce, Re, Je, Ut, _t, Ht, tr, Sr = "width" in W || "height" in W, Ee = this, ot = {}, Mt = M.style, gt = M.nodeType && Ne(M), Rt = O.get(M, "fxshow");
        fe.queue || (Je = w._queueHooks(M, "fx"), Je.unqueued == null && (Je.unqueued = 0, Ut = Je.empty.fire, Je.empty.fire = function() {
          Je.unqueued || Ut();
        }), Je.unqueued++, Ee.always(function() {
          Ee.always(function() {
            Je.unqueued--, w.queue(M, "fx").length || Je.empty.fire();
          });
        }));
        for (Se in W) if (Ce = W[Se], Tt.test(Ce)) {
          if (delete W[Se], Re = Re || Ce === "toggle", Ce === (gt ? "hide" : "show")) if (Ce === "show" && Rt && Rt[Se] !== void 0) gt = true;
          else continue;
          ot[Se] = Rt && Rt[Se] || w.style(M, Se);
        }
        if (_t = !w.isEmptyObject(W), !(!_t && w.isEmptyObject(ot))) {
          Sr && M.nodeType === 1 && (fe.overflow = [Mt.overflow, Mt.overflowX, Mt.overflowY], Ht = Rt && Rt.display, Ht == null && (Ht = O.get(M, "display")), tr = w.css(M, "display"), tr === "none" && (Ht ? tr = Ht : (rr([M], true), Ht = M.style.display || Ht, tr = w.css(M, "display"), rr([M]))), (tr === "inline" || tr === "inline-block" && Ht != null) && w.css(M, "float") === "none" && (_t || (Ee.done(function() {
            Mt.display = Ht;
          }), Ht == null && (tr = Mt.display, Ht = tr === "none" ? "" : tr)), Mt.display = "inline-block")), fe.overflow && (Mt.overflow = "hidden", Ee.always(function() {
            Mt.overflow = fe.overflow[0], Mt.overflowX = fe.overflow[1], Mt.overflowY = fe.overflow[2];
          })), _t = false;
          for (Se in ot) _t || (Rt ? "hidden" in Rt && (gt = Rt.hidden) : Rt = O.access(M, "fxshow", { display: Ht }), Re && (Rt.hidden = !gt), gt && rr([M], true), Ee.done(function() {
            gt || rr([M]), O.remove(M, "fxshow");
            for (Se in ot) w.style(M, Se, ot[Se]);
          })), _t = Gt(gt ? Rt[Se] : 0, Se, Ee), Se in Rt || (Rt[Se] = _t.start, gt && (_t.end = _t.start, _t.start = 0));
        }
      }
      function dr(M, W) {
        var fe, Se, Ce, Re, Je;
        for (fe in M) if (Se = ee(fe), Ce = W[Se], Re = M[fe], Array.isArray(Re) && (Ce = Re[1], Re = M[fe] = Re[0]), fe !== Se && (M[Se] = Re, delete M[fe]), Je = w.cssHooks[Se], Je && "expand" in Je) {
          Re = Je.expand(Re), delete M[Se];
          for (fe in Re) fe in M || (M[fe] = Re[fe], W[fe] = Ce);
        } else W[Se] = Ce;
      }
      function hr(M, W, fe) {
        var Se, Ce, Re = 0, Je = hr.prefilters.length, Ut = w.Deferred().always(function() {
          delete _t.elem;
        }), _t = function() {
          if (Ce) return false;
          for (var Sr = ze || We(), Ee = Math.max(0, Ht.startTime + Ht.duration - Sr), ot = Ee / Ht.duration || 0, Mt = 1 - ot, gt = 0, Rt = Ht.tweens.length; gt < Rt; gt++) Ht.tweens[gt].run(Mt);
          return Ut.notifyWith(M, [Ht, Mt, Ee]), Mt < 1 && Rt ? Ee : (Rt || Ut.notifyWith(M, [Ht, 1, 0]), Ut.resolveWith(M, [Ht]), false);
        }, Ht = Ut.promise({ elem: M, props: w.extend({}, W), opts: w.extend(true, { specialEasing: {}, easing: w.easing._default }, fe), originalProperties: W, originalOptions: fe, startTime: ze || We(), duration: fe.duration, tweens: [], createTween: function(Sr, Ee) {
          var ot = w.Tween(M, Ht.opts, Sr, Ee, Ht.opts.specialEasing[Sr] || Ht.opts.easing);
          return Ht.tweens.push(ot), ot;
        }, stop: function(Sr) {
          var Ee = 0, ot = Sr ? Ht.tweens.length : 0;
          if (Ce) return this;
          for (Ce = true; Ee < ot; Ee++) Ht.tweens[Ee].run(1);
          return Sr ? (Ut.notifyWith(M, [Ht, 1, 0]), Ut.resolveWith(M, [Ht, Sr])) : Ut.rejectWith(M, [Ht, Sr]), this;
        } }), tr = Ht.props;
        for (dr(tr, Ht.opts.specialEasing); Re < Je; Re++) if (Se = hr.prefilters[Re].call(Ht, M, tr, Ht.opts), Se) return a(Se.stop) && (w._queueHooks(Ht.elem, Ht.opts.queue).stop = Se.stop.bind(Se)), Se;
        return w.map(tr, Gt, Ht), a(Ht.opts.start) && Ht.opts.start.call(M, Ht), Ht.progress(Ht.opts.progress).done(Ht.opts.done, Ht.opts.complete).fail(Ht.opts.fail).always(Ht.opts.always), w.fx.timer(w.extend(_t, { elem: M, anim: Ht, queue: Ht.opts.queue })), Ht;
      }
      w.Animation = w.extend(hr, { tweeners: { "*": [function(M, W) {
        var fe = this.createTween(M, W);
        return ut(fe.elem, M, Q.exec(W), fe), fe;
      }] }, tweener: function(M, W) {
        a(M) ? (W = M, M = ["*"]) : M = M.match(ae);
        for (var fe, Se = 0, Ce = M.length; Se < Ce; Se++) fe = M[Se], hr.tweeners[fe] = hr.tweeners[fe] || [], hr.tweeners[fe].unshift(W);
      }, prefilters: [ir], prefilter: function(M, W) {
        W ? hr.prefilters.unshift(M) : hr.prefilters.push(M);
      } }), w.speed = function(M, W, fe) {
        var Se = M && typeof M == "object" ? w.extend({}, M) : { complete: fe || !fe && W || a(M) && M, duration: M, easing: fe && W || W && !a(W) && W };
        return w.fx.off ? Se.duration = 0 : typeof Se.duration != "number" && (Se.duration in w.fx.speeds ? Se.duration = w.fx.speeds[Se.duration] : Se.duration = w.fx.speeds._default), (Se.queue == null || Se.queue === true) && (Se.queue = "fx"), Se.old = Se.complete, Se.complete = function() {
          a(Se.old) && Se.old.call(this), Se.queue && w.dequeue(this, Se.queue);
        }, Se;
      }, w.fn.extend({ fadeTo: function(M, W, fe, Se) {
        return this.filter(Ne).css("opacity", 0).show().end().animate({ opacity: W }, M, fe, Se);
      }, animate: function(M, W, fe, Se) {
        var Ce = w.isEmptyObject(M), Re = w.speed(W, fe, Se), Je = function() {
          var Ut = hr(this, w.extend({}, M), Re);
          (Ce || O.get(this, "finish")) && Ut.stop(true);
        };
        return Je.finish = Je, Ce || Re.queue === false ? this.each(Je) : this.queue(Re.queue, Je);
      }, stop: function(M, W, fe) {
        var Se = function(Ce) {
          var Re = Ce.stop;
          delete Ce.stop, Re(fe);
        };
        return typeof M != "string" && (fe = W, W = M, M = void 0), W && this.queue(M || "fx", []), this.each(function() {
          var Ce = true, Re = M != null && M + "queueHooks", Je = w.timers, Ut = O.get(this);
          if (Re) Ut[Re] && Ut[Re].stop && Se(Ut[Re]);
          else for (Re in Ut) Ut[Re] && Ut[Re].stop && Ot.test(Re) && Se(Ut[Re]);
          for (Re = Je.length; Re--; ) Je[Re].elem === this && (M == null || Je[Re].queue === M) && (Je[Re].anim.stop(fe), Ce = false, Je.splice(Re, 1));
          (Ce || !fe) && w.dequeue(this, M);
        });
      }, finish: function(M) {
        return M !== false && (M = M || "fx"), this.each(function() {
          var W, fe = O.get(this), Se = fe[M + "queue"], Ce = fe[M + "queueHooks"], Re = w.timers, Je = Se ? Se.length : 0;
          for (fe.finish = true, w.queue(this, M, []), Ce && Ce.stop && Ce.stop.call(this, true), W = Re.length; W--; ) Re[W].elem === this && Re[W].queue === M && (Re[W].anim.stop(true), Re.splice(W, 1));
          for (W = 0; W < Je; W++) Se[W] && Se[W].finish && Se[W].finish.call(this);
          delete fe.finish;
        });
      } }), w.each(["toggle", "show", "hide"], function(M, W) {
        var fe = w.fn[W];
        w.fn[W] = function(Se, Ce, Re) {
          return Se == null || typeof Se == "boolean" ? fe.apply(this, arguments) : this.animate(mt(W, true), Se, Ce, Re);
        };
      }), w.each({ slideDown: mt("show"), slideUp: mt("hide"), slideToggle: mt("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(M, W) {
        w.fn[M] = function(fe, Se, Ce) {
          return this.animate(W, fe, Se, Ce);
        };
      }), w.timers = [], w.fx.tick = function() {
        var M, W = 0, fe = w.timers;
        for (ze = Date.now(); W < fe.length; W++) M = fe[W], !M() && fe[W] === M && fe.splice(W--, 1);
        fe.length || w.fx.stop(), ze = void 0;
      }, w.fx.timer = function(M) {
        w.timers.push(M), w.fx.start();
      }, w.fx.interval = 13, w.fx.start = function() {
        rt || (rt = true, It());
      }, w.fx.stop = function() {
        rt = null;
      }, w.fx.speeds = { slow: 600, fast: 200, _default: 400 }, w.fn.delay = function(M, W) {
        return M = w.fx && w.fx.speeds[M] || M, W = W || "fx", this.queue(W, function(fe, Se) {
          var Ce = e.setTimeout(fe, M);
          Se.stop = function() {
            e.clearTimeout(Ce);
          };
        });
      }, function() {
        var M = d.createElement("input"), W = d.createElement("select"), fe = W.appendChild(d.createElement("option"));
        M.type = "checkbox", g.checkOn = M.value !== "", g.optSelected = fe.selected, M = d.createElement("input"), M.value = "t", M.type = "radio", g.radioValue = M.value === "t";
      }();
      var Fr, Gr = w.expr.attrHandle;
      w.fn.extend({ attr: function(M, W) {
        return Ve(this, w.attr, M, W, arguments.length > 1);
      }, removeAttr: function(M) {
        return this.each(function() {
          w.removeAttr(this, M);
        });
      } }), w.extend({ attr: function(M, W, fe) {
        var Se, Ce, Re = M.nodeType;
        if (!(Re === 3 || Re === 8 || Re === 2)) {
          if (typeof M.getAttribute > "u") return w.prop(M, W, fe);
          if ((Re !== 1 || !w.isXMLDoc(M)) && (Ce = w.attrHooks[W.toLowerCase()] || (w.expr.match.bool.test(W) ? Fr : void 0)), fe !== void 0) {
            if (fe === null) {
              w.removeAttr(M, W);
              return;
            }
            return Ce && "set" in Ce && (Se = Ce.set(M, fe, W)) !== void 0 ? Se : (M.setAttribute(W, fe + ""), fe);
          }
          return Ce && "get" in Ce && (Se = Ce.get(M, W)) !== null ? Se : (Se = w.find.attr(M, W), Se ?? void 0);
        }
      }, attrHooks: { type: { set: function(M, W) {
        if (!g.radioValue && W === "radio" && I(M, "input")) {
          var fe = M.value;
          return M.setAttribute("type", W), fe && (M.value = fe), W;
        }
      } } }, removeAttr: function(M, W) {
        var fe, Se = 0, Ce = W && W.match(ae);
        if (Ce && M.nodeType === 1) for (; fe = Ce[Se++]; ) M.removeAttribute(fe);
      } }), Fr = { set: function(M, W, fe) {
        return W === false ? w.removeAttr(M, fe) : M.setAttribute(fe, fe), fe;
      } }, w.each(w.expr.match.bool.source.match(/\w+/g), function(M, W) {
        var fe = Gr[W] || w.find.attr;
        Gr[W] = function(Se, Ce, Re) {
          var Je, Ut, _t = Ce.toLowerCase();
          return Re || (Ut = Gr[_t], Gr[_t] = Je, Je = fe(Se, Ce, Re) != null ? _t : null, Gr[_t] = Ut), Je;
        };
      });
      var Br = /^(?:input|select|textarea|button)$/i, Dr = /^(?:a|area)$/i;
      w.fn.extend({ prop: function(M, W) {
        return Ve(this, w.prop, M, W, arguments.length > 1);
      }, removeProp: function(M) {
        return this.each(function() {
          delete this[w.propFix[M] || M];
        });
      } }), w.extend({ prop: function(M, W, fe) {
        var Se, Ce, Re = M.nodeType;
        if (!(Re === 3 || Re === 8 || Re === 2)) return (Re !== 1 || !w.isXMLDoc(M)) && (W = w.propFix[W] || W, Ce = w.propHooks[W]), fe !== void 0 ? Ce && "set" in Ce && (Se = Ce.set(M, fe, W)) !== void 0 ? Se : M[W] = fe : Ce && "get" in Ce && (Se = Ce.get(M, W)) !== null ? Se : M[W];
      }, propHooks: { tabIndex: { get: function(M) {
        var W = w.find.attr(M, "tabindex");
        return W ? parseInt(W, 10) : Br.test(M.nodeName) || Dr.test(M.nodeName) && M.href ? 0 : -1;
      } } }, propFix: { for: "htmlFor", class: "className" } }), g.optSelected || (w.propHooks.selected = { get: function(M) {
        var W = M.parentNode;
        return W && W.parentNode && W.parentNode.selectedIndex, null;
      }, set: function(M) {
        var W = M.parentNode;
        W && (W.selectedIndex, W.parentNode && W.parentNode.selectedIndex);
      } }), w.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        w.propFix[this.toLowerCase()] = this;
      });
      function Vr(M) {
        var W = M.match(ae) || [];
        return W.join(" ");
      }
      function be(M) {
        return M.getAttribute && M.getAttribute("class") || "";
      }
      function Or(M) {
        return Array.isArray(M) ? M : typeof M == "string" ? M.match(ae) || [] : [];
      }
      w.fn.extend({ addClass: function(M) {
        var W, fe, Se, Ce, Re, Je;
        return a(M) ? this.each(function(Ut) {
          w(this).addClass(M.call(this, Ut, be(this)));
        }) : (W = Or(M), W.length ? this.each(function() {
          if (Se = be(this), fe = this.nodeType === 1 && " " + Vr(Se) + " ", fe) {
            for (Re = 0; Re < W.length; Re++) Ce = W[Re], fe.indexOf(" " + Ce + " ") < 0 && (fe += Ce + " ");
            Je = Vr(fe), Se !== Je && this.setAttribute("class", Je);
          }
        }) : this);
      }, removeClass: function(M) {
        var W, fe, Se, Ce, Re, Je;
        return a(M) ? this.each(function(Ut) {
          w(this).removeClass(M.call(this, Ut, be(this)));
        }) : arguments.length ? (W = Or(M), W.length ? this.each(function() {
          if (Se = be(this), fe = this.nodeType === 1 && " " + Vr(Se) + " ", fe) {
            for (Re = 0; Re < W.length; Re++) for (Ce = W[Re]; fe.indexOf(" " + Ce + " ") > -1; ) fe = fe.replace(" " + Ce + " ", " ");
            Je = Vr(fe), Se !== Je && this.setAttribute("class", Je);
          }
        }) : this) : this.attr("class", "");
      }, toggleClass: function(M, W) {
        var fe, Se, Ce, Re, Je = typeof M, Ut = Je === "string" || Array.isArray(M);
        return a(M) ? this.each(function(_t) {
          w(this).toggleClass(M.call(this, _t, be(this), W), W);
        }) : typeof W == "boolean" && Ut ? W ? this.addClass(M) : this.removeClass(M) : (fe = Or(M), this.each(function() {
          if (Ut) for (Re = w(this), Ce = 0; Ce < fe.length; Ce++) Se = fe[Ce], Re.hasClass(Se) ? Re.removeClass(Se) : Re.addClass(Se);
          else (M === void 0 || Je === "boolean") && (Se = be(this), Se && O.set(this, "__className__", Se), this.setAttribute && this.setAttribute("class", Se || M === false ? "" : O.get(this, "__className__") || ""));
        }));
      }, hasClass: function(M) {
        var W, fe, Se = 0;
        for (W = " " + M + " "; fe = this[Se++]; ) if (fe.nodeType === 1 && (" " + Vr(be(fe)) + " ").indexOf(W) > -1) return true;
        return false;
      } });
      var Ue = /\r/g;
      w.fn.extend({ val: function(M) {
        var W, fe, Se, Ce = this[0];
        return arguments.length ? (Se = a(M), this.each(function(Re) {
          var Je;
          this.nodeType === 1 && (Se ? Je = M.call(this, Re, w(this).val()) : Je = M, Je == null ? Je = "" : typeof Je == "number" ? Je += "" : Array.isArray(Je) && (Je = w.map(Je, function(Ut) {
            return Ut == null ? "" : Ut + "";
          })), W = w.valHooks[this.type] || w.valHooks[this.nodeName.toLowerCase()], (!W || !("set" in W) || W.set(this, Je, "value") === void 0) && (this.value = Je));
        })) : Ce ? (W = w.valHooks[Ce.type] || w.valHooks[Ce.nodeName.toLowerCase()], W && "get" in W && (fe = W.get(Ce, "value")) !== void 0 ? fe : (fe = Ce.value, typeof fe == "string" ? fe.replace(Ue, "") : fe ?? "")) : void 0;
      } }), w.extend({ valHooks: { option: { get: function(M) {
        var W = w.find.attr(M, "value");
        return W ?? Vr(w.text(M));
      } }, select: { get: function(M) {
        var W, fe, Se, Ce = M.options, Re = M.selectedIndex, Je = M.type === "select-one", Ut = Je ? null : [], _t = Je ? Re + 1 : Ce.length;
        for (Re < 0 ? Se = _t : Se = Je ? Re : 0; Se < _t; Se++) if (fe = Ce[Se], (fe.selected || Se === Re) && !fe.disabled && (!fe.parentNode.disabled || !I(fe.parentNode, "optgroup"))) {
          if (W = w(fe).val(), Je) return W;
          Ut.push(W);
        }
        return Ut;
      }, set: function(M, W) {
        for (var fe, Se, Ce = M.options, Re = w.makeArray(W), Je = Ce.length; Je--; ) Se = Ce[Je], (Se.selected = w.inArray(w.valHooks.option.get(Se), Re) > -1) && (fe = true);
        return fe || (M.selectedIndex = -1), Re;
      } } } }), w.each(["radio", "checkbox"], function() {
        w.valHooks[this] = { set: function(M, W) {
          if (Array.isArray(W)) return M.checked = w.inArray(w(M).val(), W) > -1;
        } }, g.checkOn || (w.valHooks[this].get = function(M) {
          return M.getAttribute("value") === null ? "on" : M.value;
        });
      });
      var it = e.location, dt = { guid: Date.now() }, vt = /\?/;
      w.parseXML = function(M) {
        var W, fe;
        if (!M || typeof M != "string") return null;
        try {
          W = new e.DOMParser().parseFromString(M, "text/xml");
        } catch {
        }
        return fe = W && W.getElementsByTagName("parsererror")[0], (!W || fe) && w.error("Invalid XML: " + (fe ? w.map(fe.childNodes, function(Se) {
          return Se.textContent;
        }).join(`
`) : M)), W;
      };
      var wt = /^(?:focusinfocus|focusoutblur)$/, Pt = function(M) {
        M.stopPropagation();
      };
      w.extend(w.event, { trigger: function(M, W, fe, Se) {
        var Ce, Re, Je, Ut, _t, Ht, tr, Sr, Ee = [fe || d], ot = f.call(M, "type") ? M.type : M, Mt = f.call(M, "namespace") ? M.namespace.split(".") : [];
        if (Re = Sr = Je = fe = fe || d, !(fe.nodeType === 3 || fe.nodeType === 8) && !wt.test(ot + w.event.triggered) && (ot.indexOf(".") > -1 && (Mt = ot.split("."), ot = Mt.shift(), Mt.sort()), _t = ot.indexOf(":") < 0 && "on" + ot, M = M[w.expando] ? M : new w.Event(ot, typeof M == "object" && M), M.isTrigger = Se ? 2 : 3, M.namespace = Mt.join("."), M.rnamespace = M.namespace ? new RegExp("(^|\\.)" + Mt.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, M.result = void 0, M.target || (M.target = fe), W = W == null ? [M] : w.makeArray(W, [M]), tr = w.event.special[ot] || {}, !(!Se && tr.trigger && tr.trigger.apply(fe, W) === false))) {
          if (!Se && !tr.noBubble && !l(fe)) {
            for (Ut = tr.delegateType || ot, wt.test(Ut + ot) || (Re = Re.parentNode); Re; Re = Re.parentNode) Ee.push(Re), Je = Re;
            Je === (fe.ownerDocument || d) && Ee.push(Je.defaultView || Je.parentWindow || e);
          }
          for (Ce = 0; (Re = Ee[Ce++]) && !M.isPropagationStopped(); ) Sr = Re, M.type = Ce > 1 ? Ut : tr.bindType || ot, Ht = (O.get(Re, "events") || /* @__PURE__ */ Object.create(null))[M.type] && O.get(Re, "handle"), Ht && Ht.apply(Re, W), Ht = _t && Re[_t], Ht && Ht.apply && P(Re) && (M.result = Ht.apply(Re, W), M.result === false && M.preventDefault());
          return M.type = ot, !Se && !M.isDefaultPrevented() && (!tr._default || tr._default.apply(Ee.pop(), W) === false) && P(fe) && _t && a(fe[ot]) && !l(fe) && (Je = fe[_t], Je && (fe[_t] = null), w.event.triggered = ot, M.isPropagationStopped() && Sr.addEventListener(ot, Pt), fe[ot](), M.isPropagationStopped() && Sr.removeEventListener(ot, Pt), w.event.triggered = void 0, Je && (fe[_t] = Je)), M.result;
        }
      }, simulate: function(M, W, fe) {
        var Se = w.extend(new w.Event(), fe, { type: M, isSimulated: true });
        w.event.trigger(Se, null, W);
      } }), w.fn.extend({ trigger: function(M, W) {
        return this.each(function() {
          w.event.trigger(M, W, this);
        });
      }, triggerHandler: function(M, W) {
        var fe = this[0];
        if (fe) return w.event.trigger(M, W, fe, true);
      } });
      var Yt = /\[\]$/, cr = /\r?\n/g, qr = /^(?:submit|button|image|reset|file)$/i, Vt = /^(?:input|select|textarea|keygen)/i;
      function zr(M, W, fe, Se) {
        var Ce;
        if (Array.isArray(W)) w.each(W, function(Re, Je) {
          fe || Yt.test(M) ? Se(M, Je) : zr(M + "[" + (typeof Je == "object" && Je != null ? Re : "") + "]", Je, fe, Se);
        });
        else if (!fe && E(W) === "object") for (Ce in W) zr(M + "[" + Ce + "]", W[Ce], fe, Se);
        else Se(M, W);
      }
      w.param = function(M, W) {
        var fe, Se = [], Ce = function(Re, Je) {
          var Ut = a(Je) ? Je() : Je;
          Se[Se.length] = encodeURIComponent(Re) + "=" + encodeURIComponent(Ut ?? "");
        };
        if (M == null) return "";
        if (Array.isArray(M) || M.jquery && !w.isPlainObject(M)) w.each(M, function() {
          Ce(this.name, this.value);
        });
        else for (fe in M) zr(fe, M[fe], W, Ce);
        return Se.join("&");
      }, w.fn.extend({ serialize: function() {
        return w.param(this.serializeArray());
      }, serializeArray: function() {
        return this.map(function() {
          var M = w.prop(this, "elements");
          return M ? w.makeArray(M) : this;
        }).filter(function() {
          var M = this.type;
          return this.name && !w(this).is(":disabled") && Vt.test(this.nodeName) && !qr.test(M) && (this.checked || !je.test(M));
        }).map(function(M, W) {
          var fe = w(this).val();
          return fe == null ? null : Array.isArray(fe) ? w.map(fe, function(Se) {
            return { name: W.name, value: Se.replace(cr, `\r
`) };
          }) : { name: W.name, value: fe.replace(cr, `\r
`) };
        }).get();
      } });
      var en = /%20/g, Me = /#.*$/, De = /([?&])_=[^&]*/, Ke = /^(.*?):[ \t]*([^\r\n]*)$/mg, Bt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, St = /^(?:GET|HEAD)$/, ur = /^\/\//, Cr = {}, Wr = {}, Zr = "*/".concat("*"), dn = d.createElement("a");
      dn.href = it.href;
      function wn(M) {
        return function(W, fe) {
          typeof W != "string" && (fe = W, W = "*");
          var Se, Ce = 0, Re = W.toLowerCase().match(ae) || [];
          if (a(fe)) for (; Se = Re[Ce++]; ) Se[0] === "+" ? (Se = Se.slice(1) || "*", (M[Se] = M[Se] || []).unshift(fe)) : (M[Se] = M[Se] || []).push(fe);
        };
      }
      function yn(M, W, fe, Se) {
        var Ce = {}, Re = M === Wr;
        function Je(Ut) {
          var _t;
          return Ce[Ut] = true, w.each(M[Ut] || [], function(Ht, tr) {
            var Sr = tr(W, fe, Se);
            if (typeof Sr == "string" && !Re && !Ce[Sr]) return W.dataTypes.unshift(Sr), Je(Sr), false;
            if (Re) return !(_t = Sr);
          }), _t;
        }
        return Je(W.dataTypes[0]) || !Ce["*"] && Je("*");
      }
      function pi(M, W) {
        var fe, Se, Ce = w.ajaxSettings.flatOptions || {};
        for (fe in W) W[fe] !== void 0 && ((Ce[fe] ? M : Se || (Se = {}))[fe] = W[fe]);
        return Se && w.extend(true, M, Se), M;
      }
      function Bi(M, W, fe) {
        for (var Se, Ce, Re, Je, Ut = M.contents, _t = M.dataTypes; _t[0] === "*"; ) _t.shift(), Se === void 0 && (Se = M.mimeType || W.getResponseHeader("Content-Type"));
        if (Se) {
          for (Ce in Ut) if (Ut[Ce] && Ut[Ce].test(Se)) {
            _t.unshift(Ce);
            break;
          }
        }
        if (_t[0] in fe) Re = _t[0];
        else {
          for (Ce in fe) {
            if (!_t[0] || M.converters[Ce + " " + _t[0]]) {
              Re = Ce;
              break;
            }
            Je || (Je = Ce);
          }
          Re = Re || Je;
        }
        if (Re) return Re !== _t[0] && _t.unshift(Re), fe[Re];
      }
      function Ni(M, W, fe, Se) {
        var Ce, Re, Je, Ut, _t, Ht = {}, tr = M.dataTypes.slice();
        if (tr[1]) for (Je in M.converters) Ht[Je.toLowerCase()] = M.converters[Je];
        for (Re = tr.shift(); Re; ) if (M.responseFields[Re] && (fe[M.responseFields[Re]] = W), !_t && Se && M.dataFilter && (W = M.dataFilter(W, M.dataType)), _t = Re, Re = tr.shift(), Re) {
          if (Re === "*") Re = _t;
          else if (_t !== "*" && _t !== Re) {
            if (Je = Ht[_t + " " + Re] || Ht["* " + Re], !Je) {
              for (Ce in Ht) if (Ut = Ce.split(" "), Ut[1] === Re && (Je = Ht[_t + " " + Ut[0]] || Ht["* " + Ut[0]], Je)) {
                Je === true ? Je = Ht[Ce] : Ht[Ce] !== true && (Re = Ut[0], tr.unshift(Ut[1]));
                break;
              }
            }
            if (Je !== true) if (Je && M.throws) W = Je(W);
            else try {
              W = Je(W);
            } catch (Sr) {
              return { state: "parsererror", error: Je ? Sr : "No conversion from " + _t + " to " + Re };
            }
          }
        }
        return { state: "success", data: W };
      }
      w.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: it.href, type: "GET", isLocal: Bt.test(it.protocol), global: true, processData: true, async: true, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Zr, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": true, "text json": JSON.parse, "text xml": w.parseXML }, flatOptions: { url: true, context: true } }, ajaxSetup: function(M, W) {
        return W ? pi(pi(M, w.ajaxSettings), W) : pi(w.ajaxSettings, M);
      }, ajaxPrefilter: wn(Cr), ajaxTransport: wn(Wr), ajax: function(M, W) {
        typeof M == "object" && (W = M, M = void 0), W = W || {};
        var fe, Se, Ce, Re, Je, Ut, _t, Ht, tr, Sr, Ee = w.ajaxSetup({}, W), ot = Ee.context || Ee, Mt = Ee.context && (ot.nodeType || ot.jquery) ? w(ot) : w.event, gt = w.Deferred(), Rt = w.Callbacks("once memory"), or = Ee.statusCode || {}, nr = {}, Qr = {}, Xr = "canceled", Yr = { readyState: 0, getResponseHeader: function(Kr) {
          var Ir;
          if (_t) {
            if (!Re) for (Re = {}; Ir = Ke.exec(Ce); ) Re[Ir[1].toLowerCase() + " "] = (Re[Ir[1].toLowerCase() + " "] || []).concat(Ir[2]);
            Ir = Re[Kr.toLowerCase() + " "];
          }
          return Ir == null ? null : Ir.join(", ");
        }, getAllResponseHeaders: function() {
          return _t ? Ce : null;
        }, setRequestHeader: function(Kr, Ir) {
          return _t == null && (Kr = Qr[Kr.toLowerCase()] = Qr[Kr.toLowerCase()] || Kr, nr[Kr] = Ir), this;
        }, overrideMimeType: function(Kr) {
          return _t == null && (Ee.mimeType = Kr), this;
        }, statusCode: function(Kr) {
          var Ir;
          if (Kr) if (_t) Yr.always(Kr[Yr.status]);
          else for (Ir in Kr) or[Ir] = [or[Ir], Kr[Ir]];
          return this;
        }, abort: function(Kr) {
          var Ir = Kr || Xr;
          return fe && fe.abort(Ir), un(0, Ir), this;
        } };
        if (gt.promise(Yr), Ee.url = ((M || Ee.url || it.href) + "").replace(ur, it.protocol + "//"), Ee.type = W.method || W.type || Ee.method || Ee.type, Ee.dataTypes = (Ee.dataType || "*").toLowerCase().match(ae) || [""], Ee.crossDomain == null) {
          Ut = d.createElement("a");
          try {
            Ut.href = Ee.url, Ut.href = Ut.href, Ee.crossDomain = dn.protocol + "//" + dn.host != Ut.protocol + "//" + Ut.host;
          } catch {
            Ee.crossDomain = true;
          }
        }
        if (Ee.data && Ee.processData && typeof Ee.data != "string" && (Ee.data = w.param(Ee.data, Ee.traditional)), yn(Cr, Ee, W, Yr), _t) return Yr;
        Ht = w.event && Ee.global, Ht && w.active++ === 0 && w.event.trigger("ajaxStart"), Ee.type = Ee.type.toUpperCase(), Ee.hasContent = !St.test(Ee.type), Se = Ee.url.replace(Me, ""), Ee.hasContent ? Ee.data && Ee.processData && (Ee.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && (Ee.data = Ee.data.replace(en, "+")) : (Sr = Ee.url.slice(Se.length), Ee.data && (Ee.processData || typeof Ee.data == "string") && (Se += (vt.test(Se) ? "&" : "?") + Ee.data, delete Ee.data), Ee.cache === false && (Se = Se.replace(De, "$1"), Sr = (vt.test(Se) ? "&" : "?") + "_=" + dt.guid++ + Sr), Ee.url = Se + Sr), Ee.ifModified && (w.lastModified[Se] && Yr.setRequestHeader("If-Modified-Since", w.lastModified[Se]), w.etag[Se] && Yr.setRequestHeader("If-None-Match", w.etag[Se])), (Ee.data && Ee.hasContent && Ee.contentType !== false || W.contentType) && Yr.setRequestHeader("Content-Type", Ee.contentType), Yr.setRequestHeader("Accept", Ee.dataTypes[0] && Ee.accepts[Ee.dataTypes[0]] ? Ee.accepts[Ee.dataTypes[0]] + (Ee.dataTypes[0] !== "*" ? ", " + Zr + "; q=0.01" : "") : Ee.accepts["*"]);
        for (tr in Ee.headers) Yr.setRequestHeader(tr, Ee.headers[tr]);
        if (Ee.beforeSend && (Ee.beforeSend.call(ot, Yr, Ee) === false || _t)) return Yr.abort();
        if (Xr = "abort", Rt.add(Ee.complete), Yr.done(Ee.success), Yr.fail(Ee.error), fe = yn(Wr, Ee, W, Yr), !fe) un(-1, "No Transport");
        else {
          if (Yr.readyState = 1, Ht && Mt.trigger("ajaxSend", [Yr, Ee]), _t) return Yr;
          Ee.async && Ee.timeout > 0 && (Je = e.setTimeout(function() {
            Yr.abort("timeout");
          }, Ee.timeout));
          try {
            _t = false, fe.send(nr, un);
          } catch (Kr) {
            if (_t) throw Kr;
            un(-1, Kr);
          }
        }
        function un(Kr, Ir, An, En) {
          var Sn, On, gn, Bn, jn, qn = Ir;
          _t || (_t = true, Je && e.clearTimeout(Je), fe = void 0, Ce = En || "", Yr.readyState = Kr > 0 ? 4 : 0, Sn = Kr >= 200 && Kr < 300 || Kr === 304, An && (Bn = Bi(Ee, Yr, An)), !Sn && w.inArray("script", Ee.dataTypes) > -1 && w.inArray("json", Ee.dataTypes) < 0 && (Ee.converters["text script"] = function() {
          }), Bn = Ni(Ee, Bn, Yr, Sn), Sn ? (Ee.ifModified && (jn = Yr.getResponseHeader("Last-Modified"), jn && (w.lastModified[Se] = jn), jn = Yr.getResponseHeader("etag"), jn && (w.etag[Se] = jn)), Kr === 204 || Ee.type === "HEAD" ? qn = "nocontent" : Kr === 304 ? qn = "notmodified" : (qn = Bn.state, On = Bn.data, gn = Bn.error, Sn = !gn)) : (gn = qn, (Kr || !qn) && (qn = "error", Kr < 0 && (Kr = 0))), Yr.status = Kr, Yr.statusText = (Ir || qn) + "", Sn ? gt.resolveWith(ot, [On, qn, Yr]) : gt.rejectWith(ot, [Yr, qn, gn]), Yr.statusCode(or), or = void 0, Ht && Mt.trigger(Sn ? "ajaxSuccess" : "ajaxError", [Yr, Ee, Sn ? On : gn]), Rt.fireWith(ot, [Yr, qn]), Ht && (Mt.trigger("ajaxComplete", [Yr, Ee]), --w.active || w.event.trigger("ajaxStop")));
        }
        return Yr;
      }, getJSON: function(M, W, fe) {
        return w.get(M, W, fe, "json");
      }, getScript: function(M, W) {
        return w.get(M, void 0, W, "script");
      } }), w.each(["get", "post"], function(M, W) {
        w[W] = function(fe, Se, Ce, Re) {
          return a(Se) && (Re = Re || Ce, Ce = Se, Se = void 0), w.ajax(w.extend({ url: fe, type: W, dataType: Re, data: Se, success: Ce }, w.isPlainObject(fe) && fe));
        };
      }), w.ajaxPrefilter(function(M) {
        var W;
        for (W in M.headers) W.toLowerCase() === "content-type" && (M.contentType = M.headers[W] || "");
      }), w._evalUrl = function(M, W, fe) {
        return w.ajax({ url: M, type: "GET", dataType: "script", cache: true, async: false, global: false, converters: { "text script": function() {
        } }, dataFilter: function(Se) {
          w.globalEval(Se, W, fe);
        } });
      }, w.fn.extend({ wrapAll: function(M) {
        var W;
        return this[0] && (a(M) && (M = M.call(this[0])), W = w(M, this[0].ownerDocument).eq(0).clone(true), this[0].parentNode && W.insertBefore(this[0]), W.map(function() {
          for (var fe = this; fe.firstElementChild; ) fe = fe.firstElementChild;
          return fe;
        }).append(this)), this;
      }, wrapInner: function(M) {
        return a(M) ? this.each(function(W) {
          w(this).wrapInner(M.call(this, W));
        }) : this.each(function() {
          var W = w(this), fe = W.contents();
          fe.length ? fe.wrapAll(M) : W.append(M);
        });
      }, wrap: function(M) {
        var W = a(M);
        return this.each(function(fe) {
          w(this).wrapAll(W ? M.call(this, fe) : M);
        });
      }, unwrap: function(M) {
        return this.parent(M).not("body").each(function() {
          w(this).replaceWith(this.childNodes);
        }), this;
      } }), w.expr.pseudos.hidden = function(M) {
        return !w.expr.pseudos.visible(M);
      }, w.expr.pseudos.visible = function(M) {
        return !!(M.offsetWidth || M.offsetHeight || M.getClientRects().length);
      }, w.ajaxSettings.xhr = function() {
        try {
          return new e.XMLHttpRequest();
        } catch {
        }
      };
      var Un = { 0: 200, 1223: 204 }, Xe = w.ajaxSettings.xhr();
      g.cors = !!Xe && "withCredentials" in Xe, g.ajax = Xe = !!Xe, w.ajaxTransport(function(M) {
        var W, fe;
        if (g.cors || Xe && !M.crossDomain) return { send: function(Se, Ce) {
          var Re, Je = M.xhr();
          if (Je.open(M.type, M.url, M.async, M.username, M.password), M.xhrFields) for (Re in M.xhrFields) Je[Re] = M.xhrFields[Re];
          M.mimeType && Je.overrideMimeType && Je.overrideMimeType(M.mimeType), !M.crossDomain && !Se["X-Requested-With"] && (Se["X-Requested-With"] = "XMLHttpRequest");
          for (Re in Se) Je.setRequestHeader(Re, Se[Re]);
          W = function(Ut) {
            return function() {
              W && (W = fe = Je.onload = Je.onerror = Je.onabort = Je.ontimeout = Je.onreadystatechange = null, Ut === "abort" ? Je.abort() : Ut === "error" ? typeof Je.status != "number" ? Ce(0, "error") : Ce(Je.status, Je.statusText) : Ce(Un[Je.status] || Je.status, Je.statusText, (Je.responseType || "text") !== "text" || typeof Je.responseText != "string" ? { binary: Je.response } : { text: Je.responseText }, Je.getAllResponseHeaders()));
            };
          }, Je.onload = W(), fe = Je.onerror = Je.ontimeout = W("error"), Je.onabort !== void 0 ? Je.onabort = fe : Je.onreadystatechange = function() {
            Je.readyState === 4 && e.setTimeout(function() {
              W && fe();
            });
          }, W = W("abort");
          try {
            Je.send(M.hasContent && M.data || null);
          } catch (Ut) {
            if (W) throw Ut;
          }
        }, abort: function() {
          W && W();
        } };
      }), w.ajaxPrefilter(function(M) {
        M.crossDomain && (M.contents.script = false);
      }), w.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /\b(?:java|ecma)script\b/ }, converters: { "text script": function(M) {
        return w.globalEval(M), M;
      } } }), w.ajaxPrefilter("script", function(M) {
        M.cache === void 0 && (M.cache = false), M.crossDomain && (M.type = "GET");
      }), w.ajaxTransport("script", function(M) {
        if (M.crossDomain || M.scriptAttrs) {
          var W, fe;
          return { send: function(Se, Ce) {
            W = w("<script>").attr(M.scriptAttrs || {}).prop({ charset: M.scriptCharset, src: M.url }).on("load error", fe = function(Re) {
              W.remove(), fe = null, Re && Ce(Re.type === "error" ? 404 : 200, Re.type);
            }), d.head.appendChild(W[0]);
          }, abort: function() {
            fe && fe();
          } };
        }
      });
      var Ye = [], bt = /(=)\?(?=&|$)|\?\?/;
      w.ajaxSetup({ jsonp: "callback", jsonpCallback: function() {
        var M = Ye.pop() || w.expando + "_" + dt.guid++;
        return this[M] = true, M;
      } }), w.ajaxPrefilter("json jsonp", function(M, W, fe) {
        var Se, Ce, Re, Je = M.jsonp !== false && (bt.test(M.url) ? "url" : typeof M.data == "string" && (M.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && bt.test(M.data) && "data");
        if (Je || M.dataTypes[0] === "jsonp") return Se = M.jsonpCallback = a(M.jsonpCallback) ? M.jsonpCallback() : M.jsonpCallback, Je ? M[Je] = M[Je].replace(bt, "$1" + Se) : M.jsonp !== false && (M.url += (vt.test(M.url) ? "&" : "?") + M.jsonp + "=" + Se), M.converters["script json"] = function() {
          return Re || w.error(Se + " was not called"), Re[0];
        }, M.dataTypes[0] = "json", Ce = e[Se], e[Se] = function() {
          Re = arguments;
        }, fe.always(function() {
          Ce === void 0 ? w(e).removeProp(Se) : e[Se] = Ce, M[Se] && (M.jsonpCallback = W.jsonpCallback, Ye.push(Se)), Re && a(Ce) && Ce(Re[0]), Re = Ce = void 0;
        }), "script";
      }), g.createHTMLDocument = function() {
        var M = d.implementation.createHTMLDocument("").body;
        return M.innerHTML = "<form></form><form></form>", M.childNodes.length === 2;
      }(), w.parseHTML = function(M, W, fe) {
        if (typeof M != "string") return [];
        typeof W == "boolean" && (fe = W, W = false);
        var Se, Ce, Re;
        return W || (g.createHTMLDocument ? (W = d.implementation.createHTMLDocument(""), Se = W.createElement("base"), Se.href = d.location.href, W.head.appendChild(Se)) : W = d), Ce = J.exec(M), Re = !fe && [], Ce ? [W.createElement(Ce[1])] : (Ce = wr([M], W, Re), Re && Re.length && w(Re).remove(), w.merge([], Ce.childNodes));
      }, w.fn.load = function(M, W, fe) {
        var Se, Ce, Re, Je = this, Ut = M.indexOf(" ");
        return Ut > -1 && (Se = Vr(M.slice(Ut)), M = M.slice(0, Ut)), a(W) ? (fe = W, W = void 0) : W && typeof W == "object" && (Ce = "POST"), Je.length > 0 && w.ajax({ url: M, type: Ce || "GET", dataType: "html", data: W }).done(function(_t) {
          Re = arguments, Je.html(Se ? w("<div>").append(w.parseHTML(_t)).find(Se) : _t);
        }).always(fe && function(_t, Ht) {
          Je.each(function() {
            fe.apply(this, Re || [_t.responseText, Ht, _t]);
          });
        }), this;
      }, w.expr.pseudos.animated = function(M) {
        return w.grep(w.timers, function(W) {
          return M === W.elem;
        }).length;
      }, w.offset = { setOffset: function(M, W, fe) {
        var Se, Ce, Re, Je, Ut, _t, Ht, tr = w.css(M, "position"), Sr = w(M), Ee = {};
        tr === "static" && (M.style.position = "relative"), Ut = Sr.offset(), Re = w.css(M, "top"), _t = w.css(M, "left"), Ht = (tr === "absolute" || tr === "fixed") && (Re + _t).indexOf("auto") > -1, Ht ? (Se = Sr.position(), Je = Se.top, Ce = Se.left) : (Je = parseFloat(Re) || 0, Ce = parseFloat(_t) || 0), a(W) && (W = W.call(M, fe, w.extend({}, Ut))), W.top != null && (Ee.top = W.top - Ut.top + Je), W.left != null && (Ee.left = W.left - Ut.left + Ce), "using" in W ? W.using.call(M, Ee) : Sr.css(Ee);
      } }, w.fn.extend({ offset: function(M) {
        if (arguments.length) return M === void 0 ? this : this.each(function(Ce) {
          w.offset.setOffset(this, M, Ce);
        });
        var W, fe, Se = this[0];
        if (Se) return Se.getClientRects().length ? (W = Se.getBoundingClientRect(), fe = Se.ownerDocument.defaultView, { top: W.top + fe.pageYOffset, left: W.left + fe.pageXOffset }) : { top: 0, left: 0 };
      }, position: function() {
        if (this[0]) {
          var M, W, fe, Se = this[0], Ce = { top: 0, left: 0 };
          if (w.css(Se, "position") === "fixed") W = Se.getBoundingClientRect();
          else {
            for (W = this.offset(), fe = Se.ownerDocument, M = Se.offsetParent || fe.documentElement; M && (M === fe.body || M === fe.documentElement) && w.css(M, "position") === "static"; ) M = M.parentNode;
            M && M !== Se && M.nodeType === 1 && (Ce = w(M).offset(), Ce.top += w.css(M, "borderTopWidth", true), Ce.left += w.css(M, "borderLeftWidth", true));
          }
          return { top: W.top - Ce.top - w.css(Se, "marginTop", true), left: W.left - Ce.left - w.css(Se, "marginLeft", true) };
        }
      }, offsetParent: function() {
        return this.map(function() {
          for (var M = this.offsetParent; M && w.css(M, "position") === "static"; ) M = M.offsetParent;
          return M || X;
        });
      } }), w.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(M, W) {
        var fe = W === "pageYOffset";
        w.fn[M] = function(Se) {
          return Ve(this, function(Ce, Re, Je) {
            var Ut;
            if (l(Ce) ? Ut = Ce : Ce.nodeType === 9 && (Ut = Ce.defaultView), Je === void 0) return Ut ? Ut[W] : Ce[Re];
            Ut ? Ut.scrollTo(fe ? Ut.pageXOffset : Je, fe ? Je : Ut.pageYOffset) : Ce[Re] = Je;
          }, M, Se, arguments.length);
        };
      }), w.each(["top", "left"], function(M, W) {
        w.cssHooks[W] = gr(g.pixelPosition, function(fe, Se) {
          if (Se) return Se = sr(fe, W), Ct.test(Se) ? w(fe).position()[W] + "px" : Se;
        });
      }), w.each({ Height: "height", Width: "width" }, function(M, W) {
        w.each({ padding: "inner" + M, content: W, "": "outer" + M }, function(fe, Se) {
          w.fn[Se] = function(Ce, Re) {
            var Je = arguments.length && (fe || typeof Ce != "boolean"), Ut = fe || (Ce === true || Re === true ? "margin" : "border");
            return Ve(this, function(_t, Ht, tr) {
              var Sr;
              return l(_t) ? Se.indexOf("outer") === 0 ? _t["inner" + M] : _t.document.documentElement["client" + M] : _t.nodeType === 9 ? (Sr = _t.documentElement, Math.max(_t.body["scroll" + M], Sr["scroll" + M], _t.body["offset" + M], Sr["offset" + M], Sr["client" + M])) : tr === void 0 ? w.css(_t, Ht, Ut) : w.style(_t, Ht, tr, Ut);
            }, W, Je ? Ce : void 0, Je);
          };
        });
      }), w.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(M, W) {
        w.fn[W] = function(fe) {
          return this.on(W, fe);
        };
      }), w.fn.extend({ bind: function(M, W, fe) {
        return this.on(M, null, W, fe);
      }, unbind: function(M, W) {
        return this.off(M, null, W);
      }, delegate: function(M, W, fe, Se) {
        return this.on(W, M, fe, Se);
      }, undelegate: function(M, W, fe) {
        return arguments.length === 1 ? this.off(M, "**") : this.off(W, M || "**", fe);
      }, hover: function(M, W) {
        return this.on("mouseenter", M).on("mouseleave", W || M);
      } }), w.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(M, W) {
        w.fn[W] = function(fe, Se) {
          return arguments.length > 0 ? this.on(W, null, fe, Se) : this.trigger(W);
        };
      });
      var xt = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      w.proxy = function(M, W) {
        var fe, Se, Ce;
        if (typeof W == "string" && (fe = M[W], W = M, M = fe), !!a(M)) return Se = y.call(arguments, 2), Ce = function() {
          return M.apply(W || this, Se.concat(y.call(arguments)));
        }, Ce.guid = M.guid = M.guid || w.guid++, Ce;
      }, w.holdReady = function(M) {
        M ? w.readyWait++ : w.ready(true);
      }, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = I, w.isFunction = a, w.isWindow = l, w.camelCase = ee, w.type = E, w.now = Date.now, w.isNumeric = function(M) {
        var W = w.type(M);
        return (W === "number" || W === "string") && !isNaN(M - parseFloat(M));
      }, w.trim = function(M) {
        return M == null ? "" : (M + "").replace(xt, "$1");
      };
      var $t = e.jQuery, fr = e.$;
      return w.noConflict = function(M) {
        return e.$ === w && (e.$ = fr), M && e.jQuery === w && (e.jQuery = $t), w;
      }, typeof n > "u" && (e.jQuery = e.$ = w), w;
    });
  }(nc)), nc.exports;
}
var dy = hy();
const $r = $d(dy);
var Lc = {}, Va = {}, Of;
function my() {
  if (Of) return Va;
  Of = 1, Va.byteLength = o, Va.toByteArray = c, Va.fromByteArray = r;
  for (var v = [], e = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, y = i.length; s < y; ++s) v[s] = i[s], e[i.charCodeAt(s)] = s;
  e[45] = 62, e[95] = 63;
  function t(m) {
    var g = m.length;
    if (g % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var a = m.indexOf("=");
    a === -1 && (a = g);
    var l = a === g ? 0 : 4 - a % 4;
    return [a, l];
  }
  function o(m) {
    var g = t(m), a = g[0], l = g[1];
    return (a + l) * 3 / 4 - l;
  }
  function u(m, g, a) {
    return (g + a) * 3 / 4 - a;
  }
  function c(m) {
    var g, a = t(m), l = a[0], d = a[1], b = new n(u(m, l, d)), S = 0, E = d > 0 ? l - 4 : l, R;
    for (R = 0; R < E; R += 4) g = e[m.charCodeAt(R)] << 18 | e[m.charCodeAt(R + 1)] << 12 | e[m.charCodeAt(R + 2)] << 6 | e[m.charCodeAt(R + 3)], b[S++] = g >> 16 & 255, b[S++] = g >> 8 & 255, b[S++] = g & 255;
    return d === 2 && (g = e[m.charCodeAt(R)] << 2 | e[m.charCodeAt(R + 1)] >> 4, b[S++] = g & 255), d === 1 && (g = e[m.charCodeAt(R)] << 10 | e[m.charCodeAt(R + 1)] << 4 | e[m.charCodeAt(R + 2)] >> 2, b[S++] = g >> 8 & 255, b[S++] = g & 255), b;
  }
  function h(m) {
    return v[m >> 18 & 63] + v[m >> 12 & 63] + v[m >> 6 & 63] + v[m & 63];
  }
  function f(m, g, a) {
    for (var l, d = [], b = g; b < a; b += 3) l = (m[b] << 16 & 16711680) + (m[b + 1] << 8 & 65280) + (m[b + 2] & 255), d.push(h(l));
    return d.join("");
  }
  function r(m) {
    for (var g, a = m.length, l = a % 3, d = [], b = 16383, S = 0, E = a - l; S < E; S += b) d.push(f(m, S, S + b > E ? E : S + b));
    return l === 1 ? (g = m[a - 1], d.push(v[g >> 2] + v[g << 4 & 63] + "==")) : l === 2 && (g = (m[a - 2] << 8) + m[a - 1], d.push(v[g >> 10] + v[g >> 4 & 63] + v[g << 2 & 63] + "=")), d.join("");
  }
  return Va;
}
var Gs = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Pf;
function yy() {
  return Pf || (Pf = 1, Gs.read = function(v, e, n, i, s) {
    var y, t, o = s * 8 - i - 1, u = (1 << o) - 1, c = u >> 1, h = -7, f = n ? s - 1 : 0, r = n ? -1 : 1, m = v[e + f];
    for (f += r, y = m & (1 << -h) - 1, m >>= -h, h += o; h > 0; y = y * 256 + v[e + f], f += r, h -= 8) ;
    for (t = y & (1 << -h) - 1, y >>= -h, h += i; h > 0; t = t * 256 + v[e + f], f += r, h -= 8) ;
    if (y === 0) y = 1 - c;
    else {
      if (y === u) return t ? NaN : (m ? -1 : 1) * (1 / 0);
      t = t + Math.pow(2, i), y = y - c;
    }
    return (m ? -1 : 1) * t * Math.pow(2, y - i);
  }, Gs.write = function(v, e, n, i, s, y) {
    var t, o, u, c = y * 8 - s - 1, h = (1 << c) - 1, f = h >> 1, r = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, m = i ? 0 : y - 1, g = i ? 1 : -1, a = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, t = h) : (t = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -t)) < 1 && (t--, u *= 2), t + f >= 1 ? e += r / u : e += r * Math.pow(2, 1 - f), e * u >= 2 && (t++, u /= 2), t + f >= h ? (o = 0, t = h) : t + f >= 1 ? (o = (e * u - 1) * Math.pow(2, s), t = t + f) : (o = e * Math.pow(2, f - 1) * Math.pow(2, s), t = 0)); s >= 8; v[n + m] = o & 255, m += g, o /= 256, s -= 8) ;
    for (t = t << s | o, c += s; c > 0; v[n + m] = t & 255, m += g, t /= 256, c -= 8) ;
    v[n + m - g] |= a * 128;
  }), Gs;
}
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
var Cf;
function Yd() {
  return Cf || (Cf = 1, function(v) {
    const e = my(), n = yy(), i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    v.Buffer = o, v.SlowBuffer = b, v.INSPECT_MAX_BYTES = 50;
    const s = 2147483647;
    v.kMaxLength = s, o.TYPED_ARRAY_SUPPORT = y(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function y() {
      try {
        const N = new Uint8Array(1), C = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(C, Uint8Array.prototype), Object.setPrototypeOf(N, C), N.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(o.prototype, "parent", { enumerable: true, get: function() {
      if (o.isBuffer(this)) return this.buffer;
    } }), Object.defineProperty(o.prototype, "offset", { enumerable: true, get: function() {
      if (o.isBuffer(this)) return this.byteOffset;
    } });
    function t(N) {
      if (N > s) throw new RangeError('The value "' + N + '" is invalid for option "size"');
      const C = new Uint8Array(N);
      return Object.setPrototypeOf(C, o.prototype), C;
    }
    function o(N, C, p) {
      if (typeof N == "number") {
        if (typeof C == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return f(N);
      }
      return u(N, C, p);
    }
    o.poolSize = 8192;
    function u(N, C, p) {
      if (typeof N == "string") return r(N, C);
      if (ArrayBuffer.isView(N)) return g(N);
      if (N == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N);
      if (ee(N, ArrayBuffer) || N && ee(N.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ee(N, SharedArrayBuffer) || N && ee(N.buffer, SharedArrayBuffer))) return a(N, C, p);
      if (typeof N == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
      const A = N.valueOf && N.valueOf();
      if (A != null && A !== N) return o.from(A, C, p);
      const U = l(N);
      if (U) return U;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof N[Symbol.toPrimitive] == "function") return o.from(N[Symbol.toPrimitive]("string"), C, p);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof N);
    }
    o.from = function(N, C, p) {
      return u(N, C, p);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function c(N) {
      if (typeof N != "number") throw new TypeError('"size" argument must be of type number');
      if (N < 0) throw new RangeError('The value "' + N + '" is invalid for option "size"');
    }
    function h(N, C, p) {
      return c(N), N <= 0 ? t(N) : C !== void 0 ? typeof p == "string" ? t(N).fill(C, p) : t(N).fill(C) : t(N);
    }
    o.alloc = function(N, C, p) {
      return h(N, C, p);
    };
    function f(N) {
      return c(N), t(N < 0 ? 0 : d(N) | 0);
    }
    o.allocUnsafe = function(N) {
      return f(N);
    }, o.allocUnsafeSlow = function(N) {
      return f(N);
    };
    function r(N, C) {
      if ((typeof C != "string" || C === "") && (C = "utf8"), !o.isEncoding(C)) throw new TypeError("Unknown encoding: " + C);
      const p = S(N, C) | 0;
      let A = t(p);
      const U = A.write(N, C);
      return U !== p && (A = A.slice(0, U)), A;
    }
    function m(N) {
      const C = N.length < 0 ? 0 : d(N.length) | 0, p = t(C);
      for (let A = 0; A < C; A += 1) p[A] = N[A] & 255;
      return p;
    }
    function g(N) {
      if (ee(N, Uint8Array)) {
        const C = new Uint8Array(N);
        return a(C.buffer, C.byteOffset, C.byteLength);
      }
      return m(N);
    }
    function a(N, C, p) {
      if (C < 0 || N.byteLength < C) throw new RangeError('"offset" is outside of buffer bounds');
      if (N.byteLength < C + (p || 0)) throw new RangeError('"length" is outside of buffer bounds');
      let A;
      return C === void 0 && p === void 0 ? A = new Uint8Array(N) : p === void 0 ? A = new Uint8Array(N, C) : A = new Uint8Array(N, C, p), Object.setPrototypeOf(A, o.prototype), A;
    }
    function l(N) {
      if (o.isBuffer(N)) {
        const C = d(N.length) | 0, p = t(C);
        return p.length === 0 || N.copy(p, 0, 0, C), p;
      }
      if (N.length !== void 0) return typeof N.length != "number" || P(N.length) ? t(0) : m(N);
      if (N.type === "Buffer" && Array.isArray(N.data)) return m(N.data);
    }
    function d(N) {
      if (N >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
      return N | 0;
    }
    function b(N) {
      return +N != N && (N = 0), o.alloc(+N);
    }
    o.isBuffer = function(C) {
      return C != null && C._isBuffer === true && C !== o.prototype;
    }, o.compare = function(C, p) {
      if (ee(C, Uint8Array) && (C = o.from(C, C.offset, C.byteLength)), ee(p, Uint8Array) && (p = o.from(p, p.offset, p.byteLength)), !o.isBuffer(C) || !o.isBuffer(p)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (C === p) return 0;
      let A = C.length, U = p.length;
      for (let Q = 0, se = Math.min(A, U); Q < se; ++Q) if (C[Q] !== p[Q]) {
        A = C[Q], U = p[Q];
        break;
      }
      return A < U ? -1 : U < A ? 1 : 0;
    }, o.isEncoding = function(C) {
      switch (String(C).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, o.concat = function(C, p) {
      if (!Array.isArray(C)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (C.length === 0) return o.alloc(0);
      let A;
      if (p === void 0) for (p = 0, A = 0; A < C.length; ++A) p += C[A].length;
      const U = o.allocUnsafe(p);
      let Q = 0;
      for (A = 0; A < C.length; ++A) {
        let se = C[A];
        if (ee(se, Uint8Array)) Q + se.length > U.length ? (o.isBuffer(se) || (se = o.from(se)), se.copy(U, Q)) : Uint8Array.prototype.set.call(U, se, Q);
        else if (o.isBuffer(se)) se.copy(U, Q);
        else throw new TypeError('"list" argument must be an Array of Buffers');
        Q += se.length;
      }
      return U;
    };
    function S(N, C) {
      if (o.isBuffer(N)) return N.length;
      if (ArrayBuffer.isView(N) || ee(N, ArrayBuffer)) return N.byteLength;
      if (typeof N != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof N);
      const p = N.length, A = arguments.length > 2 && arguments[2] === true;
      if (!A && p === 0) return 0;
      let U = false;
      for (; ; ) switch (C) {
        case "ascii":
        case "latin1":
        case "binary":
          return p;
        case "utf8":
        case "utf-8":
          return xe(N).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return p * 2;
        case "hex":
          return p >>> 1;
        case "base64":
          return Be(N).length;
        default:
          if (U) return A ? -1 : xe(N).length;
          C = ("" + C).toLowerCase(), U = true;
      }
    }
    o.byteLength = S;
    function E(N, C, p) {
      let A = false;
      if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((p === void 0 || p > this.length) && (p = this.length), p <= 0) || (p >>>= 0, C >>>= 0, p <= C)) return "";
      for (N || (N = "utf8"); ; ) switch (N) {
        case "hex":
          return te(this, C, p);
        case "utf8":
        case "utf-8":
          return T(this, C, p);
        case "ascii":
          return z(this, C, p);
        case "latin1":
        case "binary":
          return Y(this, C, p);
        case "base64":
          return _(this, C, p);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, C, p);
        default:
          if (A) throw new TypeError("Unknown encoding: " + N);
          N = (N + "").toLowerCase(), A = true;
      }
    }
    o.prototype._isBuffer = true;
    function R(N, C, p) {
      const A = N[C];
      N[C] = N[p], N[p] = A;
    }
    o.prototype.swap16 = function() {
      const C = this.length;
      if (C % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let p = 0; p < C; p += 2) R(this, p, p + 1);
      return this;
    }, o.prototype.swap32 = function() {
      const C = this.length;
      if (C % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let p = 0; p < C; p += 4) R(this, p, p + 3), R(this, p + 1, p + 2);
      return this;
    }, o.prototype.swap64 = function() {
      const C = this.length;
      if (C % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let p = 0; p < C; p += 8) R(this, p, p + 7), R(this, p + 1, p + 6), R(this, p + 2, p + 5), R(this, p + 3, p + 4);
      return this;
    }, o.prototype.toString = function() {
      const C = this.length;
      return C === 0 ? "" : arguments.length === 0 ? T(this, 0, C) : E.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(C) {
      if (!o.isBuffer(C)) throw new TypeError("Argument must be a Buffer");
      return this === C ? true : o.compare(this, C) === 0;
    }, o.prototype.inspect = function() {
      let C = "";
      const p = v.INSPECT_MAX_BYTES;
      return C = this.toString("hex", 0, p).replace(/(.{2})/g, "$1 ").trim(), this.length > p && (C += " ... "), "<Buffer " + C + ">";
    }, i && (o.prototype[i] = o.prototype.inspect), o.prototype.compare = function(C, p, A, U, Q) {
      if (ee(C, Uint8Array) && (C = o.from(C, C.offset, C.byteLength)), !o.isBuffer(C)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof C);
      if (p === void 0 && (p = 0), A === void 0 && (A = C ? C.length : 0), U === void 0 && (U = 0), Q === void 0 && (Q = this.length), p < 0 || A > C.length || U < 0 || Q > this.length) throw new RangeError("out of range index");
      if (U >= Q && p >= A) return 0;
      if (U >= Q) return -1;
      if (p >= A) return 1;
      if (p >>>= 0, A >>>= 0, U >>>= 0, Q >>>= 0, this === C) return 0;
      let se = Q - U, X = A - p;
      const de = Math.min(se, X), tt = this.slice(U, Q), Ne = C.slice(p, A);
      for (let ut = 0; ut < de; ++ut) if (tt[ut] !== Ne[ut]) {
        se = tt[ut], X = Ne[ut];
        break;
      }
      return se < X ? -1 : X < se ? 1 : 0;
    };
    function k(N, C, p, A, U) {
      if (N.length === 0) return -1;
      if (typeof p == "string" ? (A = p, p = 0) : p > 2147483647 ? p = 2147483647 : p < -2147483648 && (p = -2147483648), p = +p, P(p) && (p = U ? 0 : N.length - 1), p < 0 && (p = N.length + p), p >= N.length) {
        if (U) return -1;
        p = N.length - 1;
      } else if (p < 0) if (U) p = 0;
      else return -1;
      if (typeof C == "string" && (C = o.from(C, A)), o.isBuffer(C)) return C.length === 0 ? -1 : w(N, C, p, A, U);
      if (typeof C == "number") return C = C & 255, typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(N, C, p) : Uint8Array.prototype.lastIndexOf.call(N, C, p) : w(N, [C], p, A, U);
      throw new TypeError("val must be string, number or Buffer");
    }
    function w(N, C, p, A, U) {
      let Q = 1, se = N.length, X = C.length;
      if (A !== void 0 && (A = String(A).toLowerCase(), A === "ucs2" || A === "ucs-2" || A === "utf16le" || A === "utf-16le")) {
        if (N.length < 2 || C.length < 2) return -1;
        Q = 2, se /= 2, X /= 2, p /= 2;
      }
      function de(Ne, ut) {
        return Q === 1 ? Ne[ut] : Ne.readUInt16BE(ut * Q);
      }
      let tt;
      if (U) {
        let Ne = -1;
        for (tt = p; tt < se; tt++) if (de(N, tt) === de(C, Ne === -1 ? 0 : tt - Ne)) {
          if (Ne === -1 && (Ne = tt), tt - Ne + 1 === X) return Ne * Q;
        } else Ne !== -1 && (tt -= tt - Ne), Ne = -1;
      } else for (p + X > se && (p = se - X), tt = p; tt >= 0; tt--) {
        let Ne = true;
        for (let ut = 0; ut < X; ut++) if (de(N, tt + ut) !== de(C, ut)) {
          Ne = false;
          break;
        }
        if (Ne) return tt;
      }
      return -1;
    }
    o.prototype.includes = function(C, p, A) {
      return this.indexOf(C, p, A) !== -1;
    }, o.prototype.indexOf = function(C, p, A) {
      return k(this, C, p, A, true);
    }, o.prototype.lastIndexOf = function(C, p, A) {
      return k(this, C, p, A, false);
    };
    function F(N, C, p, A) {
      p = Number(p) || 0;
      const U = N.length - p;
      A ? (A = Number(A), A > U && (A = U)) : A = U;
      const Q = C.length;
      A > Q / 2 && (A = Q / 2);
      let se;
      for (se = 0; se < A; ++se) {
        const X = parseInt(C.substr(se * 2, 2), 16);
        if (P(X)) return se;
        N[p + se] = X;
      }
      return se;
    }
    function I(N, C, p, A) {
      return Qe(xe(C, N.length - p), N, p, A);
    }
    function q(N, C, p, A) {
      return Qe(Ve(C), N, p, A);
    }
    function D(N, C, p, A) {
      return Qe(Be(C), N, p, A);
    }
    function H(N, C, p, A) {
      return Qe(_e(C, N.length - p), N, p, A);
    }
    o.prototype.write = function(C, p, A, U) {
      if (p === void 0) U = "utf8", A = this.length, p = 0;
      else if (A === void 0 && typeof p == "string") U = p, A = this.length, p = 0;
      else if (isFinite(p)) p = p >>> 0, isFinite(A) ? (A = A >>> 0, U === void 0 && (U = "utf8")) : (U = A, A = void 0);
      else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      const Q = this.length - p;
      if ((A === void 0 || A > Q) && (A = Q), C.length > 0 && (A < 0 || p < 0) || p > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      U || (U = "utf8");
      let se = false;
      for (; ; ) switch (U) {
        case "hex":
          return F(this, C, p, A);
        case "utf8":
        case "utf-8":
          return I(this, C, p, A);
        case "ascii":
        case "latin1":
        case "binary":
          return q(this, C, p, A);
        case "base64":
          return D(this, C, p, A);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, C, p, A);
        default:
          if (se) throw new TypeError("Unknown encoding: " + U);
          U = ("" + U).toLowerCase(), se = true;
      }
    }, o.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function _(N, C, p) {
      return C === 0 && p === N.length ? e.fromByteArray(N) : e.fromByteArray(N.slice(C, p));
    }
    function T(N, C, p) {
      p = Math.min(N.length, p);
      const A = [];
      let U = C;
      for (; U < p; ) {
        const Q = N[U];
        let se = null, X = Q > 239 ? 4 : Q > 223 ? 3 : Q > 191 ? 2 : 1;
        if (U + X <= p) {
          let de, tt, Ne, ut;
          switch (X) {
            case 1:
              Q < 128 && (se = Q);
              break;
            case 2:
              de = N[U + 1], (de & 192) === 128 && (ut = (Q & 31) << 6 | de & 63, ut > 127 && (se = ut));
              break;
            case 3:
              de = N[U + 1], tt = N[U + 2], (de & 192) === 128 && (tt & 192) === 128 && (ut = (Q & 15) << 12 | (de & 63) << 6 | tt & 63, ut > 2047 && (ut < 55296 || ut > 57343) && (se = ut));
              break;
            case 4:
              de = N[U + 1], tt = N[U + 2], Ne = N[U + 3], (de & 192) === 128 && (tt & 192) === 128 && (Ne & 192) === 128 && (ut = (Q & 15) << 18 | (de & 63) << 12 | (tt & 63) << 6 | Ne & 63, ut > 65535 && ut < 1114112 && (se = ut));
          }
        }
        se === null ? (se = 65533, X = 1) : se > 65535 && (se -= 65536, A.push(se >>> 10 & 1023 | 55296), se = 56320 | se & 1023), A.push(se), U += X;
      }
      return j(A);
    }
    const L = 4096;
    function j(N) {
      const C = N.length;
      if (C <= L) return String.fromCharCode.apply(String, N);
      let p = "", A = 0;
      for (; A < C; ) p += String.fromCharCode.apply(String, N.slice(A, A += L));
      return p;
    }
    function z(N, C, p) {
      let A = "";
      p = Math.min(N.length, p);
      for (let U = C; U < p; ++U) A += String.fromCharCode(N[U] & 127);
      return A;
    }
    function Y(N, C, p) {
      let A = "";
      p = Math.min(N.length, p);
      for (let U = C; U < p; ++U) A += String.fromCharCode(N[U]);
      return A;
    }
    function te(N, C, p) {
      const A = N.length;
      (!C || C < 0) && (C = 0), (!p || p < 0 || p > A) && (p = A);
      let U = "";
      for (let Q = C; Q < p; ++Q) U += x[N[Q]];
      return U;
    }
    function G(N, C, p) {
      const A = N.slice(C, p);
      let U = "";
      for (let Q = 0; Q < A.length - 1; Q += 2) U += String.fromCharCode(A[Q] + A[Q + 1] * 256);
      return U;
    }
    o.prototype.slice = function(C, p) {
      const A = this.length;
      C = ~~C, p = p === void 0 ? A : ~~p, C < 0 ? (C += A, C < 0 && (C = 0)) : C > A && (C = A), p < 0 ? (p += A, p < 0 && (p = 0)) : p > A && (p = A), p < C && (p = C);
      const U = this.subarray(C, p);
      return Object.setPrototypeOf(U, o.prototype), U;
    };
    function K(N, C, p) {
      if (N % 1 !== 0 || N < 0) throw new RangeError("offset is not uint");
      if (N + C > p) throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(C, p, A) {
      C = C >>> 0, p = p >>> 0, A || K(C, p, this.length);
      let U = this[C], Q = 1, se = 0;
      for (; ++se < p && (Q *= 256); ) U += this[C + se] * Q;
      return U;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(C, p, A) {
      C = C >>> 0, p = p >>> 0, A || K(C, p, this.length);
      let U = this[C + --p], Q = 1;
      for (; p > 0 && (Q *= 256); ) U += this[C + --p] * Q;
      return U;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(C, p) {
      return C = C >>> 0, p || K(C, 1, this.length), this[C];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(C, p) {
      return C = C >>> 0, p || K(C, 2, this.length), this[C] | this[C + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(C, p) {
      return C = C >>> 0, p || K(C, 2, this.length), this[C] << 8 | this[C + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), (this[C] | this[C + 1] << 8 | this[C + 2] << 16) + this[C + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), this[C] * 16777216 + (this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3]);
    }, o.prototype.readBigUInt64LE = O(function(C) {
      C = C >>> 0, ge(C, "offset");
      const p = this[C], A = this[C + 7];
      (p === void 0 || A === void 0) && Te(C, this.length - 8);
      const U = p + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24, Q = this[++C] + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + A * 2 ** 24;
      return BigInt(U) + (BigInt(Q) << BigInt(32));
    }), o.prototype.readBigUInt64BE = O(function(C) {
      C = C >>> 0, ge(C, "offset");
      const p = this[C], A = this[C + 7];
      (p === void 0 || A === void 0) && Te(C, this.length - 8);
      const U = p * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C], Q = this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + A;
      return (BigInt(U) << BigInt(32)) + BigInt(Q);
    }), o.prototype.readIntLE = function(C, p, A) {
      C = C >>> 0, p = p >>> 0, A || K(C, p, this.length);
      let U = this[C], Q = 1, se = 0;
      for (; ++se < p && (Q *= 256); ) U += this[C + se] * Q;
      return Q *= 128, U >= Q && (U -= Math.pow(2, 8 * p)), U;
    }, o.prototype.readIntBE = function(C, p, A) {
      C = C >>> 0, p = p >>> 0, A || K(C, p, this.length);
      let U = p, Q = 1, se = this[C + --U];
      for (; U > 0 && (Q *= 256); ) se += this[C + --U] * Q;
      return Q *= 128, se >= Q && (se -= Math.pow(2, 8 * p)), se;
    }, o.prototype.readInt8 = function(C, p) {
      return C = C >>> 0, p || K(C, 1, this.length), this[C] & 128 ? (255 - this[C] + 1) * -1 : this[C];
    }, o.prototype.readInt16LE = function(C, p) {
      C = C >>> 0, p || K(C, 2, this.length);
      const A = this[C] | this[C + 1] << 8;
      return A & 32768 ? A | 4294901760 : A;
    }, o.prototype.readInt16BE = function(C, p) {
      C = C >>> 0, p || K(C, 2, this.length);
      const A = this[C + 1] | this[C] << 8;
      return A & 32768 ? A | 4294901760 : A;
    }, o.prototype.readInt32LE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), this[C] | this[C + 1] << 8 | this[C + 2] << 16 | this[C + 3] << 24;
    }, o.prototype.readInt32BE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), this[C] << 24 | this[C + 1] << 16 | this[C + 2] << 8 | this[C + 3];
    }, o.prototype.readBigInt64LE = O(function(C) {
      C = C >>> 0, ge(C, "offset");
      const p = this[C], A = this[C + 7];
      (p === void 0 || A === void 0) && Te(C, this.length - 8);
      const U = this[C + 4] + this[C + 5] * 2 ** 8 + this[C + 6] * 2 ** 16 + (A << 24);
      return (BigInt(U) << BigInt(32)) + BigInt(p + this[++C] * 2 ** 8 + this[++C] * 2 ** 16 + this[++C] * 2 ** 24);
    }), o.prototype.readBigInt64BE = O(function(C) {
      C = C >>> 0, ge(C, "offset");
      const p = this[C], A = this[C + 7];
      (p === void 0 || A === void 0) && Te(C, this.length - 8);
      const U = (p << 24) + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + this[++C];
      return (BigInt(U) << BigInt(32)) + BigInt(this[++C] * 2 ** 24 + this[++C] * 2 ** 16 + this[++C] * 2 ** 8 + A);
    }), o.prototype.readFloatLE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), n.read(this, C, true, 23, 4);
    }, o.prototype.readFloatBE = function(C, p) {
      return C = C >>> 0, p || K(C, 4, this.length), n.read(this, C, false, 23, 4);
    }, o.prototype.readDoubleLE = function(C, p) {
      return C = C >>> 0, p || K(C, 8, this.length), n.read(this, C, true, 52, 8);
    }, o.prototype.readDoubleBE = function(C, p) {
      return C = C >>> 0, p || K(C, 8, this.length), n.read(this, C, false, 52, 8);
    };
    function J(N, C, p, A, U, Q) {
      if (!o.isBuffer(N)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (C > U || C < Q) throw new RangeError('"value" argument is out of bounds');
      if (p + A > N.length) throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(C, p, A, U) {
      if (C = +C, p = p >>> 0, A = A >>> 0, !U) {
        const X = Math.pow(2, 8 * A) - 1;
        J(this, C, p, A, X, 0);
      }
      let Q = 1, se = 0;
      for (this[p] = C & 255; ++se < A && (Q *= 256); ) this[p + se] = C / Q & 255;
      return p + A;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(C, p, A, U) {
      if (C = +C, p = p >>> 0, A = A >>> 0, !U) {
        const X = Math.pow(2, 8 * A) - 1;
        J(this, C, p, A, X, 0);
      }
      let Q = A - 1, se = 1;
      for (this[p + Q] = C & 255; --Q >= 0 && (se *= 256); ) this[p + Q] = C / se & 255;
      return p + A;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 1, 255, 0), this[p] = C & 255, p + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 2, 65535, 0), this[p] = C & 255, this[p + 1] = C >>> 8, p + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 2, 65535, 0), this[p] = C >>> 8, this[p + 1] = C & 255, p + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 4, 4294967295, 0), this[p + 3] = C >>> 24, this[p + 2] = C >>> 16, this[p + 1] = C >>> 8, this[p] = C & 255, p + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 4, 4294967295, 0), this[p] = C >>> 24, this[p + 1] = C >>> 16, this[p + 2] = C >>> 8, this[p + 3] = C & 255, p + 4;
    };
    function B(N, C, p, A, U) {
      ne(C, A, U, N, p, 7);
      let Q = Number(C & BigInt(4294967295));
      N[p++] = Q, Q = Q >> 8, N[p++] = Q, Q = Q >> 8, N[p++] = Q, Q = Q >> 8, N[p++] = Q;
      let se = Number(C >> BigInt(32) & BigInt(4294967295));
      return N[p++] = se, se = se >> 8, N[p++] = se, se = se >> 8, N[p++] = se, se = se >> 8, N[p++] = se, p;
    }
    function Z(N, C, p, A, U) {
      ne(C, A, U, N, p, 7);
      let Q = Number(C & BigInt(4294967295));
      N[p + 7] = Q, Q = Q >> 8, N[p + 6] = Q, Q = Q >> 8, N[p + 5] = Q, Q = Q >> 8, N[p + 4] = Q;
      let se = Number(C >> BigInt(32) & BigInt(4294967295));
      return N[p + 3] = se, se = se >> 8, N[p + 2] = se, se = se >> 8, N[p + 1] = se, se = se >> 8, N[p] = se, p + 8;
    }
    o.prototype.writeBigUInt64LE = O(function(C, p = 0) {
      return B(this, C, p, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeBigUInt64BE = O(function(C, p = 0) {
      return Z(this, C, p, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeIntLE = function(C, p, A, U) {
      if (C = +C, p = p >>> 0, !U) {
        const de = Math.pow(2, 8 * A - 1);
        J(this, C, p, A, de - 1, -de);
      }
      let Q = 0, se = 1, X = 0;
      for (this[p] = C & 255; ++Q < A && (se *= 256); ) C < 0 && X === 0 && this[p + Q - 1] !== 0 && (X = 1), this[p + Q] = (C / se >> 0) - X & 255;
      return p + A;
    }, o.prototype.writeIntBE = function(C, p, A, U) {
      if (C = +C, p = p >>> 0, !U) {
        const de = Math.pow(2, 8 * A - 1);
        J(this, C, p, A, de - 1, -de);
      }
      let Q = A - 1, se = 1, X = 0;
      for (this[p + Q] = C & 255; --Q >= 0 && (se *= 256); ) C < 0 && X === 0 && this[p + Q + 1] !== 0 && (X = 1), this[p + Q] = (C / se >> 0) - X & 255;
      return p + A;
    }, o.prototype.writeInt8 = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 1, 127, -128), C < 0 && (C = 255 + C + 1), this[p] = C & 255, p + 1;
    }, o.prototype.writeInt16LE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 2, 32767, -32768), this[p] = C & 255, this[p + 1] = C >>> 8, p + 2;
    }, o.prototype.writeInt16BE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 2, 32767, -32768), this[p] = C >>> 8, this[p + 1] = C & 255, p + 2;
    }, o.prototype.writeInt32LE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 4, 2147483647, -2147483648), this[p] = C & 255, this[p + 1] = C >>> 8, this[p + 2] = C >>> 16, this[p + 3] = C >>> 24, p + 4;
    }, o.prototype.writeInt32BE = function(C, p, A) {
      return C = +C, p = p >>> 0, A || J(this, C, p, 4, 2147483647, -2147483648), C < 0 && (C = 4294967295 + C + 1), this[p] = C >>> 24, this[p + 1] = C >>> 16, this[p + 2] = C >>> 8, this[p + 3] = C & 255, p + 4;
    }, o.prototype.writeBigInt64LE = O(function(C, p = 0) {
      return B(this, C, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), o.prototype.writeBigInt64BE = O(function(C, p = 0) {
      return Z(this, C, p, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ie(N, C, p, A, U, Q) {
      if (p + A > N.length) throw new RangeError("Index out of range");
      if (p < 0) throw new RangeError("Index out of range");
    }
    function $(N, C, p, A, U) {
      return C = +C, p = p >>> 0, U || ie(N, C, p, 4), n.write(N, C, p, A, 23, 4), p + 4;
    }
    o.prototype.writeFloatLE = function(C, p, A) {
      return $(this, C, p, true, A);
    }, o.prototype.writeFloatBE = function(C, p, A) {
      return $(this, C, p, false, A);
    };
    function oe(N, C, p, A, U) {
      return C = +C, p = p >>> 0, U || ie(N, C, p, 8), n.write(N, C, p, A, 52, 8), p + 8;
    }
    o.prototype.writeDoubleLE = function(C, p, A) {
      return oe(this, C, p, true, A);
    }, o.prototype.writeDoubleBE = function(C, p, A) {
      return oe(this, C, p, false, A);
    }, o.prototype.copy = function(C, p, A, U) {
      if (!o.isBuffer(C)) throw new TypeError("argument should be a Buffer");
      if (A || (A = 0), !U && U !== 0 && (U = this.length), p >= C.length && (p = C.length), p || (p = 0), U > 0 && U < A && (U = A), U === A || C.length === 0 || this.length === 0) return 0;
      if (p < 0) throw new RangeError("targetStart out of bounds");
      if (A < 0 || A >= this.length) throw new RangeError("Index out of range");
      if (U < 0) throw new RangeError("sourceEnd out of bounds");
      U > this.length && (U = this.length), C.length - p < U - A && (U = C.length - p + A);
      const Q = U - A;
      return this === C && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(p, A, U) : Uint8Array.prototype.set.call(C, this.subarray(A, U), p), Q;
    }, o.prototype.fill = function(C, p, A, U) {
      if (typeof C == "string") {
        if (typeof p == "string" ? (U = p, p = 0, A = this.length) : typeof A == "string" && (U = A, A = this.length), U !== void 0 && typeof U != "string") throw new TypeError("encoding must be a string");
        if (typeof U == "string" && !o.isEncoding(U)) throw new TypeError("Unknown encoding: " + U);
        if (C.length === 1) {
          const se = C.charCodeAt(0);
          (U === "utf8" && se < 128 || U === "latin1") && (C = se);
        }
      } else typeof C == "number" ? C = C & 255 : typeof C == "boolean" && (C = Number(C));
      if (p < 0 || this.length < p || this.length < A) throw new RangeError("Out of range index");
      if (A <= p) return this;
      p = p >>> 0, A = A === void 0 ? this.length : A >>> 0, C || (C = 0);
      let Q;
      if (typeof C == "number") for (Q = p; Q < A; ++Q) this[Q] = C;
      else {
        const se = o.isBuffer(C) ? C : o.from(C, U), X = se.length;
        if (X === 0) throw new TypeError('The value "' + C + '" is invalid for argument "value"');
        for (Q = 0; Q < A - p; ++Q) this[Q + p] = se[Q % X];
      }
      return this;
    };
    const ce = {};
    function ye(N, C, p) {
      ce[N] = class extends p {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: C.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${N}]`, this.stack, delete this.name;
        }
        get code() {
          return N;
        }
        set code(U) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: U, writable: true });
        }
        toString() {
          return `${this.name} [${N}]: ${this.message}`;
        }
      };
    }
    ye("ERR_BUFFER_OUT_OF_BOUNDS", function(N) {
      return N ? `${N} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), ye("ERR_INVALID_ARG_TYPE", function(N, C) {
      return `The "${N}" argument must be of type number. Received type ${typeof C}`;
    }, TypeError), ye("ERR_OUT_OF_RANGE", function(N, C, p) {
      let A = `The value of "${N}" is out of range.`, U = p;
      return Number.isInteger(p) && Math.abs(p) > 2 ** 32 ? U = ae(String(p)) : typeof p == "bigint" && (U = String(p), (p > BigInt(2) ** BigInt(32) || p < -(BigInt(2) ** BigInt(32))) && (U = ae(U)), U += "n"), A += ` It must be ${C}. Received ${U}`, A;
    }, RangeError);
    function ae(N) {
      let C = "", p = N.length;
      const A = N[0] === "-" ? 1 : 0;
      for (; p >= A + 4; p -= 3) C = `_${N.slice(p - 3, p)}${C}`;
      return `${N.slice(0, p)}${C}`;
    }
    function ue(N, C, p) {
      ge(C, "offset"), (N[C] === void 0 || N[C + p] === void 0) && Te(C, N.length - (p + 1));
    }
    function ne(N, C, p, A, U, Q) {
      if (N > p || N < C) {
        const se = typeof C == "bigint" ? "n" : "";
        let X;
        throw C === 0 || C === BigInt(0) ? X = `>= 0${se} and < 2${se} ** ${(Q + 1) * 8}${se}` : X = `>= -(2${se} ** ${(Q + 1) * 8 - 1}${se}) and < 2 ** ${(Q + 1) * 8 - 1}${se}`, new ce.ERR_OUT_OF_RANGE("value", X, N);
      }
      ue(A, U, Q);
    }
    function ge(N, C) {
      if (typeof N != "number") throw new ce.ERR_INVALID_ARG_TYPE(C, "number", N);
    }
    function Te(N, C, p) {
      throw Math.floor(N) !== N ? (ge(N, p), new ce.ERR_OUT_OF_RANGE("offset", "an integer", N)) : C < 0 ? new ce.ERR_BUFFER_OUT_OF_BOUNDS() : new ce.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${C}`, N);
    }
    const pe = /[^+/0-9A-Za-z-_]/g;
    function Oe(N) {
      if (N = N.split("=")[0], N = N.trim().replace(pe, ""), N.length < 2) return "";
      for (; N.length % 4 !== 0; ) N = N + "=";
      return N;
    }
    function xe(N, C) {
      C = C || 1 / 0;
      let p;
      const A = N.length;
      let U = null;
      const Q = [];
      for (let se = 0; se < A; ++se) {
        if (p = N.charCodeAt(se), p > 55295 && p < 57344) {
          if (!U) {
            if (p > 56319) {
              (C -= 3) > -1 && Q.push(239, 191, 189);
              continue;
            } else if (se + 1 === A) {
              (C -= 3) > -1 && Q.push(239, 191, 189);
              continue;
            }
            U = p;
            continue;
          }
          if (p < 56320) {
            (C -= 3) > -1 && Q.push(239, 191, 189), U = p;
            continue;
          }
          p = (U - 55296 << 10 | p - 56320) + 65536;
        } else U && (C -= 3) > -1 && Q.push(239, 191, 189);
        if (U = null, p < 128) {
          if ((C -= 1) < 0) break;
          Q.push(p);
        } else if (p < 2048) {
          if ((C -= 2) < 0) break;
          Q.push(p >> 6 | 192, p & 63 | 128);
        } else if (p < 65536) {
          if ((C -= 3) < 0) break;
          Q.push(p >> 12 | 224, p >> 6 & 63 | 128, p & 63 | 128);
        } else if (p < 1114112) {
          if ((C -= 4) < 0) break;
          Q.push(p >> 18 | 240, p >> 12 & 63 | 128, p >> 6 & 63 | 128, p & 63 | 128);
        } else throw new Error("Invalid code point");
      }
      return Q;
    }
    function Ve(N) {
      const C = [];
      for (let p = 0; p < N.length; ++p) C.push(N.charCodeAt(p) & 255);
      return C;
    }
    function _e(N, C) {
      let p, A, U;
      const Q = [];
      for (let se = 0; se < N.length && !((C -= 2) < 0); ++se) p = N.charCodeAt(se), A = p >> 8, U = p % 256, Q.push(U), Q.push(A);
      return Q;
    }
    function Be(N) {
      return e.toByteArray(Oe(N));
    }
    function Qe(N, C, p, A) {
      let U;
      for (U = 0; U < A && !(U + p >= C.length || U >= N.length); ++U) C[U + p] = N[U];
      return U;
    }
    function ee(N, C) {
      return N instanceof C || N != null && N.constructor != null && N.constructor.name != null && N.constructor.name === C.name;
    }
    function P(N) {
      return N !== N;
    }
    const x = function() {
      const N = "0123456789abcdef", C = new Array(256);
      for (let p = 0; p < 16; ++p) {
        const A = p * 16;
        for (let U = 0; U < 16; ++U) C[A + U] = N[p] + N[U];
      }
      return C;
    }();
    function O(N) {
      return typeof BigInt > "u" ? V : N;
    }
    function V() {
      throw new Error("BigInt not supported");
    }
  }(Lc)), Lc;
}
var $l = Yd(), Ws = { exports: {} }, qa = {}, Rf;
function Ia() {
  if (Rf) return qa;
  Rf = 1, Object.defineProperty(qa, "__esModule", { value: true }), qa.Api = void 0;
  var v;
  return function(e) {
    var n = function(o) {
      return o.SUCCESS = "SUCCESS", o.NOT_FOUND = "NOT_FOUND", o.FAILED = "FAILED", o;
    }({});
    e.GetTransactionStatus = n;
    function i(o) {
      return "error" in o;
    }
    e.isSimulationError = i;
    function s(o) {
      return "transactionData" in o;
    }
    e.isSimulationSuccess = s;
    function y(o) {
      return s(o) && "restorePreamble" in o && !!o.restorePreamble.transactionData;
    }
    e.isSimulationRestore = y;
    function t(o) {
      return !o._parsed;
    }
    e.isSimulationRaw = t;
  }(v || (qa.Api = v = {})), qa;
}
var Ti = {}, ic = { exports: {} }, Is = { exports: {} };
/*! https://mths.be/punycode v1.4.0 by @mathias */
var gy = Is.exports, Mf;
function vy() {
  return Mf || (Mf = 1, function(v, e) {
    (function(n) {
      var i = e && !e.nodeType && e, s = v && !v.nodeType && v, y = typeof vc == "object" && vc;
      (y.global === y || y.window === y || y.self === y) && (n = y);
      var t, o = 2147483647, u = 36, c = 1, h = 26, f = 38, r = 700, m = 72, g = 128, a = "-", l = /^xn--/, d = /[^\x20-\x7E]/, b = /[\x2E\u3002\uFF0E\uFF61]/g, S = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, E = u - c, R = Math.floor, k = String.fromCharCode, w;
      function F(G) {
        throw new RangeError(S[G]);
      }
      function I(G, K) {
        for (var J = G.length, B = []; J--; ) B[J] = K(G[J]);
        return B;
      }
      function q(G, K) {
        var J = G.split("@"), B = "";
        J.length > 1 && (B = J[0] + "@", G = J[1]), G = G.replace(b, ".");
        var Z = G.split("."), ie = I(Z, K).join(".");
        return B + ie;
      }
      function D(G) {
        for (var K = [], J = 0, B = G.length, Z, ie; J < B; ) Z = G.charCodeAt(J++), Z >= 55296 && Z <= 56319 && J < B ? (ie = G.charCodeAt(J++), (ie & 64512) == 56320 ? K.push(((Z & 1023) << 10) + (ie & 1023) + 65536) : (K.push(Z), J--)) : K.push(Z);
        return K;
      }
      function H(G) {
        return I(G, function(K) {
          var J = "";
          return K > 65535 && (K -= 65536, J += k(K >>> 10 & 1023 | 55296), K = 56320 | K & 1023), J += k(K), J;
        }).join("");
      }
      function _(G) {
        return G - 48 < 10 ? G - 22 : G - 65 < 26 ? G - 65 : G - 97 < 26 ? G - 97 : u;
      }
      function T(G, K) {
        return G + 22 + 75 * (G < 26) - ((K != 0) << 5);
      }
      function L(G, K, J) {
        var B = 0;
        for (G = J ? R(G / r) : G >> 1, G += R(G / K); G > E * h >> 1; B += u) G = R(G / E);
        return R(B + (E + 1) * G / (G + f));
      }
      function j(G) {
        var K = [], J = G.length, B, Z = 0, ie = g, $ = m, oe, ce, ye, ae, ue, ne, ge, Te, pe;
        for (oe = G.lastIndexOf(a), oe < 0 && (oe = 0), ce = 0; ce < oe; ++ce) G.charCodeAt(ce) >= 128 && F("not-basic"), K.push(G.charCodeAt(ce));
        for (ye = oe > 0 ? oe + 1 : 0; ye < J; ) {
          for (ae = Z, ue = 1, ne = u; ye >= J && F("invalid-input"), ge = _(G.charCodeAt(ye++)), (ge >= u || ge > R((o - Z) / ue)) && F("overflow"), Z += ge * ue, Te = ne <= $ ? c : ne >= $ + h ? h : ne - $, !(ge < Te); ne += u) pe = u - Te, ue > R(o / pe) && F("overflow"), ue *= pe;
          B = K.length + 1, $ = L(Z - ae, B, ae == 0), R(Z / B) > o - ie && F("overflow"), ie += R(Z / B), Z %= B, K.splice(Z++, 0, ie);
        }
        return H(K);
      }
      function z(G) {
        var K, J, B, Z, ie, $, oe, ce, ye, ae, ue, ne = [], ge, Te, pe, Oe;
        for (G = D(G), ge = G.length, K = g, J = 0, ie = m, $ = 0; $ < ge; ++$) ue = G[$], ue < 128 && ne.push(k(ue));
        for (B = Z = ne.length, Z && ne.push(a); B < ge; ) {
          for (oe = o, $ = 0; $ < ge; ++$) ue = G[$], ue >= K && ue < oe && (oe = ue);
          for (Te = B + 1, oe - K > R((o - J) / Te) && F("overflow"), J += (oe - K) * Te, K = oe, $ = 0; $ < ge; ++$) if (ue = G[$], ue < K && ++J > o && F("overflow"), ue == K) {
            for (ce = J, ye = u; ae = ye <= ie ? c : ye >= ie + h ? h : ye - ie, !(ce < ae); ye += u) Oe = ce - ae, pe = u - ae, ne.push(k(T(ae + Oe % pe, 0))), ce = R(Oe / pe);
            ne.push(k(T(ce, 0))), ie = L(J, Te, B == Z), J = 0, ++B;
          }
          ++J, ++K;
        }
        return ne.join("");
      }
      function Y(G) {
        return q(G, function(K) {
          return l.test(K) ? j(K.slice(4).toLowerCase()) : K;
        });
      }
      function te(G) {
        return q(G, function(K) {
          return d.test(K) ? "xn--" + z(K) : K;
        });
      }
      if (t = { version: "1.3.2", ucs2: { decode: D, encode: H }, decode: j, encode: z, toASCII: te, toUnicode: Y }, i && s) if (v.exports == i) s.exports = t;
      else for (w in t) t.hasOwnProperty(w) && (i[w] = t[w]);
      else n.punycode = t;
    })(gy);
  }(Is, Is.exports)), Is.exports;
}
var oc = { exports: {} };
/*!
* URI.js - Mutating URLs
* IPv6 Support
*
* Version: 1.19.11
*
* Author: Rodney Rehm
* Web: http://medialize.github.io/URI.js/
*
* Licensed under
*   MIT License http://www.opensource.org/licenses/mit-license
*
*/
var by = oc.exports, If;
function wy() {
  return If || (If = 1, function(v) {
    (function(e, n) {
      v.exports ? v.exports = n() : e.IPv6 = n(e);
    })(by, function(e) {
      var n = e && e.IPv6;
      function i(y) {
        var t = y.toLowerCase(), o = t.split(":"), u = o.length, c = 8;
        o[0] === "" && o[1] === "" && o[2] === "" ? (o.shift(), o.shift()) : o[0] === "" && o[1] === "" ? o.shift() : o[u - 1] === "" && o[u - 2] === "" && o.pop(), u = o.length, o[u - 1].indexOf(".") !== -1 && (c = 7);
        var h;
        for (h = 0; h < u && o[h] !== ""; h++) ;
        if (h < c) for (o.splice(h, 1, "0000"); o.length < c; ) o.splice(h, 0, "0000");
        for (var f, r = 0; r < c; r++) {
          f = o[r].split("");
          for (var m = 0; m < 3 && (f[0] === "0" && f.length > 1); m++) f.splice(0, 1);
          o[r] = f.join("");
        }
        var g = -1, a = 0, l = 0, d = -1, b = false;
        for (r = 0; r < c; r++) b ? o[r] === "0" ? l += 1 : (b = false, l > a && (g = d, a = l)) : o[r] === "0" && (b = true, d = r, l = 1);
        l > a && (g = d, a = l), a > 1 && o.splice(g, a, ""), u = o.length;
        var S = "";
        for (o[0] === "" && (S = ":"), r = 0; r < u && (S += o[r], r !== u - 1); r++) S += ":";
        return o[u - 1] === "" && (S += ":"), S;
      }
      function s() {
        return e.IPv6 === this && (e.IPv6 = n), this;
      }
      return { best: i, noConflict: s };
    });
  }(oc)), oc.exports;
}
var ac = { exports: {} };
/*!
* URI.js - Mutating URLs
* Second Level Domain (SLD) Support
*
* Version: 1.19.11
*
* Author: Rodney Rehm
* Web: http://medialize.github.io/URI.js/
*
* Licensed under
*   MIT License http://www.opensource.org/licenses/mit-license
*
*/
var Sy = ac.exports, Lf;
function _y() {
  return Lf || (Lf = 1, function(v) {
    (function(e, n) {
      v.exports ? v.exports = n() : e.SecondLevelDomains = n(e);
    })(Sy, function(e) {
      var n = e && e.SecondLevelDomains, i = { list: { ac: " com gov mil net org ", ae: " ac co gov mil name net org pro sch ", af: " com edu gov net org ", al: " com edu gov mil net org ", ao: " co ed gv it og pb ", ar: " com edu gob gov int mil net org tur ", at: " ac co gv or ", au: " asn com csiro edu gov id net org ", ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ", bb: " biz co com edu gov info net org store tv ", bh: " biz cc com edu gov info net org ", bn: " com edu gov net org ", bo: " com edu gob gov int mil net org tv ", br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ", bs: " com edu gov net org ", bz: " du et om ov rg ", ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ", ck: " biz co edu gen gov info net org ", cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ", co: " com edu gov mil net nom org ", cr: " ac c co ed fi go or sa ", cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ", do: " art com edu gob gov mil net org sld web ", dz: " art asso com edu gov net org pol ", ec: " com edu fin gov info med mil net org pro ", eg: " com edu eun gov mil name net org sci ", er: " com edu gov ind mil net org rochest w ", es: " com edu gob nom org ", et: " biz com edu gov info name net org ", fj: " ac biz com info mil name net org pro ", fk: " ac co gov net nom org ", fr: " asso com f gouv nom prd presse tm ", gg: " co net org ", gh: " com edu gov mil org ", gn: " ac com gov net org ", gr: " com edu gov mil net org ", gt: " com edu gob ind mil net org ", gu: " com edu gov net org ", hk: " com edu gov idv net org ", hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ", id: " ac co go mil net or sch web ", il: " ac co gov idf k12 muni net org ", in: " ac co edu ernet firm gen gov i ind mil net nic org res ", iq: " com edu gov i mil net org ", ir: " ac co dnssec gov i id net org sch ", it: " edu gov ", je: " co net org ", jo: " com edu gov mil name net org sch ", jp: " ac ad co ed go gr lg ne or ", ke: " ac co go info me mobi ne or sc ", kh: " com edu gov mil net org per ", ki: " biz com de edu gov info mob net org tel ", km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ", kn: " edu gov net org ", kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ", kw: " com edu gov net org ", ky: " com edu gov net org ", kz: " com edu gov mil net org ", lb: " com edu gov net org ", lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ", lr: " com edu gov net org ", lv: " asn com conf edu gov id mil net org ", ly: " com edu gov id med net org plc sch ", ma: " ac co gov m net org press ", mc: " asso tm ", me: " ac co edu gov its net org priv ", mg: " com edu gov mil nom org prd tm ", mk: " com edu gov inf name net org pro ", ml: " com edu gov net org presse ", mn: " edu gov org ", mo: " com edu gov net org ", mt: " com edu gov net org ", mv: " aero biz com coop edu gov info int mil museum name net org pro ", mw: " ac co com coop edu gov int museum net org ", mx: " com edu gob net org ", my: " com edu gov mil name net org sch ", nf: " arts com firm info net other per rec store web ", ng: " biz com edu gov mil mobi name net org sch ", ni: " ac co com edu gob mil net nom org ", np: " com edu gov mil net org ", nr: " biz com edu gov info net org ", om: " ac biz co com edu gov med mil museum net org pro sch ", pe: " com edu gob mil net nom org sld ", ph: " com edu gov i mil net ngo org ", pk: " biz com edu fam gob gok gon gop gos gov net org web ", pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ", pr: " ac biz com edu est gov info isla name net org pro prof ", ps: " com edu gov net org plo sec ", pw: " belau co ed go ne or ", ro: " arts com firm info nom nt org rec store tm www ", rs: " ac co edu gov in org ", sb: " com edu gov net org ", sc: " com edu gov net org ", sh: " co com edu gov net nom org ", sl: " com edu gov net org ", st: " co com consulado edu embaixada gov mil net org principe saotome store ", sv: " com edu gob org red ", sz: " ac co org ", tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ", tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ", tw: " club com ebiz edu game gov idv mil net org ", mu: " ac co com gov net or org ", mz: " ac co edu gov org ", na: " co com ", nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ", pa: " abo ac com edu gob ing med net nom org sld ", pt: " com edu gov int net nome org publ ", py: " com edu gov mil net org ", qa: " com edu gov mil net org ", re: " asso com nom ", ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ", rw: " ac co com edu gouv gov int mil net ", sa: " com edu gov med net org pub sch ", sd: " com edu gov info med net org tv ", se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ", sg: " com edu gov idn net org per ", sn: " art com edu gouv org perso univ ", sy: " com edu gov mil net news org ", th: " ac co go in mi net or ", tj: " ac biz co com edu go gov info int mil name net nic org test web ", tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ", tz: " ac co go ne or ", ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ", ug: " ac co go ne or org sc ", uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ", us: " dni fed isa kids nsn ", uy: " com edu gub mil net org ", ve: " co com edu gob info mil net org web ", vi: " co com k12 net org ", vn: " ac biz com edu gov health info int name net org pro ", ye: " co com gov ltd me net org plc ", yu: " ac co edu gov org ", za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ", zm: " ac co com edu gov net org sch ", com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ", net: "gb jp se uk ", org: "ae", de: "com " }, has: function(s) {
        var y = s.lastIndexOf(".");
        if (y <= 0 || y >= s.length - 1) return false;
        var t = s.lastIndexOf(".", y - 1);
        if (t <= 0 || t >= y - 1) return false;
        var o = i.list[s.slice(y + 1)];
        return o ? o.indexOf(" " + s.slice(t + 1, y) + " ") >= 0 : false;
      }, is: function(s) {
        var y = s.lastIndexOf(".");
        if (y <= 0 || y >= s.length - 1) return false;
        var t = s.lastIndexOf(".", y - 1);
        if (t >= 0) return false;
        var o = i.list[s.slice(y + 1)];
        return o ? o.indexOf(" " + s.slice(0, y) + " ") >= 0 : false;
      }, get: function(s) {
        var y = s.lastIndexOf(".");
        if (y <= 0 || y >= s.length - 1) return null;
        var t = s.lastIndexOf(".", y - 1);
        if (t <= 0 || t >= y - 1) return null;
        var o = i.list[s.slice(y + 1)];
        return !o || o.indexOf(" " + s.slice(t + 1, y) + " ") < 0 ? null : s.slice(t + 1);
      }, noConflict: function() {
        return e.SecondLevelDomains === this && (e.SecondLevelDomains = n), this;
      } };
      return i;
    });
  }(ac)), ac.exports;
}
/*!
* URI.js - Mutating URLs
*
* Version: 1.19.11
*
* Author: Rodney Rehm
* Web: http://medialize.github.io/URI.js/
*
* Licensed under
*   MIT License http://www.opensource.org/licenses/mit-license
*
*/
var Ey = ic.exports, Bf;
function Ay() {
  return Bf || (Bf = 1, function(v) {
    (function(e, n) {
      v.exports ? v.exports = n(vy(), wy(), _y()) : e.URI = n(e.punycode, e.IPv6, e.SecondLevelDomains, e);
    })(Ey, function(e, n, i, s) {
      var y = s && s.URI;
      function t(_, T) {
        var L = arguments.length >= 1, j = arguments.length >= 2;
        if (!(this instanceof t)) return L ? j ? new t(_, T) : new t(_) : new t();
        if (_ === void 0) {
          if (L) throw new TypeError("undefined is not a valid argument for URI");
          typeof location < "u" ? _ = location.href + "" : _ = "";
        }
        if (_ === null && L) throw new TypeError("null is not a valid argument for URI");
        return this.href(_), T !== void 0 ? this.absoluteTo(T) : this;
      }
      function o(_) {
        return /^[0-9]+$/.test(_);
      }
      t.version = "1.19.11";
      var u = t.prototype, c = Object.prototype.hasOwnProperty;
      function h(_) {
        return _.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function f(_) {
        return _ === void 0 ? "Undefined" : String(Object.prototype.toString.call(_)).slice(8, -1);
      }
      function r(_) {
        return f(_) === "Array";
      }
      function m(_, T) {
        var L = {}, j, z;
        if (f(T) === "RegExp") L = null;
        else if (r(T)) for (j = 0, z = T.length; j < z; j++) L[T[j]] = true;
        else L[T] = true;
        for (j = 0, z = _.length; j < z; j++) {
          var Y = L && L[_[j]] !== void 0 || !L && T.test(_[j]);
          Y && (_.splice(j, 1), z--, j--);
        }
        return _;
      }
      function g(_, T) {
        var L, j;
        if (r(T)) {
          for (L = 0, j = T.length; L < j; L++) if (!g(_, T[L])) return false;
          return true;
        }
        var z = f(T);
        for (L = 0, j = _.length; L < j; L++) if (z === "RegExp") {
          if (typeof _[L] == "string" && _[L].match(T)) return true;
        } else if (_[L] === T) return true;
        return false;
      }
      function a(_, T) {
        if (!r(_) || !r(T) || _.length !== T.length) return false;
        _.sort(), T.sort();
        for (var L = 0, j = _.length; L < j; L++) if (_[L] !== T[L]) return false;
        return true;
      }
      function l(_) {
        var T = /^\/+|\/+$/g;
        return _.replace(T, "");
      }
      t._parts = function() {
        return { protocol: null, username: null, password: null, hostname: null, urn: null, port: null, path: null, query: null, fragment: null, preventInvalidHostname: t.preventInvalidHostname, duplicateQueryParameters: t.duplicateQueryParameters, escapeQuerySpace: t.escapeQuerySpace };
      }, t.preventInvalidHostname = false, t.duplicateQueryParameters = false, t.escapeQuerySpace = true, t.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, t.idn_expression = /[^a-z0-9\._-]/i, t.punycode_expression = /(xn--)/i, t.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, t.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, t.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/ig, t.findUri = { start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi, end: /[\s\r\n]|$/, trim: /[`!()\[\]{};:'".,<>?]+$/, parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g }, t.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/, t.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g, t.defaultPorts = { http: "80", https: "443", ftp: "21", gopher: "70", ws: "80", wss: "443" }, t.hostProtocols = ["http", "https"], t.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/, t.domAttributes = { a: "href", blockquote: "cite", link: "href", base: "href", script: "src", form: "action", img: "src", area: "href", iframe: "src", embed: "src", source: "src", track: "src", input: "src", audio: "src", video: "src" }, t.getDomAttribute = function(_) {
        if (!(!_ || !_.nodeName)) {
          var T = _.nodeName.toLowerCase();
          if (!(T === "input" && _.type !== "image")) return t.domAttributes[T];
        }
      };
      function d(_) {
        return escape(_);
      }
      function b(_) {
        return encodeURIComponent(_).replace(/[!'()*]/g, d).replace(/\*/g, "%2A");
      }
      t.encode = b, t.decode = decodeURIComponent, t.iso8859 = function() {
        t.encode = escape, t.decode = unescape;
      }, t.unicode = function() {
        t.encode = b, t.decode = decodeURIComponent;
      }, t.characters = { pathname: { encode: { expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig, map: { "%24": "$", "%26": "&", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%3A": ":", "%40": "@" } }, decode: { expression: /[\/\?#]/g, map: { "/": "%2F", "?": "%3F", "#": "%23" } } }, reserved: { encode: { expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig, map: { "%3A": ":", "%2F": "/", "%3F": "?", "%23": "#", "%5B": "[", "%5D": "]", "%40": "@", "%21": "!", "%24": "$", "%26": "&", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=" } } }, urnpath: { encode: { expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig, map: { "%21": "!", "%24": "$", "%27": "'", "%28": "(", "%29": ")", "%2A": "*", "%2B": "+", "%2C": ",", "%3B": ";", "%3D": "=", "%40": "@" } }, decode: { expression: /[\/\?#:]/g, map: { "/": "%2F", "?": "%3F", "#": "%23", ":": "%3A" } } } }, t.encodeQuery = function(_, T) {
        var L = t.encode(_ + "");
        return T === void 0 && (T = t.escapeQuerySpace), T ? L.replace(/%20/g, "+") : L;
      }, t.decodeQuery = function(_, T) {
        _ += "", T === void 0 && (T = t.escapeQuerySpace);
        try {
          return t.decode(T ? _.replace(/\+/g, "%20") : _);
        } catch {
          return _;
        }
      };
      var S = { encode: "encode", decode: "decode" }, E, R = function(_, T) {
        return function(L) {
          try {
            return t[T](L + "").replace(t.characters[_][T].expression, function(j) {
              return t.characters[_][T].map[j];
            });
          } catch {
            return L;
          }
        };
      };
      for (E in S) t[E + "PathSegment"] = R("pathname", S[E]), t[E + "UrnPathSegment"] = R("urnpath", S[E]);
      var k = function(_, T, L) {
        return function(j) {
          var z;
          L ? z = function(K) {
            return t[T](t[L](K));
          } : z = t[T];
          for (var Y = (j + "").split(_), te = 0, G = Y.length; te < G; te++) Y[te] = z(Y[te]);
          return Y.join(_);
        };
      };
      t.decodePath = k("/", "decodePathSegment"), t.decodeUrnPath = k(":", "decodeUrnPathSegment"), t.recodePath = k("/", "encodePathSegment", "decode"), t.recodeUrnPath = k(":", "encodeUrnPathSegment", "decode"), t.encodeReserved = R("reserved", "encode"), t.parse = function(_, T) {
        var L;
        return T || (T = { preventInvalidHostname: t.preventInvalidHostname }), _ = _.replace(t.leading_whitespace_expression, ""), _ = _.replace(t.ascii_tab_whitespace, ""), L = _.indexOf("#"), L > -1 && (T.fragment = _.substring(L + 1) || null, _ = _.substring(0, L)), L = _.indexOf("?"), L > -1 && (T.query = _.substring(L + 1) || null, _ = _.substring(0, L)), _ = _.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://"), _ = _.replace(/^[/\\]{2,}/i, "//"), _.substring(0, 2) === "//" ? (T.protocol = null, _ = _.substring(2), _ = t.parseAuthority(_, T)) : (L = _.indexOf(":"), L > -1 && (T.protocol = _.substring(0, L) || null, T.protocol && !T.protocol.match(t.protocol_expression) ? T.protocol = void 0 : _.substring(L + 1, L + 3).replace(/\\/g, "/") === "//" ? (_ = _.substring(L + 3), _ = t.parseAuthority(_, T)) : (_ = _.substring(L + 1), T.urn = true))), T.path = _, T;
      }, t.parseHost = function(_, T) {
        _ || (_ = ""), _ = _.replace(/\\/g, "/");
        var L = _.indexOf("/"), j, z;
        if (L === -1 && (L = _.length), _.charAt(0) === "[") j = _.indexOf("]"), T.hostname = _.substring(1, j) || null, T.port = _.substring(j + 2, L) || null, T.port === "/" && (T.port = null);
        else {
          var Y = _.indexOf(":"), te = _.indexOf("/"), G = _.indexOf(":", Y + 1);
          G !== -1 && (te === -1 || G < te) ? (T.hostname = _.substring(0, L) || null, T.port = null) : (z = _.substring(0, L).split(":"), T.hostname = z[0] || null, T.port = z[1] || null);
        }
        return T.hostname && _.substring(L).charAt(0) !== "/" && (L++, _ = "/" + _), T.preventInvalidHostname && t.ensureValidHostname(T.hostname, T.protocol), T.port && t.ensureValidPort(T.port), _.substring(L) || "/";
      }, t.parseAuthority = function(_, T) {
        return _ = t.parseUserinfo(_, T), t.parseHost(_, T);
      }, t.parseUserinfo = function(_, T) {
        var L = _, j = _.indexOf("\\");
        j !== -1 && (_ = _.replace(/\\/g, "/"));
        var z = _.indexOf("/"), Y = _.lastIndexOf("@", z > -1 ? z : _.length - 1), te;
        return Y > -1 && (z === -1 || Y < z) ? (te = _.substring(0, Y).split(":"), T.username = te[0] ? t.decode(te[0]) : null, te.shift(), T.password = te[0] ? t.decode(te.join(":")) : null, _ = L.substring(Y + 1)) : (T.username = null, T.password = null), _;
      }, t.parseQuery = function(_, T) {
        if (!_) return {};
        if (_ = _.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""), !_) return {};
        for (var L = {}, j = _.split("&"), z = j.length, Y, te, G, K = 0; K < z; K++) Y = j[K].split("="), te = t.decodeQuery(Y.shift(), T), G = Y.length ? t.decodeQuery(Y.join("="), T) : null, te !== "__proto__" && (c.call(L, te) ? ((typeof L[te] == "string" || L[te] === null) && (L[te] = [L[te]]), L[te].push(G)) : L[te] = G);
        return L;
      }, t.build = function(_) {
        var T = "", L = false;
        return _.protocol && (T += _.protocol + ":"), !_.urn && (T || _.hostname) && (T += "//", L = true), T += t.buildAuthority(_) || "", typeof _.path == "string" && (_.path.charAt(0) !== "/" && L && (T += "/"), T += _.path), typeof _.query == "string" && _.query && (T += "?" + _.query), typeof _.fragment == "string" && _.fragment && (T += "#" + _.fragment), T;
      }, t.buildHost = function(_) {
        var T = "";
        if (_.hostname) t.ip6_expression.test(_.hostname) ? T += "[" + _.hostname + "]" : T += _.hostname;
        else return "";
        return _.port && (T += ":" + _.port), T;
      }, t.buildAuthority = function(_) {
        return t.buildUserinfo(_) + t.buildHost(_);
      }, t.buildUserinfo = function(_) {
        var T = "";
        return _.username && (T += t.encode(_.username)), _.password && (T += ":" + t.encode(_.password)), T && (T += "@"), T;
      }, t.buildQuery = function(_, T, L) {
        var j = "", z, Y, te, G;
        for (Y in _) if (Y !== "__proto__" && c.call(_, Y)) if (r(_[Y])) for (z = {}, te = 0, G = _[Y].length; te < G; te++) _[Y][te] !== void 0 && z[_[Y][te] + ""] === void 0 && (j += "&" + t.buildQueryParameter(Y, _[Y][te], L), T !== true && (z[_[Y][te] + ""] = true));
        else _[Y] !== void 0 && (j += "&" + t.buildQueryParameter(Y, _[Y], L));
        return j.substring(1);
      }, t.buildQueryParameter = function(_, T, L) {
        return t.encodeQuery(_, L) + (T !== null ? "=" + t.encodeQuery(T, L) : "");
      }, t.addQuery = function(_, T, L) {
        if (typeof T == "object") for (var j in T) c.call(T, j) && t.addQuery(_, j, T[j]);
        else if (typeof T == "string") {
          if (_[T] === void 0) {
            _[T] = L;
            return;
          } else typeof _[T] == "string" && (_[T] = [_[T]]);
          r(L) || (L = [L]), _[T] = (_[T] || []).concat(L);
        } else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
      }, t.setQuery = function(_, T, L) {
        if (typeof T == "object") for (var j in T) c.call(T, j) && t.setQuery(_, j, T[j]);
        else if (typeof T == "string") _[T] = L === void 0 ? null : L;
        else throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
      }, t.removeQuery = function(_, T, L) {
        var j, z, Y;
        if (r(T)) for (j = 0, z = T.length; j < z; j++) _[T[j]] = void 0;
        else if (f(T) === "RegExp") for (Y in _) T.test(Y) && (_[Y] = void 0);
        else if (typeof T == "object") for (Y in T) c.call(T, Y) && t.removeQuery(_, Y, T[Y]);
        else if (typeof T == "string") L !== void 0 ? f(L) === "RegExp" ? !r(_[T]) && L.test(_[T]) ? _[T] = void 0 : _[T] = m(_[T], L) : _[T] === String(L) && (!r(L) || L.length === 1) ? _[T] = void 0 : r(_[T]) && (_[T] = m(_[T], L)) : _[T] = void 0;
        else throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
      }, t.hasQuery = function(_, T, L, j) {
        switch (f(T)) {
          case "String":
            break;
          case "RegExp":
            for (var z in _) if (c.call(_, z) && T.test(z) && (L === void 0 || t.hasQuery(_, z, L))) return true;
            return false;
          case "Object":
            for (var Y in T) if (c.call(T, Y) && !t.hasQuery(_, Y, T[Y])) return false;
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (f(L)) {
          case "Undefined":
            return T in _;
          case "Boolean":
            var te = !!(r(_[T]) ? _[T].length : _[T]);
            return L === te;
          case "Function":
            return !!L(_[T], T, _);
          case "Array":
            if (!r(_[T])) return false;
            var G = j ? g : a;
            return G(_[T], L);
          case "RegExp":
            return r(_[T]) ? j ? g(_[T], L) : false : !!(_[T] && _[T].match(L));
          case "Number":
            L = String(L);
          case "String":
            return r(_[T]) ? j ? g(_[T], L) : false : _[T] === L;
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      }, t.joinPaths = function() {
        for (var _ = [], T = [], L = 0, j = 0; j < arguments.length; j++) {
          var z = new t(arguments[j]);
          _.push(z);
          for (var Y = z.segment(), te = 0; te < Y.length; te++) typeof Y[te] == "string" && T.push(Y[te]), Y[te] && L++;
        }
        if (!T.length || !L) return new t("");
        var G = new t("").segment(T);
        return (_[0].path() === "" || _[0].path().slice(0, 1) === "/") && G.path("/" + G.path()), G.normalize();
      }, t.commonPath = function(_, T) {
        var L = Math.min(_.length, T.length), j;
        for (j = 0; j < L; j++) if (_.charAt(j) !== T.charAt(j)) {
          j--;
          break;
        }
        return j < 1 ? _.charAt(0) === T.charAt(0) && _.charAt(0) === "/" ? "/" : "" : ((_.charAt(j) !== "/" || T.charAt(j) !== "/") && (j = _.substring(0, j).lastIndexOf("/")), _.substring(0, j + 1));
      }, t.withinString = function(_, T, L) {
        L || (L = {});
        var j = L.start || t.findUri.start, z = L.end || t.findUri.end, Y = L.trim || t.findUri.trim, te = L.parens || t.findUri.parens, G = /[a-z0-9-]=["']?$/i;
        for (j.lastIndex = 0; ; ) {
          var K = j.exec(_);
          if (!K) break;
          var J = K.index;
          if (L.ignoreHtml) {
            var B = _.slice(Math.max(J - 3, 0), J);
            if (B && G.test(B)) continue;
          }
          for (var Z = J + _.slice(J).search(z), ie = _.slice(J, Z), $ = -1; ; ) {
            var oe = te.exec(ie);
            if (!oe) break;
            var ce = oe.index + oe[0].length;
            $ = Math.max($, ce);
          }
          if ($ > -1 ? ie = ie.slice(0, $) + ie.slice($).replace(Y, "") : ie = ie.replace(Y, ""), !(ie.length <= K[0].length) && !(L.ignore && L.ignore.test(ie))) {
            Z = J + ie.length;
            var ye = T(ie, J, Z, _);
            if (ye === void 0) {
              j.lastIndex = Z;
              continue;
            }
            ye = String(ye), _ = _.slice(0, J) + ye + _.slice(Z), j.lastIndex = J + ye.length;
          }
        }
        return j.lastIndex = 0, _;
      }, t.ensureValidHostname = function(_, T) {
        var L = !!_, j = !!T, z = false;
        if (j && (z = g(t.hostProtocols, T)), z && !L) throw new TypeError("Hostname cannot be empty, if protocol is " + T);
        if (_ && _.match(t.invalid_hostname_characters)) {
          if (!e) throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          if (e.toASCII(_).match(t.invalid_hostname_characters)) throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-:_]');
        }
      }, t.ensureValidPort = function(_) {
        if (_) {
          var T = Number(_);
          if (!(o(T) && T > 0 && T < 65536)) throw new TypeError('Port "' + _ + '" is not a valid port');
        }
      }, t.noConflict = function(_) {
        if (_) {
          var T = { URI: this.noConflict() };
          return s.URITemplate && typeof s.URITemplate.noConflict == "function" && (T.URITemplate = s.URITemplate.noConflict()), s.IPv6 && typeof s.IPv6.noConflict == "function" && (T.IPv6 = s.IPv6.noConflict()), s.SecondLevelDomains && typeof s.SecondLevelDomains.noConflict == "function" && (T.SecondLevelDomains = s.SecondLevelDomains.noConflict()), T;
        } else s.URI === this && (s.URI = y);
        return this;
      }, u.build = function(_) {
        return _ === true ? this._deferred_build = true : (_ === void 0 || this._deferred_build) && (this._string = t.build(this._parts), this._deferred_build = false), this;
      }, u.clone = function() {
        return new t(this);
      }, u.valueOf = u.toString = function() {
        return this.build(false)._string;
      };
      function w(_) {
        return function(T, L) {
          return T === void 0 ? this._parts[_] || "" : (this._parts[_] = T || null, this.build(!L), this);
        };
      }
      function F(_, T) {
        return function(L, j) {
          return L === void 0 ? this._parts[_] || "" : (L !== null && (L = L + "", L.charAt(0) === T && (L = L.substring(1))), this._parts[_] = L, this.build(!j), this);
        };
      }
      u.protocol = w("protocol"), u.username = w("username"), u.password = w("password"), u.hostname = w("hostname"), u.port = w("port"), u.query = F("query", "?"), u.fragment = F("fragment", "#"), u.search = function(_, T) {
        var L = this.query(_, T);
        return typeof L == "string" && L.length ? "?" + L : L;
      }, u.hash = function(_, T) {
        var L = this.fragment(_, T);
        return typeof L == "string" && L.length ? "#" + L : L;
      }, u.pathname = function(_, T) {
        if (_ === void 0 || _ === true) {
          var L = this._parts.path || (this._parts.hostname ? "/" : "");
          return _ ? (this._parts.urn ? t.decodeUrnPath : t.decodePath)(L) : L;
        } else return this._parts.urn ? this._parts.path = _ ? t.recodeUrnPath(_) : "" : this._parts.path = _ ? t.recodePath(_) : "/", this.build(!T), this;
      }, u.path = u.pathname, u.href = function(_, T) {
        var L;
        if (_ === void 0) return this.toString();
        this._string = "", this._parts = t._parts();
        var j = _ instanceof t, z = typeof _ == "object" && (_.hostname || _.path || _.pathname);
        if (_.nodeName) {
          var Y = t.getDomAttribute(_);
          _ = _[Y] || "", z = false;
        }
        if (!j && z && _.pathname !== void 0 && (_ = _.toString()), typeof _ == "string" || _ instanceof String) this._parts = t.parse(String(_), this._parts);
        else if (j || z) {
          var te = j ? _._parts : _;
          for (L in te) L !== "query" && c.call(this._parts, L) && (this._parts[L] = te[L]);
          te.query && this.query(te.query, false);
        } else throw new TypeError("invalid input");
        return this.build(!T), this;
      }, u.is = function(_) {
        var T = false, L = false, j = false, z = false, Y = false, te = false, G = false, K = !this._parts.urn;
        switch (this._parts.hostname && (K = false, L = t.ip4_expression.test(this._parts.hostname), j = t.ip6_expression.test(this._parts.hostname), T = L || j, z = !T, Y = z && i && i.has(this._parts.hostname), te = z && t.idn_expression.test(this._parts.hostname), G = z && t.punycode_expression.test(this._parts.hostname)), _.toLowerCase()) {
          case "relative":
            return K;
          case "absolute":
            return !K;
          case "domain":
          case "name":
            return z;
          case "sld":
            return Y;
          case "ip":
            return T;
          case "ip4":
          case "ipv4":
          case "inet4":
            return L;
          case "ip6":
          case "ipv6":
          case "inet6":
            return j;
          case "idn":
            return te;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return G;
        }
        return null;
      };
      var I = u.protocol, q = u.port, D = u.hostname;
      u.protocol = function(_, T) {
        if (_ && (_ = _.replace(/:(\/\/)?$/, ""), !_.match(t.protocol_expression))) throw new TypeError('Protocol "' + _ + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
        return I.call(this, _, T);
      }, u.scheme = u.protocol, u.port = function(_, T) {
        return this._parts.urn ? _ === void 0 ? "" : this : (_ !== void 0 && (_ === 0 && (_ = null), _ && (_ += "", _.charAt(0) === ":" && (_ = _.substring(1)), t.ensureValidPort(_))), q.call(this, _, T));
      }, u.hostname = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ !== void 0) {
          var L = { preventInvalidHostname: this._parts.preventInvalidHostname }, j = t.parseHost(_, L);
          if (j !== "/") throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
          _ = L.hostname, this._parts.preventInvalidHostname && t.ensureValidHostname(_, this._parts.protocol);
        }
        return D.call(this, _, T);
      }, u.origin = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0) {
          var L = this.protocol(), j = this.authority();
          return j ? (L ? L + "://" : "") + this.authority() : "";
        } else {
          var z = t(_);
          return this.protocol(z.protocol()).authority(z.authority()).build(!T), this;
        }
      }, u.host = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0) return this._parts.hostname ? t.buildHost(this._parts) : "";
        var L = t.parseHost(_, this._parts);
        if (L !== "/") throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
        return this.build(!T), this;
      }, u.authority = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0) return this._parts.hostname ? t.buildAuthority(this._parts) : "";
        var L = t.parseAuthority(_, this._parts);
        if (L !== "/") throw new TypeError('Hostname "' + _ + '" contains characters other than [A-Z0-9.-]');
        return this.build(!T), this;
      }, u.userinfo = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0) {
          var L = t.buildUserinfo(this._parts);
          return L && L.substring(0, L.length - 1);
        } else return _[_.length - 1] !== "@" && (_ += "@"), t.parseUserinfo(_, this._parts), this.build(!T), this;
      }, u.resource = function(_, T) {
        var L;
        return _ === void 0 ? this.path() + this.search() + this.hash() : (L = t.parse(_), this._parts.path = L.path, this._parts.query = L.query, this._parts.fragment = L.fragment, this.build(!T), this);
      }, u.subdomain = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0) {
          if (!this._parts.hostname || this.is("IP")) return "";
          var L = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, L) || "";
        } else {
          var j = this._parts.hostname.length - this.domain().length, z = this._parts.hostname.substring(0, j), Y = new RegExp("^" + h(z));
          if (_ && _.charAt(_.length - 1) !== "." && (_ += "."), _.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
          return _ && t.ensureValidHostname(_, this._parts.protocol), this._parts.hostname = this._parts.hostname.replace(Y, _), this.build(!T), this;
        }
      }, u.domain = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (typeof _ == "boolean" && (T = _, _ = void 0), _ === void 0) {
          if (!this._parts.hostname || this.is("IP")) return "";
          var L = this._parts.hostname.match(/\./g);
          if (L && L.length < 2) return this._parts.hostname;
          var j = this._parts.hostname.length - this.tld(T).length - 1;
          return j = this._parts.hostname.lastIndexOf(".", j - 1) + 1, this._parts.hostname.substring(j) || "";
        } else {
          if (!_) throw new TypeError("cannot set domain empty");
          if (_.indexOf(":") !== -1) throw new TypeError("Domains cannot contain colons");
          if (t.ensureValidHostname(_, this._parts.protocol), !this._parts.hostname || this.is("IP")) this._parts.hostname = _;
          else {
            var z = new RegExp(h(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(z, _);
          }
          return this.build(!T), this;
        }
      }, u.tld = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (typeof _ == "boolean" && (T = _, _ = void 0), _ === void 0) {
          if (!this._parts.hostname || this.is("IP")) return "";
          var L = this._parts.hostname.lastIndexOf("."), j = this._parts.hostname.substring(L + 1);
          return T !== true && i && i.list[j.toLowerCase()] && i.get(this._parts.hostname) || j;
        } else {
          var z;
          if (_) if (_.match(/[^a-zA-Z0-9-]/)) if (i && i.is(_)) z = new RegExp(h(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(z, _);
          else throw new TypeError('TLD "' + _ + '" contains characters other than [A-Z0-9]');
          else {
            if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host");
            z = new RegExp(h(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(z, _);
          }
          else throw new TypeError("cannot set TLD empty");
          return this.build(!T), this;
        }
      }, u.directory = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0 || _ === true) {
          if (!this._parts.path && !this._parts.hostname) return "";
          if (this._parts.path === "/") return "/";
          var L = this._parts.path.length - this.filename().length - 1, j = this._parts.path.substring(0, L) || (this._parts.hostname ? "/" : "");
          return _ ? t.decodePath(j) : j;
        } else {
          var z = this._parts.path.length - this.filename().length, Y = this._parts.path.substring(0, z), te = new RegExp("^" + h(Y));
          return this.is("relative") || (_ || (_ = "/"), _.charAt(0) !== "/" && (_ = "/" + _)), _ && _.charAt(_.length - 1) !== "/" && (_ += "/"), _ = t.recodePath(_), this._parts.path = this._parts.path.replace(te, _), this.build(!T), this;
        }
      }, u.filename = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (typeof _ != "string") {
          if (!this._parts.path || this._parts.path === "/") return "";
          var L = this._parts.path.lastIndexOf("/"), j = this._parts.path.substring(L + 1);
          return _ ? t.decodePathSegment(j) : j;
        } else {
          var z = false;
          _.charAt(0) === "/" && (_ = _.substring(1)), _.match(/\.?\//) && (z = true);
          var Y = new RegExp(h(this.filename()) + "$");
          return _ = t.recodePath(_), this._parts.path = this._parts.path.replace(Y, _), z ? this.normalizePath(T) : this.build(!T), this;
        }
      }, u.suffix = function(_, T) {
        if (this._parts.urn) return _ === void 0 ? "" : this;
        if (_ === void 0 || _ === true) {
          if (!this._parts.path || this._parts.path === "/") return "";
          var L = this.filename(), j = L.lastIndexOf("."), z, Y;
          return j === -1 ? "" : (z = L.substring(j + 1), Y = /^[a-z0-9%]+$/i.test(z) ? z : "", _ ? t.decodePathSegment(Y) : Y);
        } else {
          _.charAt(0) === "." && (_ = _.substring(1));
          var te = this.suffix(), G;
          if (te) _ ? G = new RegExp(h(te) + "$") : G = new RegExp(h("." + te) + "$");
          else {
            if (!_) return this;
            this._parts.path += "." + t.recodePath(_);
          }
          return G && (_ = t.recodePath(_), this._parts.path = this._parts.path.replace(G, _)), this.build(!T), this;
        }
      }, u.segment = function(_, T, L) {
        var j = this._parts.urn ? ":" : "/", z = this.path(), Y = z.substring(0, 1) === "/", te = z.split(j);
        if (_ !== void 0 && typeof _ != "number" && (L = T, T = _, _ = void 0), _ !== void 0 && typeof _ != "number") throw new Error('Bad segment "' + _ + '", must be 0-based integer');
        if (Y && te.shift(), _ < 0 && (_ = Math.max(te.length + _, 0)), T === void 0) return _ === void 0 ? te : te[_];
        if (_ === null || te[_] === void 0) if (r(T)) {
          te = [];
          for (var G = 0, K = T.length; G < K; G++) !T[G].length && (!te.length || !te[te.length - 1].length) || (te.length && !te[te.length - 1].length && te.pop(), te.push(l(T[G])));
        } else (T || typeof T == "string") && (T = l(T), te[te.length - 1] === "" ? te[te.length - 1] = T : te.push(T));
        else T ? te[_] = l(T) : te.splice(_, 1);
        return Y && te.unshift(""), this.path(te.join(j), L);
      }, u.segmentCoded = function(_, T, L) {
        var j, z, Y;
        if (typeof _ != "number" && (L = T, T = _, _ = void 0), T === void 0) {
          if (j = this.segment(_, T, L), !r(j)) j = j !== void 0 ? t.decode(j) : void 0;
          else for (z = 0, Y = j.length; z < Y; z++) j[z] = t.decode(j[z]);
          return j;
        }
        if (!r(T)) T = typeof T == "string" || T instanceof String ? t.encode(T) : T;
        else for (z = 0, Y = T.length; z < Y; z++) T[z] = t.encode(T[z]);
        return this.segment(_, T, L);
      };
      var H = u.query;
      return u.query = function(_, T) {
        if (_ === true) return t.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof _ == "function") {
          var L = t.parseQuery(this._parts.query, this._parts.escapeQuerySpace), j = _.call(this, L);
          return this._parts.query = t.buildQuery(j || L, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!T), this;
        } else return _ !== void 0 && typeof _ != "string" ? (this._parts.query = t.buildQuery(_, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), this.build(!T), this) : H.call(this, _, T);
      }, u.setQuery = function(_, T, L) {
        var j = t.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof _ == "string" || _ instanceof String) j[_] = T !== void 0 ? T : null;
        else if (typeof _ == "object") for (var z in _) c.call(_, z) && (j[z] = _[z]);
        else throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        return this._parts.query = t.buildQuery(j, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (L = T), this.build(!L), this;
      }, u.addQuery = function(_, T, L) {
        var j = t.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return t.addQuery(j, _, T === void 0 ? null : T), this._parts.query = t.buildQuery(j, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (L = T), this.build(!L), this;
      }, u.removeQuery = function(_, T, L) {
        var j = t.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return t.removeQuery(j, _, T), this._parts.query = t.buildQuery(j, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), typeof _ != "string" && (L = T), this.build(!L), this;
      }, u.hasQuery = function(_, T, L) {
        var j = t.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return t.hasQuery(j, _, T, L);
      }, u.setSearch = u.setQuery, u.addSearch = u.addQuery, u.removeSearch = u.removeQuery, u.hasSearch = u.hasQuery, u.normalize = function() {
        return this._parts.urn ? this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build() : this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      }, u.normalizeProtocol = function(_) {
        return typeof this._parts.protocol == "string" && (this._parts.protocol = this._parts.protocol.toLowerCase(), this.build(!_)), this;
      }, u.normalizeHostname = function(_) {
        return this._parts.hostname && (this.is("IDN") && e ? this._parts.hostname = e.toASCII(this._parts.hostname) : this.is("IPv6") && n && (this._parts.hostname = n.best(this._parts.hostname)), this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!_)), this;
      }, u.normalizePort = function(_) {
        return typeof this._parts.protocol == "string" && this._parts.port === t.defaultPorts[this._parts.protocol] && (this._parts.port = null, this.build(!_)), this;
      }, u.normalizePath = function(_) {
        var T = this._parts.path;
        if (!T) return this;
        if (this._parts.urn) return this._parts.path = t.recodeUrnPath(this._parts.path), this.build(!_), this;
        if (this._parts.path === "/") return this;
        T = t.recodePath(T);
        var L, j = "", z, Y;
        for (T.charAt(0) !== "/" && (L = true, T = "/" + T), (T.slice(-3) === "/.." || T.slice(-2) === "/.") && (T += "/"), T = T.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), L && (j = T.substring(1).match(/^(\.\.\/)+/) || "", j && (j = j[0])); z = T.search(/\/\.\.(\/|$)/), z !== -1; ) {
          if (z === 0) {
            T = T.substring(3);
            continue;
          }
          Y = T.substring(0, z).lastIndexOf("/"), Y === -1 && (Y = z), T = T.substring(0, Y) + T.substring(z + 3);
        }
        return L && this.is("relative") && (T = j + T.substring(1)), this._parts.path = T, this.build(!_), this;
      }, u.normalizePathname = u.normalizePath, u.normalizeQuery = function(_) {
        return typeof this._parts.query == "string" && (this._parts.query.length ? this.query(t.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, this.build(!_)), this;
      }, u.normalizeFragment = function(_) {
        return this._parts.fragment || (this._parts.fragment = null, this.build(!_)), this;
      }, u.normalizeSearch = u.normalizeQuery, u.normalizeHash = u.normalizeFragment, u.iso8859 = function() {
        var _ = t.encode, T = t.decode;
        t.encode = escape, t.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          t.encode = _, t.decode = T;
        }
        return this;
      }, u.unicode = function() {
        var _ = t.encode, T = t.decode;
        t.encode = b, t.decode = unescape;
        try {
          this.normalize();
        } finally {
          t.encode = _, t.decode = T;
        }
        return this;
      }, u.readable = function() {
        var _ = this.clone();
        _.username("").password("").normalize();
        var T = "";
        if (_._parts.protocol && (T += _._parts.protocol + "://"), _._parts.hostname && (_.is("punycode") && e ? (T += e.toUnicode(_._parts.hostname), _._parts.port && (T += ":" + _._parts.port)) : T += _.host()), _._parts.hostname && _._parts.path && _._parts.path.charAt(0) !== "/" && (T += "/"), T += _.path(true), _._parts.query) {
          for (var L = "", j = 0, z = _._parts.query.split("&"), Y = z.length; j < Y; j++) {
            var te = (z[j] || "").split("=");
            L += "&" + t.decodeQuery(te[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), te[1] !== void 0 && (L += "=" + t.decodeQuery(te[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
          }
          T += "?" + L.substring(1);
        }
        return T += t.decodeQuery(_.hash(), true), T;
      }, u.absoluteTo = function(_) {
        var T = this.clone(), L = ["protocol", "username", "password", "hostname", "port"], j, z, Y;
        if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
        if (_ instanceof t || (_ = new t(_)), T._parts.protocol || (T._parts.protocol = _._parts.protocol, this._parts.hostname)) return T;
        for (z = 0; Y = L[z]; z++) T._parts[Y] = _._parts[Y];
        return T._parts.path ? (T._parts.path.substring(-2) === ".." && (T._parts.path += "/"), T.path().charAt(0) !== "/" && (j = _.directory(), j = j || (_.path().indexOf("/") === 0 ? "/" : ""), T._parts.path = (j ? j + "/" : "") + T._parts.path, T.normalizePath())) : (T._parts.path = _._parts.path, T._parts.query || (T._parts.query = _._parts.query)), T.build(), T;
      }, u.relativeTo = function(_) {
        var T = this.clone().normalize(), L, j, z, Y, te;
        if (T._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
        if (_ = new t(_).normalize(), L = T._parts, j = _._parts, Y = T.path(), te = _.path(), Y.charAt(0) !== "/") throw new Error("URI is already relative");
        if (te.charAt(0) !== "/") throw new Error("Cannot calculate a URI relative to another relative URI");
        if (L.protocol === j.protocol && (L.protocol = null), L.username !== j.username || L.password !== j.password || L.protocol !== null || L.username !== null || L.password !== null) return T.build();
        if (L.hostname === j.hostname && L.port === j.port) L.hostname = null, L.port = null;
        else return T.build();
        if (Y === te) return L.path = "", T.build();
        if (z = t.commonPath(Y, te), !z) return T.build();
        var G = j.path.substring(z.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        return L.path = G + L.path.substring(z.length) || "./", T.build();
      }, u.equals = function(_) {
        var T = this.clone(), L = new t(_), j = {}, z = {}, Y = {}, te, G, K;
        if (T.normalize(), L.normalize(), T.toString() === L.toString()) return true;
        if (te = T.query(), G = L.query(), T.query(""), L.query(""), T.toString() !== L.toString() || te.length !== G.length) return false;
        j = t.parseQuery(te, this._parts.escapeQuerySpace), z = t.parseQuery(G, this._parts.escapeQuerySpace);
        for (K in j) if (c.call(j, K)) {
          if (r(j[K])) {
            if (!a(j[K], z[K])) return false;
          } else if (j[K] !== z[K]) return false;
          Y[K] = true;
        }
        for (K in z) if (c.call(z, K) && !Y[K]) return false;
        return true;
      }, u.preventInvalidHostname = function(_) {
        return this._parts.preventInvalidHostname = !!_, this;
      }, u.duplicateQueryParameters = function(_) {
        return this._parts.duplicateQueryParameters = !!_, this;
      }, u.escapeQuerySpace = function(_) {
        return this._parts.escapeQuerySpace = !!_, this;
      }, t;
    });
  }(ic)), ic.exports;
}
var Ks = { exports: {} }, Bc = {}, Nc = {}, sc = { exports: {} };
/*! For license information please see xdr.js.LICENSE.txt */
var xy = sc.exports, Nf;
function Ai() {
  return Nf || (Nf = 1, function(v, e) {
    (function(n, i) {
      v.exports = i();
    })(xy, () => (() => {
      var n = { 616: (y, t, o) => {
        o.d(t, { A: () => c });
        var u = o(287);
        u.hp.alloc(1).subarray(0, 1) instanceof u.hp || (u.hp.prototype.subarray = function(h, f) {
          const r = Uint8Array.prototype.subarray.call(this, h, f);
          return Object.setPrototypeOf(r, u.hp.prototype), r;
        });
        const c = u.hp;
      }, 281: (y, t, o) => {
        const u = o(164);
        y.exports = u;
      }, 164: (y, t, o) => {
        o.r(t), o.d(t, { Array: () => ae, Bool: () => B, Double: () => K, Enum: () => Te, Float: () => G, Hyper: () => j, Int: () => H, LargeInt: () => L, Opaque: () => oe, Option: () => ne, Quadruple: () => J, Reference: () => pe, String: () => ie, Struct: () => Oe, Union: () => Ve, UnsignedHyper: () => te, UnsignedInt: () => Y, VarArray: () => ue, VarOpaque: () => ye, Void: () => ge, XdrReader: () => m, XdrWriter: () => l, config: () => N });
        class u extends TypeError {
          constructor(p) {
            super(`XDR Write Error: ${p}`);
          }
        }
        class c extends TypeError {
          constructor(p) {
            super(`XDR Read Error: ${p}`);
          }
        }
        class h extends TypeError {
          constructor(p) {
            super(`XDR Type Definition Error: ${p}`);
          }
        }
        class f extends h {
          constructor() {
            super("method not implemented, it should be overloaded in the descendant class.");
          }
        }
        var r = o(616).A;
        class m {
          constructor(p) {
            __publicField(this, "_buffer");
            __publicField(this, "_length");
            __publicField(this, "_index");
            if (!r.isBuffer(p)) {
              if (!(p instanceof Array || Array.isArray(p) || ArrayBuffer.isView(p))) throw new c(`source invalid: ${p}`);
              p = r.from(p);
            }
            this._buffer = p, this._length = p.length, this._index = 0;
          }
          get eof() {
            return this._index === this._length;
          }
          advance(p) {
            const A = this._index;
            if (this._index += p, this._length < this._index) throw new c("attempt to read outside the boundary of the buffer");
            const U = 4 - (p % 4 || 4);
            if (U > 0) {
              for (let Q = 0; Q < U; Q++) if (this._buffer[this._index + Q] !== 0) throw new c("invalid padding");
              this._index += U;
            }
            return A;
          }
          rewind() {
            this._index = 0;
          }
          read(p) {
            const A = this.advance(p);
            return this._buffer.subarray(A, A + p);
          }
          readInt32BE() {
            return this._buffer.readInt32BE(this.advance(4));
          }
          readUInt32BE() {
            return this._buffer.readUInt32BE(this.advance(4));
          }
          readBigInt64BE() {
            return this._buffer.readBigInt64BE(this.advance(8));
          }
          readBigUInt64BE() {
            return this._buffer.readBigUInt64BE(this.advance(8));
          }
          readFloatBE() {
            return this._buffer.readFloatBE(this.advance(4));
          }
          readDoubleBE() {
            return this._buffer.readDoubleBE(this.advance(8));
          }
          ensureInputConsumed() {
            if (this._index !== this._length) throw new c("invalid XDR contract typecast - source buffer not entirely consumed");
          }
        }
        var g = o(616).A;
        const a = 8192;
        class l {
          constructor(p) {
            __publicField(this, "_buffer");
            __publicField(this, "_length");
            __publicField(this, "_index", 0);
            typeof p == "number" ? p = g.allocUnsafe(p) : p instanceof g || (p = g.allocUnsafe(a)), this._buffer = p, this._length = p.length;
          }
          alloc(p) {
            const A = this._index;
            return this._index += p, this._length < this._index && this.resize(this._index), A;
          }
          resize(p) {
            const A = Math.ceil(p / a) * a, U = g.allocUnsafe(A);
            this._buffer.copy(U, 0, 0, this._length), this._buffer = U, this._length = A;
          }
          finalize() {
            return this._buffer.subarray(0, this._index);
          }
          toArray() {
            return [...this.finalize()];
          }
          write(p, A) {
            if (typeof p == "string") {
              const Q = this.alloc(A);
              this._buffer.write(p, Q, "utf8");
            } else {
              p instanceof g || (p = g.from(p));
              const Q = this.alloc(A);
              p.copy(this._buffer, Q, 0, A);
            }
            const U = 4 - (A % 4 || 4);
            if (U > 0) {
              const Q = this.alloc(U);
              this._buffer.fill(0, Q, this._index);
            }
          }
          writeInt32BE(p) {
            const A = this.alloc(4);
            this._buffer.writeInt32BE(p, A);
          }
          writeUInt32BE(p) {
            const A = this.alloc(4);
            this._buffer.writeUInt32BE(p, A);
          }
          writeBigInt64BE(p) {
            const A = this.alloc(8);
            this._buffer.writeBigInt64BE(p, A);
          }
          writeBigUInt64BE(p) {
            const A = this.alloc(8);
            this._buffer.writeBigUInt64BE(p, A);
          }
          writeFloatBE(p) {
            const A = this.alloc(4);
            this._buffer.writeFloatBE(p, A);
          }
          writeDoubleBE(p) {
            const A = this.alloc(8);
            this._buffer.writeDoubleBE(p, A);
          }
        }
        __publicField(l, "bufferChunkSize", a);
        var d = o(616).A;
        class b {
          toXDR(p = "raw") {
            if (!this.write) return this.constructor.toXDR(this, p);
            const A = new l();
            return this.write(this, A), k(A.finalize(), p);
          }
          fromXDR(p, A = "raw") {
            if (!this.read) return this.constructor.fromXDR(p, A);
            const U = new m(w(p, A)), Q = this.read(U);
            return U.ensureInputConsumed(), Q;
          }
          validateXDR(p, A = "raw") {
            try {
              return this.fromXDR(p, A), true;
            } catch {
              return false;
            }
          }
          static toXDR(p, A = "raw") {
            const U = new l();
            return this.write(p, U), k(U.finalize(), A);
          }
          static fromXDR(p, A = "raw") {
            const U = new m(w(p, A)), Q = this.read(U);
            return U.ensureInputConsumed(), Q;
          }
          static validateXDR(p, A = "raw") {
            try {
              return this.fromXDR(p, A), true;
            } catch {
              return false;
            }
          }
        }
        class S extends b {
          static read(p) {
            throw new f();
          }
          static write(p, A) {
            throw new f();
          }
          static isValid(p) {
            return false;
          }
        }
        class E extends b {
          isValid(p) {
            return false;
          }
        }
        class R extends TypeError {
          constructor(p) {
            super(`Invalid format ${p}, must be one of "raw", "hex", "base64"`);
          }
        }
        function k(C, p) {
          switch (p) {
            case "raw":
              return C;
            case "hex":
              return C.toString("hex");
            case "base64":
              return C.toString("base64");
            default:
              throw new R(p);
          }
        }
        function w(C, p) {
          switch (p) {
            case "raw":
              return C;
            case "hex":
              return d.from(C, "hex");
            case "base64":
              return d.from(C, "base64");
            default:
              throw new R(p);
          }
        }
        function F(C, p) {
          return C != null && (C instanceof p || I(C, p) && typeof C.constructor.read == "function" && typeof C.constructor.write == "function" && I(C, "XdrType"));
        }
        function I(C, p) {
          do
            if (C.constructor.name === p) return true;
          while (C = Object.getPrototypeOf(C));
          return false;
        }
        const q = 2147483647, D = -2147483648;
        class H extends S {
          static read(p) {
            return p.readInt32BE();
          }
          static write(p, A) {
            if (typeof p != "number") throw new u("not a number");
            if ((0 | p) !== p) throw new u("invalid i32 value");
            A.writeInt32BE(p);
          }
          static isValid(p) {
            return typeof p == "number" && (0 | p) === p && p >= D && p <= q;
          }
        }
        function _(C, p, A) {
          if (typeof C != "bigint") throw new TypeError("Expected bigint 'value', got " + typeof C);
          const U = p / A;
          if (U === 1) return [C];
          if (A < 32 || A > 128 || U !== 2 && U !== 4 && U !== 8) throw new TypeError(`invalid bigint (${C}) and slice size (${p} -> ${A}) combination`);
          const Q = BigInt(A), se = new Array(U);
          for (let X = 0; X < U; X++) se[X] = BigInt.asIntN(A, C), C >>= Q;
          return se;
        }
        function T(C, p) {
          if (p) return [0n, (1n << BigInt(C)) - 1n];
          const A = 1n << BigInt(C - 1);
          return [0n - A, A - 1n];
        }
        H.MAX_VALUE = q, H.MIN_VALUE = 2147483648;
        class L extends S {
          constructor(p) {
            super(), this._value = function(A, U, Q) {
              A instanceof Array ? A.length && A[0] instanceof Array && (A = A[0]) : A = [A];
              const se = U / A.length;
              switch (se) {
                case 32:
                case 64:
                case 128:
                case 256:
                  break;
                default:
                  throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${A}`);
              }
              try {
                for (let Ne = 0; Ne < A.length; Ne++) typeof A[Ne] != "bigint" && (A[Ne] = BigInt(A[Ne].valueOf()));
              } catch (Ne) {
                throw new TypeError(`expected bigint-like values, got: ${A} (${Ne})`);
              }
              if (Q && A.length === 1 && A[0] < 0n) throw new RangeError(`expected a positive value, got: ${A}`);
              let X = BigInt.asUintN(se, A[0]);
              for (let Ne = 1; Ne < A.length; Ne++) X |= BigInt.asUintN(se, A[Ne]) << BigInt(Ne * se);
              Q || (X = BigInt.asIntN(U, X));
              const [de, tt] = T(U, Q);
              if (X >= de && X <= tt) return X;
              throw new TypeError(`bigint values [${A}] for ${function(Ne, ut) {
                return `${ut ? "u" : "i"}${Ne}`;
              }(U, Q)} out of range [${de}, ${tt}]: ${X}`);
            }(p, this.size, this.unsigned);
          }
          get unsigned() {
            throw new f();
          }
          get size() {
            throw new f();
          }
          slice(p) {
            return _(this._value, this.size, p);
          }
          toString() {
            return this._value.toString();
          }
          toJSON() {
            return { _value: this._value.toString() };
          }
          toBigInt() {
            return BigInt(this._value);
          }
          static read(p) {
            const { size: A } = this.prototype;
            return A === 64 ? new this(p.readBigUInt64BE()) : new this(...Array.from({ length: A / 64 }, () => p.readBigUInt64BE()).reverse());
          }
          static write(p, A) {
            if (p instanceof this) p = p._value;
            else if (typeof p != "bigint" || p > this.MAX_VALUE || p < this.MIN_VALUE) throw new u(`${p} is not a ${this.name}`);
            const { unsigned: U, size: Q } = this.prototype;
            if (Q === 64) U ? A.writeBigUInt64BE(p) : A.writeBigInt64BE(p);
            else for (const se of _(p, Q, 64).reverse()) U ? A.writeBigUInt64BE(se) : A.writeBigInt64BE(se);
          }
          static isValid(p) {
            return typeof p == "bigint" || p instanceof this;
          }
          static fromString(p) {
            return new this(p);
          }
          static defineIntBoundaries() {
            const [p, A] = T(this.prototype.size, this.prototype.unsigned);
            this.MIN_VALUE = p, this.MAX_VALUE = A;
          }
        }
        __publicField(L, "MAX_VALUE", 0n);
        __publicField(L, "MIN_VALUE", 0n);
        class j extends L {
          constructor(...p) {
            super(p);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return false;
          }
          static fromBits(p, A) {
            return new this(p, A);
          }
        }
        j.defineIntBoundaries();
        const z = 4294967295;
        class Y extends S {
          static read(p) {
            return p.readUInt32BE();
          }
          static write(p, A) {
            if (typeof p != "number" || !(p >= 0 && p <= z) || p % 1 != 0) throw new u("invalid u32 value");
            A.writeUInt32BE(p);
          }
          static isValid(p) {
            return typeof p == "number" && p % 1 == 0 && p >= 0 && p <= z;
          }
        }
        Y.MAX_VALUE = z, Y.MIN_VALUE = 0;
        class te extends L {
          constructor(...p) {
            super(p);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return true;
          }
          static fromBits(p, A) {
            return new this(p, A);
          }
        }
        te.defineIntBoundaries();
        class G extends S {
          static read(p) {
            return p.readFloatBE();
          }
          static write(p, A) {
            if (typeof p != "number") throw new u("not a number");
            A.writeFloatBE(p);
          }
          static isValid(p) {
            return typeof p == "number";
          }
        }
        class K extends S {
          static read(p) {
            return p.readDoubleBE();
          }
          static write(p, A) {
            if (typeof p != "number") throw new u("not a number");
            A.writeDoubleBE(p);
          }
          static isValid(p) {
            return typeof p == "number";
          }
        }
        class J extends S {
          static read() {
            throw new h("quadruple not supported");
          }
          static write() {
            throw new h("quadruple not supported");
          }
          static isValid() {
            return false;
          }
        }
        class B extends S {
          static read(p) {
            const A = H.read(p);
            switch (A) {
              case 0:
                return false;
              case 1:
                return true;
              default:
                throw new c(`got ${A} when trying to read a bool`);
            }
          }
          static write(p, A) {
            const U = p ? 1 : 0;
            H.write(U, A);
          }
          static isValid(p) {
            return typeof p == "boolean";
          }
        }
        var Z = o(616).A;
        class ie extends E {
          constructor(p = Y.MAX_VALUE) {
            super(), this._maxLength = p;
          }
          read(p) {
            const A = Y.read(p);
            if (A > this._maxLength) throw new c(`saw ${A} length String, max allowed is ${this._maxLength}`);
            return p.read(A);
          }
          readString(p) {
            return this.read(p).toString("utf8");
          }
          write(p, A) {
            const U = typeof p == "string" ? Z.byteLength(p, "utf8") : p.length;
            if (U > this._maxLength) throw new u(`got ${p.length} bytes, max allowed is ${this._maxLength}`);
            Y.write(U, A), A.write(p, U);
          }
          isValid(p) {
            return typeof p == "string" ? Z.byteLength(p, "utf8") <= this._maxLength : !!(p instanceof Array || Z.isBuffer(p)) && p.length <= this._maxLength;
          }
        }
        var $ = o(616).A;
        class oe extends E {
          constructor(p) {
            super(), this._length = p;
          }
          read(p) {
            return p.read(this._length);
          }
          write(p, A) {
            const { length: U } = p;
            if (U !== this._length) throw new u(`got ${p.length} bytes, expected ${this._length}`);
            A.write(p, U);
          }
          isValid(p) {
            return $.isBuffer(p) && p.length === this._length;
          }
        }
        var ce = o(616).A;
        class ye extends E {
          constructor(p = Y.MAX_VALUE) {
            super(), this._maxLength = p;
          }
          read(p) {
            const A = Y.read(p);
            if (A > this._maxLength) throw new c(`saw ${A} length VarOpaque, max allowed is ${this._maxLength}`);
            return p.read(A);
          }
          write(p, A) {
            const { length: U } = p;
            if (p.length > this._maxLength) throw new u(`got ${p.length} bytes, max allowed is ${this._maxLength}`);
            Y.write(U, A), A.write(p, U);
          }
          isValid(p) {
            return ce.isBuffer(p) && p.length <= this._maxLength;
          }
        }
        class ae extends E {
          constructor(p, A) {
            super(), this._childType = p, this._length = A;
          }
          read(p) {
            const A = new o.g.Array(this._length);
            for (let U = 0; U < this._length; U++) A[U] = this._childType.read(p);
            return A;
          }
          write(p, A) {
            if (!o.g.Array.isArray(p)) throw new u("value is not array");
            if (p.length !== this._length) throw new u(`got array of size ${p.length}, expected ${this._length}`);
            for (const U of p) this._childType.write(U, A);
          }
          isValid(p) {
            if (!(p instanceof o.g.Array) || p.length !== this._length) return false;
            for (const A of p) if (!this._childType.isValid(A)) return false;
            return true;
          }
        }
        class ue extends E {
          constructor(p, A = Y.MAX_VALUE) {
            super(), this._childType = p, this._maxLength = A;
          }
          read(p) {
            const A = Y.read(p);
            if (A > this._maxLength) throw new c(`saw ${A} length VarArray, max allowed is ${this._maxLength}`);
            const U = new Array(A);
            for (let Q = 0; Q < A; Q++) U[Q] = this._childType.read(p);
            return U;
          }
          write(p, A) {
            if (!(p instanceof Array)) throw new u("value is not array");
            if (p.length > this._maxLength) throw new u(`got array of size ${p.length}, max allowed is ${this._maxLength}`);
            Y.write(p.length, A);
            for (const U of p) this._childType.write(U, A);
          }
          isValid(p) {
            if (!(p instanceof Array) || p.length > this._maxLength) return false;
            for (const A of p) if (!this._childType.isValid(A)) return false;
            return true;
          }
        }
        class ne extends S {
          constructor(p) {
            super(), this._childType = p;
          }
          read(p) {
            if (B.read(p)) return this._childType.read(p);
          }
          write(p, A) {
            const U = p != null;
            B.write(U, A), U && this._childType.write(p, A);
          }
          isValid(p) {
            return p == null || this._childType.isValid(p);
          }
        }
        class ge extends S {
          static read() {
          }
          static write(p) {
            if (p !== void 0) throw new u("trying to write value to a void slot");
          }
          static isValid(p) {
            return p === void 0;
          }
        }
        class Te extends S {
          constructor(p, A) {
            super(), this.name = p, this.value = A;
          }
          static read(p) {
            const A = H.read(p), U = this._byValue[A];
            if (U === void 0) throw new c(`unknown ${this.enumName} member for value ${A}`);
            return U;
          }
          static write(p, A) {
            if (!this.isValid(p)) throw new u(`${p} has enum name ${p == null ? void 0 : p.enumName}, not ${this.enumName}: ${JSON.stringify(p)}`);
            H.write(p.value, A);
          }
          static isValid(p) {
            var _a2;
            return ((_a2 = p == null ? void 0 : p.constructor) == null ? void 0 : _a2.enumName) === this.enumName || F(p, this);
          }
          static members() {
            return this._members;
          }
          static values() {
            return Object.values(this._members);
          }
          static fromName(p) {
            const A = this._members[p];
            if (!A) throw new TypeError(`${p} is not a member of ${this.enumName}`);
            return A;
          }
          static fromValue(p) {
            const A = this._byValue[p];
            if (A === void 0) throw new TypeError(`${p} is not a value of any member of ${this.enumName}`);
            return A;
          }
          static create(p, A, U) {
            const Q = class extends Te {
            };
            Q.enumName = A, p.results[A] = Q, Q._members = {}, Q._byValue = {};
            for (const [se, X] of Object.entries(U)) {
              const de = new Q(se, X);
              Q._members[se] = de, Q._byValue[X] = de, Q[se] = () => de;
            }
            return Q;
          }
        }
        class pe extends S {
          resolve() {
            throw new h('"resolve" method should be implemented in the descendant class');
          }
        }
        class Oe extends E {
          constructor(p) {
            super(), this._attributes = p || {};
          }
          static read(p) {
            const A = {};
            for (const [U, Q] of this._fields) A[U] = Q.read(p);
            return new this(A);
          }
          static write(p, A) {
            var _a2;
            if (!this.isValid(p)) throw new u(`${p} has struct name ${(_a2 = p == null ? void 0 : p.constructor) == null ? void 0 : _a2.structName}, not ${this.structName}: ${JSON.stringify(p)}`);
            for (const [U, Q] of this._fields) {
              const se = p._attributes[U];
              Q.write(se, A);
            }
          }
          static isValid(p) {
            var _a2;
            return ((_a2 = p == null ? void 0 : p.constructor) == null ? void 0 : _a2.structName) === this.structName || F(p, this);
          }
          static create(p, A, U) {
            const Q = class extends Oe {
            };
            Q.structName = A, p.results[A] = Q;
            const se = new Array(U.length);
            for (let X = 0; X < U.length; X++) {
              const de = U[X], tt = de[0];
              let Ne = de[1];
              Ne instanceof pe && (Ne = Ne.resolve(p)), se[X] = [tt, Ne], Q.prototype[tt] = xe(tt);
            }
            return Q._fields = se, Q;
          }
        }
        function xe(C) {
          return function(p) {
            return p !== void 0 && (this._attributes[C] = p), this._attributes[C];
          };
        }
        class Ve extends E {
          constructor(p, A) {
            super(), this.set(p, A);
          }
          set(p, A) {
            typeof p == "string" && (p = this.constructor._switchOn.fromName(p)), this._switch = p;
            const U = this.constructor.armForSwitch(this._switch);
            this._arm = U, this._armType = U === ge ? ge : this.constructor._arms[U], this._value = A;
          }
          get(p = this._arm) {
            if (this._arm !== ge && this._arm !== p) throw new TypeError(`${p} not set`);
            return this._value;
          }
          switch() {
            return this._switch;
          }
          arm() {
            return this._arm;
          }
          armType() {
            return this._armType;
          }
          value() {
            return this._value;
          }
          static armForSwitch(p) {
            const A = this._switches.get(p);
            if (A !== void 0) return A;
            if (this._defaultArm) return this._defaultArm;
            throw new TypeError(`Bad union switch: ${p}`);
          }
          static armTypeForArm(p) {
            return p === ge ? ge : this._arms[p];
          }
          static read(p) {
            const A = this._switchOn.read(p), U = this.armForSwitch(A), Q = U === ge ? ge : this._arms[U];
            let se;
            return se = Q !== void 0 ? Q.read(p) : U.read(p), new this(A, se);
          }
          static write(p, A) {
            if (!this.isValid(p)) throw new u(`${p} has union name ${p == null ? void 0 : p.unionName}, not ${this.unionName}: ${JSON.stringify(p)}`);
            this._switchOn.write(p.switch(), A), p.armType().write(p.value(), A);
          }
          static isValid(p) {
            var _a2;
            return ((_a2 = p == null ? void 0 : p.constructor) == null ? void 0 : _a2.unionName) === this.unionName || F(p, this);
          }
          static create(p, A, U) {
            const Q = class extends Ve {
            };
            Q.unionName = A, p.results[A] = Q, U.switchOn instanceof pe ? Q._switchOn = U.switchOn.resolve(p) : Q._switchOn = U.switchOn, Q._switches = /* @__PURE__ */ new Map(), Q._arms = {};
            let se = U.defaultArm;
            se instanceof pe && (se = se.resolve(p)), Q._defaultArm = se;
            for (const [X, de] of U.switches) {
              const tt = typeof X == "string" ? Q._switchOn.fromName(X) : X;
              Q._switches.set(tt, de);
            }
            if (Q._switchOn.values !== void 0) for (const X of Q._switchOn.values()) Q[X.name] = function(de) {
              return new Q(X, de);
            }, Q.prototype[X.name] = function(de) {
              return this.set(X, de);
            };
            if (U.arms) for (const [X, de] of Object.entries(U.arms)) Q._arms[X] = de instanceof pe ? de.resolve(p) : de, de !== ge && (Q.prototype[X] = function() {
              return this.get(X);
            });
            return Q;
          }
        }
        class _e extends pe {
          constructor(p) {
            super(), this.name = p;
          }
          resolve(p) {
            return p.definitions[this.name].resolve(p);
          }
        }
        class Be extends pe {
          constructor(p, A, U = false) {
            super(), this.childReference = p, this.length = A, this.variable = U;
          }
          resolve(p) {
            let A = this.childReference, U = this.length;
            return A instanceof pe && (A = A.resolve(p)), U instanceof pe && (U = U.resolve(p)), this.variable ? new ue(A, U) : new ae(A, U);
          }
        }
        class Qe extends pe {
          constructor(p) {
            super(), this.childReference = p, this.name = p.name;
          }
          resolve(p) {
            let A = this.childReference;
            return A instanceof pe && (A = A.resolve(p)), new ne(A);
          }
        }
        class ee extends pe {
          constructor(p, A) {
            super(), this.sizedType = p, this.length = A;
          }
          resolve(p) {
            let A = this.length;
            return A instanceof pe && (A = A.resolve(p)), new this.sizedType(A);
          }
        }
        class P {
          constructor(p, A, U) {
            this.constructor = p, this.name = A, this.config = U;
          }
          resolve(p) {
            return this.name in p.results ? p.results[this.name] : this.constructor(p, this.name, this.config);
          }
        }
        function x(C, p, A) {
          return A instanceof pe && (A = A.resolve(C)), C.results[p] = A, A;
        }
        function O(C, p, A) {
          return C.results[p] = A, A;
        }
        class V {
          constructor(p) {
            this._destination = p, this._definitions = {};
          }
          enum(p, A) {
            const U = new P(Te.create, p, A);
            this.define(p, U);
          }
          struct(p, A) {
            const U = new P(Oe.create, p, A);
            this.define(p, U);
          }
          union(p, A) {
            const U = new P(Ve.create, p, A);
            this.define(p, U);
          }
          typedef(p, A) {
            const U = new P(x, p, A);
            this.define(p, U);
          }
          const(p, A) {
            const U = new P(O, p, A);
            this.define(p, U);
          }
          void() {
            return ge;
          }
          bool() {
            return B;
          }
          int() {
            return H;
          }
          hyper() {
            return j;
          }
          uint() {
            return Y;
          }
          uhyper() {
            return te;
          }
          float() {
            return G;
          }
          double() {
            return K;
          }
          quadruple() {
            return J;
          }
          string(p) {
            return new ee(ie, p);
          }
          opaque(p) {
            return new ee(oe, p);
          }
          varOpaque(p) {
            return new ee(ye, p);
          }
          array(p, A) {
            return new Be(p, A);
          }
          varArray(p, A) {
            return new Be(p, A, true);
          }
          option(p) {
            return new Qe(p);
          }
          define(p, A) {
            if (this._destination[p] !== void 0) throw new h(`${p} is already defined`);
            this._definitions[p] = A;
          }
          lookup(p) {
            return new _e(p);
          }
          resolve() {
            for (const p of Object.values(this._definitions)) p.resolve({ definitions: this._definitions, results: this._destination });
          }
        }
        function N(C, p = {}) {
          if (C) {
            const A = new V(p);
            C(A), A.resolve();
          }
          return p;
        }
      }, 526: (y, t) => {
        t.byteLength = function(g) {
          var a = r(g), l = a[0], d = a[1];
          return 3 * (l + d) / 4 - d;
        }, t.toByteArray = function(g) {
          var a, l, d = r(g), b = d[0], S = d[1], E = new c(function(w, F, I) {
            return 3 * (F + I) / 4 - I;
          }(0, b, S)), R = 0, k = S > 0 ? b - 4 : b;
          for (l = 0; l < k; l += 4) a = u[g.charCodeAt(l)] << 18 | u[g.charCodeAt(l + 1)] << 12 | u[g.charCodeAt(l + 2)] << 6 | u[g.charCodeAt(l + 3)], E[R++] = a >> 16 & 255, E[R++] = a >> 8 & 255, E[R++] = 255 & a;
          return S === 2 && (a = u[g.charCodeAt(l)] << 2 | u[g.charCodeAt(l + 1)] >> 4, E[R++] = 255 & a), S === 1 && (a = u[g.charCodeAt(l)] << 10 | u[g.charCodeAt(l + 1)] << 4 | u[g.charCodeAt(l + 2)] >> 2, E[R++] = a >> 8 & 255, E[R++] = 255 & a), E;
        }, t.fromByteArray = function(g) {
          for (var a, l = g.length, d = l % 3, b = [], S = 16383, E = 0, R = l - d; E < R; E += S) b.push(m(g, E, E + S > R ? R : E + S));
          return d === 1 ? (a = g[l - 1], b.push(o[a >> 2] + o[a << 4 & 63] + "==")) : d === 2 && (a = (g[l - 2] << 8) + g[l - 1], b.push(o[a >> 10] + o[a >> 4 & 63] + o[a << 2 & 63] + "=")), b.join("");
        };
        for (var o = [], u = [], c = typeof Uint8Array < "u" ? Uint8Array : Array, h = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", f = 0; f < 64; ++f) o[f] = h[f], u[h.charCodeAt(f)] = f;
        function r(g) {
          var a = g.length;
          if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var l = g.indexOf("=");
          return l === -1 && (l = a), [l, l === a ? 0 : 4 - l % 4];
        }
        function m(g, a, l) {
          for (var d, b, S = [], E = a; E < l; E += 3) d = (g[E] << 16 & 16711680) + (g[E + 1] << 8 & 65280) + (255 & g[E + 2]), S.push(o[(b = d) >> 18 & 63] + o[b >> 12 & 63] + o[b >> 6 & 63] + o[63 & b]);
          return S.join("");
        }
        u[45] = 62, u[95] = 63;
      }, 287: (y, t, o) => {
        const u = o(526), c = o(251), h = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        t.hp = m, t.IS = 50;
        const f = 2147483647;
        function r(P) {
          if (P > f) throw new RangeError('The value "' + P + '" is invalid for option "size"');
          const x = new Uint8Array(P);
          return Object.setPrototypeOf(x, m.prototype), x;
        }
        function m(P, x, O) {
          if (typeof P == "number") {
            if (typeof x == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return l(P);
          }
          return g(P, x, O);
        }
        function g(P, x, O) {
          if (typeof P == "string") return function(C, p) {
            if (typeof p == "string" && p !== "" || (p = "utf8"), !m.isEncoding(p)) throw new TypeError("Unknown encoding: " + p);
            const A = 0 | E(C, p);
            let U = r(A);
            const Q = U.write(C, p);
            return Q !== A && (U = U.slice(0, Q)), U;
          }(P, x);
          if (ArrayBuffer.isView(P)) return function(C) {
            if (Ve(C, Uint8Array)) {
              const p = new Uint8Array(C);
              return b(p.buffer, p.byteOffset, p.byteLength);
            }
            return d(C);
          }(P);
          if (P == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P);
          if (Ve(P, ArrayBuffer) || P && Ve(P.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Ve(P, SharedArrayBuffer) || P && Ve(P.buffer, SharedArrayBuffer))) return b(P, x, O);
          if (typeof P == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
          const V = P.valueOf && P.valueOf();
          if (V != null && V !== P) return m.from(V, x, O);
          const N = function(C) {
            if (m.isBuffer(C)) {
              const p = 0 | S(C.length), A = r(p);
              return A.length === 0 || C.copy(A, 0, 0, p), A;
            }
            if (C.length !== void 0) return typeof C.length != "number" || _e(C.length) ? r(0) : d(C);
            if (C.type === "Buffer" && Array.isArray(C.data)) return d(C.data);
          }(P);
          if (N) return N;
          if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof P[Symbol.toPrimitive] == "function") return m.from(P[Symbol.toPrimitive]("string"), x, O);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof P);
        }
        function a(P) {
          if (typeof P != "number") throw new TypeError('"size" argument must be of type number');
          if (P < 0) throw new RangeError('The value "' + P + '" is invalid for option "size"');
        }
        function l(P) {
          return a(P), r(P < 0 ? 0 : 0 | S(P));
        }
        function d(P) {
          const x = P.length < 0 ? 0 : 0 | S(P.length), O = r(x);
          for (let V = 0; V < x; V += 1) O[V] = 255 & P[V];
          return O;
        }
        function b(P, x, O) {
          if (x < 0 || P.byteLength < x) throw new RangeError('"offset" is outside of buffer bounds');
          if (P.byteLength < x + (O || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let V;
          return V = x === void 0 && O === void 0 ? new Uint8Array(P) : O === void 0 ? new Uint8Array(P, x) : new Uint8Array(P, x, O), Object.setPrototypeOf(V, m.prototype), V;
        }
        function S(P) {
          if (P >= f) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + f.toString(16) + " bytes");
          return 0 | P;
        }
        function E(P, x) {
          if (m.isBuffer(P)) return P.length;
          if (ArrayBuffer.isView(P) || Ve(P, ArrayBuffer)) return P.byteLength;
          if (typeof P != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof P);
          const O = P.length, V = arguments.length > 2 && arguments[2] === true;
          if (!V && O === 0) return 0;
          let N = false;
          for (; ; ) switch (x) {
            case "ascii":
            case "latin1":
            case "binary":
              return O;
            case "utf8":
            case "utf-8":
              return pe(P).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * O;
            case "hex":
              return O >>> 1;
            case "base64":
              return Oe(P).length;
            default:
              if (N) return V ? -1 : pe(P).length;
              x = ("" + x).toLowerCase(), N = true;
          }
        }
        function R(P, x, O) {
          let V = false;
          if ((x === void 0 || x < 0) && (x = 0), x > this.length || ((O === void 0 || O > this.length) && (O = this.length), O <= 0) || (O >>>= 0) <= (x >>>= 0)) return "";
          for (P || (P = "utf8"); ; ) switch (P) {
            case "hex":
              return te(this, x, O);
            case "utf8":
            case "utf-8":
              return L(this, x, O);
            case "ascii":
              return z(this, x, O);
            case "latin1":
            case "binary":
              return Y(this, x, O);
            case "base64":
              return T(this, x, O);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return G(this, x, O);
            default:
              if (V) throw new TypeError("Unknown encoding: " + P);
              P = (P + "").toLowerCase(), V = true;
          }
        }
        function k(P, x, O) {
          const V = P[x];
          P[x] = P[O], P[O] = V;
        }
        function w(P, x, O, V, N) {
          if (P.length === 0) return -1;
          if (typeof O == "string" ? (V = O, O = 0) : O > 2147483647 ? O = 2147483647 : O < -2147483648 && (O = -2147483648), _e(O = +O) && (O = N ? 0 : P.length - 1), O < 0 && (O = P.length + O), O >= P.length) {
            if (N) return -1;
            O = P.length - 1;
          } else if (O < 0) {
            if (!N) return -1;
            O = 0;
          }
          if (typeof x == "string" && (x = m.from(x, V)), m.isBuffer(x)) return x.length === 0 ? -1 : F(P, x, O, V, N);
          if (typeof x == "number") return x &= 255, typeof Uint8Array.prototype.indexOf == "function" ? N ? Uint8Array.prototype.indexOf.call(P, x, O) : Uint8Array.prototype.lastIndexOf.call(P, x, O) : F(P, [x], O, V, N);
          throw new TypeError("val must be string, number or Buffer");
        }
        function F(P, x, O, V, N) {
          let C, p = 1, A = P.length, U = x.length;
          if (V !== void 0 && ((V = String(V).toLowerCase()) === "ucs2" || V === "ucs-2" || V === "utf16le" || V === "utf-16le")) {
            if (P.length < 2 || x.length < 2) return -1;
            p = 2, A /= 2, U /= 2, O /= 2;
          }
          function Q(se, X) {
            return p === 1 ? se[X] : se.readUInt16BE(X * p);
          }
          if (N) {
            let se = -1;
            for (C = O; C < A; C++) if (Q(P, C) === Q(x, se === -1 ? 0 : C - se)) {
              if (se === -1 && (se = C), C - se + 1 === U) return se * p;
            } else se !== -1 && (C -= C - se), se = -1;
          } else for (O + U > A && (O = A - U), C = O; C >= 0; C--) {
            let se = true;
            for (let X = 0; X < U; X++) if (Q(P, C + X) !== Q(x, X)) {
              se = false;
              break;
            }
            if (se) return C;
          }
          return -1;
        }
        function I(P, x, O, V) {
          O = Number(O) || 0;
          const N = P.length - O;
          V ? (V = Number(V)) > N && (V = N) : V = N;
          const C = x.length;
          let p;
          for (V > C / 2 && (V = C / 2), p = 0; p < V; ++p) {
            const A = parseInt(x.substr(2 * p, 2), 16);
            if (_e(A)) return p;
            P[O + p] = A;
          }
          return p;
        }
        function q(P, x, O, V) {
          return xe(pe(x, P.length - O), P, O, V);
        }
        function D(P, x, O, V) {
          return xe(function(N) {
            const C = [];
            for (let p = 0; p < N.length; ++p) C.push(255 & N.charCodeAt(p));
            return C;
          }(x), P, O, V);
        }
        function H(P, x, O, V) {
          return xe(Oe(x), P, O, V);
        }
        function _(P, x, O, V) {
          return xe(function(N, C) {
            let p, A, U;
            const Q = [];
            for (let se = 0; se < N.length && !((C -= 2) < 0); ++se) p = N.charCodeAt(se), A = p >> 8, U = p % 256, Q.push(U), Q.push(A);
            return Q;
          }(x, P.length - O), P, O, V);
        }
        function T(P, x, O) {
          return x === 0 && O === P.length ? u.fromByteArray(P) : u.fromByteArray(P.slice(x, O));
        }
        function L(P, x, O) {
          O = Math.min(P.length, O);
          const V = [];
          let N = x;
          for (; N < O; ) {
            const C = P[N];
            let p = null, A = C > 239 ? 4 : C > 223 ? 3 : C > 191 ? 2 : 1;
            if (N + A <= O) {
              let U, Q, se, X;
              switch (A) {
                case 1:
                  C < 128 && (p = C);
                  break;
                case 2:
                  U = P[N + 1], (192 & U) == 128 && (X = (31 & C) << 6 | 63 & U, X > 127 && (p = X));
                  break;
                case 3:
                  U = P[N + 1], Q = P[N + 2], (192 & U) == 128 && (192 & Q) == 128 && (X = (15 & C) << 12 | (63 & U) << 6 | 63 & Q, X > 2047 && (X < 55296 || X > 57343) && (p = X));
                  break;
                case 4:
                  U = P[N + 1], Q = P[N + 2], se = P[N + 3], (192 & U) == 128 && (192 & Q) == 128 && (192 & se) == 128 && (X = (15 & C) << 18 | (63 & U) << 12 | (63 & Q) << 6 | 63 & se, X > 65535 && X < 1114112 && (p = X));
              }
            }
            p === null ? (p = 65533, A = 1) : p > 65535 && (p -= 65536, V.push(p >>> 10 & 1023 | 55296), p = 56320 | 1023 & p), V.push(p), N += A;
          }
          return function(C) {
            const p = C.length;
            if (p <= j) return String.fromCharCode.apply(String, C);
            let A = "", U = 0;
            for (; U < p; ) A += String.fromCharCode.apply(String, C.slice(U, U += j));
            return A;
          }(V);
        }
        m.TYPED_ARRAY_SUPPORT = function() {
          try {
            const P = new Uint8Array(1), x = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(x, Uint8Array.prototype), Object.setPrototypeOf(P, x), P.foo() === 42;
          } catch {
            return false;
          }
        }(), m.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(m.prototype, "parent", { enumerable: true, get: function() {
          if (m.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(m.prototype, "offset", { enumerable: true, get: function() {
          if (m.isBuffer(this)) return this.byteOffset;
        } }), m.poolSize = 8192, m.from = function(P, x, O) {
          return g(P, x, O);
        }, Object.setPrototypeOf(m.prototype, Uint8Array.prototype), Object.setPrototypeOf(m, Uint8Array), m.alloc = function(P, x, O) {
          return function(V, N, C) {
            return a(V), V <= 0 ? r(V) : N !== void 0 ? typeof C == "string" ? r(V).fill(N, C) : r(V).fill(N) : r(V);
          }(P, x, O);
        }, m.allocUnsafe = function(P) {
          return l(P);
        }, m.allocUnsafeSlow = function(P) {
          return l(P);
        }, m.isBuffer = function(P) {
          return P != null && P._isBuffer === true && P !== m.prototype;
        }, m.compare = function(P, x) {
          if (Ve(P, Uint8Array) && (P = m.from(P, P.offset, P.byteLength)), Ve(x, Uint8Array) && (x = m.from(x, x.offset, x.byteLength)), !m.isBuffer(P) || !m.isBuffer(x)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (P === x) return 0;
          let O = P.length, V = x.length;
          for (let N = 0, C = Math.min(O, V); N < C; ++N) if (P[N] !== x[N]) {
            O = P[N], V = x[N];
            break;
          }
          return O < V ? -1 : V < O ? 1 : 0;
        }, m.isEncoding = function(P) {
          switch (String(P).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, m.concat = function(P, x) {
          if (!Array.isArray(P)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (P.length === 0) return m.alloc(0);
          let O;
          if (x === void 0) for (x = 0, O = 0; O < P.length; ++O) x += P[O].length;
          const V = m.allocUnsafe(x);
          let N = 0;
          for (O = 0; O < P.length; ++O) {
            let C = P[O];
            if (Ve(C, Uint8Array)) N + C.length > V.length ? (m.isBuffer(C) || (C = m.from(C)), C.copy(V, N)) : Uint8Array.prototype.set.call(V, C, N);
            else {
              if (!m.isBuffer(C)) throw new TypeError('"list" argument must be an Array of Buffers');
              C.copy(V, N);
            }
            N += C.length;
          }
          return V;
        }, m.byteLength = E, m.prototype._isBuffer = true, m.prototype.swap16 = function() {
          const P = this.length;
          if (P % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let x = 0; x < P; x += 2) k(this, x, x + 1);
          return this;
        }, m.prototype.swap32 = function() {
          const P = this.length;
          if (P % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let x = 0; x < P; x += 4) k(this, x, x + 3), k(this, x + 1, x + 2);
          return this;
        }, m.prototype.swap64 = function() {
          const P = this.length;
          if (P % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let x = 0; x < P; x += 8) k(this, x, x + 7), k(this, x + 1, x + 6), k(this, x + 2, x + 5), k(this, x + 3, x + 4);
          return this;
        }, m.prototype.toString = function() {
          const P = this.length;
          return P === 0 ? "" : arguments.length === 0 ? L(this, 0, P) : R.apply(this, arguments);
        }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(P) {
          if (!m.isBuffer(P)) throw new TypeError("Argument must be a Buffer");
          return this === P || m.compare(this, P) === 0;
        }, m.prototype.inspect = function() {
          let P = "";
          const x = t.IS;
          return P = this.toString("hex", 0, x).replace(/(.{2})/g, "$1 ").trim(), this.length > x && (P += " ... "), "<Buffer " + P + ">";
        }, h && (m.prototype[h] = m.prototype.inspect), m.prototype.compare = function(P, x, O, V, N) {
          if (Ve(P, Uint8Array) && (P = m.from(P, P.offset, P.byteLength)), !m.isBuffer(P)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof P);
          if (x === void 0 && (x = 0), O === void 0 && (O = P ? P.length : 0), V === void 0 && (V = 0), N === void 0 && (N = this.length), x < 0 || O > P.length || V < 0 || N > this.length) throw new RangeError("out of range index");
          if (V >= N && x >= O) return 0;
          if (V >= N) return -1;
          if (x >= O) return 1;
          if (this === P) return 0;
          let C = (N >>>= 0) - (V >>>= 0), p = (O >>>= 0) - (x >>>= 0);
          const A = Math.min(C, p), U = this.slice(V, N), Q = P.slice(x, O);
          for (let se = 0; se < A; ++se) if (U[se] !== Q[se]) {
            C = U[se], p = Q[se];
            break;
          }
          return C < p ? -1 : p < C ? 1 : 0;
        }, m.prototype.includes = function(P, x, O) {
          return this.indexOf(P, x, O) !== -1;
        }, m.prototype.indexOf = function(P, x, O) {
          return w(this, P, x, O, true);
        }, m.prototype.lastIndexOf = function(P, x, O) {
          return w(this, P, x, O, false);
        }, m.prototype.write = function(P, x, O, V) {
          if (x === void 0) V = "utf8", O = this.length, x = 0;
          else if (O === void 0 && typeof x == "string") V = x, O = this.length, x = 0;
          else {
            if (!isFinite(x)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            x >>>= 0, isFinite(O) ? (O >>>= 0, V === void 0 && (V = "utf8")) : (V = O, O = void 0);
          }
          const N = this.length - x;
          if ((O === void 0 || O > N) && (O = N), P.length > 0 && (O < 0 || x < 0) || x > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          V || (V = "utf8");
          let C = false;
          for (; ; ) switch (V) {
            case "hex":
              return I(this, P, x, O);
            case "utf8":
            case "utf-8":
              return q(this, P, x, O);
            case "ascii":
            case "latin1":
            case "binary":
              return D(this, P, x, O);
            case "base64":
              return H(this, P, x, O);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return _(this, P, x, O);
            default:
              if (C) throw new TypeError("Unknown encoding: " + V);
              V = ("" + V).toLowerCase(), C = true;
          }
        }, m.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const j = 4096;
        function z(P, x, O) {
          let V = "";
          O = Math.min(P.length, O);
          for (let N = x; N < O; ++N) V += String.fromCharCode(127 & P[N]);
          return V;
        }
        function Y(P, x, O) {
          let V = "";
          O = Math.min(P.length, O);
          for (let N = x; N < O; ++N) V += String.fromCharCode(P[N]);
          return V;
        }
        function te(P, x, O) {
          const V = P.length;
          (!x || x < 0) && (x = 0), (!O || O < 0 || O > V) && (O = V);
          let N = "";
          for (let C = x; C < O; ++C) N += Be[P[C]];
          return N;
        }
        function G(P, x, O) {
          const V = P.slice(x, O);
          let N = "";
          for (let C = 0; C < V.length - 1; C += 2) N += String.fromCharCode(V[C] + 256 * V[C + 1]);
          return N;
        }
        function K(P, x, O) {
          if (P % 1 != 0 || P < 0) throw new RangeError("offset is not uint");
          if (P + x > O) throw new RangeError("Trying to access beyond buffer length");
        }
        function J(P, x, O, V, N, C) {
          if (!m.isBuffer(P)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (x > N || x < C) throw new RangeError('"value" argument is out of bounds');
          if (O + V > P.length) throw new RangeError("Index out of range");
        }
        function B(P, x, O, V, N) {
          ue(x, V, N, P, O, 7);
          let C = Number(x & BigInt(4294967295));
          P[O++] = C, C >>= 8, P[O++] = C, C >>= 8, P[O++] = C, C >>= 8, P[O++] = C;
          let p = Number(x >> BigInt(32) & BigInt(4294967295));
          return P[O++] = p, p >>= 8, P[O++] = p, p >>= 8, P[O++] = p, p >>= 8, P[O++] = p, O;
        }
        function Z(P, x, O, V, N) {
          ue(x, V, N, P, O, 7);
          let C = Number(x & BigInt(4294967295));
          P[O + 7] = C, C >>= 8, P[O + 6] = C, C >>= 8, P[O + 5] = C, C >>= 8, P[O + 4] = C;
          let p = Number(x >> BigInt(32) & BigInt(4294967295));
          return P[O + 3] = p, p >>= 8, P[O + 2] = p, p >>= 8, P[O + 1] = p, p >>= 8, P[O] = p, O + 8;
        }
        function ie(P, x, O, V, N, C) {
          if (O + V > P.length) throw new RangeError("Index out of range");
          if (O < 0) throw new RangeError("Index out of range");
        }
        function $(P, x, O, V, N) {
          return x = +x, O >>>= 0, N || ie(P, 0, O, 4), c.write(P, x, O, V, 23, 4), O + 4;
        }
        function oe(P, x, O, V, N) {
          return x = +x, O >>>= 0, N || ie(P, 0, O, 8), c.write(P, x, O, V, 52, 8), O + 8;
        }
        m.prototype.slice = function(P, x) {
          const O = this.length;
          (P = ~~P) < 0 ? (P += O) < 0 && (P = 0) : P > O && (P = O), (x = x === void 0 ? O : ~~x) < 0 ? (x += O) < 0 && (x = 0) : x > O && (x = O), x < P && (x = P);
          const V = this.subarray(P, x);
          return Object.setPrototypeOf(V, m.prototype), V;
        }, m.prototype.readUintLE = m.prototype.readUIntLE = function(P, x, O) {
          P >>>= 0, x >>>= 0, O || K(P, x, this.length);
          let V = this[P], N = 1, C = 0;
          for (; ++C < x && (N *= 256); ) V += this[P + C] * N;
          return V;
        }, m.prototype.readUintBE = m.prototype.readUIntBE = function(P, x, O) {
          P >>>= 0, x >>>= 0, O || K(P, x, this.length);
          let V = this[P + --x], N = 1;
          for (; x > 0 && (N *= 256); ) V += this[P + --x] * N;
          return V;
        }, m.prototype.readUint8 = m.prototype.readUInt8 = function(P, x) {
          return P >>>= 0, x || K(P, 1, this.length), this[P];
        }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(P, x) {
          return P >>>= 0, x || K(P, 2, this.length), this[P] | this[P + 1] << 8;
        }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(P, x) {
          return P >>>= 0, x || K(P, 2, this.length), this[P] << 8 | this[P + 1];
        }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), (this[P] | this[P + 1] << 8 | this[P + 2] << 16) + 16777216 * this[P + 3];
        }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), 16777216 * this[P] + (this[P + 1] << 16 | this[P + 2] << 8 | this[P + 3]);
        }, m.prototype.readBigUInt64LE = Qe(function(P) {
          ne(P >>>= 0, "offset");
          const x = this[P], O = this[P + 7];
          x !== void 0 && O !== void 0 || ge(P, this.length - 8);
          const V = x + 256 * this[++P] + 65536 * this[++P] + this[++P] * 2 ** 24, N = this[++P] + 256 * this[++P] + 65536 * this[++P] + O * 2 ** 24;
          return BigInt(V) + (BigInt(N) << BigInt(32));
        }), m.prototype.readBigUInt64BE = Qe(function(P) {
          ne(P >>>= 0, "offset");
          const x = this[P], O = this[P + 7];
          x !== void 0 && O !== void 0 || ge(P, this.length - 8);
          const V = x * 2 ** 24 + 65536 * this[++P] + 256 * this[++P] + this[++P], N = this[++P] * 2 ** 24 + 65536 * this[++P] + 256 * this[++P] + O;
          return (BigInt(V) << BigInt(32)) + BigInt(N);
        }), m.prototype.readIntLE = function(P, x, O) {
          P >>>= 0, x >>>= 0, O || K(P, x, this.length);
          let V = this[P], N = 1, C = 0;
          for (; ++C < x && (N *= 256); ) V += this[P + C] * N;
          return N *= 128, V >= N && (V -= Math.pow(2, 8 * x)), V;
        }, m.prototype.readIntBE = function(P, x, O) {
          P >>>= 0, x >>>= 0, O || K(P, x, this.length);
          let V = x, N = 1, C = this[P + --V];
          for (; V > 0 && (N *= 256); ) C += this[P + --V] * N;
          return N *= 128, C >= N && (C -= Math.pow(2, 8 * x)), C;
        }, m.prototype.readInt8 = function(P, x) {
          return P >>>= 0, x || K(P, 1, this.length), 128 & this[P] ? -1 * (255 - this[P] + 1) : this[P];
        }, m.prototype.readInt16LE = function(P, x) {
          P >>>= 0, x || K(P, 2, this.length);
          const O = this[P] | this[P + 1] << 8;
          return 32768 & O ? 4294901760 | O : O;
        }, m.prototype.readInt16BE = function(P, x) {
          P >>>= 0, x || K(P, 2, this.length);
          const O = this[P + 1] | this[P] << 8;
          return 32768 & O ? 4294901760 | O : O;
        }, m.prototype.readInt32LE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), this[P] | this[P + 1] << 8 | this[P + 2] << 16 | this[P + 3] << 24;
        }, m.prototype.readInt32BE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), this[P] << 24 | this[P + 1] << 16 | this[P + 2] << 8 | this[P + 3];
        }, m.prototype.readBigInt64LE = Qe(function(P) {
          ne(P >>>= 0, "offset");
          const x = this[P], O = this[P + 7];
          x !== void 0 && O !== void 0 || ge(P, this.length - 8);
          const V = this[P + 4] + 256 * this[P + 5] + 65536 * this[P + 6] + (O << 24);
          return (BigInt(V) << BigInt(32)) + BigInt(x + 256 * this[++P] + 65536 * this[++P] + this[++P] * 16777216);
        }), m.prototype.readBigInt64BE = Qe(function(P) {
          ne(P >>>= 0, "offset");
          const x = this[P], O = this[P + 7];
          x !== void 0 && O !== void 0 || ge(P, this.length - 8);
          const V = (x << 24) + 65536 * this[++P] + 256 * this[++P] + this[++P];
          return (BigInt(V) << BigInt(32)) + BigInt(this[++P] * 16777216 + 65536 * this[++P] + 256 * this[++P] + O);
        }), m.prototype.readFloatLE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), c.read(this, P, true, 23, 4);
        }, m.prototype.readFloatBE = function(P, x) {
          return P >>>= 0, x || K(P, 4, this.length), c.read(this, P, false, 23, 4);
        }, m.prototype.readDoubleLE = function(P, x) {
          return P >>>= 0, x || K(P, 8, this.length), c.read(this, P, true, 52, 8);
        }, m.prototype.readDoubleBE = function(P, x) {
          return P >>>= 0, x || K(P, 8, this.length), c.read(this, P, false, 52, 8);
        }, m.prototype.writeUintLE = m.prototype.writeUIntLE = function(P, x, O, V) {
          P = +P, x >>>= 0, O >>>= 0, !V && J(this, P, x, O, Math.pow(2, 8 * O) - 1, 0);
          let N = 1, C = 0;
          for (this[x] = 255 & P; ++C < O && (N *= 256); ) this[x + C] = P / N & 255;
          return x + O;
        }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(P, x, O, V) {
          P = +P, x >>>= 0, O >>>= 0, !V && J(this, P, x, O, Math.pow(2, 8 * O) - 1, 0);
          let N = O - 1, C = 1;
          for (this[x + N] = 255 & P; --N >= 0 && (C *= 256); ) this[x + N] = P / C & 255;
          return x + O;
        }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 1, 255, 0), this[x] = 255 & P, x + 1;
        }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 2, 65535, 0), this[x] = 255 & P, this[x + 1] = P >>> 8, x + 2;
        }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 2, 65535, 0), this[x] = P >>> 8, this[x + 1] = 255 & P, x + 2;
        }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 4, 4294967295, 0), this[x + 3] = P >>> 24, this[x + 2] = P >>> 16, this[x + 1] = P >>> 8, this[x] = 255 & P, x + 4;
        }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 4, 4294967295, 0), this[x] = P >>> 24, this[x + 1] = P >>> 16, this[x + 2] = P >>> 8, this[x + 3] = 255 & P, x + 4;
        }, m.prototype.writeBigUInt64LE = Qe(function(P, x = 0) {
          return B(this, P, x, BigInt(0), BigInt("0xffffffffffffffff"));
        }), m.prototype.writeBigUInt64BE = Qe(function(P, x = 0) {
          return Z(this, P, x, BigInt(0), BigInt("0xffffffffffffffff"));
        }), m.prototype.writeIntLE = function(P, x, O, V) {
          if (P = +P, x >>>= 0, !V) {
            const A = Math.pow(2, 8 * O - 1);
            J(this, P, x, O, A - 1, -A);
          }
          let N = 0, C = 1, p = 0;
          for (this[x] = 255 & P; ++N < O && (C *= 256); ) P < 0 && p === 0 && this[x + N - 1] !== 0 && (p = 1), this[x + N] = (P / C | 0) - p & 255;
          return x + O;
        }, m.prototype.writeIntBE = function(P, x, O, V) {
          if (P = +P, x >>>= 0, !V) {
            const A = Math.pow(2, 8 * O - 1);
            J(this, P, x, O, A - 1, -A);
          }
          let N = O - 1, C = 1, p = 0;
          for (this[x + N] = 255 & P; --N >= 0 && (C *= 256); ) P < 0 && p === 0 && this[x + N + 1] !== 0 && (p = 1), this[x + N] = (P / C | 0) - p & 255;
          return x + O;
        }, m.prototype.writeInt8 = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 1, 127, -128), P < 0 && (P = 255 + P + 1), this[x] = 255 & P, x + 1;
        }, m.prototype.writeInt16LE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 2, 32767, -32768), this[x] = 255 & P, this[x + 1] = P >>> 8, x + 2;
        }, m.prototype.writeInt16BE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 2, 32767, -32768), this[x] = P >>> 8, this[x + 1] = 255 & P, x + 2;
        }, m.prototype.writeInt32LE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 4, 2147483647, -2147483648), this[x] = 255 & P, this[x + 1] = P >>> 8, this[x + 2] = P >>> 16, this[x + 3] = P >>> 24, x + 4;
        }, m.prototype.writeInt32BE = function(P, x, O) {
          return P = +P, x >>>= 0, O || J(this, P, x, 4, 2147483647, -2147483648), P < 0 && (P = 4294967295 + P + 1), this[x] = P >>> 24, this[x + 1] = P >>> 16, this[x + 2] = P >>> 8, this[x + 3] = 255 & P, x + 4;
        }, m.prototype.writeBigInt64LE = Qe(function(P, x = 0) {
          return B(this, P, x, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), m.prototype.writeBigInt64BE = Qe(function(P, x = 0) {
          return Z(this, P, x, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), m.prototype.writeFloatLE = function(P, x, O) {
          return $(this, P, x, true, O);
        }, m.prototype.writeFloatBE = function(P, x, O) {
          return $(this, P, x, false, O);
        }, m.prototype.writeDoubleLE = function(P, x, O) {
          return oe(this, P, x, true, O);
        }, m.prototype.writeDoubleBE = function(P, x, O) {
          return oe(this, P, x, false, O);
        }, m.prototype.copy = function(P, x, O, V) {
          if (!m.isBuffer(P)) throw new TypeError("argument should be a Buffer");
          if (O || (O = 0), V || V === 0 || (V = this.length), x >= P.length && (x = P.length), x || (x = 0), V > 0 && V < O && (V = O), V === O || P.length === 0 || this.length === 0) return 0;
          if (x < 0) throw new RangeError("targetStart out of bounds");
          if (O < 0 || O >= this.length) throw new RangeError("Index out of range");
          if (V < 0) throw new RangeError("sourceEnd out of bounds");
          V > this.length && (V = this.length), P.length - x < V - O && (V = P.length - x + O);
          const N = V - O;
          return this === P && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(x, O, V) : Uint8Array.prototype.set.call(P, this.subarray(O, V), x), N;
        }, m.prototype.fill = function(P, x, O, V) {
          if (typeof P == "string") {
            if (typeof x == "string" ? (V = x, x = 0, O = this.length) : typeof O == "string" && (V = O, O = this.length), V !== void 0 && typeof V != "string") throw new TypeError("encoding must be a string");
            if (typeof V == "string" && !m.isEncoding(V)) throw new TypeError("Unknown encoding: " + V);
            if (P.length === 1) {
              const C = P.charCodeAt(0);
              (V === "utf8" && C < 128 || V === "latin1") && (P = C);
            }
          } else typeof P == "number" ? P &= 255 : typeof P == "boolean" && (P = Number(P));
          if (x < 0 || this.length < x || this.length < O) throw new RangeError("Out of range index");
          if (O <= x) return this;
          let N;
          if (x >>>= 0, O = O === void 0 ? this.length : O >>> 0, P || (P = 0), typeof P == "number") for (N = x; N < O; ++N) this[N] = P;
          else {
            const C = m.isBuffer(P) ? P : m.from(P, V), p = C.length;
            if (p === 0) throw new TypeError('The value "' + P + '" is invalid for argument "value"');
            for (N = 0; N < O - x; ++N) this[N + x] = C[N % p];
          }
          return this;
        };
        const ce = {};
        function ye(P, x, O) {
          ce[P] = class extends O {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: x.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${P}]`, this.stack, delete this.name;
            }
            get code() {
              return P;
            }
            set code(V) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: V, writable: true });
            }
            toString() {
              return `${this.name} [${P}]: ${this.message}`;
            }
          };
        }
        function ae(P) {
          let x = "", O = P.length;
          const V = P[0] === "-" ? 1 : 0;
          for (; O >= V + 4; O -= 3) x = `_${P.slice(O - 3, O)}${x}`;
          return `${P.slice(0, O)}${x}`;
        }
        function ue(P, x, O, V, N, C) {
          if (P > O || P < x) {
            const p = typeof x == "bigint" ? "n" : "";
            let A;
            throw A = x === 0 || x === BigInt(0) ? `>= 0${p} and < 2${p} ** ${8 * (C + 1)}${p}` : `>= -(2${p} ** ${8 * (C + 1) - 1}${p}) and < 2 ** ${8 * (C + 1) - 1}${p}`, new ce.ERR_OUT_OF_RANGE("value", A, P);
          }
          (function(p, A, U) {
            ne(A, "offset"), p[A] !== void 0 && p[A + U] !== void 0 || ge(A, p.length - (U + 1));
          })(V, N, C);
        }
        function ne(P, x) {
          if (typeof P != "number") throw new ce.ERR_INVALID_ARG_TYPE(x, "number", P);
        }
        function ge(P, x, O) {
          throw Math.floor(P) !== P ? (ne(P, O), new ce.ERR_OUT_OF_RANGE("offset", "an integer", P)) : x < 0 ? new ce.ERR_BUFFER_OUT_OF_BOUNDS() : new ce.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${x}`, P);
        }
        ye("ERR_BUFFER_OUT_OF_BOUNDS", function(P) {
          return P ? `${P} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), ye("ERR_INVALID_ARG_TYPE", function(P, x) {
          return `The "${P}" argument must be of type number. Received type ${typeof x}`;
        }, TypeError), ye("ERR_OUT_OF_RANGE", function(P, x, O) {
          let V = `The value of "${P}" is out of range.`, N = O;
          return Number.isInteger(O) && Math.abs(O) > 4294967296 ? N = ae(String(O)) : typeof O == "bigint" && (N = String(O), (O > BigInt(2) ** BigInt(32) || O < -(BigInt(2) ** BigInt(32))) && (N = ae(N)), N += "n"), V += ` It must be ${x}. Received ${N}`, V;
        }, RangeError);
        const Te = /[^+/0-9A-Za-z-_]/g;
        function pe(P, x) {
          let O;
          x = x || 1 / 0;
          const V = P.length;
          let N = null;
          const C = [];
          for (let p = 0; p < V; ++p) {
            if (O = P.charCodeAt(p), O > 55295 && O < 57344) {
              if (!N) {
                if (O > 56319) {
                  (x -= 3) > -1 && C.push(239, 191, 189);
                  continue;
                }
                if (p + 1 === V) {
                  (x -= 3) > -1 && C.push(239, 191, 189);
                  continue;
                }
                N = O;
                continue;
              }
              if (O < 56320) {
                (x -= 3) > -1 && C.push(239, 191, 189), N = O;
                continue;
              }
              O = 65536 + (N - 55296 << 10 | O - 56320);
            } else N && (x -= 3) > -1 && C.push(239, 191, 189);
            if (N = null, O < 128) {
              if ((x -= 1) < 0) break;
              C.push(O);
            } else if (O < 2048) {
              if ((x -= 2) < 0) break;
              C.push(O >> 6 | 192, 63 & O | 128);
            } else if (O < 65536) {
              if ((x -= 3) < 0) break;
              C.push(O >> 12 | 224, O >> 6 & 63 | 128, 63 & O | 128);
            } else {
              if (!(O < 1114112)) throw new Error("Invalid code point");
              if ((x -= 4) < 0) break;
              C.push(O >> 18 | 240, O >> 12 & 63 | 128, O >> 6 & 63 | 128, 63 & O | 128);
            }
          }
          return C;
        }
        function Oe(P) {
          return u.toByteArray(function(x) {
            if ((x = (x = x.split("=")[0]).trim().replace(Te, "")).length < 2) return "";
            for (; x.length % 4 != 0; ) x += "=";
            return x;
          }(P));
        }
        function xe(P, x, O, V) {
          let N;
          for (N = 0; N < V && !(N + O >= x.length || N >= P.length); ++N) x[N + O] = P[N];
          return N;
        }
        function Ve(P, x) {
          return P instanceof x || P != null && P.constructor != null && P.constructor.name != null && P.constructor.name === x.name;
        }
        function _e(P) {
          return P != P;
        }
        const Be = function() {
          const P = "0123456789abcdef", x = new Array(256);
          for (let O = 0; O < 16; ++O) {
            const V = 16 * O;
            for (let N = 0; N < 16; ++N) x[V + N] = P[O] + P[N];
          }
          return x;
        }();
        function Qe(P) {
          return typeof BigInt > "u" ? ee : P;
        }
        function ee() {
          throw new Error("BigInt not supported");
        }
      }, 251: (y, t) => {
        t.read = function(o, u, c, h, f) {
          var r, m, g = 8 * f - h - 1, a = (1 << g) - 1, l = a >> 1, d = -7, b = c ? f - 1 : 0, S = c ? -1 : 1, E = o[u + b];
          for (b += S, r = E & (1 << -d) - 1, E >>= -d, d += g; d > 0; r = 256 * r + o[u + b], b += S, d -= 8) ;
          for (m = r & (1 << -d) - 1, r >>= -d, d += h; d > 0; m = 256 * m + o[u + b], b += S, d -= 8) ;
          if (r === 0) r = 1 - l;
          else {
            if (r === a) return m ? NaN : 1 / 0 * (E ? -1 : 1);
            m += Math.pow(2, h), r -= l;
          }
          return (E ? -1 : 1) * m * Math.pow(2, r - h);
        }, t.write = function(o, u, c, h, f, r) {
          var m, g, a, l = 8 * r - f - 1, d = (1 << l) - 1, b = d >> 1, S = f === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E = h ? 0 : r - 1, R = h ? 1 : -1, k = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
          for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (g = isNaN(u) ? 1 : 0, m = d) : (m = Math.floor(Math.log(u) / Math.LN2), u * (a = Math.pow(2, -m)) < 1 && (m--, a *= 2), (u += m + b >= 1 ? S / a : S * Math.pow(2, 1 - b)) * a >= 2 && (m++, a /= 2), m + b >= d ? (g = 0, m = d) : m + b >= 1 ? (g = (u * a - 1) * Math.pow(2, f), m += b) : (g = u * Math.pow(2, b - 1) * Math.pow(2, f), m = 0)); f >= 8; o[c + E] = 255 & g, E += R, g /= 256, f -= 8) ;
          for (m = m << f | g, l += f; l > 0; o[c + E] = 255 & m, E += R, m /= 256, l -= 8) ;
          o[c + E - R] |= 128 * k;
        };
      } }, i = {};
      function s(y) {
        var t = i[y];
        if (t !== void 0) return t.exports;
        var o = i[y] = { exports: {} };
        return n[y](o, o.exports, s), o.exports;
      }
      return s.d = (y, t) => {
        for (var o in t) s.o(t, o) && !s.o(y, o) && Object.defineProperty(y, o, { enumerable: true, get: t[o] });
      }, s.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), s.o = (y, t) => Object.prototype.hasOwnProperty.call(y, t), s.r = (y) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(y, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(y, "__esModule", { value: true });
      }, s(281);
    })());
  }(sc)), sc.exports;
}
var Df;
function Ty() {
  return Df || (Df = 1, function(v) {
    function e(t) {
      "@babel/helpers - typeof";
      return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
        return typeof o;
      } : function(o) {
        return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, e(t);
    }
    Object.defineProperty(v, "__esModule", { value: true }), v.default = void 0;
    var n = s(Ai());
    function i(t) {
      if (typeof WeakMap != "function") return null;
      var o = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
      return (i = function(h) {
        return h ? u : o;
      })(t);
    }
    function s(t, o) {
      if (t && t.__esModule) return t;
      if (t === null || e(t) != "object" && typeof t != "function") return { default: t };
      var u = i(o);
      if (u && u.has(t)) return u.get(t);
      var c = { __proto__: null }, h = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var f in t) if (f !== "default" && {}.hasOwnProperty.call(t, f)) {
        var r = h ? Object.getOwnPropertyDescriptor(t, f) : null;
        r && (r.get || r.set) ? Object.defineProperty(c, f, r) : c[f] = t[f];
      }
      return c.default = t, u && u.set(t, c), c;
    }
    var y = n.config(function(t) {
      var o = 32, u = 1024;
      t.typedef("Value", t.varOpaque()), t.struct("ScpBallot", [["counter", t.lookup("Uint32")], ["value", t.lookup("Value")]]), t.enum("ScpStatementType", { scpStPrepare: 0, scpStConfirm: 1, scpStExternalize: 2, scpStNominate: 3 }), t.struct("ScpNomination", [["quorumSetHash", t.lookup("Hash")], ["votes", t.varArray(t.lookup("Value"), 2147483647)], ["accepted", t.varArray(t.lookup("Value"), 2147483647)]]), t.struct("ScpStatementPrepare", [["quorumSetHash", t.lookup("Hash")], ["ballot", t.lookup("ScpBallot")], ["prepared", t.option(t.lookup("ScpBallot"))], ["preparedPrime", t.option(t.lookup("ScpBallot"))], ["nC", t.lookup("Uint32")], ["nH", t.lookup("Uint32")]]), t.struct("ScpStatementConfirm", [["ballot", t.lookup("ScpBallot")], ["nPrepared", t.lookup("Uint32")], ["nCommit", t.lookup("Uint32")], ["nH", t.lookup("Uint32")], ["quorumSetHash", t.lookup("Hash")]]), t.struct("ScpStatementExternalize", [["commit", t.lookup("ScpBallot")], ["nH", t.lookup("Uint32")], ["commitQuorumSetHash", t.lookup("Hash")]]), t.union("ScpStatementPledges", { switchOn: t.lookup("ScpStatementType"), switchName: "type", switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]], arms: { prepare: t.lookup("ScpStatementPrepare"), confirm: t.lookup("ScpStatementConfirm"), externalize: t.lookup("ScpStatementExternalize"), nominate: t.lookup("ScpNomination") } }), t.struct("ScpStatement", [["nodeId", t.lookup("NodeId")], ["slotIndex", t.lookup("Uint64")], ["pledges", t.lookup("ScpStatementPledges")]]), t.struct("ScpEnvelope", [["statement", t.lookup("ScpStatement")], ["signature", t.lookup("Signature")]]), t.struct("ScpQuorumSet", [["threshold", t.lookup("Uint32")], ["validators", t.varArray(t.lookup("NodeId"), 2147483647)], ["innerSets", t.varArray(t.lookup("ScpQuorumSet"), 2147483647)]]), t.typedef("Thresholds", t.opaque(4)), t.typedef("String32", t.string(32)), t.typedef("String64", t.string(64)), t.typedef("SequenceNumber", t.lookup("Int64")), t.typedef("DataValue", t.varOpaque(64)), t.typedef("PoolId", t.lookup("Hash")), t.typedef("AssetCode4", t.opaque(4)), t.typedef("AssetCode12", t.opaque(12)), t.enum("AssetType", { assetTypeNative: 0, assetTypeCreditAlphanum4: 1, assetTypeCreditAlphanum12: 2, assetTypePoolShare: 3 }), t.union("AssetCode", { switchOn: t.lookup("AssetType"), switchName: "type", switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]], arms: { assetCode4: t.lookup("AssetCode4"), assetCode12: t.lookup("AssetCode12") } }), t.struct("AlphaNum4", [["assetCode", t.lookup("AssetCode4")], ["issuer", t.lookup("AccountId")]]), t.struct("AlphaNum12", [["assetCode", t.lookup("AssetCode12")], ["issuer", t.lookup("AccountId")]]), t.union("Asset", { switchOn: t.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", t.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]], arms: { alphaNum4: t.lookup("AlphaNum4"), alphaNum12: t.lookup("AlphaNum12") } }), t.struct("Price", [["n", t.lookup("Int32")], ["d", t.lookup("Int32")]]), t.struct("Liabilities", [["buying", t.lookup("Int64")], ["selling", t.lookup("Int64")]]), t.enum("ThresholdIndices", { thresholdMasterWeight: 0, thresholdLow: 1, thresholdMed: 2, thresholdHigh: 3 }), t.enum("LedgerEntryType", { account: 0, trustline: 1, offer: 2, data: 3, claimableBalance: 4, liquidityPool: 5, contractData: 6, contractCode: 7, configSetting: 8, ttl: 9 }), t.struct("Signer", [["key", t.lookup("SignerKey")], ["weight", t.lookup("Uint32")]]), t.enum("AccountFlags", { authRequiredFlag: 1, authRevocableFlag: 2, authImmutableFlag: 4, authClawbackEnabledFlag: 8 }), t.const("MASK_ACCOUNT_FLAGS", 7), t.const("MASK_ACCOUNT_FLAGS_V17", 15), t.const("MAX_SIGNERS", 20), t.typedef("SponsorshipDescriptor", t.option(t.lookup("AccountId"))), t.struct("AccountEntryExtensionV3", [["ext", t.lookup("ExtensionPoint")], ["seqLedger", t.lookup("Uint32")], ["seqTime", t.lookup("TimePoint")]]), t.union("AccountEntryExtensionV2Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [3, "v3"]], arms: { v3: t.lookup("AccountEntryExtensionV3") } }), t.struct("AccountEntryExtensionV2", [["numSponsored", t.lookup("Uint32")], ["numSponsoring", t.lookup("Uint32")], ["signerSponsoringIDs", t.varArray(t.lookup("SponsorshipDescriptor"), t.lookup("MAX_SIGNERS"))], ["ext", t.lookup("AccountEntryExtensionV2Ext")]]), t.union("AccountEntryExtensionV1Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [2, "v2"]], arms: { v2: t.lookup("AccountEntryExtensionV2") } }), t.struct("AccountEntryExtensionV1", [["liabilities", t.lookup("Liabilities")], ["ext", t.lookup("AccountEntryExtensionV1Ext")]]), t.union("AccountEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("AccountEntryExtensionV1") } }), t.struct("AccountEntry", [["accountId", t.lookup("AccountId")], ["balance", t.lookup("Int64")], ["seqNum", t.lookup("SequenceNumber")], ["numSubEntries", t.lookup("Uint32")], ["inflationDest", t.option(t.lookup("AccountId"))], ["flags", t.lookup("Uint32")], ["homeDomain", t.lookup("String32")], ["thresholds", t.lookup("Thresholds")], ["signers", t.varArray(t.lookup("Signer"), t.lookup("MAX_SIGNERS"))], ["ext", t.lookup("AccountEntryExt")]]), t.enum("TrustLineFlags", { authorizedFlag: 1, authorizedToMaintainLiabilitiesFlag: 2, trustlineClawbackEnabledFlag: 4 }), t.const("MASK_TRUSTLINE_FLAGS", 1), t.const("MASK_TRUSTLINE_FLAGS_V13", 3), t.const("MASK_TRUSTLINE_FLAGS_V17", 7), t.enum("LiquidityPoolType", { liquidityPoolConstantProduct: 0 }), t.union("TrustLineAsset", { switchOn: t.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", t.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]], arms: { alphaNum4: t.lookup("AlphaNum4"), alphaNum12: t.lookup("AlphaNum12"), liquidityPoolId: t.lookup("PoolId") } }), t.union("TrustLineEntryExtensionV2Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", t.lookup("Int32")], ["ext", t.lookup("TrustLineEntryExtensionV2Ext")]]), t.union("TrustLineEntryV1Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [2, "v2"]], arms: { v2: t.lookup("TrustLineEntryExtensionV2") } }), t.struct("TrustLineEntryV1", [["liabilities", t.lookup("Liabilities")], ["ext", t.lookup("TrustLineEntryV1Ext")]]), t.union("TrustLineEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("TrustLineEntryV1") } }), t.struct("TrustLineEntry", [["accountId", t.lookup("AccountId")], ["asset", t.lookup("TrustLineAsset")], ["balance", t.lookup("Int64")], ["limit", t.lookup("Int64")], ["flags", t.lookup("Uint32")], ["ext", t.lookup("TrustLineEntryExt")]]), t.enum("OfferEntryFlags", { passiveFlag: 1 }), t.const("MASK_OFFERENTRY_FLAGS", 1), t.union("OfferEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("OfferEntry", [["sellerId", t.lookup("AccountId")], ["offerId", t.lookup("Int64")], ["selling", t.lookup("Asset")], ["buying", t.lookup("Asset")], ["amount", t.lookup("Int64")], ["price", t.lookup("Price")], ["flags", t.lookup("Uint32")], ["ext", t.lookup("OfferEntryExt")]]), t.union("DataEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("DataEntry", [["accountId", t.lookup("AccountId")], ["dataName", t.lookup("String64")], ["dataValue", t.lookup("DataValue")], ["ext", t.lookup("DataEntryExt")]]), t.enum("ClaimPredicateType", { claimPredicateUnconditional: 0, claimPredicateAnd: 1, claimPredicateOr: 2, claimPredicateNot: 3, claimPredicateBeforeAbsoluteTime: 4, claimPredicateBeforeRelativeTime: 5 }), t.union("ClaimPredicate", { switchOn: t.lookup("ClaimPredicateType"), switchName: "type", switches: [["claimPredicateUnconditional", t.void()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]], arms: { andPredicates: t.varArray(t.lookup("ClaimPredicate"), 2), orPredicates: t.varArray(t.lookup("ClaimPredicate"), 2), notPredicate: t.option(t.lookup("ClaimPredicate")), absBefore: t.lookup("Int64"), relBefore: t.lookup("Int64") } }), t.enum("ClaimantType", { claimantTypeV0: 0 }), t.struct("ClaimantV0", [["destination", t.lookup("AccountId")], ["predicate", t.lookup("ClaimPredicate")]]), t.union("Claimant", { switchOn: t.lookup("ClaimantType"), switchName: "type", switches: [["claimantTypeV0", "v0"]], arms: { v0: t.lookup("ClaimantV0") } }), t.enum("ClaimableBalanceIdType", { claimableBalanceIdTypeV0: 0 }), t.union("ClaimableBalanceId", { switchOn: t.lookup("ClaimableBalanceIdType"), switchName: "type", switches: [["claimableBalanceIdTypeV0", "v0"]], arms: { v0: t.lookup("Hash") } }), t.enum("ClaimableBalanceFlags", { claimableBalanceClawbackEnabledFlag: 1 }), t.const("MASK_CLAIMABLE_BALANCE_FLAGS", 1), t.union("ClaimableBalanceEntryExtensionV1Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("ClaimableBalanceEntryExtensionV1", [["ext", t.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", t.lookup("Uint32")]]), t.union("ClaimableBalanceEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("ClaimableBalanceEntryExtensionV1") } }), t.struct("ClaimableBalanceEntry", [["balanceId", t.lookup("ClaimableBalanceId")], ["claimants", t.varArray(t.lookup("Claimant"), 10)], ["asset", t.lookup("Asset")], ["amount", t.lookup("Int64")], ["ext", t.lookup("ClaimableBalanceEntryExt")]]), t.struct("LiquidityPoolConstantProductParameters", [["assetA", t.lookup("Asset")], ["assetB", t.lookup("Asset")], ["fee", t.lookup("Int32")]]), t.struct("LiquidityPoolEntryConstantProduct", [["params", t.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", t.lookup("Int64")], ["reserveB", t.lookup("Int64")], ["totalPoolShares", t.lookup("Int64")], ["poolSharesTrustLineCount", t.lookup("Int64")]]), t.union("LiquidityPoolEntryBody", { switchOn: t.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: t.lookup("LiquidityPoolEntryConstantProduct") } }), t.struct("LiquidityPoolEntry", [["liquidityPoolId", t.lookup("PoolId")], ["body", t.lookup("LiquidityPoolEntryBody")]]), t.enum("ContractDataDurability", { temporary: 0, persistent: 1 }), t.struct("ContractDataEntry", [["ext", t.lookup("ExtensionPoint")], ["contract", t.lookup("ScAddress")], ["key", t.lookup("ScVal")], ["durability", t.lookup("ContractDataDurability")], ["val", t.lookup("ScVal")]]), t.struct("ContractCodeCostInputs", [["ext", t.lookup("ExtensionPoint")], ["nInstructions", t.lookup("Uint32")], ["nFunctions", t.lookup("Uint32")], ["nGlobals", t.lookup("Uint32")], ["nTableEntries", t.lookup("Uint32")], ["nTypes", t.lookup("Uint32")], ["nDataSegments", t.lookup("Uint32")], ["nElemSegments", t.lookup("Uint32")], ["nImports", t.lookup("Uint32")], ["nExports", t.lookup("Uint32")], ["nDataSegmentBytes", t.lookup("Uint32")]]), t.struct("ContractCodeEntryV1", [["ext", t.lookup("ExtensionPoint")], ["costInputs", t.lookup("ContractCodeCostInputs")]]), t.union("ContractCodeEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("ContractCodeEntryV1") } }), t.struct("ContractCodeEntry", [["ext", t.lookup("ContractCodeEntryExt")], ["hash", t.lookup("Hash")], ["code", t.varOpaque()]]), t.struct("TtlEntry", [["keyHash", t.lookup("Hash")], ["liveUntilLedgerSeq", t.lookup("Uint32")]]), t.union("LedgerEntryExtensionV1Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("LedgerEntryExtensionV1", [["sponsoringId", t.lookup("SponsorshipDescriptor")], ["ext", t.lookup("LedgerEntryExtensionV1Ext")]]), t.union("LedgerEntryData", { switchOn: t.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: t.lookup("AccountEntry"), trustLine: t.lookup("TrustLineEntry"), offer: t.lookup("OfferEntry"), data: t.lookup("DataEntry"), claimableBalance: t.lookup("ClaimableBalanceEntry"), liquidityPool: t.lookup("LiquidityPoolEntry"), contractData: t.lookup("ContractDataEntry"), contractCode: t.lookup("ContractCodeEntry"), configSetting: t.lookup("ConfigSettingEntry"), ttl: t.lookup("TtlEntry") } }), t.union("LedgerEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("LedgerEntryExtensionV1") } }), t.struct("LedgerEntry", [["lastModifiedLedgerSeq", t.lookup("Uint32")], ["data", t.lookup("LedgerEntryData")], ["ext", t.lookup("LedgerEntryExt")]]), t.struct("LedgerKeyAccount", [["accountId", t.lookup("AccountId")]]), t.struct("LedgerKeyTrustLine", [["accountId", t.lookup("AccountId")], ["asset", t.lookup("TrustLineAsset")]]), t.struct("LedgerKeyOffer", [["sellerId", t.lookup("AccountId")], ["offerId", t.lookup("Int64")]]), t.struct("LedgerKeyData", [["accountId", t.lookup("AccountId")], ["dataName", t.lookup("String64")]]), t.struct("LedgerKeyClaimableBalance", [["balanceId", t.lookup("ClaimableBalanceId")]]), t.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", t.lookup("PoolId")]]), t.struct("LedgerKeyContractData", [["contract", t.lookup("ScAddress")], ["key", t.lookup("ScVal")], ["durability", t.lookup("ContractDataDurability")]]), t.struct("LedgerKeyContractCode", [["hash", t.lookup("Hash")]]), t.struct("LedgerKeyConfigSetting", [["configSettingId", t.lookup("ConfigSettingId")]]), t.struct("LedgerKeyTtl", [["keyHash", t.lookup("Hash")]]), t.union("LedgerKey", { switchOn: t.lookup("LedgerEntryType"), switchName: "type", switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]], arms: { account: t.lookup("LedgerKeyAccount"), trustLine: t.lookup("LedgerKeyTrustLine"), offer: t.lookup("LedgerKeyOffer"), data: t.lookup("LedgerKeyData"), claimableBalance: t.lookup("LedgerKeyClaimableBalance"), liquidityPool: t.lookup("LedgerKeyLiquidityPool"), contractData: t.lookup("LedgerKeyContractData"), contractCode: t.lookup("LedgerKeyContractCode"), configSetting: t.lookup("LedgerKeyConfigSetting"), ttl: t.lookup("LedgerKeyTtl") } }), t.enum("EnvelopeType", { envelopeTypeTxV0: 0, envelopeTypeScp: 1, envelopeTypeTx: 2, envelopeTypeAuth: 3, envelopeTypeScpvalue: 4, envelopeTypeTxFeeBump: 5, envelopeTypeOpId: 6, envelopeTypePoolRevokeOpId: 7, envelopeTypeContractId: 8, envelopeTypeSorobanAuthorization: 9 }), t.enum("BucketListType", { live: 0, hotArchive: 1, coldArchive: 2 }), t.enum("BucketEntryType", { metaentry: -1, liveentry: 0, deadentry: 1, initentry: 2 }), t.enum("HotArchiveBucketEntryType", { hotArchiveMetaentry: -1, hotArchiveArchived: 0, hotArchiveLive: 1, hotArchiveDeleted: 2 }), t.enum("ColdArchiveBucketEntryType", { coldArchiveMetaentry: -1, coldArchiveArchivedLeaf: 0, coldArchiveDeletedLeaf: 1, coldArchiveBoundaryLeaf: 2, coldArchiveHash: 3 }), t.union("BucketMetadataExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "bucketListType"]], arms: { bucketListType: t.lookup("BucketListType") } }), t.struct("BucketMetadata", [["ledgerVersion", t.lookup("Uint32")], ["ext", t.lookup("BucketMetadataExt")]]), t.union("BucketEntry", { switchOn: t.lookup("BucketEntryType"), switchName: "type", switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]], arms: { liveEntry: t.lookup("LedgerEntry"), deadEntry: t.lookup("LedgerKey"), metaEntry: t.lookup("BucketMetadata") } }), t.union("HotArchiveBucketEntry", { switchOn: t.lookup("HotArchiveBucketEntryType"), switchName: "type", switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]], arms: { archivedEntry: t.lookup("LedgerEntry"), key: t.lookup("LedgerKey"), metaEntry: t.lookup("BucketMetadata") } }), t.struct("ColdArchiveArchivedLeaf", [["index", t.lookup("Uint32")], ["archivedEntry", t.lookup("LedgerEntry")]]), t.struct("ColdArchiveDeletedLeaf", [["index", t.lookup("Uint32")], ["deletedKey", t.lookup("LedgerKey")]]), t.struct("ColdArchiveBoundaryLeaf", [["index", t.lookup("Uint32")], ["isLowerBound", t.bool()]]), t.struct("ColdArchiveHashEntry", [["index", t.lookup("Uint32")], ["level", t.lookup("Uint32")], ["hash", t.lookup("Hash")]]), t.union("ColdArchiveBucketEntry", { switchOn: t.lookup("ColdArchiveBucketEntryType"), switchName: "type", switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]], arms: { metaEntry: t.lookup("BucketMetadata"), archivedLeaf: t.lookup("ColdArchiveArchivedLeaf"), deletedLeaf: t.lookup("ColdArchiveDeletedLeaf"), boundaryLeaf: t.lookup("ColdArchiveBoundaryLeaf"), hashEntry: t.lookup("ColdArchiveHashEntry") } }), t.typedef("UpgradeType", t.varOpaque(128)), t.enum("StellarValueType", { stellarValueBasic: 0, stellarValueSigned: 1 }), t.struct("LedgerCloseValueSignature", [["nodeId", t.lookup("NodeId")], ["signature", t.lookup("Signature")]]), t.union("StellarValueExt", { switchOn: t.lookup("StellarValueType"), switchName: "v", switches: [["stellarValueBasic", t.void()], ["stellarValueSigned", "lcValueSignature"]], arms: { lcValueSignature: t.lookup("LedgerCloseValueSignature") } }), t.struct("StellarValue", [["txSetHash", t.lookup("Hash")], ["closeTime", t.lookup("TimePoint")], ["upgrades", t.varArray(t.lookup("UpgradeType"), 6)], ["ext", t.lookup("StellarValueExt")]]), t.const("MASK_LEDGER_HEADER_FLAGS", 7), t.enum("LedgerHeaderFlags", { disableLiquidityPoolTradingFlag: 1, disableLiquidityPoolDepositFlag: 2, disableLiquidityPoolWithdrawalFlag: 4 }), t.union("LedgerHeaderExtensionV1Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("LedgerHeaderExtensionV1", [["flags", t.lookup("Uint32")], ["ext", t.lookup("LedgerHeaderExtensionV1Ext")]]), t.union("LedgerHeaderExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("LedgerHeaderExtensionV1") } }), t.struct("LedgerHeader", [["ledgerVersion", t.lookup("Uint32")], ["previousLedgerHash", t.lookup("Hash")], ["scpValue", t.lookup("StellarValue")], ["txSetResultHash", t.lookup("Hash")], ["bucketListHash", t.lookup("Hash")], ["ledgerSeq", t.lookup("Uint32")], ["totalCoins", t.lookup("Int64")], ["feePool", t.lookup("Int64")], ["inflationSeq", t.lookup("Uint32")], ["idPool", t.lookup("Uint64")], ["baseFee", t.lookup("Uint32")], ["baseReserve", t.lookup("Uint32")], ["maxTxSetSize", t.lookup("Uint32")], ["skipList", t.array(t.lookup("Hash"), 4)], ["ext", t.lookup("LedgerHeaderExt")]]), t.enum("LedgerUpgradeType", { ledgerUpgradeVersion: 1, ledgerUpgradeBaseFee: 2, ledgerUpgradeMaxTxSetSize: 3, ledgerUpgradeBaseReserve: 4, ledgerUpgradeFlags: 5, ledgerUpgradeConfig: 6, ledgerUpgradeMaxSorobanTxSetSize: 7 }), t.struct("ConfigUpgradeSetKey", [["contractId", t.lookup("Hash")], ["contentHash", t.lookup("Hash")]]), t.union("LedgerUpgrade", { switchOn: t.lookup("LedgerUpgradeType"), switchName: "type", switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]], arms: { newLedgerVersion: t.lookup("Uint32"), newBaseFee: t.lookup("Uint32"), newMaxTxSetSize: t.lookup("Uint32"), newBaseReserve: t.lookup("Uint32"), newFlags: t.lookup("Uint32"), newConfig: t.lookup("ConfigUpgradeSetKey"), newMaxSorobanTxSetSize: t.lookup("Uint32") } }), t.struct("ConfigUpgradeSet", [["updatedEntry", t.varArray(t.lookup("ConfigSettingEntry"), 2147483647)]]), t.enum("TxSetComponentType", { txsetCompTxsMaybeDiscountedFee: 0 }), t.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", t.option(t.lookup("Int64"))], ["txes", t.varArray(t.lookup("TransactionEnvelope"), 2147483647)]]), t.union("TxSetComponent", { switchOn: t.lookup("TxSetComponentType"), switchName: "type", switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]], arms: { txsMaybeDiscountedFee: t.lookup("TxSetComponentTxsMaybeDiscountedFee") } }), t.union("TransactionPhase", { switchOn: t.int(), switchName: "v", switches: [[0, "v0Components"]], arms: { v0Components: t.varArray(t.lookup("TxSetComponent"), 2147483647) } }), t.struct("TransactionSet", [["previousLedgerHash", t.lookup("Hash")], ["txes", t.varArray(t.lookup("TransactionEnvelope"), 2147483647)]]), t.struct("TransactionSetV1", [["previousLedgerHash", t.lookup("Hash")], ["phases", t.varArray(t.lookup("TransactionPhase"), 2147483647)]]), t.union("GeneralizedTransactionSet", { switchOn: t.int(), switchName: "v", switches: [[1, "v1TxSet"]], arms: { v1TxSet: t.lookup("TransactionSetV1") } }), t.struct("TransactionResultPair", [["transactionHash", t.lookup("Hash")], ["result", t.lookup("TransactionResult")]]), t.struct("TransactionResultSet", [["results", t.varArray(t.lookup("TransactionResultPair"), 2147483647)]]), t.union("TransactionHistoryEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "generalizedTxSet"]], arms: { generalizedTxSet: t.lookup("GeneralizedTransactionSet") } }), t.struct("TransactionHistoryEntry", [["ledgerSeq", t.lookup("Uint32")], ["txSet", t.lookup("TransactionSet")], ["ext", t.lookup("TransactionHistoryEntryExt")]]), t.union("TransactionHistoryResultEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("TransactionHistoryResultEntry", [["ledgerSeq", t.lookup("Uint32")], ["txResultSet", t.lookup("TransactionResultSet")], ["ext", t.lookup("TransactionHistoryResultEntryExt")]]), t.union("LedgerHeaderHistoryEntryExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("LedgerHeaderHistoryEntry", [["hash", t.lookup("Hash")], ["header", t.lookup("LedgerHeader")], ["ext", t.lookup("LedgerHeaderHistoryEntryExt")]]), t.struct("LedgerScpMessages", [["ledgerSeq", t.lookup("Uint32")], ["messages", t.varArray(t.lookup("ScpEnvelope"), 2147483647)]]), t.struct("ScpHistoryEntryV0", [["quorumSets", t.varArray(t.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", t.lookup("LedgerScpMessages")]]), t.union("ScpHistoryEntry", { switchOn: t.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: t.lookup("ScpHistoryEntryV0") } }), t.enum("LedgerEntryChangeType", { ledgerEntryCreated: 0, ledgerEntryUpdated: 1, ledgerEntryRemoved: 2, ledgerEntryState: 3 }), t.union("LedgerEntryChange", { switchOn: t.lookup("LedgerEntryChangeType"), switchName: "type", switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]], arms: { created: t.lookup("LedgerEntry"), updated: t.lookup("LedgerEntry"), removed: t.lookup("LedgerKey"), state: t.lookup("LedgerEntry") } }), t.typedef("LedgerEntryChanges", t.varArray(t.lookup("LedgerEntryChange"), 2147483647)), t.struct("OperationMeta", [["changes", t.lookup("LedgerEntryChanges")]]), t.struct("TransactionMetaV1", [["txChanges", t.lookup("LedgerEntryChanges")], ["operations", t.varArray(t.lookup("OperationMeta"), 2147483647)]]), t.struct("TransactionMetaV2", [["txChangesBefore", t.lookup("LedgerEntryChanges")], ["operations", t.varArray(t.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", t.lookup("LedgerEntryChanges")]]), t.enum("ContractEventType", { system: 0, contract: 1, diagnostic: 2 }), t.struct("ContractEventV0", [["topics", t.varArray(t.lookup("ScVal"), 2147483647)], ["data", t.lookup("ScVal")]]), t.union("ContractEventBody", { switchOn: t.int(), switchName: "v", switches: [[0, "v0"]], arms: { v0: t.lookup("ContractEventV0") } }), t.struct("ContractEvent", [["ext", t.lookup("ExtensionPoint")], ["contractId", t.option(t.lookup("Hash"))], ["type", t.lookup("ContractEventType")], ["body", t.lookup("ContractEventBody")]]), t.struct("DiagnosticEvent", [["inSuccessfulContractCall", t.bool()], ["event", t.lookup("ContractEvent")]]), t.typedef("DiagnosticEvents", t.varArray(t.lookup("DiagnosticEvent"), 2147483647)), t.struct("SorobanTransactionMetaExtV1", [["ext", t.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", t.lookup("Int64")], ["totalRefundableResourceFeeCharged", t.lookup("Int64")], ["rentFeeCharged", t.lookup("Int64")]]), t.union("SorobanTransactionMetaExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("SorobanTransactionMetaExtV1") } }), t.struct("SorobanTransactionMeta", [["ext", t.lookup("SorobanTransactionMetaExt")], ["events", t.varArray(t.lookup("ContractEvent"), 2147483647)], ["returnValue", t.lookup("ScVal")], ["diagnosticEvents", t.varArray(t.lookup("DiagnosticEvent"), 2147483647)]]), t.struct("TransactionMetaV3", [["ext", t.lookup("ExtensionPoint")], ["txChangesBefore", t.lookup("LedgerEntryChanges")], ["operations", t.varArray(t.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", t.lookup("LedgerEntryChanges")], ["sorobanMeta", t.option(t.lookup("SorobanTransactionMeta"))]]), t.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", t.lookup("ScVal")], ["events", t.varArray(t.lookup("ContractEvent"), 2147483647)]]), t.union("TransactionMeta", { switchOn: t.int(), switchName: "v", switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]], arms: { operations: t.varArray(t.lookup("OperationMeta"), 2147483647), v1: t.lookup("TransactionMetaV1"), v2: t.lookup("TransactionMetaV2"), v3: t.lookup("TransactionMetaV3") } }), t.struct("TransactionResultMeta", [["result", t.lookup("TransactionResultPair")], ["feeProcessing", t.lookup("LedgerEntryChanges")], ["txApplyProcessing", t.lookup("TransactionMeta")]]), t.struct("UpgradeEntryMeta", [["upgrade", t.lookup("LedgerUpgrade")], ["changes", t.lookup("LedgerEntryChanges")]]), t.struct("LedgerCloseMetaV0", [["ledgerHeader", t.lookup("LedgerHeaderHistoryEntry")], ["txSet", t.lookup("TransactionSet")], ["txProcessing", t.varArray(t.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", t.varArray(t.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", t.varArray(t.lookup("ScpHistoryEntry"), 2147483647)]]), t.struct("LedgerCloseMetaExtV1", [["ext", t.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", t.lookup("Int64")]]), t.union("LedgerCloseMetaExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "v1"]], arms: { v1: t.lookup("LedgerCloseMetaExtV1") } }), t.struct("LedgerCloseMetaV1", [["ext", t.lookup("LedgerCloseMetaExt")], ["ledgerHeader", t.lookup("LedgerHeaderHistoryEntry")], ["txSet", t.lookup("GeneralizedTransactionSet")], ["txProcessing", t.varArray(t.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", t.varArray(t.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", t.varArray(t.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", t.lookup("Uint64")], ["evictedTemporaryLedgerKeys", t.varArray(t.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", t.varArray(t.lookup("LedgerEntry"), 2147483647)]]), t.union("LedgerCloseMeta", { switchOn: t.int(), switchName: "v", switches: [[0, "v0"], [1, "v1"]], arms: { v0: t.lookup("LedgerCloseMetaV0"), v1: t.lookup("LedgerCloseMetaV1") } }), t.enum("ErrorCode", { errMisc: 0, errData: 1, errConf: 2, errAuth: 3, errLoad: 4 }), t.struct("Error", [["code", t.lookup("ErrorCode")], ["msg", t.string(100)]]), t.struct("SendMore", [["numMessages", t.lookup("Uint32")]]), t.struct("SendMoreExtended", [["numMessages", t.lookup("Uint32")], ["numBytes", t.lookup("Uint32")]]), t.struct("AuthCert", [["pubkey", t.lookup("Curve25519Public")], ["expiration", t.lookup("Uint64")], ["sig", t.lookup("Signature")]]), t.struct("Hello", [["ledgerVersion", t.lookup("Uint32")], ["overlayVersion", t.lookup("Uint32")], ["overlayMinVersion", t.lookup("Uint32")], ["networkId", t.lookup("Hash")], ["versionStr", t.string(100)], ["listeningPort", t.int()], ["peerId", t.lookup("NodeId")], ["cert", t.lookup("AuthCert")], ["nonce", t.lookup("Uint256")]]), t.const("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200), t.struct("Auth", [["flags", t.int()]]), t.enum("IpAddrType", { iPv4: 0, iPv6: 1 }), t.union("PeerAddressIp", { switchOn: t.lookup("IpAddrType"), switchName: "type", switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]], arms: { ipv4: t.opaque(4), ipv6: t.opaque(16) } }), t.struct("PeerAddress", [["ip", t.lookup("PeerAddressIp")], ["port", t.lookup("Uint32")], ["numFailures", t.lookup("Uint32")]]), t.enum("MessageType", { errorMsg: 0, auth: 2, dontHave: 3, getPeers: 4, peers: 5, getTxSet: 6, txSet: 7, generalizedTxSet: 17, transaction: 8, getScpQuorumset: 9, scpQuorumset: 10, scpMessage: 11, getScpState: 12, hello: 13, surveyRequest: 14, surveyResponse: 15, sendMore: 16, sendMoreExtended: 20, floodAdvert: 18, floodDemand: 19, timeSlicedSurveyRequest: 21, timeSlicedSurveyResponse: 22, timeSlicedSurveyStartCollecting: 23, timeSlicedSurveyStopCollecting: 24 }), t.struct("DontHave", [["type", t.lookup("MessageType")], ["reqHash", t.lookup("Uint256")]]), t.enum("SurveyMessageCommandType", { surveyTopology: 0, timeSlicedSurveyTopology: 1 }), t.enum("SurveyMessageResponseType", { surveyTopologyResponseV0: 0, surveyTopologyResponseV1: 1, surveyTopologyResponseV2: 2 }), t.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", t.lookup("NodeId")], ["nonce", t.lookup("Uint32")], ["ledgerNum", t.lookup("Uint32")]]), t.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", t.lookup("Signature")], ["startCollecting", t.lookup("TimeSlicedSurveyStartCollectingMessage")]]), t.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", t.lookup("NodeId")], ["nonce", t.lookup("Uint32")], ["ledgerNum", t.lookup("Uint32")]]), t.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", t.lookup("Signature")], ["stopCollecting", t.lookup("TimeSlicedSurveyStopCollectingMessage")]]), t.struct("SurveyRequestMessage", [["surveyorPeerId", t.lookup("NodeId")], ["surveyedPeerId", t.lookup("NodeId")], ["ledgerNum", t.lookup("Uint32")], ["encryptionKey", t.lookup("Curve25519Public")], ["commandType", t.lookup("SurveyMessageCommandType")]]), t.struct("TimeSlicedSurveyRequestMessage", [["request", t.lookup("SurveyRequestMessage")], ["nonce", t.lookup("Uint32")], ["inboundPeersIndex", t.lookup("Uint32")], ["outboundPeersIndex", t.lookup("Uint32")]]), t.struct("SignedSurveyRequestMessage", [["requestSignature", t.lookup("Signature")], ["request", t.lookup("SurveyRequestMessage")]]), t.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", t.lookup("Signature")], ["request", t.lookup("TimeSlicedSurveyRequestMessage")]]), t.typedef("EncryptedBody", t.varOpaque(64e3)), t.struct("SurveyResponseMessage", [["surveyorPeerId", t.lookup("NodeId")], ["surveyedPeerId", t.lookup("NodeId")], ["ledgerNum", t.lookup("Uint32")], ["commandType", t.lookup("SurveyMessageCommandType")], ["encryptedBody", t.lookup("EncryptedBody")]]), t.struct("TimeSlicedSurveyResponseMessage", [["response", t.lookup("SurveyResponseMessage")], ["nonce", t.lookup("Uint32")]]), t.struct("SignedSurveyResponseMessage", [["responseSignature", t.lookup("Signature")], ["response", t.lookup("SurveyResponseMessage")]]), t.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", t.lookup("Signature")], ["response", t.lookup("TimeSlicedSurveyResponseMessage")]]), t.struct("PeerStats", [["id", t.lookup("NodeId")], ["versionStr", t.string(100)], ["messagesRead", t.lookup("Uint64")], ["messagesWritten", t.lookup("Uint64")], ["bytesRead", t.lookup("Uint64")], ["bytesWritten", t.lookup("Uint64")], ["secondsConnected", t.lookup("Uint64")], ["uniqueFloodBytesRecv", t.lookup("Uint64")], ["duplicateFloodBytesRecv", t.lookup("Uint64")], ["uniqueFetchBytesRecv", t.lookup("Uint64")], ["duplicateFetchBytesRecv", t.lookup("Uint64")], ["uniqueFloodMessageRecv", t.lookup("Uint64")], ["duplicateFloodMessageRecv", t.lookup("Uint64")], ["uniqueFetchMessageRecv", t.lookup("Uint64")], ["duplicateFetchMessageRecv", t.lookup("Uint64")]]), t.typedef("PeerStatList", t.varArray(t.lookup("PeerStats"), 25)), t.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", t.lookup("Uint32")], ["droppedAuthenticatedPeers", t.lookup("Uint32")], ["totalInboundPeerCount", t.lookup("Uint32")], ["totalOutboundPeerCount", t.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", t.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", t.lookup("Uint32")], ["lostSyncCount", t.lookup("Uint32")], ["isValidator", t.bool()], ["maxInboundPeerCount", t.lookup("Uint32")], ["maxOutboundPeerCount", t.lookup("Uint32")]]), t.struct("TimeSlicedPeerData", [["peerStats", t.lookup("PeerStats")], ["averageLatencyMs", t.lookup("Uint32")]]), t.typedef("TimeSlicedPeerDataList", t.varArray(t.lookup("TimeSlicedPeerData"), 25)), t.struct("TopologyResponseBodyV0", [["inboundPeers", t.lookup("PeerStatList")], ["outboundPeers", t.lookup("PeerStatList")], ["totalInboundPeerCount", t.lookup("Uint32")], ["totalOutboundPeerCount", t.lookup("Uint32")]]), t.struct("TopologyResponseBodyV1", [["inboundPeers", t.lookup("PeerStatList")], ["outboundPeers", t.lookup("PeerStatList")], ["totalInboundPeerCount", t.lookup("Uint32")], ["totalOutboundPeerCount", t.lookup("Uint32")], ["maxInboundPeerCount", t.lookup("Uint32")], ["maxOutboundPeerCount", t.lookup("Uint32")]]), t.struct("TopologyResponseBodyV2", [["inboundPeers", t.lookup("TimeSlicedPeerDataList")], ["outboundPeers", t.lookup("TimeSlicedPeerDataList")], ["nodeData", t.lookup("TimeSlicedNodeData")]]), t.union("SurveyResponseBody", { switchOn: t.lookup("SurveyMessageResponseType"), switchName: "type", switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]], arms: { topologyResponseBodyV0: t.lookup("TopologyResponseBodyV0"), topologyResponseBodyV1: t.lookup("TopologyResponseBodyV1"), topologyResponseBodyV2: t.lookup("TopologyResponseBodyV2") } }), t.const("TX_ADVERT_VECTOR_MAX_SIZE", 1e3), t.typedef("TxAdvertVector", t.varArray(t.lookup("Hash"), t.lookup("TX_ADVERT_VECTOR_MAX_SIZE"))), t.struct("FloodAdvert", [["txHashes", t.lookup("TxAdvertVector")]]), t.const("TX_DEMAND_VECTOR_MAX_SIZE", 1e3), t.typedef("TxDemandVector", t.varArray(t.lookup("Hash"), t.lookup("TX_DEMAND_VECTOR_MAX_SIZE"))), t.struct("FloodDemand", [["txHashes", t.lookup("TxDemandVector")]]), t.union("StellarMessage", { switchOn: t.lookup("MessageType"), switchName: "type", switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", t.void()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]], arms: { error: t.lookup("Error"), hello: t.lookup("Hello"), auth: t.lookup("Auth"), dontHave: t.lookup("DontHave"), peers: t.varArray(t.lookup("PeerAddress"), 100), txSetHash: t.lookup("Uint256"), txSet: t.lookup("TransactionSet"), generalizedTxSet: t.lookup("GeneralizedTransactionSet"), transaction: t.lookup("TransactionEnvelope"), signedSurveyRequestMessage: t.lookup("SignedSurveyRequestMessage"), signedSurveyResponseMessage: t.lookup("SignedSurveyResponseMessage"), signedTimeSlicedSurveyRequestMessage: t.lookup("SignedTimeSlicedSurveyRequestMessage"), signedTimeSlicedSurveyResponseMessage: t.lookup("SignedTimeSlicedSurveyResponseMessage"), signedTimeSlicedSurveyStartCollectingMessage: t.lookup("SignedTimeSlicedSurveyStartCollectingMessage"), signedTimeSlicedSurveyStopCollectingMessage: t.lookup("SignedTimeSlicedSurveyStopCollectingMessage"), qSetHash: t.lookup("Uint256"), qSet: t.lookup("ScpQuorumSet"), envelope: t.lookup("ScpEnvelope"), getScpLedgerSeq: t.lookup("Uint32"), sendMoreMessage: t.lookup("SendMore"), sendMoreExtendedMessage: t.lookup("SendMoreExtended"), floodAdvert: t.lookup("FloodAdvert"), floodDemand: t.lookup("FloodDemand") } }), t.struct("AuthenticatedMessageV0", [["sequence", t.lookup("Uint64")], ["message", t.lookup("StellarMessage")], ["mac", t.lookup("HmacSha256Mac")]]), t.union("AuthenticatedMessage", { switchOn: t.lookup("Uint32"), switchName: "v", switches: [[0, "v0"]], arms: { v0: t.lookup("AuthenticatedMessageV0") } }), t.const("MAX_OPS_PER_TX", 100), t.union("LiquidityPoolParameters", { switchOn: t.lookup("LiquidityPoolType"), switchName: "type", switches: [["liquidityPoolConstantProduct", "constantProduct"]], arms: { constantProduct: t.lookup("LiquidityPoolConstantProductParameters") } }), t.struct("MuxedAccountMed25519", [["id", t.lookup("Uint64")], ["ed25519", t.lookup("Uint256")]]), t.union("MuxedAccount", { switchOn: t.lookup("CryptoKeyType"), switchName: "type", switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]], arms: { ed25519: t.lookup("Uint256"), med25519: t.lookup("MuxedAccountMed25519") } }), t.struct("DecoratedSignature", [["hint", t.lookup("SignatureHint")], ["signature", t.lookup("Signature")]]), t.enum("OperationType", { createAccount: 0, payment: 1, pathPaymentStrictReceive: 2, manageSellOffer: 3, createPassiveSellOffer: 4, setOptions: 5, changeTrust: 6, allowTrust: 7, accountMerge: 8, inflation: 9, manageData: 10, bumpSequence: 11, manageBuyOffer: 12, pathPaymentStrictSend: 13, createClaimableBalance: 14, claimClaimableBalance: 15, beginSponsoringFutureReserves: 16, endSponsoringFutureReserves: 17, revokeSponsorship: 18, clawback: 19, clawbackClaimableBalance: 20, setTrustLineFlags: 21, liquidityPoolDeposit: 22, liquidityPoolWithdraw: 23, invokeHostFunction: 24, extendFootprintTtl: 25, restoreFootprint: 26 }), t.struct("CreateAccountOp", [["destination", t.lookup("AccountId")], ["startingBalance", t.lookup("Int64")]]), t.struct("PaymentOp", [["destination", t.lookup("MuxedAccount")], ["asset", t.lookup("Asset")], ["amount", t.lookup("Int64")]]), t.struct("PathPaymentStrictReceiveOp", [["sendAsset", t.lookup("Asset")], ["sendMax", t.lookup("Int64")], ["destination", t.lookup("MuxedAccount")], ["destAsset", t.lookup("Asset")], ["destAmount", t.lookup("Int64")], ["path", t.varArray(t.lookup("Asset"), 5)]]), t.struct("PathPaymentStrictSendOp", [["sendAsset", t.lookup("Asset")], ["sendAmount", t.lookup("Int64")], ["destination", t.lookup("MuxedAccount")], ["destAsset", t.lookup("Asset")], ["destMin", t.lookup("Int64")], ["path", t.varArray(t.lookup("Asset"), 5)]]), t.struct("ManageSellOfferOp", [["selling", t.lookup("Asset")], ["buying", t.lookup("Asset")], ["amount", t.lookup("Int64")], ["price", t.lookup("Price")], ["offerId", t.lookup("Int64")]]), t.struct("ManageBuyOfferOp", [["selling", t.lookup("Asset")], ["buying", t.lookup("Asset")], ["buyAmount", t.lookup("Int64")], ["price", t.lookup("Price")], ["offerId", t.lookup("Int64")]]), t.struct("CreatePassiveSellOfferOp", [["selling", t.lookup("Asset")], ["buying", t.lookup("Asset")], ["amount", t.lookup("Int64")], ["price", t.lookup("Price")]]), t.struct("SetOptionsOp", [["inflationDest", t.option(t.lookup("AccountId"))], ["clearFlags", t.option(t.lookup("Uint32"))], ["setFlags", t.option(t.lookup("Uint32"))], ["masterWeight", t.option(t.lookup("Uint32"))], ["lowThreshold", t.option(t.lookup("Uint32"))], ["medThreshold", t.option(t.lookup("Uint32"))], ["highThreshold", t.option(t.lookup("Uint32"))], ["homeDomain", t.option(t.lookup("String32"))], ["signer", t.option(t.lookup("Signer"))]]), t.union("ChangeTrustAsset", { switchOn: t.lookup("AssetType"), switchName: "type", switches: [["assetTypeNative", t.void()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]], arms: { alphaNum4: t.lookup("AlphaNum4"), alphaNum12: t.lookup("AlphaNum12"), liquidityPool: t.lookup("LiquidityPoolParameters") } }), t.struct("ChangeTrustOp", [["line", t.lookup("ChangeTrustAsset")], ["limit", t.lookup("Int64")]]), t.struct("AllowTrustOp", [["trustor", t.lookup("AccountId")], ["asset", t.lookup("AssetCode")], ["authorize", t.lookup("Uint32")]]), t.struct("ManageDataOp", [["dataName", t.lookup("String64")], ["dataValue", t.option(t.lookup("DataValue"))]]), t.struct("BumpSequenceOp", [["bumpTo", t.lookup("SequenceNumber")]]), t.struct("CreateClaimableBalanceOp", [["asset", t.lookup("Asset")], ["amount", t.lookup("Int64")], ["claimants", t.varArray(t.lookup("Claimant"), 10)]]), t.struct("ClaimClaimableBalanceOp", [["balanceId", t.lookup("ClaimableBalanceId")]]), t.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", t.lookup("AccountId")]]), t.enum("RevokeSponsorshipType", { revokeSponsorshipLedgerEntry: 0, revokeSponsorshipSigner: 1 }), t.struct("RevokeSponsorshipOpSigner", [["accountId", t.lookup("AccountId")], ["signerKey", t.lookup("SignerKey")]]), t.union("RevokeSponsorshipOp", { switchOn: t.lookup("RevokeSponsorshipType"), switchName: "type", switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]], arms: { ledgerKey: t.lookup("LedgerKey"), signer: t.lookup("RevokeSponsorshipOpSigner") } }), t.struct("ClawbackOp", [["asset", t.lookup("Asset")], ["from", t.lookup("MuxedAccount")], ["amount", t.lookup("Int64")]]), t.struct("ClawbackClaimableBalanceOp", [["balanceId", t.lookup("ClaimableBalanceId")]]), t.struct("SetTrustLineFlagsOp", [["trustor", t.lookup("AccountId")], ["asset", t.lookup("Asset")], ["clearFlags", t.lookup("Uint32")], ["setFlags", t.lookup("Uint32")]]), t.const("LIQUIDITY_POOL_FEE_V18", 30), t.struct("LiquidityPoolDepositOp", [["liquidityPoolId", t.lookup("PoolId")], ["maxAmountA", t.lookup("Int64")], ["maxAmountB", t.lookup("Int64")], ["minPrice", t.lookup("Price")], ["maxPrice", t.lookup("Price")]]), t.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", t.lookup("PoolId")], ["amount", t.lookup("Int64")], ["minAmountA", t.lookup("Int64")], ["minAmountB", t.lookup("Int64")]]), t.enum("HostFunctionType", { hostFunctionTypeInvokeContract: 0, hostFunctionTypeCreateContract: 1, hostFunctionTypeUploadContractWasm: 2, hostFunctionTypeCreateContractV2: 3 }), t.enum("ContractIdPreimageType", { contractIdPreimageFromAddress: 0, contractIdPreimageFromAsset: 1 }), t.struct("ContractIdPreimageFromAddress", [["address", t.lookup("ScAddress")], ["salt", t.lookup("Uint256")]]), t.union("ContractIdPreimage", { switchOn: t.lookup("ContractIdPreimageType"), switchName: "type", switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]], arms: { fromAddress: t.lookup("ContractIdPreimageFromAddress"), fromAsset: t.lookup("Asset") } }), t.struct("CreateContractArgs", [["contractIdPreimage", t.lookup("ContractIdPreimage")], ["executable", t.lookup("ContractExecutable")]]), t.struct("CreateContractArgsV2", [["contractIdPreimage", t.lookup("ContractIdPreimage")], ["executable", t.lookup("ContractExecutable")], ["constructorArgs", t.varArray(t.lookup("ScVal"), 2147483647)]]), t.struct("InvokeContractArgs", [["contractAddress", t.lookup("ScAddress")], ["functionName", t.lookup("ScSymbol")], ["args", t.varArray(t.lookup("ScVal"), 2147483647)]]), t.union("HostFunction", { switchOn: t.lookup("HostFunctionType"), switchName: "type", switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]], arms: { invokeContract: t.lookup("InvokeContractArgs"), createContract: t.lookup("CreateContractArgs"), wasm: t.varOpaque(), createContractV2: t.lookup("CreateContractArgsV2") } }), t.enum("SorobanAuthorizedFunctionType", { sorobanAuthorizedFunctionTypeContractFn: 0, sorobanAuthorizedFunctionTypeCreateContractHostFn: 1, sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2 }), t.union("SorobanAuthorizedFunction", { switchOn: t.lookup("SorobanAuthorizedFunctionType"), switchName: "type", switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]], arms: { contractFn: t.lookup("InvokeContractArgs"), createContractHostFn: t.lookup("CreateContractArgs"), createContractV2HostFn: t.lookup("CreateContractArgsV2") } }), t.struct("SorobanAuthorizedInvocation", [["function", t.lookup("SorobanAuthorizedFunction")], ["subInvocations", t.varArray(t.lookup("SorobanAuthorizedInvocation"), 2147483647)]]), t.struct("SorobanAddressCredentials", [["address", t.lookup("ScAddress")], ["nonce", t.lookup("Int64")], ["signatureExpirationLedger", t.lookup("Uint32")], ["signature", t.lookup("ScVal")]]), t.enum("SorobanCredentialsType", { sorobanCredentialsSourceAccount: 0, sorobanCredentialsAddress: 1 }), t.union("SorobanCredentials", { switchOn: t.lookup("SorobanCredentialsType"), switchName: "type", switches: [["sorobanCredentialsSourceAccount", t.void()], ["sorobanCredentialsAddress", "address"]], arms: { address: t.lookup("SorobanAddressCredentials") } }), t.struct("SorobanAuthorizationEntry", [["credentials", t.lookup("SorobanCredentials")], ["rootInvocation", t.lookup("SorobanAuthorizedInvocation")]]), t.struct("InvokeHostFunctionOp", [["hostFunction", t.lookup("HostFunction")], ["auth", t.varArray(t.lookup("SorobanAuthorizationEntry"), 2147483647)]]), t.struct("ExtendFootprintTtlOp", [["ext", t.lookup("ExtensionPoint")], ["extendTo", t.lookup("Uint32")]]), t.struct("RestoreFootprintOp", [["ext", t.lookup("ExtensionPoint")]]), t.union("OperationBody", { switchOn: t.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", t.void()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", t.void()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]], arms: { createAccountOp: t.lookup("CreateAccountOp"), paymentOp: t.lookup("PaymentOp"), pathPaymentStrictReceiveOp: t.lookup("PathPaymentStrictReceiveOp"), manageSellOfferOp: t.lookup("ManageSellOfferOp"), createPassiveSellOfferOp: t.lookup("CreatePassiveSellOfferOp"), setOptionsOp: t.lookup("SetOptionsOp"), changeTrustOp: t.lookup("ChangeTrustOp"), allowTrustOp: t.lookup("AllowTrustOp"), destination: t.lookup("MuxedAccount"), manageDataOp: t.lookup("ManageDataOp"), bumpSequenceOp: t.lookup("BumpSequenceOp"), manageBuyOfferOp: t.lookup("ManageBuyOfferOp"), pathPaymentStrictSendOp: t.lookup("PathPaymentStrictSendOp"), createClaimableBalanceOp: t.lookup("CreateClaimableBalanceOp"), claimClaimableBalanceOp: t.lookup("ClaimClaimableBalanceOp"), beginSponsoringFutureReservesOp: t.lookup("BeginSponsoringFutureReservesOp"), revokeSponsorshipOp: t.lookup("RevokeSponsorshipOp"), clawbackOp: t.lookup("ClawbackOp"), clawbackClaimableBalanceOp: t.lookup("ClawbackClaimableBalanceOp"), setTrustLineFlagsOp: t.lookup("SetTrustLineFlagsOp"), liquidityPoolDepositOp: t.lookup("LiquidityPoolDepositOp"), liquidityPoolWithdrawOp: t.lookup("LiquidityPoolWithdrawOp"), invokeHostFunctionOp: t.lookup("InvokeHostFunctionOp"), extendFootprintTtlOp: t.lookup("ExtendFootprintTtlOp"), restoreFootprintOp: t.lookup("RestoreFootprintOp") } }), t.struct("Operation", [["sourceAccount", t.option(t.lookup("MuxedAccount"))], ["body", t.lookup("OperationBody")]]), t.struct("HashIdPreimageOperationId", [["sourceAccount", t.lookup("AccountId")], ["seqNum", t.lookup("SequenceNumber")], ["opNum", t.lookup("Uint32")]]), t.struct("HashIdPreimageRevokeId", [["sourceAccount", t.lookup("AccountId")], ["seqNum", t.lookup("SequenceNumber")], ["opNum", t.lookup("Uint32")], ["liquidityPoolId", t.lookup("PoolId")], ["asset", t.lookup("Asset")]]), t.struct("HashIdPreimageContractId", [["networkId", t.lookup("Hash")], ["contractIdPreimage", t.lookup("ContractIdPreimage")]]), t.struct("HashIdPreimageSorobanAuthorization", [["networkId", t.lookup("Hash")], ["nonce", t.lookup("Int64")], ["signatureExpirationLedger", t.lookup("Uint32")], ["invocation", t.lookup("SorobanAuthorizedInvocation")]]), t.union("HashIdPreimage", { switchOn: t.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]], arms: { operationId: t.lookup("HashIdPreimageOperationId"), revokeId: t.lookup("HashIdPreimageRevokeId"), contractId: t.lookup("HashIdPreimageContractId"), sorobanAuthorization: t.lookup("HashIdPreimageSorobanAuthorization") } }), t.enum("MemoType", { memoNone: 0, memoText: 1, memoId: 2, memoHash: 3, memoReturn: 4 }), t.union("Memo", { switchOn: t.lookup("MemoType"), switchName: "type", switches: [["memoNone", t.void()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]], arms: { text: t.string(28), id: t.lookup("Uint64"), hash: t.lookup("Hash"), retHash: t.lookup("Hash") } }), t.struct("TimeBounds", [["minTime", t.lookup("TimePoint")], ["maxTime", t.lookup("TimePoint")]]), t.struct("LedgerBounds", [["minLedger", t.lookup("Uint32")], ["maxLedger", t.lookup("Uint32")]]), t.struct("PreconditionsV2", [["timeBounds", t.option(t.lookup("TimeBounds"))], ["ledgerBounds", t.option(t.lookup("LedgerBounds"))], ["minSeqNum", t.option(t.lookup("SequenceNumber"))], ["minSeqAge", t.lookup("Duration")], ["minSeqLedgerGap", t.lookup("Uint32")], ["extraSigners", t.varArray(t.lookup("SignerKey"), 2)]]), t.enum("PreconditionType", { precondNone: 0, precondTime: 1, precondV2: 2 }), t.union("Preconditions", { switchOn: t.lookup("PreconditionType"), switchName: "type", switches: [["precondNone", t.void()], ["precondTime", "timeBounds"], ["precondV2", "v2"]], arms: { timeBounds: t.lookup("TimeBounds"), v2: t.lookup("PreconditionsV2") } }), t.struct("LedgerFootprint", [["readOnly", t.varArray(t.lookup("LedgerKey"), 2147483647)], ["readWrite", t.varArray(t.lookup("LedgerKey"), 2147483647)]]), t.enum("ArchivalProofType", { existence: 0, nonexistence: 1 }), t.struct("ArchivalProofNode", [["index", t.lookup("Uint32")], ["hash", t.lookup("Hash")]]), t.typedef("ProofLevel", t.varArray(t.lookup("ArchivalProofNode"), 2147483647)), t.struct("NonexistenceProofBody", [["entriesToProve", t.varArray(t.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", t.varArray(t.lookup("ProofLevel"), 2147483647)]]), t.struct("ExistenceProofBody", [["keysToProve", t.varArray(t.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", t.varArray(t.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", t.varArray(t.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", t.varArray(t.lookup("ProofLevel"), 2147483647)]]), t.union("ArchivalProofBody", { switchOn: t.lookup("ArchivalProofType"), switchName: "t", switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]], arms: { nonexistenceProof: t.lookup("NonexistenceProofBody"), existenceProof: t.lookup("ExistenceProofBody") } }), t.struct("ArchivalProof", [["epoch", t.lookup("Uint32")], ["body", t.lookup("ArchivalProofBody")]]), t.struct("SorobanResources", [["footprint", t.lookup("LedgerFootprint")], ["instructions", t.lookup("Uint32")], ["readBytes", t.lookup("Uint32")], ["writeBytes", t.lookup("Uint32")]]), t.struct("SorobanTransactionData", [["ext", t.lookup("ExtensionPoint")], ["resources", t.lookup("SorobanResources")], ["resourceFee", t.lookup("Int64")]]), t.union("TransactionV0Ext", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("TransactionV0", [["sourceAccountEd25519", t.lookup("Uint256")], ["fee", t.lookup("Uint32")], ["seqNum", t.lookup("SequenceNumber")], ["timeBounds", t.option(t.lookup("TimeBounds"))], ["memo", t.lookup("Memo")], ["operations", t.varArray(t.lookup("Operation"), t.lookup("MAX_OPS_PER_TX"))], ["ext", t.lookup("TransactionV0Ext")]]), t.struct("TransactionV0Envelope", [["tx", t.lookup("TransactionV0")], ["signatures", t.varArray(t.lookup("DecoratedSignature"), 20)]]), t.union("TransactionExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()], [1, "sorobanData"]], arms: { sorobanData: t.lookup("SorobanTransactionData") } }), t.struct("Transaction", [["sourceAccount", t.lookup("MuxedAccount")], ["fee", t.lookup("Uint32")], ["seqNum", t.lookup("SequenceNumber")], ["cond", t.lookup("Preconditions")], ["memo", t.lookup("Memo")], ["operations", t.varArray(t.lookup("Operation"), t.lookup("MAX_OPS_PER_TX"))], ["ext", t.lookup("TransactionExt")]]), t.struct("TransactionV1Envelope", [["tx", t.lookup("Transaction")], ["signatures", t.varArray(t.lookup("DecoratedSignature"), 20)]]), t.union("FeeBumpTransactionInnerTx", { switchOn: t.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "v1"]], arms: { v1: t.lookup("TransactionV1Envelope") } }), t.union("FeeBumpTransactionExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("FeeBumpTransaction", [["feeSource", t.lookup("MuxedAccount")], ["fee", t.lookup("Int64")], ["innerTx", t.lookup("FeeBumpTransactionInnerTx")], ["ext", t.lookup("FeeBumpTransactionExt")]]), t.struct("FeeBumpTransactionEnvelope", [["tx", t.lookup("FeeBumpTransaction")], ["signatures", t.varArray(t.lookup("DecoratedSignature"), 20)]]), t.union("TransactionEnvelope", { switchOn: t.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { v0: t.lookup("TransactionV0Envelope"), v1: t.lookup("TransactionV1Envelope"), feeBump: t.lookup("FeeBumpTransactionEnvelope") } }), t.union("TransactionSignaturePayloadTaggedTransaction", { switchOn: t.lookup("EnvelopeType"), switchName: "type", switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]], arms: { tx: t.lookup("Transaction"), feeBump: t.lookup("FeeBumpTransaction") } }), t.struct("TransactionSignaturePayload", [["networkId", t.lookup("Hash")], ["taggedTransaction", t.lookup("TransactionSignaturePayloadTaggedTransaction")]]), t.enum("ClaimAtomType", { claimAtomTypeV0: 0, claimAtomTypeOrderBook: 1, claimAtomTypeLiquidityPool: 2 }), t.struct("ClaimOfferAtomV0", [["sellerEd25519", t.lookup("Uint256")], ["offerId", t.lookup("Int64")], ["assetSold", t.lookup("Asset")], ["amountSold", t.lookup("Int64")], ["assetBought", t.lookup("Asset")], ["amountBought", t.lookup("Int64")]]), t.struct("ClaimOfferAtom", [["sellerId", t.lookup("AccountId")], ["offerId", t.lookup("Int64")], ["assetSold", t.lookup("Asset")], ["amountSold", t.lookup("Int64")], ["assetBought", t.lookup("Asset")], ["amountBought", t.lookup("Int64")]]), t.struct("ClaimLiquidityAtom", [["liquidityPoolId", t.lookup("PoolId")], ["assetSold", t.lookup("Asset")], ["amountSold", t.lookup("Int64")], ["assetBought", t.lookup("Asset")], ["amountBought", t.lookup("Int64")]]), t.union("ClaimAtom", { switchOn: t.lookup("ClaimAtomType"), switchName: "type", switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]], arms: { v0: t.lookup("ClaimOfferAtomV0"), orderBook: t.lookup("ClaimOfferAtom"), liquidityPool: t.lookup("ClaimLiquidityAtom") } }), t.enum("CreateAccountResultCode", { createAccountSuccess: 0, createAccountMalformed: -1, createAccountUnderfunded: -2, createAccountLowReserve: -3, createAccountAlreadyExist: -4 }), t.union("CreateAccountResult", { switchOn: t.lookup("CreateAccountResultCode"), switchName: "code", switches: [["createAccountSuccess", t.void()], ["createAccountMalformed", t.void()], ["createAccountUnderfunded", t.void()], ["createAccountLowReserve", t.void()], ["createAccountAlreadyExist", t.void()]], arms: {} }), t.enum("PaymentResultCode", { paymentSuccess: 0, paymentMalformed: -1, paymentUnderfunded: -2, paymentSrcNoTrust: -3, paymentSrcNotAuthorized: -4, paymentNoDestination: -5, paymentNoTrust: -6, paymentNotAuthorized: -7, paymentLineFull: -8, paymentNoIssuer: -9 }), t.union("PaymentResult", { switchOn: t.lookup("PaymentResultCode"), switchName: "code", switches: [["paymentSuccess", t.void()], ["paymentMalformed", t.void()], ["paymentUnderfunded", t.void()], ["paymentSrcNoTrust", t.void()], ["paymentSrcNotAuthorized", t.void()], ["paymentNoDestination", t.void()], ["paymentNoTrust", t.void()], ["paymentNotAuthorized", t.void()], ["paymentLineFull", t.void()], ["paymentNoIssuer", t.void()]], arms: {} }), t.enum("PathPaymentStrictReceiveResultCode", { pathPaymentStrictReceiveSuccess: 0, pathPaymentStrictReceiveMalformed: -1, pathPaymentStrictReceiveUnderfunded: -2, pathPaymentStrictReceiveSrcNoTrust: -3, pathPaymentStrictReceiveSrcNotAuthorized: -4, pathPaymentStrictReceiveNoDestination: -5, pathPaymentStrictReceiveNoTrust: -6, pathPaymentStrictReceiveNotAuthorized: -7, pathPaymentStrictReceiveLineFull: -8, pathPaymentStrictReceiveNoIssuer: -9, pathPaymentStrictReceiveTooFewOffers: -10, pathPaymentStrictReceiveOfferCrossSelf: -11, pathPaymentStrictReceiveOverSendmax: -12 }), t.struct("SimplePaymentResult", [["destination", t.lookup("AccountId")], ["asset", t.lookup("Asset")], ["amount", t.lookup("Int64")]]), t.struct("PathPaymentStrictReceiveResultSuccess", [["offers", t.varArray(t.lookup("ClaimAtom"), 2147483647)], ["last", t.lookup("SimplePaymentResult")]]), t.union("PathPaymentStrictReceiveResult", { switchOn: t.lookup("PathPaymentStrictReceiveResultCode"), switchName: "code", switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", t.void()], ["pathPaymentStrictReceiveUnderfunded", t.void()], ["pathPaymentStrictReceiveSrcNoTrust", t.void()], ["pathPaymentStrictReceiveSrcNotAuthorized", t.void()], ["pathPaymentStrictReceiveNoDestination", t.void()], ["pathPaymentStrictReceiveNoTrust", t.void()], ["pathPaymentStrictReceiveNotAuthorized", t.void()], ["pathPaymentStrictReceiveLineFull", t.void()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", t.void()], ["pathPaymentStrictReceiveOfferCrossSelf", t.void()], ["pathPaymentStrictReceiveOverSendmax", t.void()]], arms: { success: t.lookup("PathPaymentStrictReceiveResultSuccess"), noIssuer: t.lookup("Asset") } }), t.enum("PathPaymentStrictSendResultCode", { pathPaymentStrictSendSuccess: 0, pathPaymentStrictSendMalformed: -1, pathPaymentStrictSendUnderfunded: -2, pathPaymentStrictSendSrcNoTrust: -3, pathPaymentStrictSendSrcNotAuthorized: -4, pathPaymentStrictSendNoDestination: -5, pathPaymentStrictSendNoTrust: -6, pathPaymentStrictSendNotAuthorized: -7, pathPaymentStrictSendLineFull: -8, pathPaymentStrictSendNoIssuer: -9, pathPaymentStrictSendTooFewOffers: -10, pathPaymentStrictSendOfferCrossSelf: -11, pathPaymentStrictSendUnderDestmin: -12 }), t.struct("PathPaymentStrictSendResultSuccess", [["offers", t.varArray(t.lookup("ClaimAtom"), 2147483647)], ["last", t.lookup("SimplePaymentResult")]]), t.union("PathPaymentStrictSendResult", { switchOn: t.lookup("PathPaymentStrictSendResultCode"), switchName: "code", switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", t.void()], ["pathPaymentStrictSendUnderfunded", t.void()], ["pathPaymentStrictSendSrcNoTrust", t.void()], ["pathPaymentStrictSendSrcNotAuthorized", t.void()], ["pathPaymentStrictSendNoDestination", t.void()], ["pathPaymentStrictSendNoTrust", t.void()], ["pathPaymentStrictSendNotAuthorized", t.void()], ["pathPaymentStrictSendLineFull", t.void()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", t.void()], ["pathPaymentStrictSendOfferCrossSelf", t.void()], ["pathPaymentStrictSendUnderDestmin", t.void()]], arms: { success: t.lookup("PathPaymentStrictSendResultSuccess"), noIssuer: t.lookup("Asset") } }), t.enum("ManageSellOfferResultCode", { manageSellOfferSuccess: 0, manageSellOfferMalformed: -1, manageSellOfferSellNoTrust: -2, manageSellOfferBuyNoTrust: -3, manageSellOfferSellNotAuthorized: -4, manageSellOfferBuyNotAuthorized: -5, manageSellOfferLineFull: -6, manageSellOfferUnderfunded: -7, manageSellOfferCrossSelf: -8, manageSellOfferSellNoIssuer: -9, manageSellOfferBuyNoIssuer: -10, manageSellOfferNotFound: -11, manageSellOfferLowReserve: -12 }), t.enum("ManageOfferEffect", { manageOfferCreated: 0, manageOfferUpdated: 1, manageOfferDeleted: 2 }), t.union("ManageOfferSuccessResultOffer", { switchOn: t.lookup("ManageOfferEffect"), switchName: "effect", switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", t.void()]], arms: { offer: t.lookup("OfferEntry") } }), t.struct("ManageOfferSuccessResult", [["offersClaimed", t.varArray(t.lookup("ClaimAtom"), 2147483647)], ["offer", t.lookup("ManageOfferSuccessResultOffer")]]), t.union("ManageSellOfferResult", { switchOn: t.lookup("ManageSellOfferResultCode"), switchName: "code", switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", t.void()], ["manageSellOfferSellNoTrust", t.void()], ["manageSellOfferBuyNoTrust", t.void()], ["manageSellOfferSellNotAuthorized", t.void()], ["manageSellOfferBuyNotAuthorized", t.void()], ["manageSellOfferLineFull", t.void()], ["manageSellOfferUnderfunded", t.void()], ["manageSellOfferCrossSelf", t.void()], ["manageSellOfferSellNoIssuer", t.void()], ["manageSellOfferBuyNoIssuer", t.void()], ["manageSellOfferNotFound", t.void()], ["manageSellOfferLowReserve", t.void()]], arms: { success: t.lookup("ManageOfferSuccessResult") } }), t.enum("ManageBuyOfferResultCode", { manageBuyOfferSuccess: 0, manageBuyOfferMalformed: -1, manageBuyOfferSellNoTrust: -2, manageBuyOfferBuyNoTrust: -3, manageBuyOfferSellNotAuthorized: -4, manageBuyOfferBuyNotAuthorized: -5, manageBuyOfferLineFull: -6, manageBuyOfferUnderfunded: -7, manageBuyOfferCrossSelf: -8, manageBuyOfferSellNoIssuer: -9, manageBuyOfferBuyNoIssuer: -10, manageBuyOfferNotFound: -11, manageBuyOfferLowReserve: -12 }), t.union("ManageBuyOfferResult", { switchOn: t.lookup("ManageBuyOfferResultCode"), switchName: "code", switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", t.void()], ["manageBuyOfferSellNoTrust", t.void()], ["manageBuyOfferBuyNoTrust", t.void()], ["manageBuyOfferSellNotAuthorized", t.void()], ["manageBuyOfferBuyNotAuthorized", t.void()], ["manageBuyOfferLineFull", t.void()], ["manageBuyOfferUnderfunded", t.void()], ["manageBuyOfferCrossSelf", t.void()], ["manageBuyOfferSellNoIssuer", t.void()], ["manageBuyOfferBuyNoIssuer", t.void()], ["manageBuyOfferNotFound", t.void()], ["manageBuyOfferLowReserve", t.void()]], arms: { success: t.lookup("ManageOfferSuccessResult") } }), t.enum("SetOptionsResultCode", { setOptionsSuccess: 0, setOptionsLowReserve: -1, setOptionsTooManySigners: -2, setOptionsBadFlags: -3, setOptionsInvalidInflation: -4, setOptionsCantChange: -5, setOptionsUnknownFlag: -6, setOptionsThresholdOutOfRange: -7, setOptionsBadSigner: -8, setOptionsInvalidHomeDomain: -9, setOptionsAuthRevocableRequired: -10 }), t.union("SetOptionsResult", { switchOn: t.lookup("SetOptionsResultCode"), switchName: "code", switches: [["setOptionsSuccess", t.void()], ["setOptionsLowReserve", t.void()], ["setOptionsTooManySigners", t.void()], ["setOptionsBadFlags", t.void()], ["setOptionsInvalidInflation", t.void()], ["setOptionsCantChange", t.void()], ["setOptionsUnknownFlag", t.void()], ["setOptionsThresholdOutOfRange", t.void()], ["setOptionsBadSigner", t.void()], ["setOptionsInvalidHomeDomain", t.void()], ["setOptionsAuthRevocableRequired", t.void()]], arms: {} }), t.enum("ChangeTrustResultCode", { changeTrustSuccess: 0, changeTrustMalformed: -1, changeTrustNoIssuer: -2, changeTrustInvalidLimit: -3, changeTrustLowReserve: -4, changeTrustSelfNotAllowed: -5, changeTrustTrustLineMissing: -6, changeTrustCannotDelete: -7, changeTrustNotAuthMaintainLiabilities: -8 }), t.union("ChangeTrustResult", { switchOn: t.lookup("ChangeTrustResultCode"), switchName: "code", switches: [["changeTrustSuccess", t.void()], ["changeTrustMalformed", t.void()], ["changeTrustNoIssuer", t.void()], ["changeTrustInvalidLimit", t.void()], ["changeTrustLowReserve", t.void()], ["changeTrustSelfNotAllowed", t.void()], ["changeTrustTrustLineMissing", t.void()], ["changeTrustCannotDelete", t.void()], ["changeTrustNotAuthMaintainLiabilities", t.void()]], arms: {} }), t.enum("AllowTrustResultCode", { allowTrustSuccess: 0, allowTrustMalformed: -1, allowTrustNoTrustLine: -2, allowTrustTrustNotRequired: -3, allowTrustCantRevoke: -4, allowTrustSelfNotAllowed: -5, allowTrustLowReserve: -6 }), t.union("AllowTrustResult", { switchOn: t.lookup("AllowTrustResultCode"), switchName: "code", switches: [["allowTrustSuccess", t.void()], ["allowTrustMalformed", t.void()], ["allowTrustNoTrustLine", t.void()], ["allowTrustTrustNotRequired", t.void()], ["allowTrustCantRevoke", t.void()], ["allowTrustSelfNotAllowed", t.void()], ["allowTrustLowReserve", t.void()]], arms: {} }), t.enum("AccountMergeResultCode", { accountMergeSuccess: 0, accountMergeMalformed: -1, accountMergeNoAccount: -2, accountMergeImmutableSet: -3, accountMergeHasSubEntries: -4, accountMergeSeqnumTooFar: -5, accountMergeDestFull: -6, accountMergeIsSponsor: -7 }), t.union("AccountMergeResult", { switchOn: t.lookup("AccountMergeResultCode"), switchName: "code", switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", t.void()], ["accountMergeNoAccount", t.void()], ["accountMergeImmutableSet", t.void()], ["accountMergeHasSubEntries", t.void()], ["accountMergeSeqnumTooFar", t.void()], ["accountMergeDestFull", t.void()], ["accountMergeIsSponsor", t.void()]], arms: { sourceAccountBalance: t.lookup("Int64") } }), t.enum("InflationResultCode", { inflationSuccess: 0, inflationNotTime: -1 }), t.struct("InflationPayout", [["destination", t.lookup("AccountId")], ["amount", t.lookup("Int64")]]), t.union("InflationResult", { switchOn: t.lookup("InflationResultCode"), switchName: "code", switches: [["inflationSuccess", "payouts"], ["inflationNotTime", t.void()]], arms: { payouts: t.varArray(t.lookup("InflationPayout"), 2147483647) } }), t.enum("ManageDataResultCode", { manageDataSuccess: 0, manageDataNotSupportedYet: -1, manageDataNameNotFound: -2, manageDataLowReserve: -3, manageDataInvalidName: -4 }), t.union("ManageDataResult", { switchOn: t.lookup("ManageDataResultCode"), switchName: "code", switches: [["manageDataSuccess", t.void()], ["manageDataNotSupportedYet", t.void()], ["manageDataNameNotFound", t.void()], ["manageDataLowReserve", t.void()], ["manageDataInvalidName", t.void()]], arms: {} }), t.enum("BumpSequenceResultCode", { bumpSequenceSuccess: 0, bumpSequenceBadSeq: -1 }), t.union("BumpSequenceResult", { switchOn: t.lookup("BumpSequenceResultCode"), switchName: "code", switches: [["bumpSequenceSuccess", t.void()], ["bumpSequenceBadSeq", t.void()]], arms: {} }), t.enum("CreateClaimableBalanceResultCode", { createClaimableBalanceSuccess: 0, createClaimableBalanceMalformed: -1, createClaimableBalanceLowReserve: -2, createClaimableBalanceNoTrust: -3, createClaimableBalanceNotAuthorized: -4, createClaimableBalanceUnderfunded: -5 }), t.union("CreateClaimableBalanceResult", { switchOn: t.lookup("CreateClaimableBalanceResultCode"), switchName: "code", switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", t.void()], ["createClaimableBalanceLowReserve", t.void()], ["createClaimableBalanceNoTrust", t.void()], ["createClaimableBalanceNotAuthorized", t.void()], ["createClaimableBalanceUnderfunded", t.void()]], arms: { balanceId: t.lookup("ClaimableBalanceId") } }), t.enum("ClaimClaimableBalanceResultCode", { claimClaimableBalanceSuccess: 0, claimClaimableBalanceDoesNotExist: -1, claimClaimableBalanceCannotClaim: -2, claimClaimableBalanceLineFull: -3, claimClaimableBalanceNoTrust: -4, claimClaimableBalanceNotAuthorized: -5 }), t.union("ClaimClaimableBalanceResult", { switchOn: t.lookup("ClaimClaimableBalanceResultCode"), switchName: "code", switches: [["claimClaimableBalanceSuccess", t.void()], ["claimClaimableBalanceDoesNotExist", t.void()], ["claimClaimableBalanceCannotClaim", t.void()], ["claimClaimableBalanceLineFull", t.void()], ["claimClaimableBalanceNoTrust", t.void()], ["claimClaimableBalanceNotAuthorized", t.void()]], arms: {} }), t.enum("BeginSponsoringFutureReservesResultCode", { beginSponsoringFutureReservesSuccess: 0, beginSponsoringFutureReservesMalformed: -1, beginSponsoringFutureReservesAlreadySponsored: -2, beginSponsoringFutureReservesRecursive: -3 }), t.union("BeginSponsoringFutureReservesResult", { switchOn: t.lookup("BeginSponsoringFutureReservesResultCode"), switchName: "code", switches: [["beginSponsoringFutureReservesSuccess", t.void()], ["beginSponsoringFutureReservesMalformed", t.void()], ["beginSponsoringFutureReservesAlreadySponsored", t.void()], ["beginSponsoringFutureReservesRecursive", t.void()]], arms: {} }), t.enum("EndSponsoringFutureReservesResultCode", { endSponsoringFutureReservesSuccess: 0, endSponsoringFutureReservesNotSponsored: -1 }), t.union("EndSponsoringFutureReservesResult", { switchOn: t.lookup("EndSponsoringFutureReservesResultCode"), switchName: "code", switches: [["endSponsoringFutureReservesSuccess", t.void()], ["endSponsoringFutureReservesNotSponsored", t.void()]], arms: {} }), t.enum("RevokeSponsorshipResultCode", { revokeSponsorshipSuccess: 0, revokeSponsorshipDoesNotExist: -1, revokeSponsorshipNotSponsor: -2, revokeSponsorshipLowReserve: -3, revokeSponsorshipOnlyTransferable: -4, revokeSponsorshipMalformed: -5 }), t.union("RevokeSponsorshipResult", { switchOn: t.lookup("RevokeSponsorshipResultCode"), switchName: "code", switches: [["revokeSponsorshipSuccess", t.void()], ["revokeSponsorshipDoesNotExist", t.void()], ["revokeSponsorshipNotSponsor", t.void()], ["revokeSponsorshipLowReserve", t.void()], ["revokeSponsorshipOnlyTransferable", t.void()], ["revokeSponsorshipMalformed", t.void()]], arms: {} }), t.enum("ClawbackResultCode", { clawbackSuccess: 0, clawbackMalformed: -1, clawbackNotClawbackEnabled: -2, clawbackNoTrust: -3, clawbackUnderfunded: -4 }), t.union("ClawbackResult", { switchOn: t.lookup("ClawbackResultCode"), switchName: "code", switches: [["clawbackSuccess", t.void()], ["clawbackMalformed", t.void()], ["clawbackNotClawbackEnabled", t.void()], ["clawbackNoTrust", t.void()], ["clawbackUnderfunded", t.void()]], arms: {} }), t.enum("ClawbackClaimableBalanceResultCode", { clawbackClaimableBalanceSuccess: 0, clawbackClaimableBalanceDoesNotExist: -1, clawbackClaimableBalanceNotIssuer: -2, clawbackClaimableBalanceNotClawbackEnabled: -3 }), t.union("ClawbackClaimableBalanceResult", { switchOn: t.lookup("ClawbackClaimableBalanceResultCode"), switchName: "code", switches: [["clawbackClaimableBalanceSuccess", t.void()], ["clawbackClaimableBalanceDoesNotExist", t.void()], ["clawbackClaimableBalanceNotIssuer", t.void()], ["clawbackClaimableBalanceNotClawbackEnabled", t.void()]], arms: {} }), t.enum("SetTrustLineFlagsResultCode", { setTrustLineFlagsSuccess: 0, setTrustLineFlagsMalformed: -1, setTrustLineFlagsNoTrustLine: -2, setTrustLineFlagsCantRevoke: -3, setTrustLineFlagsInvalidState: -4, setTrustLineFlagsLowReserve: -5 }), t.union("SetTrustLineFlagsResult", { switchOn: t.lookup("SetTrustLineFlagsResultCode"), switchName: "code", switches: [["setTrustLineFlagsSuccess", t.void()], ["setTrustLineFlagsMalformed", t.void()], ["setTrustLineFlagsNoTrustLine", t.void()], ["setTrustLineFlagsCantRevoke", t.void()], ["setTrustLineFlagsInvalidState", t.void()], ["setTrustLineFlagsLowReserve", t.void()]], arms: {} }), t.enum("LiquidityPoolDepositResultCode", { liquidityPoolDepositSuccess: 0, liquidityPoolDepositMalformed: -1, liquidityPoolDepositNoTrust: -2, liquidityPoolDepositNotAuthorized: -3, liquidityPoolDepositUnderfunded: -4, liquidityPoolDepositLineFull: -5, liquidityPoolDepositBadPrice: -6, liquidityPoolDepositPoolFull: -7 }), t.union("LiquidityPoolDepositResult", { switchOn: t.lookup("LiquidityPoolDepositResultCode"), switchName: "code", switches: [["liquidityPoolDepositSuccess", t.void()], ["liquidityPoolDepositMalformed", t.void()], ["liquidityPoolDepositNoTrust", t.void()], ["liquidityPoolDepositNotAuthorized", t.void()], ["liquidityPoolDepositUnderfunded", t.void()], ["liquidityPoolDepositLineFull", t.void()], ["liquidityPoolDepositBadPrice", t.void()], ["liquidityPoolDepositPoolFull", t.void()]], arms: {} }), t.enum("LiquidityPoolWithdrawResultCode", { liquidityPoolWithdrawSuccess: 0, liquidityPoolWithdrawMalformed: -1, liquidityPoolWithdrawNoTrust: -2, liquidityPoolWithdrawUnderfunded: -3, liquidityPoolWithdrawLineFull: -4, liquidityPoolWithdrawUnderMinimum: -5 }), t.union("LiquidityPoolWithdrawResult", { switchOn: t.lookup("LiquidityPoolWithdrawResultCode"), switchName: "code", switches: [["liquidityPoolWithdrawSuccess", t.void()], ["liquidityPoolWithdrawMalformed", t.void()], ["liquidityPoolWithdrawNoTrust", t.void()], ["liquidityPoolWithdrawUnderfunded", t.void()], ["liquidityPoolWithdrawLineFull", t.void()], ["liquidityPoolWithdrawUnderMinimum", t.void()]], arms: {} }), t.enum("InvokeHostFunctionResultCode", { invokeHostFunctionSuccess: 0, invokeHostFunctionMalformed: -1, invokeHostFunctionTrapped: -2, invokeHostFunctionResourceLimitExceeded: -3, invokeHostFunctionEntryArchived: -4, invokeHostFunctionInsufficientRefundableFee: -5 }), t.union("InvokeHostFunctionResult", { switchOn: t.lookup("InvokeHostFunctionResultCode"), switchName: "code", switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", t.void()], ["invokeHostFunctionTrapped", t.void()], ["invokeHostFunctionResourceLimitExceeded", t.void()], ["invokeHostFunctionEntryArchived", t.void()], ["invokeHostFunctionInsufficientRefundableFee", t.void()]], arms: { success: t.lookup("Hash") } }), t.enum("ExtendFootprintTtlResultCode", { extendFootprintTtlSuccess: 0, extendFootprintTtlMalformed: -1, extendFootprintTtlResourceLimitExceeded: -2, extendFootprintTtlInsufficientRefundableFee: -3 }), t.union("ExtendFootprintTtlResult", { switchOn: t.lookup("ExtendFootprintTtlResultCode"), switchName: "code", switches: [["extendFootprintTtlSuccess", t.void()], ["extendFootprintTtlMalformed", t.void()], ["extendFootprintTtlResourceLimitExceeded", t.void()], ["extendFootprintTtlInsufficientRefundableFee", t.void()]], arms: {} }), t.enum("RestoreFootprintResultCode", { restoreFootprintSuccess: 0, restoreFootprintMalformed: -1, restoreFootprintResourceLimitExceeded: -2, restoreFootprintInsufficientRefundableFee: -3 }), t.union("RestoreFootprintResult", { switchOn: t.lookup("RestoreFootprintResultCode"), switchName: "code", switches: [["restoreFootprintSuccess", t.void()], ["restoreFootprintMalformed", t.void()], ["restoreFootprintResourceLimitExceeded", t.void()], ["restoreFootprintInsufficientRefundableFee", t.void()]], arms: {} }), t.enum("OperationResultCode", { opInner: 0, opBadAuth: -1, opNoAccount: -2, opNotSupported: -3, opTooManySubentries: -4, opExceededWorkLimit: -5, opTooManySponsoring: -6 }), t.union("OperationResultTr", { switchOn: t.lookup("OperationType"), switchName: "type", switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]], arms: { createAccountResult: t.lookup("CreateAccountResult"), paymentResult: t.lookup("PaymentResult"), pathPaymentStrictReceiveResult: t.lookup("PathPaymentStrictReceiveResult"), manageSellOfferResult: t.lookup("ManageSellOfferResult"), createPassiveSellOfferResult: t.lookup("ManageSellOfferResult"), setOptionsResult: t.lookup("SetOptionsResult"), changeTrustResult: t.lookup("ChangeTrustResult"), allowTrustResult: t.lookup("AllowTrustResult"), accountMergeResult: t.lookup("AccountMergeResult"), inflationResult: t.lookup("InflationResult"), manageDataResult: t.lookup("ManageDataResult"), bumpSeqResult: t.lookup("BumpSequenceResult"), manageBuyOfferResult: t.lookup("ManageBuyOfferResult"), pathPaymentStrictSendResult: t.lookup("PathPaymentStrictSendResult"), createClaimableBalanceResult: t.lookup("CreateClaimableBalanceResult"), claimClaimableBalanceResult: t.lookup("ClaimClaimableBalanceResult"), beginSponsoringFutureReservesResult: t.lookup("BeginSponsoringFutureReservesResult"), endSponsoringFutureReservesResult: t.lookup("EndSponsoringFutureReservesResult"), revokeSponsorshipResult: t.lookup("RevokeSponsorshipResult"), clawbackResult: t.lookup("ClawbackResult"), clawbackClaimableBalanceResult: t.lookup("ClawbackClaimableBalanceResult"), setTrustLineFlagsResult: t.lookup("SetTrustLineFlagsResult"), liquidityPoolDepositResult: t.lookup("LiquidityPoolDepositResult"), liquidityPoolWithdrawResult: t.lookup("LiquidityPoolWithdrawResult"), invokeHostFunctionResult: t.lookup("InvokeHostFunctionResult"), extendFootprintTtlResult: t.lookup("ExtendFootprintTtlResult"), restoreFootprintResult: t.lookup("RestoreFootprintResult") } }), t.union("OperationResult", { switchOn: t.lookup("OperationResultCode"), switchName: "code", switches: [["opInner", "tr"], ["opBadAuth", t.void()], ["opNoAccount", t.void()], ["opNotSupported", t.void()], ["opTooManySubentries", t.void()], ["opExceededWorkLimit", t.void()], ["opTooManySponsoring", t.void()]], arms: { tr: t.lookup("OperationResultTr") } }), t.enum("TransactionResultCode", { txFeeBumpInnerSuccess: 1, txSuccess: 0, txFailed: -1, txTooEarly: -2, txTooLate: -3, txMissingOperation: -4, txBadSeq: -5, txBadAuth: -6, txInsufficientBalance: -7, txNoAccount: -8, txInsufficientFee: -9, txBadAuthExtra: -10, txInternalError: -11, txNotSupported: -12, txFeeBumpInnerFailed: -13, txBadSponsorship: -14, txBadMinSeqAgeOrGap: -15, txMalformed: -16, txSorobanInvalid: -17 }), t.union("InnerTransactionResultResult", { switchOn: t.lookup("TransactionResultCode"), switchName: "code", switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", t.void()], ["txTooLate", t.void()], ["txMissingOperation", t.void()], ["txBadSeq", t.void()], ["txBadAuth", t.void()], ["txInsufficientBalance", t.void()], ["txNoAccount", t.void()], ["txInsufficientFee", t.void()], ["txBadAuthExtra", t.void()], ["txInternalError", t.void()], ["txNotSupported", t.void()], ["txBadSponsorship", t.void()], ["txBadMinSeqAgeOrGap", t.void()], ["txMalformed", t.void()], ["txSorobanInvalid", t.void()]], arms: { results: t.varArray(t.lookup("OperationResult"), 2147483647) } }), t.union("InnerTransactionResultExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("InnerTransactionResult", [["feeCharged", t.lookup("Int64")], ["result", t.lookup("InnerTransactionResultResult")], ["ext", t.lookup("InnerTransactionResultExt")]]), t.struct("InnerTransactionResultPair", [["transactionHash", t.lookup("Hash")], ["result", t.lookup("InnerTransactionResult")]]), t.union("TransactionResultResult", { switchOn: t.lookup("TransactionResultCode"), switchName: "code", switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", t.void()], ["txTooLate", t.void()], ["txMissingOperation", t.void()], ["txBadSeq", t.void()], ["txBadAuth", t.void()], ["txInsufficientBalance", t.void()], ["txNoAccount", t.void()], ["txInsufficientFee", t.void()], ["txBadAuthExtra", t.void()], ["txInternalError", t.void()], ["txNotSupported", t.void()], ["txBadSponsorship", t.void()], ["txBadMinSeqAgeOrGap", t.void()], ["txMalformed", t.void()], ["txSorobanInvalid", t.void()]], arms: { innerResultPair: t.lookup("InnerTransactionResultPair"), results: t.varArray(t.lookup("OperationResult"), 2147483647) } }), t.union("TransactionResultExt", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.struct("TransactionResult", [["feeCharged", t.lookup("Int64")], ["result", t.lookup("TransactionResultResult")], ["ext", t.lookup("TransactionResultExt")]]), t.typedef("Hash", t.opaque(32)), t.typedef("Uint256", t.opaque(32)), t.typedef("Uint32", t.uint()), t.typedef("Int32", t.int()), t.typedef("Uint64", t.uhyper()), t.typedef("Int64", t.hyper()), t.typedef("TimePoint", t.lookup("Uint64")), t.typedef("Duration", t.lookup("Uint64")), t.union("ExtensionPoint", { switchOn: t.int(), switchName: "v", switches: [[0, t.void()]], arms: {} }), t.enum("CryptoKeyType", { keyTypeEd25519: 0, keyTypePreAuthTx: 1, keyTypeHashX: 2, keyTypeEd25519SignedPayload: 3, keyTypeMuxedEd25519: 256 }), t.enum("PublicKeyType", { publicKeyTypeEd25519: 0 }), t.enum("SignerKeyType", { signerKeyTypeEd25519: 0, signerKeyTypePreAuthTx: 1, signerKeyTypeHashX: 2, signerKeyTypeEd25519SignedPayload: 3 }), t.union("PublicKey", { switchOn: t.lookup("PublicKeyType"), switchName: "type", switches: [["publicKeyTypeEd25519", "ed25519"]], arms: { ed25519: t.lookup("Uint256") } }), t.struct("SignerKeyEd25519SignedPayload", [["ed25519", t.lookup("Uint256")], ["payload", t.varOpaque(64)]]), t.union("SignerKey", { switchOn: t.lookup("SignerKeyType"), switchName: "type", switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]], arms: { ed25519: t.lookup("Uint256"), preAuthTx: t.lookup("Uint256"), hashX: t.lookup("Uint256"), ed25519SignedPayload: t.lookup("SignerKeyEd25519SignedPayload") } }), t.typedef("Signature", t.varOpaque(64)), t.typedef("SignatureHint", t.opaque(4)), t.typedef("NodeId", t.lookup("PublicKey")), t.typedef("AccountId", t.lookup("PublicKey")), t.struct("Curve25519Secret", [["key", t.opaque(32)]]), t.struct("Curve25519Public", [["key", t.opaque(32)]]), t.struct("HmacSha256Key", [["key", t.opaque(32)]]), t.struct("HmacSha256Mac", [["mac", t.opaque(32)]]), t.struct("ShortHashSeed", [["seed", t.opaque(16)]]), t.enum("BinaryFuseFilterType", { binaryFuseFilter8Bit: 0, binaryFuseFilter16Bit: 1, binaryFuseFilter32Bit: 2 }), t.struct("SerializedBinaryFuseFilter", [["type", t.lookup("BinaryFuseFilterType")], ["inputHashSeed", t.lookup("ShortHashSeed")], ["filterSeed", t.lookup("ShortHashSeed")], ["segmentLength", t.lookup("Uint32")], ["segementLengthMask", t.lookup("Uint32")], ["segmentCount", t.lookup("Uint32")], ["segmentCountLength", t.lookup("Uint32")], ["fingerprintLength", t.lookup("Uint32")], ["fingerprints", t.varOpaque()]]), t.enum("ScValType", { scvBool: 0, scvVoid: 1, scvError: 2, scvU32: 3, scvI32: 4, scvU64: 5, scvI64: 6, scvTimepoint: 7, scvDuration: 8, scvU128: 9, scvI128: 10, scvU256: 11, scvI256: 12, scvBytes: 13, scvString: 14, scvSymbol: 15, scvVec: 16, scvMap: 17, scvAddress: 18, scvContractInstance: 19, scvLedgerKeyContractInstance: 20, scvLedgerKeyNonce: 21 }), t.enum("ScErrorType", { sceContract: 0, sceWasmVm: 1, sceContext: 2, sceStorage: 3, sceObject: 4, sceCrypto: 5, sceEvents: 6, sceBudget: 7, sceValue: 8, sceAuth: 9 }), t.enum("ScErrorCode", { scecArithDomain: 0, scecIndexBounds: 1, scecInvalidInput: 2, scecMissingValue: 3, scecExistingValue: 4, scecExceededLimit: 5, scecInvalidAction: 6, scecInternalError: 7, scecUnexpectedType: 8, scecUnexpectedSize: 9 }), t.union("ScError", { switchOn: t.lookup("ScErrorType"), switchName: "type", switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]], arms: { contractCode: t.lookup("Uint32"), code: t.lookup("ScErrorCode") } }), t.struct("UInt128Parts", [["hi", t.lookup("Uint64")], ["lo", t.lookup("Uint64")]]), t.struct("Int128Parts", [["hi", t.lookup("Int64")], ["lo", t.lookup("Uint64")]]), t.struct("UInt256Parts", [["hiHi", t.lookup("Uint64")], ["hiLo", t.lookup("Uint64")], ["loHi", t.lookup("Uint64")], ["loLo", t.lookup("Uint64")]]), t.struct("Int256Parts", [["hiHi", t.lookup("Int64")], ["hiLo", t.lookup("Uint64")], ["loHi", t.lookup("Uint64")], ["loLo", t.lookup("Uint64")]]), t.enum("ContractExecutableType", { contractExecutableWasm: 0, contractExecutableStellarAsset: 1 }), t.union("ContractExecutable", { switchOn: t.lookup("ContractExecutableType"), switchName: "type", switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", t.void()]], arms: { wasmHash: t.lookup("Hash") } }), t.enum("ScAddressType", { scAddressTypeAccount: 0, scAddressTypeContract: 1 }), t.union("ScAddress", { switchOn: t.lookup("ScAddressType"), switchName: "type", switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]], arms: { accountId: t.lookup("AccountId"), contractId: t.lookup("Hash") } }), t.const("SCSYMBOL_LIMIT", 32), t.typedef("ScVec", t.varArray(t.lookup("ScVal"), 2147483647)), t.typedef("ScMap", t.varArray(t.lookup("ScMapEntry"), 2147483647)), t.typedef("ScBytes", t.varOpaque()), t.typedef("ScString", t.string()), t.typedef("ScSymbol", t.string(o)), t.struct("ScNonceKey", [["nonce", t.lookup("Int64")]]), t.struct("ScContractInstance", [["executable", t.lookup("ContractExecutable")], ["storage", t.option(t.lookup("ScMap"))]]), t.union("ScVal", { switchOn: t.lookup("ScValType"), switchName: "type", switches: [["scvBool", "b"], ["scvVoid", t.void()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", t.void()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]], arms: { b: t.bool(), error: t.lookup("ScError"), u32: t.lookup("Uint32"), i32: t.lookup("Int32"), u64: t.lookup("Uint64"), i64: t.lookup("Int64"), timepoint: t.lookup("TimePoint"), duration: t.lookup("Duration"), u128: t.lookup("UInt128Parts"), i128: t.lookup("Int128Parts"), u256: t.lookup("UInt256Parts"), i256: t.lookup("Int256Parts"), bytes: t.lookup("ScBytes"), str: t.lookup("ScString"), sym: t.lookup("ScSymbol"), vec: t.option(t.lookup("ScVec")), map: t.option(t.lookup("ScMap")), address: t.lookup("ScAddress"), nonceKey: t.lookup("ScNonceKey"), instance: t.lookup("ScContractInstance") } }), t.struct("ScMapEntry", [["key", t.lookup("ScVal")], ["val", t.lookup("ScVal")]]), t.enum("ScEnvMetaKind", { scEnvMetaKindInterfaceVersion: 0 }), t.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", t.lookup("Uint32")], ["preRelease", t.lookup("Uint32")]]), t.union("ScEnvMetaEntry", { switchOn: t.lookup("ScEnvMetaKind"), switchName: "kind", switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]], arms: { interfaceVersion: t.lookup("ScEnvMetaEntryInterfaceVersion") } }), t.struct("ScMetaV0", [["key", t.string()], ["val", t.string()]]), t.enum("ScMetaKind", { scMetaV0: 0 }), t.union("ScMetaEntry", { switchOn: t.lookup("ScMetaKind"), switchName: "kind", switches: [["scMetaV0", "v0"]], arms: { v0: t.lookup("ScMetaV0") } }), t.const("SC_SPEC_DOC_LIMIT", 1024), t.enum("ScSpecType", { scSpecTypeVal: 0, scSpecTypeBool: 1, scSpecTypeVoid: 2, scSpecTypeError: 3, scSpecTypeU32: 4, scSpecTypeI32: 5, scSpecTypeU64: 6, scSpecTypeI64: 7, scSpecTypeTimepoint: 8, scSpecTypeDuration: 9, scSpecTypeU128: 10, scSpecTypeI128: 11, scSpecTypeU256: 12, scSpecTypeI256: 13, scSpecTypeBytes: 14, scSpecTypeString: 16, scSpecTypeSymbol: 17, scSpecTypeAddress: 19, scSpecTypeOption: 1e3, scSpecTypeResult: 1001, scSpecTypeVec: 1002, scSpecTypeMap: 1004, scSpecTypeTuple: 1005, scSpecTypeBytesN: 1006, scSpecTypeUdt: 2e3 }), t.struct("ScSpecTypeOption", [["valueType", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecTypeResult", [["okType", t.lookup("ScSpecTypeDef")], ["errorType", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecTypeVec", [["elementType", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecTypeMap", [["keyType", t.lookup("ScSpecTypeDef")], ["valueType", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecTypeTuple", [["valueTypes", t.varArray(t.lookup("ScSpecTypeDef"), 12)]]), t.struct("ScSpecTypeBytesN", [["n", t.lookup("Uint32")]]), t.struct("ScSpecTypeUdt", [["name", t.string(60)]]), t.union("ScSpecTypeDef", { switchOn: t.lookup("ScSpecType"), switchName: "type", switches: [["scSpecTypeVal", t.void()], ["scSpecTypeBool", t.void()], ["scSpecTypeVoid", t.void()], ["scSpecTypeError", t.void()], ["scSpecTypeU32", t.void()], ["scSpecTypeI32", t.void()], ["scSpecTypeU64", t.void()], ["scSpecTypeI64", t.void()], ["scSpecTypeTimepoint", t.void()], ["scSpecTypeDuration", t.void()], ["scSpecTypeU128", t.void()], ["scSpecTypeI128", t.void()], ["scSpecTypeU256", t.void()], ["scSpecTypeI256", t.void()], ["scSpecTypeBytes", t.void()], ["scSpecTypeString", t.void()], ["scSpecTypeSymbol", t.void()], ["scSpecTypeAddress", t.void()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]], arms: { option: t.lookup("ScSpecTypeOption"), result: t.lookup("ScSpecTypeResult"), vec: t.lookup("ScSpecTypeVec"), map: t.lookup("ScSpecTypeMap"), tuple: t.lookup("ScSpecTypeTuple"), bytesN: t.lookup("ScSpecTypeBytesN"), udt: t.lookup("ScSpecTypeUdt") } }), t.struct("ScSpecUdtStructFieldV0", [["doc", t.string(u)], ["name", t.string(30)], ["type", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecUdtStructV0", [["doc", t.string(u)], ["lib", t.string(80)], ["name", t.string(60)], ["fields", t.varArray(t.lookup("ScSpecUdtStructFieldV0"), 40)]]), t.struct("ScSpecUdtUnionCaseVoidV0", [["doc", t.string(u)], ["name", t.string(60)]]), t.struct("ScSpecUdtUnionCaseTupleV0", [["doc", t.string(u)], ["name", t.string(60)], ["type", t.varArray(t.lookup("ScSpecTypeDef"), 12)]]), t.enum("ScSpecUdtUnionCaseV0Kind", { scSpecUdtUnionCaseVoidV0: 0, scSpecUdtUnionCaseTupleV0: 1 }), t.union("ScSpecUdtUnionCaseV0", { switchOn: t.lookup("ScSpecUdtUnionCaseV0Kind"), switchName: "kind", switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]], arms: { voidCase: t.lookup("ScSpecUdtUnionCaseVoidV0"), tupleCase: t.lookup("ScSpecUdtUnionCaseTupleV0") } }), t.struct("ScSpecUdtUnionV0", [["doc", t.string(u)], ["lib", t.string(80)], ["name", t.string(60)], ["cases", t.varArray(t.lookup("ScSpecUdtUnionCaseV0"), 50)]]), t.struct("ScSpecUdtEnumCaseV0", [["doc", t.string(u)], ["name", t.string(60)], ["value", t.lookup("Uint32")]]), t.struct("ScSpecUdtEnumV0", [["doc", t.string(u)], ["lib", t.string(80)], ["name", t.string(60)], ["cases", t.varArray(t.lookup("ScSpecUdtEnumCaseV0"), 50)]]), t.struct("ScSpecUdtErrorEnumCaseV0", [["doc", t.string(u)], ["name", t.string(60)], ["value", t.lookup("Uint32")]]), t.struct("ScSpecUdtErrorEnumV0", [["doc", t.string(u)], ["lib", t.string(80)], ["name", t.string(60)], ["cases", t.varArray(t.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]), t.struct("ScSpecFunctionInputV0", [["doc", t.string(u)], ["name", t.string(30)], ["type", t.lookup("ScSpecTypeDef")]]), t.struct("ScSpecFunctionV0", [["doc", t.string(u)], ["name", t.lookup("ScSymbol")], ["inputs", t.varArray(t.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", t.varArray(t.lookup("ScSpecTypeDef"), 1)]]), t.enum("ScSpecEntryKind", { scSpecEntryFunctionV0: 0, scSpecEntryUdtStructV0: 1, scSpecEntryUdtUnionV0: 2, scSpecEntryUdtEnumV0: 3, scSpecEntryUdtErrorEnumV0: 4 }), t.union("ScSpecEntry", { switchOn: t.lookup("ScSpecEntryKind"), switchName: "kind", switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]], arms: { functionV0: t.lookup("ScSpecFunctionV0"), udtStructV0: t.lookup("ScSpecUdtStructV0"), udtUnionV0: t.lookup("ScSpecUdtUnionV0"), udtEnumV0: t.lookup("ScSpecUdtEnumV0"), udtErrorEnumV0: t.lookup("ScSpecUdtErrorEnumV0") } }), t.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", t.lookup("Uint32")]]), t.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", t.lookup("Int64")], ["txMaxInstructions", t.lookup("Int64")], ["feeRatePerInstructionsIncrement", t.lookup("Int64")], ["txMemoryLimit", t.lookup("Uint32")]]), t.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", t.lookup("Uint32")], ["ledgerMaxReadBytes", t.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", t.lookup("Uint32")], ["ledgerMaxWriteBytes", t.lookup("Uint32")], ["txMaxReadLedgerEntries", t.lookup("Uint32")], ["txMaxReadBytes", t.lookup("Uint32")], ["txMaxWriteLedgerEntries", t.lookup("Uint32")], ["txMaxWriteBytes", t.lookup("Uint32")], ["feeReadLedgerEntry", t.lookup("Int64")], ["feeWriteLedgerEntry", t.lookup("Int64")], ["feeRead1Kb", t.lookup("Int64")], ["bucketListTargetSizeBytes", t.lookup("Int64")], ["writeFee1KbBucketListLow", t.lookup("Int64")], ["writeFee1KbBucketListHigh", t.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", t.lookup("Uint32")]]), t.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", t.lookup("Int64")]]), t.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", t.lookup("Uint32")], ["feeContractEvents1Kb", t.lookup("Int64")]]), t.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", t.lookup("Uint32")], ["txMaxSizeBytes", t.lookup("Uint32")], ["feeTxSize1Kb", t.lookup("Int64")]]), t.enum("ContractCostType", { wasmInsnExec: 0, memAlloc: 1, memCpy: 2, memCmp: 3, dispatchHostFunction: 4, visitObject: 5, valSer: 6, valDeser: 7, computeSha256Hash: 8, computeEd25519PubKey: 9, verifyEd25519Sig: 10, vmInstantiation: 11, vmCachedInstantiation: 12, invokeVmFunction: 13, computeKeccak256Hash: 14, decodeEcdsaCurve256Sig: 15, recoverEcdsaSecp256k1Key: 16, int256AddSub: 17, int256Mul: 18, int256Div: 19, int256Pow: 20, int256Shift: 21, chaCha20DrawBytes: 22, parseWasmInstructions: 23, parseWasmFunctions: 24, parseWasmGlobals: 25, parseWasmTableEntries: 26, parseWasmTypes: 27, parseWasmDataSegments: 28, parseWasmElemSegments: 29, parseWasmImports: 30, parseWasmExports: 31, parseWasmDataSegmentBytes: 32, instantiateWasmInstructions: 33, instantiateWasmFunctions: 34, instantiateWasmGlobals: 35, instantiateWasmTableEntries: 36, instantiateWasmTypes: 37, instantiateWasmDataSegments: 38, instantiateWasmElemSegments: 39, instantiateWasmImports: 40, instantiateWasmExports: 41, instantiateWasmDataSegmentBytes: 42, sec1DecodePointUncompressed: 43, verifyEcdsaSecp256r1Sig: 44, bls12381EncodeFp: 45, bls12381DecodeFp: 46, bls12381G1CheckPointOnCurve: 47, bls12381G1CheckPointInSubgroup: 48, bls12381G2CheckPointOnCurve: 49, bls12381G2CheckPointInSubgroup: 50, bls12381G1ProjectiveToAffine: 51, bls12381G2ProjectiveToAffine: 52, bls12381G1Add: 53, bls12381G1Mul: 54, bls12381G1Msm: 55, bls12381MapFpToG1: 56, bls12381HashToG1: 57, bls12381G2Add: 58, bls12381G2Mul: 59, bls12381G2Msm: 60, bls12381MapFp2ToG2: 61, bls12381HashToG2: 62, bls12381Pairing: 63, bls12381FrFromU256: 64, bls12381FrToU256: 65, bls12381FrAddSub: 66, bls12381FrMul: 67, bls12381FrPow: 68, bls12381FrInv: 69 }), t.struct("ContractCostParamEntry", [["ext", t.lookup("ExtensionPoint")], ["constTerm", t.lookup("Int64")], ["linearTerm", t.lookup("Int64")]]), t.struct("StateArchivalSettings", [["maxEntryTtl", t.lookup("Uint32")], ["minTemporaryTtl", t.lookup("Uint32")], ["minPersistentTtl", t.lookup("Uint32")], ["persistentRentRateDenominator", t.lookup("Int64")], ["tempRentRateDenominator", t.lookup("Int64")], ["maxEntriesToArchive", t.lookup("Uint32")], ["bucketListSizeWindowSampleSize", t.lookup("Uint32")], ["bucketListWindowSamplePeriod", t.lookup("Uint32")], ["evictionScanSize", t.lookup("Uint32")], ["startingEvictionScanLevel", t.lookup("Uint32")]]), t.struct("EvictionIterator", [["bucketListLevel", t.lookup("Uint32")], ["isCurrBucket", t.bool()], ["bucketFileOffset", t.lookup("Uint64")]]), t.const("CONTRACT_COST_COUNT_LIMIT", 1024), t.typedef("ContractCostParams", t.varArray(t.lookup("ContractCostParamEntry"), t.lookup("CONTRACT_COST_COUNT_LIMIT"))), t.enum("ConfigSettingId", { configSettingContractMaxSizeBytes: 0, configSettingContractComputeV0: 1, configSettingContractLedgerCostV0: 2, configSettingContractHistoricalDataV0: 3, configSettingContractEventsV0: 4, configSettingContractBandwidthV0: 5, configSettingContractCostParamsCpuInstructions: 6, configSettingContractCostParamsMemoryBytes: 7, configSettingContractDataKeySizeBytes: 8, configSettingContractDataEntrySizeBytes: 9, configSettingStateArchival: 10, configSettingContractExecutionLanes: 11, configSettingBucketlistSizeWindow: 12, configSettingEvictionIterator: 13 }), t.union("ConfigSettingEntry", { switchOn: t.lookup("ConfigSettingId"), switchName: "configSettingId", switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]], arms: { contractMaxSizeBytes: t.lookup("Uint32"), contractCompute: t.lookup("ConfigSettingContractComputeV0"), contractLedgerCost: t.lookup("ConfigSettingContractLedgerCostV0"), contractHistoricalData: t.lookup("ConfigSettingContractHistoricalDataV0"), contractEvents: t.lookup("ConfigSettingContractEventsV0"), contractBandwidth: t.lookup("ConfigSettingContractBandwidthV0"), contractCostParamsCpuInsns: t.lookup("ContractCostParams"), contractCostParamsMemBytes: t.lookup("ContractCostParams"), contractDataKeySizeBytes: t.lookup("Uint32"), contractDataEntrySizeBytes: t.lookup("Uint32"), stateArchivalSettings: t.lookup("StateArchivalSettings"), contractExecutionLanes: t.lookup("ConfigSettingContractExecutionLanesV0"), bucketListSizeWindow: t.varArray(t.lookup("Uint64"), 2147483647), evictionIterator: t.lookup("EvictionIterator") } });
    });
    v.default = y;
  }(Nc)), Nc;
}
var Ff;
function bn() {
  return Ff || (Ff = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true }), v.default = void 0;
    var e = n(Ty());
    function n(i) {
      return i && i.__esModule ? i : { default: i };
    }
    v.default = e.default;
  }(Bc)), Bc;
}
var Dc = {}, Uf;
function ky() {
  return Uf || (Uf = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true }), v.default = void 0;
    var e = Ai(), n = { XdrWriter: e.XdrWriter, XdrReader: e.XdrReader };
    v.default = n;
  }(Dc)), Dc;
}
var Xs = {}, Fc = { exports: {} }, $s = { exports: {} }, jf;
function La() {
  return jf || (jf = 1, typeof Object.create == "function" ? $s.exports = function(e, n) {
    n && (e.super_ = n, e.prototype = Object.create(n.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
  } : $s.exports = function(e, n) {
    if (n) {
      e.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, e.prototype = new i(), e.prototype.constructor = e;
    }
  }), $s.exports;
}
var Ys = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Vf;
function sa() {
  return Vf || (Vf = 1, function(v, e) {
    var n = Yd(), i = n.Buffer;
    function s(t, o) {
      for (var u in t) o[u] = t[u];
    }
    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? v.exports = n : (s(n, e), e.Buffer = y);
    function y(t, o, u) {
      return i(t, o, u);
    }
    y.prototype = Object.create(i.prototype), s(i, y), y.from = function(t, o, u) {
      if (typeof t == "number") throw new TypeError("Argument must not be a number");
      return i(t, o, u);
    }, y.alloc = function(t, o, u) {
      if (typeof t != "number") throw new TypeError("Argument must be a number");
      var c = i(t);
      return o !== void 0 ? typeof u == "string" ? c.fill(o, u) : c.fill(o) : c.fill(0), c;
    }, y.allocUnsafe = function(t) {
      if (typeof t != "number") throw new TypeError("Argument must be a number");
      return i(t);
    }, y.allocUnsafeSlow = function(t) {
      if (typeof t != "number") throw new TypeError("Argument must be a number");
      return n.SlowBuffer(t);
    };
  }(Ys, Ys.exports)), Ys.exports;
}
var Uc, qf;
function Ba() {
  if (qf) return Uc;
  qf = 1;
  var v = sa().Buffer;
  function e(n, i) {
    this._block = v.alloc(n), this._finalSize = i, this._blockSize = n, this._len = 0;
  }
  return e.prototype.update = function(n, i) {
    typeof n == "string" && (i = i || "utf8", n = v.from(n, i));
    for (var s = this._block, y = this._blockSize, t = n.length, o = this._len, u = 0; u < t; ) {
      for (var c = o % y, h = Math.min(t - u, y - c), f = 0; f < h; f++) s[c + f] = n[u + f];
      o += h, u += h, o % y === 0 && this._update(s);
    }
    return this._len += t, this;
  }, e.prototype.digest = function(n) {
    var i = this._len % this._blockSize;
    this._block[i] = 128, this._block.fill(0, i + 1), i >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var s = this._len * 8;
    if (s <= 4294967295) this._block.writeUInt32BE(s, this._blockSize - 4);
    else {
      var y = (s & 4294967295) >>> 0, t = (s - y) / 4294967296;
      this._block.writeUInt32BE(t, this._blockSize - 8), this._block.writeUInt32BE(y, this._blockSize - 4);
    }
    this._update(this._block);
    var o = this._hash();
    return n ? o.toString(n) : o;
  }, e.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, Uc = e, Uc;
}
var jc, zf;
function Oy() {
  if (zf) return jc;
  zf = 1;
  var v = La(), e = Ba(), n = sa().Buffer, i = [1518500249, 1859775393, -1894007588, -899497514], s = new Array(80);
  function y() {
    this.init(), this._w = s, e.call(this, 64, 56);
  }
  v(y, e), y.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function t(c) {
    return c << 5 | c >>> 27;
  }
  function o(c) {
    return c << 30 | c >>> 2;
  }
  function u(c, h, f, r) {
    return c === 0 ? h & f | ~h & r : c === 2 ? h & f | h & r | f & r : h ^ f ^ r;
  }
  return y.prototype._update = function(c) {
    for (var h = this._w, f = this._a | 0, r = this._b | 0, m = this._c | 0, g = this._d | 0, a = this._e | 0, l = 0; l < 16; ++l) h[l] = c.readInt32BE(l * 4);
    for (; l < 80; ++l) h[l] = h[l - 3] ^ h[l - 8] ^ h[l - 14] ^ h[l - 16];
    for (var d = 0; d < 80; ++d) {
      var b = ~~(d / 20), S = t(f) + u(b, r, m, g) + a + h[d] + i[b] | 0;
      a = g, g = m, m = o(r), r = f, f = S;
    }
    this._a = f + this._a | 0, this._b = r + this._b | 0, this._c = m + this._c | 0, this._d = g + this._d | 0, this._e = a + this._e | 0;
  }, y.prototype._hash = function() {
    var c = n.allocUnsafe(20);
    return c.writeInt32BE(this._a | 0, 0), c.writeInt32BE(this._b | 0, 4), c.writeInt32BE(this._c | 0, 8), c.writeInt32BE(this._d | 0, 12), c.writeInt32BE(this._e | 0, 16), c;
  }, jc = y, jc;
}
var Vc, Hf;
function Py() {
  if (Hf) return Vc;
  Hf = 1;
  var v = La(), e = Ba(), n = sa().Buffer, i = [1518500249, 1859775393, -1894007588, -899497514], s = new Array(80);
  function y() {
    this.init(), this._w = s, e.call(this, 64, 56);
  }
  v(y, e), y.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function t(h) {
    return h << 1 | h >>> 31;
  }
  function o(h) {
    return h << 5 | h >>> 27;
  }
  function u(h) {
    return h << 30 | h >>> 2;
  }
  function c(h, f, r, m) {
    return h === 0 ? f & r | ~f & m : h === 2 ? f & r | f & m | r & m : f ^ r ^ m;
  }
  return y.prototype._update = function(h) {
    for (var f = this._w, r = this._a | 0, m = this._b | 0, g = this._c | 0, a = this._d | 0, l = this._e | 0, d = 0; d < 16; ++d) f[d] = h.readInt32BE(d * 4);
    for (; d < 80; ++d) f[d] = t(f[d - 3] ^ f[d - 8] ^ f[d - 14] ^ f[d - 16]);
    for (var b = 0; b < 80; ++b) {
      var S = ~~(b / 20), E = o(r) + c(S, m, g, a) + l + f[b] + i[S] | 0;
      l = a, a = g, g = u(m), m = r, r = E;
    }
    this._a = r + this._a | 0, this._b = m + this._b | 0, this._c = g + this._c | 0, this._d = a + this._d | 0, this._e = l + this._e | 0;
  }, y.prototype._hash = function() {
    var h = n.allocUnsafe(20);
    return h.writeInt32BE(this._a | 0, 0), h.writeInt32BE(this._b | 0, 4), h.writeInt32BE(this._c | 0, 8), h.writeInt32BE(this._d | 0, 12), h.writeInt32BE(this._e | 0, 16), h;
  }, Vc = y, Vc;
}
var qc, Gf;
function Qd() {
  if (Gf) return qc;
  Gf = 1;
  var v = La(), e = Ba(), n = sa().Buffer, i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], s = new Array(64);
  function y() {
    this.init(), this._w = s, e.call(this, 64, 56);
  }
  v(y, e), y.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function t(r, m, g) {
    return g ^ r & (m ^ g);
  }
  function o(r, m, g) {
    return r & m | g & (r | m);
  }
  function u(r) {
    return (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10);
  }
  function c(r) {
    return (r >>> 6 | r << 26) ^ (r >>> 11 | r << 21) ^ (r >>> 25 | r << 7);
  }
  function h(r) {
    return (r >>> 7 | r << 25) ^ (r >>> 18 | r << 14) ^ r >>> 3;
  }
  function f(r) {
    return (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10;
  }
  return y.prototype._update = function(r) {
    for (var m = this._w, g = this._a | 0, a = this._b | 0, l = this._c | 0, d = this._d | 0, b = this._e | 0, S = this._f | 0, E = this._g | 0, R = this._h | 0, k = 0; k < 16; ++k) m[k] = r.readInt32BE(k * 4);
    for (; k < 64; ++k) m[k] = f(m[k - 2]) + m[k - 7] + h(m[k - 15]) + m[k - 16] | 0;
    for (var w = 0; w < 64; ++w) {
      var F = R + c(b) + t(b, S, E) + i[w] + m[w] | 0, I = u(g) + o(g, a, l) | 0;
      R = E, E = S, S = b, b = d + F | 0, d = l, l = a, a = g, g = F + I | 0;
    }
    this._a = g + this._a | 0, this._b = a + this._b | 0, this._c = l + this._c | 0, this._d = d + this._d | 0, this._e = b + this._e | 0, this._f = S + this._f | 0, this._g = E + this._g | 0, this._h = R + this._h | 0;
  }, y.prototype._hash = function() {
    var r = n.allocUnsafe(32);
    return r.writeInt32BE(this._a, 0), r.writeInt32BE(this._b, 4), r.writeInt32BE(this._c, 8), r.writeInt32BE(this._d, 12), r.writeInt32BE(this._e, 16), r.writeInt32BE(this._f, 20), r.writeInt32BE(this._g, 24), r.writeInt32BE(this._h, 28), r;
  }, qc = y, qc;
}
var zc, Wf;
function Cy() {
  if (Wf) return zc;
  Wf = 1;
  var v = La(), e = Qd(), n = Ba(), i = sa().Buffer, s = new Array(64);
  function y() {
    this.init(), this._w = s, n.call(this, 64, 56);
  }
  return v(y, e), y.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, y.prototype._hash = function() {
    var t = i.allocUnsafe(28);
    return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
  }, zc = y, zc;
}
var Hc, Kf;
function Zd() {
  if (Kf) return Hc;
  Kf = 1;
  var v = La(), e = Ba(), n = sa().Buffer, i = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], s = new Array(160);
  function y() {
    this.init(), this._w = s, e.call(this, 128, 112);
  }
  v(y, e), y.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function t(a, l, d) {
    return d ^ a & (l ^ d);
  }
  function o(a, l, d) {
    return a & l | d & (a | l);
  }
  function u(a, l) {
    return (a >>> 28 | l << 4) ^ (l >>> 2 | a << 30) ^ (l >>> 7 | a << 25);
  }
  function c(a, l) {
    return (a >>> 14 | l << 18) ^ (a >>> 18 | l << 14) ^ (l >>> 9 | a << 23);
  }
  function h(a, l) {
    return (a >>> 1 | l << 31) ^ (a >>> 8 | l << 24) ^ a >>> 7;
  }
  function f(a, l) {
    return (a >>> 1 | l << 31) ^ (a >>> 8 | l << 24) ^ (a >>> 7 | l << 25);
  }
  function r(a, l) {
    return (a >>> 19 | l << 13) ^ (l >>> 29 | a << 3) ^ a >>> 6;
  }
  function m(a, l) {
    return (a >>> 19 | l << 13) ^ (l >>> 29 | a << 3) ^ (a >>> 6 | l << 26);
  }
  function g(a, l) {
    return a >>> 0 < l >>> 0 ? 1 : 0;
  }
  return y.prototype._update = function(a) {
    for (var l = this._w, d = this._ah | 0, b = this._bh | 0, S = this._ch | 0, E = this._dh | 0, R = this._eh | 0, k = this._fh | 0, w = this._gh | 0, F = this._hh | 0, I = this._al | 0, q = this._bl | 0, D = this._cl | 0, H = this._dl | 0, _ = this._el | 0, T = this._fl | 0, L = this._gl | 0, j = this._hl | 0, z = 0; z < 32; z += 2) l[z] = a.readInt32BE(z * 4), l[z + 1] = a.readInt32BE(z * 4 + 4);
    for (; z < 160; z += 2) {
      var Y = l[z - 30], te = l[z - 15 * 2 + 1], G = h(Y, te), K = f(te, Y);
      Y = l[z - 2 * 2], te = l[z - 2 * 2 + 1];
      var J = r(Y, te), B = m(te, Y), Z = l[z - 7 * 2], ie = l[z - 7 * 2 + 1], $ = l[z - 16 * 2], oe = l[z - 16 * 2 + 1], ce = K + ie | 0, ye = G + Z + g(ce, K) | 0;
      ce = ce + B | 0, ye = ye + J + g(ce, B) | 0, ce = ce + oe | 0, ye = ye + $ + g(ce, oe) | 0, l[z] = ye, l[z + 1] = ce;
    }
    for (var ae = 0; ae < 160; ae += 2) {
      ye = l[ae], ce = l[ae + 1];
      var ue = o(d, b, S), ne = o(I, q, D), ge = u(d, I), Te = u(I, d), pe = c(R, _), Oe = c(_, R), xe = i[ae], Ve = i[ae + 1], _e = t(R, k, w), Be = t(_, T, L), Qe = j + Oe | 0, ee = F + pe + g(Qe, j) | 0;
      Qe = Qe + Be | 0, ee = ee + _e + g(Qe, Be) | 0, Qe = Qe + Ve | 0, ee = ee + xe + g(Qe, Ve) | 0, Qe = Qe + ce | 0, ee = ee + ye + g(Qe, ce) | 0;
      var P = Te + ne | 0, x = ge + ue + g(P, Te) | 0;
      F = w, j = L, w = k, L = T, k = R, T = _, _ = H + Qe | 0, R = E + ee + g(_, H) | 0, E = S, H = D, S = b, D = q, b = d, q = I, I = Qe + P | 0, d = ee + x + g(I, Qe) | 0;
    }
    this._al = this._al + I | 0, this._bl = this._bl + q | 0, this._cl = this._cl + D | 0, this._dl = this._dl + H | 0, this._el = this._el + _ | 0, this._fl = this._fl + T | 0, this._gl = this._gl + L | 0, this._hl = this._hl + j | 0, this._ah = this._ah + d + g(this._al, I) | 0, this._bh = this._bh + b + g(this._bl, q) | 0, this._ch = this._ch + S + g(this._cl, D) | 0, this._dh = this._dh + E + g(this._dl, H) | 0, this._eh = this._eh + R + g(this._el, _) | 0, this._fh = this._fh + k + g(this._fl, T) | 0, this._gh = this._gh + w + g(this._gl, L) | 0, this._hh = this._hh + F + g(this._hl, j) | 0;
  }, y.prototype._hash = function() {
    var a = n.allocUnsafe(64);
    function l(d, b, S) {
      a.writeInt32BE(d, S), a.writeInt32BE(b, S + 4);
    }
    return l(this._ah, this._al, 0), l(this._bh, this._bl, 8), l(this._ch, this._cl, 16), l(this._dh, this._dl, 24), l(this._eh, this._el, 32), l(this._fh, this._fl, 40), l(this._gh, this._gl, 48), l(this._hh, this._hl, 56), a;
  }, Hc = y, Hc;
}
var Gc, Xf;
function Ry() {
  if (Xf) return Gc;
  Xf = 1;
  var v = La(), e = Zd(), n = Ba(), i = sa().Buffer, s = new Array(160);
  function y() {
    this.init(), this._w = s, n.call(this, 128, 112);
  }
  return v(y, e), y.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, y.prototype._hash = function() {
    var t = i.allocUnsafe(48);
    function o(u, c, h) {
      t.writeInt32BE(u, h), t.writeInt32BE(c, h + 4);
    }
    return o(this._ah, this._al, 0), o(this._bh, this._bl, 8), o(this._ch, this._cl, 16), o(this._dh, this._dl, 24), o(this._eh, this._el, 32), o(this._fh, this._fl, 40), t;
  }, Gc = y, Gc;
}
var $f;
function My() {
  if ($f) return Fc.exports;
  $f = 1;
  var v = Fc.exports = function(n) {
    n = n.toLowerCase();
    var i = v[n];
    if (!i) throw new Error(n + " is not supported (we accept pull requests)");
    return new i();
  };
  return v.sha = Oy(), v.sha1 = Py(), v.sha224 = Cy(), v.sha256 = Qd(), v.sha384 = Ry(), v.sha512 = Zd(), Fc.exports;
}
var Yf;
function Uo() {
  if (Yf) return Xs;
  Yf = 1, Object.defineProperty(Xs, "__esModule", { value: true }), Xs.hash = e;
  var v = My();
  function e(n) {
    var i = new v.sha256();
    return i.update(n, "utf8"), i.digest();
  }
  return Xs;
}
var Oo = {};
const Iy = {}, Ly = Object.freeze(Object.defineProperty({ __proto__: null, default: Iy }, Symbol.toStringTag, { value: "Module" })), Jd = ly(Ly);
function By(v) {
  throw new Error('Could not dynamically require "' + v + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Wc = { exports: {} }, Qf;
function em() {
  return Qf || (Qf = 1, function(v) {
    (function(e) {
      var n = function(Pe) {
        var $e, le = new Float64Array(16);
        if (Pe) for ($e = 0; $e < Pe.length; $e++) le[$e] = Pe[$e];
        return le;
      }, i = function() {
        throw new Error("no PRNG");
      }, s = new Uint8Array(16), y = new Uint8Array(32);
      y[0] = 9;
      var t = n(), o = n([1]), u = n([56129, 1]), c = n([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), h = n([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), f = n([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), r = n([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), m = n([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function g(Pe, $e, le, re) {
        Pe[$e] = le >> 24 & 255, Pe[$e + 1] = le >> 16 & 255, Pe[$e + 2] = le >> 8 & 255, Pe[$e + 3] = le & 255, Pe[$e + 4] = re >> 24 & 255, Pe[$e + 5] = re >> 16 & 255, Pe[$e + 6] = re >> 8 & 255, Pe[$e + 7] = re & 255;
      }
      function a(Pe, $e, le, re, Le) {
        var nt, ft = 0;
        for (nt = 0; nt < Le; nt++) ft |= Pe[$e + nt] ^ le[re + nt];
        return (1 & ft - 1 >>> 8) - 1;
      }
      function l(Pe, $e, le, re) {
        return a(Pe, $e, le, re, 16);
      }
      function d(Pe, $e, le, re) {
        return a(Pe, $e, le, re, 32);
      }
      function b(Pe, $e, le, re) {
        for (var Le = re[0] & 255 | (re[1] & 255) << 8 | (re[2] & 255) << 16 | (re[3] & 255) << 24, nt = le[0] & 255 | (le[1] & 255) << 8 | (le[2] & 255) << 16 | (le[3] & 255) << 24, ft = le[4] & 255 | (le[5] & 255) << 8 | (le[6] & 255) << 16 | (le[7] & 255) << 24, zt = le[8] & 255 | (le[9] & 255) << 8 | (le[10] & 255) << 16 | (le[11] & 255) << 24, st = le[12] & 255 | (le[13] & 255) << 8 | (le[14] & 255) << 16 | (le[15] & 255) << 24, ct = re[4] & 255 | (re[5] & 255) << 8 | (re[6] & 255) << 16 | (re[7] & 255) << 24, yt = $e[0] & 255 | ($e[1] & 255) << 8 | ($e[2] & 255) << 16 | ($e[3] & 255) << 24, Zt = $e[4] & 255 | ($e[5] & 255) << 8 | ($e[6] & 255) << 16 | ($e[7] & 255) << 24, Ct = $e[8] & 255 | ($e[9] & 255) << 8 | ($e[10] & 255) << 16 | ($e[11] & 255) << 24, Lt = $e[12] & 255 | ($e[13] & 255) << 8 | ($e[14] & 255) << 16 | ($e[15] & 255) << 24, Wt = re[8] & 255 | (re[9] & 255) << 8 | (re[10] & 255) << 16 | (re[11] & 255) << 24, vr = le[16] & 255 | (le[17] & 255) << 8 | (le[18] & 255) << 16 | (le[19] & 255) << 24, ar = le[20] & 255 | (le[21] & 255) << 8 | (le[22] & 255) << 16 | (le[23] & 255) << 24, sr = le[24] & 255 | (le[25] & 255) << 8 | (le[26] & 255) << 16 | (le[27] & 255) << 24, gr = le[28] & 255 | (le[29] & 255) << 8 | (le[30] & 255) << 16 | (le[31] & 255) << 24, Tr = re[12] & 255 | (re[13] & 255) << 8 | (re[14] & 255) << 16 | (re[15] & 255) << 24, Mr = Le, Nr = nt, Lr = ft, jr = zt, Hr = st, kr = ct, Xt = yt, Qt = Zt, br = Ct, we = Lt, me = Wt, ze = vr, rt = ar, Tt = sr, Ot = gr, It = Tr, We, mt = 0; mt < 20; mt += 2) We = Mr + rt | 0, Hr ^= We << 7 | We >>> 25, We = Hr + Mr | 0, br ^= We << 9 | We >>> 23, We = br + Hr | 0, rt ^= We << 13 | We >>> 19, We = rt + br | 0, Mr ^= We << 18 | We >>> 14, We = kr + Nr | 0, we ^= We << 7 | We >>> 25, We = we + kr | 0, Tt ^= We << 9 | We >>> 23, We = Tt + we | 0, Nr ^= We << 13 | We >>> 19, We = Nr + Tt | 0, kr ^= We << 18 | We >>> 14, We = me + Xt | 0, Ot ^= We << 7 | We >>> 25, We = Ot + me | 0, Lr ^= We << 9 | We >>> 23, We = Lr + Ot | 0, Xt ^= We << 13 | We >>> 19, We = Xt + Lr | 0, me ^= We << 18 | We >>> 14, We = It + ze | 0, jr ^= We << 7 | We >>> 25, We = jr + It | 0, Qt ^= We << 9 | We >>> 23, We = Qt + jr | 0, ze ^= We << 13 | We >>> 19, We = ze + Qt | 0, It ^= We << 18 | We >>> 14, We = Mr + jr | 0, Nr ^= We << 7 | We >>> 25, We = Nr + Mr | 0, Lr ^= We << 9 | We >>> 23, We = Lr + Nr | 0, jr ^= We << 13 | We >>> 19, We = jr + Lr | 0, Mr ^= We << 18 | We >>> 14, We = kr + Hr | 0, Xt ^= We << 7 | We >>> 25, We = Xt + kr | 0, Qt ^= We << 9 | We >>> 23, We = Qt + Xt | 0, Hr ^= We << 13 | We >>> 19, We = Hr + Qt | 0, kr ^= We << 18 | We >>> 14, We = me + we | 0, ze ^= We << 7 | We >>> 25, We = ze + me | 0, br ^= We << 9 | We >>> 23, We = br + ze | 0, we ^= We << 13 | We >>> 19, We = we + br | 0, me ^= We << 18 | We >>> 14, We = It + Ot | 0, rt ^= We << 7 | We >>> 25, We = rt + It | 0, Tt ^= We << 9 | We >>> 23, We = Tt + rt | 0, Ot ^= We << 13 | We >>> 19, We = Ot + Tt | 0, It ^= We << 18 | We >>> 14;
        Mr = Mr + Le | 0, Nr = Nr + nt | 0, Lr = Lr + ft | 0, jr = jr + zt | 0, Hr = Hr + st | 0, kr = kr + ct | 0, Xt = Xt + yt | 0, Qt = Qt + Zt | 0, br = br + Ct | 0, we = we + Lt | 0, me = me + Wt | 0, ze = ze + vr | 0, rt = rt + ar | 0, Tt = Tt + sr | 0, Ot = Ot + gr | 0, It = It + Tr | 0, Pe[0] = Mr >>> 0 & 255, Pe[1] = Mr >>> 8 & 255, Pe[2] = Mr >>> 16 & 255, Pe[3] = Mr >>> 24 & 255, Pe[4] = Nr >>> 0 & 255, Pe[5] = Nr >>> 8 & 255, Pe[6] = Nr >>> 16 & 255, Pe[7] = Nr >>> 24 & 255, Pe[8] = Lr >>> 0 & 255, Pe[9] = Lr >>> 8 & 255, Pe[10] = Lr >>> 16 & 255, Pe[11] = Lr >>> 24 & 255, Pe[12] = jr >>> 0 & 255, Pe[13] = jr >>> 8 & 255, Pe[14] = jr >>> 16 & 255, Pe[15] = jr >>> 24 & 255, Pe[16] = Hr >>> 0 & 255, Pe[17] = Hr >>> 8 & 255, Pe[18] = Hr >>> 16 & 255, Pe[19] = Hr >>> 24 & 255, Pe[20] = kr >>> 0 & 255, Pe[21] = kr >>> 8 & 255, Pe[22] = kr >>> 16 & 255, Pe[23] = kr >>> 24 & 255, Pe[24] = Xt >>> 0 & 255, Pe[25] = Xt >>> 8 & 255, Pe[26] = Xt >>> 16 & 255, Pe[27] = Xt >>> 24 & 255, Pe[28] = Qt >>> 0 & 255, Pe[29] = Qt >>> 8 & 255, Pe[30] = Qt >>> 16 & 255, Pe[31] = Qt >>> 24 & 255, Pe[32] = br >>> 0 & 255, Pe[33] = br >>> 8 & 255, Pe[34] = br >>> 16 & 255, Pe[35] = br >>> 24 & 255, Pe[36] = we >>> 0 & 255, Pe[37] = we >>> 8 & 255, Pe[38] = we >>> 16 & 255, Pe[39] = we >>> 24 & 255, Pe[40] = me >>> 0 & 255, Pe[41] = me >>> 8 & 255, Pe[42] = me >>> 16 & 255, Pe[43] = me >>> 24 & 255, Pe[44] = ze >>> 0 & 255, Pe[45] = ze >>> 8 & 255, Pe[46] = ze >>> 16 & 255, Pe[47] = ze >>> 24 & 255, Pe[48] = rt >>> 0 & 255, Pe[49] = rt >>> 8 & 255, Pe[50] = rt >>> 16 & 255, Pe[51] = rt >>> 24 & 255, Pe[52] = Tt >>> 0 & 255, Pe[53] = Tt >>> 8 & 255, Pe[54] = Tt >>> 16 & 255, Pe[55] = Tt >>> 24 & 255, Pe[56] = Ot >>> 0 & 255, Pe[57] = Ot >>> 8 & 255, Pe[58] = Ot >>> 16 & 255, Pe[59] = Ot >>> 24 & 255, Pe[60] = It >>> 0 & 255, Pe[61] = It >>> 8 & 255, Pe[62] = It >>> 16 & 255, Pe[63] = It >>> 24 & 255;
      }
      function S(Pe, $e, le, re) {
        for (var Le = re[0] & 255 | (re[1] & 255) << 8 | (re[2] & 255) << 16 | (re[3] & 255) << 24, nt = le[0] & 255 | (le[1] & 255) << 8 | (le[2] & 255) << 16 | (le[3] & 255) << 24, ft = le[4] & 255 | (le[5] & 255) << 8 | (le[6] & 255) << 16 | (le[7] & 255) << 24, zt = le[8] & 255 | (le[9] & 255) << 8 | (le[10] & 255) << 16 | (le[11] & 255) << 24, st = le[12] & 255 | (le[13] & 255) << 8 | (le[14] & 255) << 16 | (le[15] & 255) << 24, ct = re[4] & 255 | (re[5] & 255) << 8 | (re[6] & 255) << 16 | (re[7] & 255) << 24, yt = $e[0] & 255 | ($e[1] & 255) << 8 | ($e[2] & 255) << 16 | ($e[3] & 255) << 24, Zt = $e[4] & 255 | ($e[5] & 255) << 8 | ($e[6] & 255) << 16 | ($e[7] & 255) << 24, Ct = $e[8] & 255 | ($e[9] & 255) << 8 | ($e[10] & 255) << 16 | ($e[11] & 255) << 24, Lt = $e[12] & 255 | ($e[13] & 255) << 8 | ($e[14] & 255) << 16 | ($e[15] & 255) << 24, Wt = re[8] & 255 | (re[9] & 255) << 8 | (re[10] & 255) << 16 | (re[11] & 255) << 24, vr = le[16] & 255 | (le[17] & 255) << 8 | (le[18] & 255) << 16 | (le[19] & 255) << 24, ar = le[20] & 255 | (le[21] & 255) << 8 | (le[22] & 255) << 16 | (le[23] & 255) << 24, sr = le[24] & 255 | (le[25] & 255) << 8 | (le[26] & 255) << 16 | (le[27] & 255) << 24, gr = le[28] & 255 | (le[29] & 255) << 8 | (le[30] & 255) << 16 | (le[31] & 255) << 24, Tr = re[12] & 255 | (re[13] & 255) << 8 | (re[14] & 255) << 16 | (re[15] & 255) << 24, Mr = Le, Nr = nt, Lr = ft, jr = zt, Hr = st, kr = ct, Xt = yt, Qt = Zt, br = Ct, we = Lt, me = Wt, ze = vr, rt = ar, Tt = sr, Ot = gr, It = Tr, We, mt = 0; mt < 20; mt += 2) We = Mr + rt | 0, Hr ^= We << 7 | We >>> 25, We = Hr + Mr | 0, br ^= We << 9 | We >>> 23, We = br + Hr | 0, rt ^= We << 13 | We >>> 19, We = rt + br | 0, Mr ^= We << 18 | We >>> 14, We = kr + Nr | 0, we ^= We << 7 | We >>> 25, We = we + kr | 0, Tt ^= We << 9 | We >>> 23, We = Tt + we | 0, Nr ^= We << 13 | We >>> 19, We = Nr + Tt | 0, kr ^= We << 18 | We >>> 14, We = me + Xt | 0, Ot ^= We << 7 | We >>> 25, We = Ot + me | 0, Lr ^= We << 9 | We >>> 23, We = Lr + Ot | 0, Xt ^= We << 13 | We >>> 19, We = Xt + Lr | 0, me ^= We << 18 | We >>> 14, We = It + ze | 0, jr ^= We << 7 | We >>> 25, We = jr + It | 0, Qt ^= We << 9 | We >>> 23, We = Qt + jr | 0, ze ^= We << 13 | We >>> 19, We = ze + Qt | 0, It ^= We << 18 | We >>> 14, We = Mr + jr | 0, Nr ^= We << 7 | We >>> 25, We = Nr + Mr | 0, Lr ^= We << 9 | We >>> 23, We = Lr + Nr | 0, jr ^= We << 13 | We >>> 19, We = jr + Lr | 0, Mr ^= We << 18 | We >>> 14, We = kr + Hr | 0, Xt ^= We << 7 | We >>> 25, We = Xt + kr | 0, Qt ^= We << 9 | We >>> 23, We = Qt + Xt | 0, Hr ^= We << 13 | We >>> 19, We = Hr + Qt | 0, kr ^= We << 18 | We >>> 14, We = me + we | 0, ze ^= We << 7 | We >>> 25, We = ze + me | 0, br ^= We << 9 | We >>> 23, We = br + ze | 0, we ^= We << 13 | We >>> 19, We = we + br | 0, me ^= We << 18 | We >>> 14, We = It + Ot | 0, rt ^= We << 7 | We >>> 25, We = rt + It | 0, Tt ^= We << 9 | We >>> 23, We = Tt + rt | 0, Ot ^= We << 13 | We >>> 19, We = Ot + Tt | 0, It ^= We << 18 | We >>> 14;
        Pe[0] = Mr >>> 0 & 255, Pe[1] = Mr >>> 8 & 255, Pe[2] = Mr >>> 16 & 255, Pe[3] = Mr >>> 24 & 255, Pe[4] = kr >>> 0 & 255, Pe[5] = kr >>> 8 & 255, Pe[6] = kr >>> 16 & 255, Pe[7] = kr >>> 24 & 255, Pe[8] = me >>> 0 & 255, Pe[9] = me >>> 8 & 255, Pe[10] = me >>> 16 & 255, Pe[11] = me >>> 24 & 255, Pe[12] = It >>> 0 & 255, Pe[13] = It >>> 8 & 255, Pe[14] = It >>> 16 & 255, Pe[15] = It >>> 24 & 255, Pe[16] = Xt >>> 0 & 255, Pe[17] = Xt >>> 8 & 255, Pe[18] = Xt >>> 16 & 255, Pe[19] = Xt >>> 24 & 255, Pe[20] = Qt >>> 0 & 255, Pe[21] = Qt >>> 8 & 255, Pe[22] = Qt >>> 16 & 255, Pe[23] = Qt >>> 24 & 255, Pe[24] = br >>> 0 & 255, Pe[25] = br >>> 8 & 255, Pe[26] = br >>> 16 & 255, Pe[27] = br >>> 24 & 255, Pe[28] = we >>> 0 & 255, Pe[29] = we >>> 8 & 255, Pe[30] = we >>> 16 & 255, Pe[31] = we >>> 24 & 255;
      }
      function E(Pe, $e, le, re) {
        b(Pe, $e, le, re);
      }
      function R(Pe, $e, le, re) {
        S(Pe, $e, le, re);
      }
      var k = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function w(Pe, $e, le, re, Le, nt, ft) {
        var zt = new Uint8Array(16), st = new Uint8Array(64), ct, yt;
        for (yt = 0; yt < 16; yt++) zt[yt] = 0;
        for (yt = 0; yt < 8; yt++) zt[yt] = nt[yt];
        for (; Le >= 64; ) {
          for (E(st, zt, ft, k), yt = 0; yt < 64; yt++) Pe[$e + yt] = le[re + yt] ^ st[yt];
          for (ct = 1, yt = 8; yt < 16; yt++) ct = ct + (zt[yt] & 255) | 0, zt[yt] = ct & 255, ct >>>= 8;
          Le -= 64, $e += 64, re += 64;
        }
        if (Le > 0) for (E(st, zt, ft, k), yt = 0; yt < Le; yt++) Pe[$e + yt] = le[re + yt] ^ st[yt];
        return 0;
      }
      function F(Pe, $e, le, re, Le) {
        var nt = new Uint8Array(16), ft = new Uint8Array(64), zt, st;
        for (st = 0; st < 16; st++) nt[st] = 0;
        for (st = 0; st < 8; st++) nt[st] = re[st];
        for (; le >= 64; ) {
          for (E(ft, nt, Le, k), st = 0; st < 64; st++) Pe[$e + st] = ft[st];
          for (zt = 1, st = 8; st < 16; st++) zt = zt + (nt[st] & 255) | 0, nt[st] = zt & 255, zt >>>= 8;
          le -= 64, $e += 64;
        }
        if (le > 0) for (E(ft, nt, Le, k), st = 0; st < le; st++) Pe[$e + st] = ft[st];
        return 0;
      }
      function I(Pe, $e, le, re, Le) {
        var nt = new Uint8Array(32);
        R(nt, re, Le, k);
        for (var ft = new Uint8Array(8), zt = 0; zt < 8; zt++) ft[zt] = re[zt + 16];
        return F(Pe, $e, le, ft, nt);
      }
      function q(Pe, $e, le, re, Le, nt, ft) {
        var zt = new Uint8Array(32);
        R(zt, nt, ft, k);
        for (var st = new Uint8Array(8), ct = 0; ct < 8; ct++) st[ct] = nt[ct + 16];
        return w(Pe, $e, le, re, Le, st, zt);
      }
      var D = function(Pe) {
        this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
        var $e, le, re, Le, nt, ft, zt, st;
        $e = Pe[0] & 255 | (Pe[1] & 255) << 8, this.r[0] = $e & 8191, le = Pe[2] & 255 | (Pe[3] & 255) << 8, this.r[1] = ($e >>> 13 | le << 3) & 8191, re = Pe[4] & 255 | (Pe[5] & 255) << 8, this.r[2] = (le >>> 10 | re << 6) & 7939, Le = Pe[6] & 255 | (Pe[7] & 255) << 8, this.r[3] = (re >>> 7 | Le << 9) & 8191, nt = Pe[8] & 255 | (Pe[9] & 255) << 8, this.r[4] = (Le >>> 4 | nt << 12) & 255, this.r[5] = nt >>> 1 & 8190, ft = Pe[10] & 255 | (Pe[11] & 255) << 8, this.r[6] = (nt >>> 14 | ft << 2) & 8191, zt = Pe[12] & 255 | (Pe[13] & 255) << 8, this.r[7] = (ft >>> 11 | zt << 5) & 8065, st = Pe[14] & 255 | (Pe[15] & 255) << 8, this.r[8] = (zt >>> 8 | st << 8) & 8191, this.r[9] = st >>> 5 & 127, this.pad[0] = Pe[16] & 255 | (Pe[17] & 255) << 8, this.pad[1] = Pe[18] & 255 | (Pe[19] & 255) << 8, this.pad[2] = Pe[20] & 255 | (Pe[21] & 255) << 8, this.pad[3] = Pe[22] & 255 | (Pe[23] & 255) << 8, this.pad[4] = Pe[24] & 255 | (Pe[25] & 255) << 8, this.pad[5] = Pe[26] & 255 | (Pe[27] & 255) << 8, this.pad[6] = Pe[28] & 255 | (Pe[29] & 255) << 8, this.pad[7] = Pe[30] & 255 | (Pe[31] & 255) << 8;
      };
      D.prototype.blocks = function(Pe, $e, le) {
        for (var re = this.fin ? 0 : 2048, Le, nt, ft, zt, st, ct, yt, Zt, Ct, Lt, Wt, vr, ar, sr, gr, Tr, Mr, Nr, Lr, jr = this.h[0], Hr = this.h[1], kr = this.h[2], Xt = this.h[3], Qt = this.h[4], br = this.h[5], we = this.h[6], me = this.h[7], ze = this.h[8], rt = this.h[9], Tt = this.r[0], Ot = this.r[1], It = this.r[2], We = this.r[3], mt = this.r[4], Gt = this.r[5], ir = this.r[6], dr = this.r[7], hr = this.r[8], Fr = this.r[9]; le >= 16; ) Le = Pe[$e + 0] & 255 | (Pe[$e + 1] & 255) << 8, jr += Le & 8191, nt = Pe[$e + 2] & 255 | (Pe[$e + 3] & 255) << 8, Hr += (Le >>> 13 | nt << 3) & 8191, ft = Pe[$e + 4] & 255 | (Pe[$e + 5] & 255) << 8, kr += (nt >>> 10 | ft << 6) & 8191, zt = Pe[$e + 6] & 255 | (Pe[$e + 7] & 255) << 8, Xt += (ft >>> 7 | zt << 9) & 8191, st = Pe[$e + 8] & 255 | (Pe[$e + 9] & 255) << 8, Qt += (zt >>> 4 | st << 12) & 8191, br += st >>> 1 & 8191, ct = Pe[$e + 10] & 255 | (Pe[$e + 11] & 255) << 8, we += (st >>> 14 | ct << 2) & 8191, yt = Pe[$e + 12] & 255 | (Pe[$e + 13] & 255) << 8, me += (ct >>> 11 | yt << 5) & 8191, Zt = Pe[$e + 14] & 255 | (Pe[$e + 15] & 255) << 8, ze += (yt >>> 8 | Zt << 8) & 8191, rt += Zt >>> 5 | re, Ct = 0, Lt = Ct, Lt += jr * Tt, Lt += Hr * (5 * Fr), Lt += kr * (5 * hr), Lt += Xt * (5 * dr), Lt += Qt * (5 * ir), Ct = Lt >>> 13, Lt &= 8191, Lt += br * (5 * Gt), Lt += we * (5 * mt), Lt += me * (5 * We), Lt += ze * (5 * It), Lt += rt * (5 * Ot), Ct += Lt >>> 13, Lt &= 8191, Wt = Ct, Wt += jr * Ot, Wt += Hr * Tt, Wt += kr * (5 * Fr), Wt += Xt * (5 * hr), Wt += Qt * (5 * dr), Ct = Wt >>> 13, Wt &= 8191, Wt += br * (5 * ir), Wt += we * (5 * Gt), Wt += me * (5 * mt), Wt += ze * (5 * We), Wt += rt * (5 * It), Ct += Wt >>> 13, Wt &= 8191, vr = Ct, vr += jr * It, vr += Hr * Ot, vr += kr * Tt, vr += Xt * (5 * Fr), vr += Qt * (5 * hr), Ct = vr >>> 13, vr &= 8191, vr += br * (5 * dr), vr += we * (5 * ir), vr += me * (5 * Gt), vr += ze * (5 * mt), vr += rt * (5 * We), Ct += vr >>> 13, vr &= 8191, ar = Ct, ar += jr * We, ar += Hr * It, ar += kr * Ot, ar += Xt * Tt, ar += Qt * (5 * Fr), Ct = ar >>> 13, ar &= 8191, ar += br * (5 * hr), ar += we * (5 * dr), ar += me * (5 * ir), ar += ze * (5 * Gt), ar += rt * (5 * mt), Ct += ar >>> 13, ar &= 8191, sr = Ct, sr += jr * mt, sr += Hr * We, sr += kr * It, sr += Xt * Ot, sr += Qt * Tt, Ct = sr >>> 13, sr &= 8191, sr += br * (5 * Fr), sr += we * (5 * hr), sr += me * (5 * dr), sr += ze * (5 * ir), sr += rt * (5 * Gt), Ct += sr >>> 13, sr &= 8191, gr = Ct, gr += jr * Gt, gr += Hr * mt, gr += kr * We, gr += Xt * It, gr += Qt * Ot, Ct = gr >>> 13, gr &= 8191, gr += br * Tt, gr += we * (5 * Fr), gr += me * (5 * hr), gr += ze * (5 * dr), gr += rt * (5 * ir), Ct += gr >>> 13, gr &= 8191, Tr = Ct, Tr += jr * ir, Tr += Hr * Gt, Tr += kr * mt, Tr += Xt * We, Tr += Qt * It, Ct = Tr >>> 13, Tr &= 8191, Tr += br * Ot, Tr += we * Tt, Tr += me * (5 * Fr), Tr += ze * (5 * hr), Tr += rt * (5 * dr), Ct += Tr >>> 13, Tr &= 8191, Mr = Ct, Mr += jr * dr, Mr += Hr * ir, Mr += kr * Gt, Mr += Xt * mt, Mr += Qt * We, Ct = Mr >>> 13, Mr &= 8191, Mr += br * It, Mr += we * Ot, Mr += me * Tt, Mr += ze * (5 * Fr), Mr += rt * (5 * hr), Ct += Mr >>> 13, Mr &= 8191, Nr = Ct, Nr += jr * hr, Nr += Hr * dr, Nr += kr * ir, Nr += Xt * Gt, Nr += Qt * mt, Ct = Nr >>> 13, Nr &= 8191, Nr += br * We, Nr += we * It, Nr += me * Ot, Nr += ze * Tt, Nr += rt * (5 * Fr), Ct += Nr >>> 13, Nr &= 8191, Lr = Ct, Lr += jr * Fr, Lr += Hr * hr, Lr += kr * dr, Lr += Xt * ir, Lr += Qt * Gt, Ct = Lr >>> 13, Lr &= 8191, Lr += br * mt, Lr += we * We, Lr += me * It, Lr += ze * Ot, Lr += rt * Tt, Ct += Lr >>> 13, Lr &= 8191, Ct = (Ct << 2) + Ct | 0, Ct = Ct + Lt | 0, Lt = Ct & 8191, Ct = Ct >>> 13, Wt += Ct, jr = Lt, Hr = Wt, kr = vr, Xt = ar, Qt = sr, br = gr, we = Tr, me = Mr, ze = Nr, rt = Lr, $e += 16, le -= 16;
        this.h[0] = jr, this.h[1] = Hr, this.h[2] = kr, this.h[3] = Xt, this.h[4] = Qt, this.h[5] = br, this.h[6] = we, this.h[7] = me, this.h[8] = ze, this.h[9] = rt;
      }, D.prototype.finish = function(Pe, $e) {
        var le = new Uint16Array(10), re, Le, nt, ft;
        if (this.leftover) {
          for (ft = this.leftover, this.buffer[ft++] = 1; ft < 16; ft++) this.buffer[ft] = 0;
          this.fin = 1, this.blocks(this.buffer, 0, 16);
        }
        for (re = this.h[1] >>> 13, this.h[1] &= 8191, ft = 2; ft < 10; ft++) this.h[ft] += re, re = this.h[ft] >>> 13, this.h[ft] &= 8191;
        for (this.h[0] += re * 5, re = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += re, re = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += re, le[0] = this.h[0] + 5, re = le[0] >>> 13, le[0] &= 8191, ft = 1; ft < 10; ft++) le[ft] = this.h[ft] + re, re = le[ft] >>> 13, le[ft] &= 8191;
        for (le[9] -= 8192, Le = (re ^ 1) - 1, ft = 0; ft < 10; ft++) le[ft] &= Le;
        for (Le = ~Le, ft = 0; ft < 10; ft++) this.h[ft] = this.h[ft] & Le | le[ft];
        for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, nt = this.h[0] + this.pad[0], this.h[0] = nt & 65535, ft = 1; ft < 8; ft++) nt = (this.h[ft] + this.pad[ft] | 0) + (nt >>> 16) | 0, this.h[ft] = nt & 65535;
        Pe[$e + 0] = this.h[0] >>> 0 & 255, Pe[$e + 1] = this.h[0] >>> 8 & 255, Pe[$e + 2] = this.h[1] >>> 0 & 255, Pe[$e + 3] = this.h[1] >>> 8 & 255, Pe[$e + 4] = this.h[2] >>> 0 & 255, Pe[$e + 5] = this.h[2] >>> 8 & 255, Pe[$e + 6] = this.h[3] >>> 0 & 255, Pe[$e + 7] = this.h[3] >>> 8 & 255, Pe[$e + 8] = this.h[4] >>> 0 & 255, Pe[$e + 9] = this.h[4] >>> 8 & 255, Pe[$e + 10] = this.h[5] >>> 0 & 255, Pe[$e + 11] = this.h[5] >>> 8 & 255, Pe[$e + 12] = this.h[6] >>> 0 & 255, Pe[$e + 13] = this.h[6] >>> 8 & 255, Pe[$e + 14] = this.h[7] >>> 0 & 255, Pe[$e + 15] = this.h[7] >>> 8 & 255;
      }, D.prototype.update = function(Pe, $e, le) {
        var re, Le;
        if (this.leftover) {
          for (Le = 16 - this.leftover, Le > le && (Le = le), re = 0; re < Le; re++) this.buffer[this.leftover + re] = Pe[$e + re];
          if (le -= Le, $e += Le, this.leftover += Le, this.leftover < 16) return;
          this.blocks(this.buffer, 0, 16), this.leftover = 0;
        }
        if (le >= 16 && (Le = le - le % 16, this.blocks(Pe, $e, Le), $e += Le, le -= Le), le) {
          for (re = 0; re < le; re++) this.buffer[this.leftover + re] = Pe[$e + re];
          this.leftover += le;
        }
      };
      function H(Pe, $e, le, re, Le, nt) {
        var ft = new D(nt);
        return ft.update(le, re, Le), ft.finish(Pe, $e), 0;
      }
      function _(Pe, $e, le, re, Le, nt) {
        var ft = new Uint8Array(16);
        return H(ft, 0, le, re, Le, nt), l(Pe, $e, ft, 0);
      }
      function T(Pe, $e, le, re, Le) {
        var nt;
        if (le < 32) return -1;
        for (q(Pe, 0, $e, 0, le, re, Le), H(Pe, 16, Pe, 32, le - 32, Pe), nt = 0; nt < 16; nt++) Pe[nt] = 0;
        return 0;
      }
      function L(Pe, $e, le, re, Le) {
        var nt, ft = new Uint8Array(32);
        if (le < 32 || (I(ft, 0, 32, re, Le), _($e, 16, $e, 32, le - 32, ft) !== 0)) return -1;
        for (q(Pe, 0, $e, 0, le, re, Le), nt = 0; nt < 32; nt++) Pe[nt] = 0;
        return 0;
      }
      function j(Pe, $e) {
        var le;
        for (le = 0; le < 16; le++) Pe[le] = $e[le] | 0;
      }
      function z(Pe) {
        var $e, le, re = 1;
        for ($e = 0; $e < 16; $e++) le = Pe[$e] + re + 65535, re = Math.floor(le / 65536), Pe[$e] = le - re * 65536;
        Pe[0] += re - 1 + 37 * (re - 1);
      }
      function Y(Pe, $e, le) {
        for (var re, Le = ~(le - 1), nt = 0; nt < 16; nt++) re = Le & (Pe[nt] ^ $e[nt]), Pe[nt] ^= re, $e[nt] ^= re;
      }
      function te(Pe, $e) {
        var le, re, Le, nt = n(), ft = n();
        for (le = 0; le < 16; le++) ft[le] = $e[le];
        for (z(ft), z(ft), z(ft), re = 0; re < 2; re++) {
          for (nt[0] = ft[0] - 65517, le = 1; le < 15; le++) nt[le] = ft[le] - 65535 - (nt[le - 1] >> 16 & 1), nt[le - 1] &= 65535;
          nt[15] = ft[15] - 32767 - (nt[14] >> 16 & 1), Le = nt[15] >> 16 & 1, nt[14] &= 65535, Y(ft, nt, 1 - Le);
        }
        for (le = 0; le < 16; le++) Pe[2 * le] = ft[le] & 255, Pe[2 * le + 1] = ft[le] >> 8;
      }
      function G(Pe, $e) {
        var le = new Uint8Array(32), re = new Uint8Array(32);
        return te(le, Pe), te(re, $e), d(le, 0, re, 0);
      }
      function K(Pe) {
        var $e = new Uint8Array(32);
        return te($e, Pe), $e[0] & 1;
      }
      function J(Pe, $e) {
        var le;
        for (le = 0; le < 16; le++) Pe[le] = $e[2 * le] + ($e[2 * le + 1] << 8);
        Pe[15] &= 32767;
      }
      function B(Pe, $e, le) {
        for (var re = 0; re < 16; re++) Pe[re] = $e[re] + le[re];
      }
      function Z(Pe, $e, le) {
        for (var re = 0; re < 16; re++) Pe[re] = $e[re] - le[re];
      }
      function ie(Pe, $e, le) {
        var re, Le, nt = 0, ft = 0, zt = 0, st = 0, ct = 0, yt = 0, Zt = 0, Ct = 0, Lt = 0, Wt = 0, vr = 0, ar = 0, sr = 0, gr = 0, Tr = 0, Mr = 0, Nr = 0, Lr = 0, jr = 0, Hr = 0, kr = 0, Xt = 0, Qt = 0, br = 0, we = 0, me = 0, ze = 0, rt = 0, Tt = 0, Ot = 0, It = 0, We = le[0], mt = le[1], Gt = le[2], ir = le[3], dr = le[4], hr = le[5], Fr = le[6], Gr = le[7], Br = le[8], Dr = le[9], Vr = le[10], be = le[11], Or = le[12], Ue = le[13], it = le[14], dt = le[15];
        re = $e[0], nt += re * We, ft += re * mt, zt += re * Gt, st += re * ir, ct += re * dr, yt += re * hr, Zt += re * Fr, Ct += re * Gr, Lt += re * Br, Wt += re * Dr, vr += re * Vr, ar += re * be, sr += re * Or, gr += re * Ue, Tr += re * it, Mr += re * dt, re = $e[1], ft += re * We, zt += re * mt, st += re * Gt, ct += re * ir, yt += re * dr, Zt += re * hr, Ct += re * Fr, Lt += re * Gr, Wt += re * Br, vr += re * Dr, ar += re * Vr, sr += re * be, gr += re * Or, Tr += re * Ue, Mr += re * it, Nr += re * dt, re = $e[2], zt += re * We, st += re * mt, ct += re * Gt, yt += re * ir, Zt += re * dr, Ct += re * hr, Lt += re * Fr, Wt += re * Gr, vr += re * Br, ar += re * Dr, sr += re * Vr, gr += re * be, Tr += re * Or, Mr += re * Ue, Nr += re * it, Lr += re * dt, re = $e[3], st += re * We, ct += re * mt, yt += re * Gt, Zt += re * ir, Ct += re * dr, Lt += re * hr, Wt += re * Fr, vr += re * Gr, ar += re * Br, sr += re * Dr, gr += re * Vr, Tr += re * be, Mr += re * Or, Nr += re * Ue, Lr += re * it, jr += re * dt, re = $e[4], ct += re * We, yt += re * mt, Zt += re * Gt, Ct += re * ir, Lt += re * dr, Wt += re * hr, vr += re * Fr, ar += re * Gr, sr += re * Br, gr += re * Dr, Tr += re * Vr, Mr += re * be, Nr += re * Or, Lr += re * Ue, jr += re * it, Hr += re * dt, re = $e[5], yt += re * We, Zt += re * mt, Ct += re * Gt, Lt += re * ir, Wt += re * dr, vr += re * hr, ar += re * Fr, sr += re * Gr, gr += re * Br, Tr += re * Dr, Mr += re * Vr, Nr += re * be, Lr += re * Or, jr += re * Ue, Hr += re * it, kr += re * dt, re = $e[6], Zt += re * We, Ct += re * mt, Lt += re * Gt, Wt += re * ir, vr += re * dr, ar += re * hr, sr += re * Fr, gr += re * Gr, Tr += re * Br, Mr += re * Dr, Nr += re * Vr, Lr += re * be, jr += re * Or, Hr += re * Ue, kr += re * it, Xt += re * dt, re = $e[7], Ct += re * We, Lt += re * mt, Wt += re * Gt, vr += re * ir, ar += re * dr, sr += re * hr, gr += re * Fr, Tr += re * Gr, Mr += re * Br, Nr += re * Dr, Lr += re * Vr, jr += re * be, Hr += re * Or, kr += re * Ue, Xt += re * it, Qt += re * dt, re = $e[8], Lt += re * We, Wt += re * mt, vr += re * Gt, ar += re * ir, sr += re * dr, gr += re * hr, Tr += re * Fr, Mr += re * Gr, Nr += re * Br, Lr += re * Dr, jr += re * Vr, Hr += re * be, kr += re * Or, Xt += re * Ue, Qt += re * it, br += re * dt, re = $e[9], Wt += re * We, vr += re * mt, ar += re * Gt, sr += re * ir, gr += re * dr, Tr += re * hr, Mr += re * Fr, Nr += re * Gr, Lr += re * Br, jr += re * Dr, Hr += re * Vr, kr += re * be, Xt += re * Or, Qt += re * Ue, br += re * it, we += re * dt, re = $e[10], vr += re * We, ar += re * mt, sr += re * Gt, gr += re * ir, Tr += re * dr, Mr += re * hr, Nr += re * Fr, Lr += re * Gr, jr += re * Br, Hr += re * Dr, kr += re * Vr, Xt += re * be, Qt += re * Or, br += re * Ue, we += re * it, me += re * dt, re = $e[11], ar += re * We, sr += re * mt, gr += re * Gt, Tr += re * ir, Mr += re * dr, Nr += re * hr, Lr += re * Fr, jr += re * Gr, Hr += re * Br, kr += re * Dr, Xt += re * Vr, Qt += re * be, br += re * Or, we += re * Ue, me += re * it, ze += re * dt, re = $e[12], sr += re * We, gr += re * mt, Tr += re * Gt, Mr += re * ir, Nr += re * dr, Lr += re * hr, jr += re * Fr, Hr += re * Gr, kr += re * Br, Xt += re * Dr, Qt += re * Vr, br += re * be, we += re * Or, me += re * Ue, ze += re * it, rt += re * dt, re = $e[13], gr += re * We, Tr += re * mt, Mr += re * Gt, Nr += re * ir, Lr += re * dr, jr += re * hr, Hr += re * Fr, kr += re * Gr, Xt += re * Br, Qt += re * Dr, br += re * Vr, we += re * be, me += re * Or, ze += re * Ue, rt += re * it, Tt += re * dt, re = $e[14], Tr += re * We, Mr += re * mt, Nr += re * Gt, Lr += re * ir, jr += re * dr, Hr += re * hr, kr += re * Fr, Xt += re * Gr, Qt += re * Br, br += re * Dr, we += re * Vr, me += re * be, ze += re * Or, rt += re * Ue, Tt += re * it, Ot += re * dt, re = $e[15], Mr += re * We, Nr += re * mt, Lr += re * Gt, jr += re * ir, Hr += re * dr, kr += re * hr, Xt += re * Fr, Qt += re * Gr, br += re * Br, we += re * Dr, me += re * Vr, ze += re * be, rt += re * Or, Tt += re * Ue, Ot += re * it, It += re * dt, nt += 38 * Nr, ft += 38 * Lr, zt += 38 * jr, st += 38 * Hr, ct += 38 * kr, yt += 38 * Xt, Zt += 38 * Qt, Ct += 38 * br, Lt += 38 * we, Wt += 38 * me, vr += 38 * ze, ar += 38 * rt, sr += 38 * Tt, gr += 38 * Ot, Tr += 38 * It, Le = 1, re = nt + Le + 65535, Le = Math.floor(re / 65536), nt = re - Le * 65536, re = ft + Le + 65535, Le = Math.floor(re / 65536), ft = re - Le * 65536, re = zt + Le + 65535, Le = Math.floor(re / 65536), zt = re - Le * 65536, re = st + Le + 65535, Le = Math.floor(re / 65536), st = re - Le * 65536, re = ct + Le + 65535, Le = Math.floor(re / 65536), ct = re - Le * 65536, re = yt + Le + 65535, Le = Math.floor(re / 65536), yt = re - Le * 65536, re = Zt + Le + 65535, Le = Math.floor(re / 65536), Zt = re - Le * 65536, re = Ct + Le + 65535, Le = Math.floor(re / 65536), Ct = re - Le * 65536, re = Lt + Le + 65535, Le = Math.floor(re / 65536), Lt = re - Le * 65536, re = Wt + Le + 65535, Le = Math.floor(re / 65536), Wt = re - Le * 65536, re = vr + Le + 65535, Le = Math.floor(re / 65536), vr = re - Le * 65536, re = ar + Le + 65535, Le = Math.floor(re / 65536), ar = re - Le * 65536, re = sr + Le + 65535, Le = Math.floor(re / 65536), sr = re - Le * 65536, re = gr + Le + 65535, Le = Math.floor(re / 65536), gr = re - Le * 65536, re = Tr + Le + 65535, Le = Math.floor(re / 65536), Tr = re - Le * 65536, re = Mr + Le + 65535, Le = Math.floor(re / 65536), Mr = re - Le * 65536, nt += Le - 1 + 37 * (Le - 1), Le = 1, re = nt + Le + 65535, Le = Math.floor(re / 65536), nt = re - Le * 65536, re = ft + Le + 65535, Le = Math.floor(re / 65536), ft = re - Le * 65536, re = zt + Le + 65535, Le = Math.floor(re / 65536), zt = re - Le * 65536, re = st + Le + 65535, Le = Math.floor(re / 65536), st = re - Le * 65536, re = ct + Le + 65535, Le = Math.floor(re / 65536), ct = re - Le * 65536, re = yt + Le + 65535, Le = Math.floor(re / 65536), yt = re - Le * 65536, re = Zt + Le + 65535, Le = Math.floor(re / 65536), Zt = re - Le * 65536, re = Ct + Le + 65535, Le = Math.floor(re / 65536), Ct = re - Le * 65536, re = Lt + Le + 65535, Le = Math.floor(re / 65536), Lt = re - Le * 65536, re = Wt + Le + 65535, Le = Math.floor(re / 65536), Wt = re - Le * 65536, re = vr + Le + 65535, Le = Math.floor(re / 65536), vr = re - Le * 65536, re = ar + Le + 65535, Le = Math.floor(re / 65536), ar = re - Le * 65536, re = sr + Le + 65535, Le = Math.floor(re / 65536), sr = re - Le * 65536, re = gr + Le + 65535, Le = Math.floor(re / 65536), gr = re - Le * 65536, re = Tr + Le + 65535, Le = Math.floor(re / 65536), Tr = re - Le * 65536, re = Mr + Le + 65535, Le = Math.floor(re / 65536), Mr = re - Le * 65536, nt += Le - 1 + 37 * (Le - 1), Pe[0] = nt, Pe[1] = ft, Pe[2] = zt, Pe[3] = st, Pe[4] = ct, Pe[5] = yt, Pe[6] = Zt, Pe[7] = Ct, Pe[8] = Lt, Pe[9] = Wt, Pe[10] = vr, Pe[11] = ar, Pe[12] = sr, Pe[13] = gr, Pe[14] = Tr, Pe[15] = Mr;
      }
      function $(Pe, $e) {
        ie(Pe, $e, $e);
      }
      function oe(Pe, $e) {
        var le = n(), re;
        for (re = 0; re < 16; re++) le[re] = $e[re];
        for (re = 253; re >= 0; re--) $(le, le), re !== 2 && re !== 4 && ie(le, le, $e);
        for (re = 0; re < 16; re++) Pe[re] = le[re];
      }
      function ce(Pe, $e) {
        var le = n(), re;
        for (re = 0; re < 16; re++) le[re] = $e[re];
        for (re = 250; re >= 0; re--) $(le, le), re !== 1 && ie(le, le, $e);
        for (re = 0; re < 16; re++) Pe[re] = le[re];
      }
      function ye(Pe, $e, le) {
        var re = new Uint8Array(32), Le = new Float64Array(80), nt, ft, zt = n(), st = n(), ct = n(), yt = n(), Zt = n(), Ct = n();
        for (ft = 0; ft < 31; ft++) re[ft] = $e[ft];
        for (re[31] = $e[31] & 127 | 64, re[0] &= 248, J(Le, le), ft = 0; ft < 16; ft++) st[ft] = Le[ft], yt[ft] = zt[ft] = ct[ft] = 0;
        for (zt[0] = yt[0] = 1, ft = 254; ft >= 0; --ft) nt = re[ft >>> 3] >>> (ft & 7) & 1, Y(zt, st, nt), Y(ct, yt, nt), B(Zt, zt, ct), Z(zt, zt, ct), B(ct, st, yt), Z(st, st, yt), $(yt, Zt), $(Ct, zt), ie(zt, ct, zt), ie(ct, st, Zt), B(Zt, zt, ct), Z(zt, zt, ct), $(st, zt), Z(ct, yt, Ct), ie(zt, ct, u), B(zt, zt, yt), ie(ct, ct, zt), ie(zt, yt, Ct), ie(yt, st, Le), $(st, Zt), Y(zt, st, nt), Y(ct, yt, nt);
        for (ft = 0; ft < 16; ft++) Le[ft + 16] = zt[ft], Le[ft + 32] = ct[ft], Le[ft + 48] = st[ft], Le[ft + 64] = yt[ft];
        var Lt = Le.subarray(32), Wt = Le.subarray(16);
        return oe(Lt, Lt), ie(Wt, Wt, Lt), te(Pe, Wt), 0;
      }
      function ae(Pe, $e) {
        return ye(Pe, $e, y);
      }
      function ue(Pe, $e) {
        return i($e, 32), ae(Pe, $e);
      }
      function ne(Pe, $e, le) {
        var re = new Uint8Array(32);
        return ye(re, le, $e), R(Pe, s, re, k);
      }
      var ge = T, Te = L;
      function pe(Pe, $e, le, re, Le, nt) {
        var ft = new Uint8Array(32);
        return ne(ft, Le, nt), ge(Pe, $e, le, re, ft);
      }
      function Oe(Pe, $e, le, re, Le, nt) {
        var ft = new Uint8Array(32);
        return ne(ft, Le, nt), Te(Pe, $e, le, re, ft);
      }
      var xe = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function Ve(Pe, $e, le, re) {
        for (var Le = new Int32Array(16), nt = new Int32Array(16), ft, zt, st, ct, yt, Zt, Ct, Lt, Wt, vr, ar, sr, gr, Tr, Mr, Nr, Lr, jr, Hr, kr, Xt, Qt, br, we, me, ze, rt = Pe[0], Tt = Pe[1], Ot = Pe[2], It = Pe[3], We = Pe[4], mt = Pe[5], Gt = Pe[6], ir = Pe[7], dr = $e[0], hr = $e[1], Fr = $e[2], Gr = $e[3], Br = $e[4], Dr = $e[5], Vr = $e[6], be = $e[7], Or = 0; re >= 128; ) {
          for (Hr = 0; Hr < 16; Hr++) kr = 8 * Hr + Or, Le[Hr] = le[kr + 0] << 24 | le[kr + 1] << 16 | le[kr + 2] << 8 | le[kr + 3], nt[Hr] = le[kr + 4] << 24 | le[kr + 5] << 16 | le[kr + 6] << 8 | le[kr + 7];
          for (Hr = 0; Hr < 80; Hr++) if (ft = rt, zt = Tt, st = Ot, ct = It, yt = We, Zt = mt, Ct = Gt, Lt = ir, Wt = dr, vr = hr, ar = Fr, sr = Gr, gr = Br, Tr = Dr, Mr = Vr, Nr = be, Xt = ir, Qt = be, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = (We >>> 14 | Br << 18) ^ (We >>> 18 | Br << 14) ^ (Br >>> 9 | We << 23), Qt = (Br >>> 14 | We << 18) ^ (Br >>> 18 | We << 14) ^ (We >>> 9 | Br << 23), br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Xt = We & mt ^ ~We & Gt, Qt = Br & Dr ^ ~Br & Vr, br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Xt = xe[Hr * 2], Qt = xe[Hr * 2 + 1], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Xt = Le[Hr % 16], Qt = nt[Hr % 16], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Lr = me & 65535 | ze << 16, jr = br & 65535 | we << 16, Xt = Lr, Qt = jr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = (rt >>> 28 | dr << 4) ^ (dr >>> 2 | rt << 30) ^ (dr >>> 7 | rt << 25), Qt = (dr >>> 28 | rt << 4) ^ (rt >>> 2 | dr << 30) ^ (rt >>> 7 | dr << 25), br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Xt = rt & Tt ^ rt & Ot ^ Tt & Ot, Qt = dr & hr ^ dr & Fr ^ hr & Fr, br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Lt = me & 65535 | ze << 16, Nr = br & 65535 | we << 16, Xt = ct, Qt = sr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Lr, Qt = jr, br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, ct = me & 65535 | ze << 16, sr = br & 65535 | we << 16, Tt = ft, Ot = zt, It = st, We = ct, mt = yt, Gt = Zt, ir = Ct, rt = Lt, hr = Wt, Fr = vr, Gr = ar, Br = sr, Dr = gr, Vr = Tr, be = Mr, dr = Nr, Hr % 16 === 15) for (kr = 0; kr < 16; kr++) Xt = Le[kr], Qt = nt[kr], br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Le[(kr + 9) % 16], Qt = nt[(kr + 9) % 16], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Lr = Le[(kr + 1) % 16], jr = nt[(kr + 1) % 16], Xt = (Lr >>> 1 | jr << 31) ^ (Lr >>> 8 | jr << 24) ^ Lr >>> 7, Qt = (jr >>> 1 | Lr << 31) ^ (jr >>> 8 | Lr << 24) ^ (jr >>> 7 | Lr << 25), br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, Lr = Le[(kr + 14) % 16], jr = nt[(kr + 14) % 16], Xt = (Lr >>> 19 | jr << 13) ^ (jr >>> 29 | Lr << 3) ^ Lr >>> 6, Qt = (jr >>> 19 | Lr << 13) ^ (Lr >>> 29 | jr << 3) ^ (jr >>> 6 | Lr << 26), br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Le[kr] = me & 65535 | ze << 16, nt[kr] = br & 65535 | we << 16;
          Xt = rt, Qt = dr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[0], Qt = $e[0], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[0] = rt = me & 65535 | ze << 16, $e[0] = dr = br & 65535 | we << 16, Xt = Tt, Qt = hr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[1], Qt = $e[1], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[1] = Tt = me & 65535 | ze << 16, $e[1] = hr = br & 65535 | we << 16, Xt = Ot, Qt = Fr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[2], Qt = $e[2], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[2] = Ot = me & 65535 | ze << 16, $e[2] = Fr = br & 65535 | we << 16, Xt = It, Qt = Gr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[3], Qt = $e[3], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[3] = It = me & 65535 | ze << 16, $e[3] = Gr = br & 65535 | we << 16, Xt = We, Qt = Br, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[4], Qt = $e[4], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[4] = We = me & 65535 | ze << 16, $e[4] = Br = br & 65535 | we << 16, Xt = mt, Qt = Dr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[5], Qt = $e[5], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[5] = mt = me & 65535 | ze << 16, $e[5] = Dr = br & 65535 | we << 16, Xt = Gt, Qt = Vr, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[6], Qt = $e[6], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[6] = Gt = me & 65535 | ze << 16, $e[6] = Vr = br & 65535 | we << 16, Xt = ir, Qt = be, br = Qt & 65535, we = Qt >>> 16, me = Xt & 65535, ze = Xt >>> 16, Xt = Pe[7], Qt = $e[7], br += Qt & 65535, we += Qt >>> 16, me += Xt & 65535, ze += Xt >>> 16, we += br >>> 16, me += we >>> 16, ze += me >>> 16, Pe[7] = ir = me & 65535 | ze << 16, $e[7] = be = br & 65535 | we << 16, Or += 128, re -= 128;
        }
        return re;
      }
      function _e(Pe, $e, le) {
        var re = new Int32Array(8), Le = new Int32Array(8), nt = new Uint8Array(256), ft, zt = le;
        for (re[0] = 1779033703, re[1] = 3144134277, re[2] = 1013904242, re[3] = 2773480762, re[4] = 1359893119, re[5] = 2600822924, re[6] = 528734635, re[7] = 1541459225, Le[0] = 4089235720, Le[1] = 2227873595, Le[2] = 4271175723, Le[3] = 1595750129, Le[4] = 2917565137, Le[5] = 725511199, Le[6] = 4215389547, Le[7] = 327033209, Ve(re, Le, $e, le), le %= 128, ft = 0; ft < le; ft++) nt[ft] = $e[zt - le + ft];
        for (nt[le] = 128, le = 256 - 128 * (le < 112 ? 1 : 0), nt[le - 9] = 0, g(nt, le - 8, zt / 536870912 | 0, zt << 3), Ve(re, Le, nt, le), ft = 0; ft < 8; ft++) g(Pe, 8 * ft, re[ft], Le[ft]);
        return 0;
      }
      function Be(Pe, $e) {
        var le = n(), re = n(), Le = n(), nt = n(), ft = n(), zt = n(), st = n(), ct = n(), yt = n();
        Z(le, Pe[1], Pe[0]), Z(yt, $e[1], $e[0]), ie(le, le, yt), B(re, Pe[0], Pe[1]), B(yt, $e[0], $e[1]), ie(re, re, yt), ie(Le, Pe[3], $e[3]), ie(Le, Le, h), ie(nt, Pe[2], $e[2]), B(nt, nt, nt), Z(ft, re, le), Z(zt, nt, Le), B(st, nt, Le), B(ct, re, le), ie(Pe[0], ft, zt), ie(Pe[1], ct, st), ie(Pe[2], st, zt), ie(Pe[3], ft, ct);
      }
      function Qe(Pe, $e, le) {
        var re;
        for (re = 0; re < 4; re++) Y(Pe[re], $e[re], le);
      }
      function ee(Pe, $e) {
        var le = n(), re = n(), Le = n();
        oe(Le, $e[2]), ie(le, $e[0], Le), ie(re, $e[1], Le), te(Pe, re), Pe[31] ^= K(le) << 7;
      }
      function P(Pe, $e, le) {
        var re, Le;
        for (j(Pe[0], t), j(Pe[1], o), j(Pe[2], o), j(Pe[3], t), Le = 255; Le >= 0; --Le) re = le[Le / 8 | 0] >> (Le & 7) & 1, Qe(Pe, $e, re), Be($e, Pe), Be(Pe, Pe), Qe(Pe, $e, re);
      }
      function x(Pe, $e) {
        var le = [n(), n(), n(), n()];
        j(le[0], f), j(le[1], r), j(le[2], o), ie(le[3], f, r), P(Pe, le, $e);
      }
      function O(Pe, $e, le) {
        var re = new Uint8Array(64), Le = [n(), n(), n(), n()], nt;
        for (le || i($e, 32), _e(re, $e, 32), re[0] &= 248, re[31] &= 127, re[31] |= 64, x(Le, re), ee(Pe, Le), nt = 0; nt < 32; nt++) $e[nt + 32] = Pe[nt];
        return 0;
      }
      var V = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function N(Pe, $e) {
        var le, re, Le, nt;
        for (re = 63; re >= 32; --re) {
          for (le = 0, Le = re - 32, nt = re - 12; Le < nt; ++Le) $e[Le] += le - 16 * $e[re] * V[Le - (re - 32)], le = Math.floor(($e[Le] + 128) / 256), $e[Le] -= le * 256;
          $e[Le] += le, $e[re] = 0;
        }
        for (le = 0, Le = 0; Le < 32; Le++) $e[Le] += le - ($e[31] >> 4) * V[Le], le = $e[Le] >> 8, $e[Le] &= 255;
        for (Le = 0; Le < 32; Le++) $e[Le] -= le * V[Le];
        for (re = 0; re < 32; re++) $e[re + 1] += $e[re] >> 8, Pe[re] = $e[re] & 255;
      }
      function C(Pe) {
        var $e = new Float64Array(64), le;
        for (le = 0; le < 64; le++) $e[le] = Pe[le];
        for (le = 0; le < 64; le++) Pe[le] = 0;
        N(Pe, $e);
      }
      function p(Pe, $e, le, re) {
        var Le = new Uint8Array(64), nt = new Uint8Array(64), ft = new Uint8Array(64), zt, st, ct = new Float64Array(64), yt = [n(), n(), n(), n()];
        _e(Le, re, 32), Le[0] &= 248, Le[31] &= 127, Le[31] |= 64;
        var Zt = le + 64;
        for (zt = 0; zt < le; zt++) Pe[64 + zt] = $e[zt];
        for (zt = 0; zt < 32; zt++) Pe[32 + zt] = Le[32 + zt];
        for (_e(ft, Pe.subarray(32), le + 32), C(ft), x(yt, ft), ee(Pe, yt), zt = 32; zt < 64; zt++) Pe[zt] = re[zt];
        for (_e(nt, Pe, le + 64), C(nt), zt = 0; zt < 64; zt++) ct[zt] = 0;
        for (zt = 0; zt < 32; zt++) ct[zt] = ft[zt];
        for (zt = 0; zt < 32; zt++) for (st = 0; st < 32; st++) ct[zt + st] += nt[zt] * Le[st];
        return N(Pe.subarray(32), ct), Zt;
      }
      function A(Pe, $e) {
        var le = n(), re = n(), Le = n(), nt = n(), ft = n(), zt = n(), st = n();
        return j(Pe[2], o), J(Pe[1], $e), $(Le, Pe[1]), ie(nt, Le, c), Z(Le, Le, Pe[2]), B(nt, Pe[2], nt), $(ft, nt), $(zt, ft), ie(st, zt, ft), ie(le, st, Le), ie(le, le, nt), ce(le, le), ie(le, le, Le), ie(le, le, nt), ie(le, le, nt), ie(Pe[0], le, nt), $(re, Pe[0]), ie(re, re, nt), G(re, Le) && ie(Pe[0], Pe[0], m), $(re, Pe[0]), ie(re, re, nt), G(re, Le) ? -1 : (K(Pe[0]) === $e[31] >> 7 && Z(Pe[0], t, Pe[0]), ie(Pe[3], Pe[0], Pe[1]), 0);
      }
      function U(Pe, $e, le, re) {
        var Le, nt = new Uint8Array(32), ft = new Uint8Array(64), zt = [n(), n(), n(), n()], st = [n(), n(), n(), n()];
        if (le < 64 || A(st, re)) return -1;
        for (Le = 0; Le < le; Le++) Pe[Le] = $e[Le];
        for (Le = 0; Le < 32; Le++) Pe[Le + 32] = re[Le];
        if (_e(ft, Pe, le), C(ft), P(zt, st, ft), x(st, $e.subarray(32)), Be(zt, st), ee(nt, zt), le -= 64, d($e, 0, nt, 0)) {
          for (Le = 0; Le < le; Le++) Pe[Le] = 0;
          return -1;
        }
        for (Le = 0; Le < le; Le++) Pe[Le] = $e[Le + 64];
        return le;
      }
      var Q = 32, se = 24, X = 32, de = 16, tt = 32, Ne = 32, ut = 32, Ze = 32, Et = 32, rr = se, je = X, Ge = de, at = 64, Ae = 32, qe = 64, Ft = 32, Dt = 64;
      e.lowlevel = { crypto_core_hsalsa20: R, crypto_stream_xor: q, crypto_stream: I, crypto_stream_salsa20_xor: w, crypto_stream_salsa20: F, crypto_onetimeauth: H, crypto_onetimeauth_verify: _, crypto_verify_16: l, crypto_verify_32: d, crypto_secretbox: T, crypto_secretbox_open: L, crypto_scalarmult: ye, crypto_scalarmult_base: ae, crypto_box_beforenm: ne, crypto_box_afternm: ge, crypto_box: pe, crypto_box_open: Oe, crypto_box_keypair: ue, crypto_hash: _e, crypto_sign: p, crypto_sign_keypair: O, crypto_sign_open: U, crypto_secretbox_KEYBYTES: Q, crypto_secretbox_NONCEBYTES: se, crypto_secretbox_ZEROBYTES: X, crypto_secretbox_BOXZEROBYTES: de, crypto_scalarmult_BYTES: tt, crypto_scalarmult_SCALARBYTES: Ne, crypto_box_PUBLICKEYBYTES: ut, crypto_box_SECRETKEYBYTES: Ze, crypto_box_BEFORENMBYTES: Et, crypto_box_NONCEBYTES: rr, crypto_box_ZEROBYTES: je, crypto_box_BOXZEROBYTES: Ge, crypto_sign_BYTES: at, crypto_sign_PUBLICKEYBYTES: Ae, crypto_sign_SECRETKEYBYTES: qe, crypto_sign_SEEDBYTES: Ft, crypto_hash_BYTES: Dt, gf: n, D: c, L: V, pack25519: te, unpack25519: J, M: ie, A: B, S: $, Z, pow2523: ce, add: Be, set25519: j, modL: N, scalarmult: P, scalarbase: x };
      function wr(Pe, $e) {
        if (Pe.length !== Q) throw new Error("bad key size");
        if ($e.length !== se) throw new Error("bad nonce size");
      }
      function Nt(Pe, $e) {
        if (Pe.length !== ut) throw new Error("bad public key size");
        if ($e.length !== Ze) throw new Error("bad secret key size");
      }
      function yr() {
        for (var Pe = 0; Pe < arguments.length; Pe++) if (!(arguments[Pe] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array");
      }
      function Ur(Pe) {
        for (var $e = 0; $e < Pe.length; $e++) Pe[$e] = 0;
      }
      e.randomBytes = function(Pe) {
        var $e = new Uint8Array(Pe);
        return i($e, Pe), $e;
      }, e.secretbox = function(Pe, $e, le) {
        yr(Pe, $e, le), wr(le, $e);
        for (var re = new Uint8Array(X + Pe.length), Le = new Uint8Array(re.length), nt = 0; nt < Pe.length; nt++) re[nt + X] = Pe[nt];
        return T(Le, re, re.length, $e, le), Le.subarray(de);
      }, e.secretbox.open = function(Pe, $e, le) {
        yr(Pe, $e, le), wr(le, $e);
        for (var re = new Uint8Array(de + Pe.length), Le = new Uint8Array(re.length), nt = 0; nt < Pe.length; nt++) re[nt + de] = Pe[nt];
        return re.length < 32 || L(Le, re, re.length, $e, le) !== 0 ? null : Le.subarray(X);
      }, e.secretbox.keyLength = Q, e.secretbox.nonceLength = se, e.secretbox.overheadLength = de, e.scalarMult = function(Pe, $e) {
        if (yr(Pe, $e), Pe.length !== Ne) throw new Error("bad n size");
        if ($e.length !== tt) throw new Error("bad p size");
        var le = new Uint8Array(tt);
        return ye(le, Pe, $e), le;
      }, e.scalarMult.base = function(Pe) {
        if (yr(Pe), Pe.length !== Ne) throw new Error("bad n size");
        var $e = new Uint8Array(tt);
        return ae($e, Pe), $e;
      }, e.scalarMult.scalarLength = Ne, e.scalarMult.groupElementLength = tt, e.box = function(Pe, $e, le, re) {
        var Le = e.box.before(le, re);
        return e.secretbox(Pe, $e, Le);
      }, e.box.before = function(Pe, $e) {
        yr(Pe, $e), Nt(Pe, $e);
        var le = new Uint8Array(Et);
        return ne(le, Pe, $e), le;
      }, e.box.after = e.secretbox, e.box.open = function(Pe, $e, le, re) {
        var Le = e.box.before(le, re);
        return e.secretbox.open(Pe, $e, Le);
      }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
        var Pe = new Uint8Array(ut), $e = new Uint8Array(Ze);
        return ue(Pe, $e), { publicKey: Pe, secretKey: $e };
      }, e.box.keyPair.fromSecretKey = function(Pe) {
        if (yr(Pe), Pe.length !== Ze) throw new Error("bad secret key size");
        var $e = new Uint8Array(ut);
        return ae($e, Pe), { publicKey: $e, secretKey: new Uint8Array(Pe) };
      }, e.box.publicKeyLength = ut, e.box.secretKeyLength = Ze, e.box.sharedKeyLength = Et, e.box.nonceLength = rr, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(Pe, $e) {
        if (yr(Pe, $e), $e.length !== qe) throw new Error("bad secret key size");
        var le = new Uint8Array(at + Pe.length);
        return p(le, Pe, Pe.length, $e), le;
      }, e.sign.open = function(Pe, $e) {
        if (yr(Pe, $e), $e.length !== Ae) throw new Error("bad public key size");
        var le = new Uint8Array(Pe.length), re = U(le, Pe, Pe.length, $e);
        if (re < 0) return null;
        for (var Le = new Uint8Array(re), nt = 0; nt < Le.length; nt++) Le[nt] = le[nt];
        return Le;
      }, e.sign.detached = function(Pe, $e) {
        for (var le = e.sign(Pe, $e), re = new Uint8Array(at), Le = 0; Le < re.length; Le++) re[Le] = le[Le];
        return re;
      }, e.sign.detached.verify = function(Pe, $e, le) {
        if (yr(Pe, $e, le), $e.length !== at) throw new Error("bad signature size");
        if (le.length !== Ae) throw new Error("bad public key size");
        var re = new Uint8Array(at + Pe.length), Le = new Uint8Array(at + Pe.length), nt;
        for (nt = 0; nt < at; nt++) re[nt] = $e[nt];
        for (nt = 0; nt < Pe.length; nt++) re[nt + at] = Pe[nt];
        return U(Le, re, re.length, le) >= 0;
      }, e.sign.keyPair = function() {
        var Pe = new Uint8Array(Ae), $e = new Uint8Array(qe);
        return O(Pe, $e), { publicKey: Pe, secretKey: $e };
      }, e.sign.keyPair.fromSecretKey = function(Pe) {
        if (yr(Pe), Pe.length !== qe) throw new Error("bad secret key size");
        for (var $e = new Uint8Array(Ae), le = 0; le < $e.length; le++) $e[le] = Pe[32 + le];
        return { publicKey: $e, secretKey: new Uint8Array(Pe) };
      }, e.sign.keyPair.fromSeed = function(Pe) {
        if (yr(Pe), Pe.length !== Ft) throw new Error("bad seed size");
        for (var $e = new Uint8Array(Ae), le = new Uint8Array(qe), re = 0; re < 32; re++) le[re] = Pe[re];
        return O($e, le, true), { publicKey: $e, secretKey: le };
      }, e.sign.publicKeyLength = Ae, e.sign.secretKeyLength = qe, e.sign.seedLength = Ft, e.sign.signatureLength = at, e.hash = function(Pe) {
        yr(Pe);
        var $e = new Uint8Array(Dt);
        return _e($e, Pe, Pe.length), $e;
      }, e.hash.hashLength = Dt, e.verify = function(Pe, $e) {
        return yr(Pe, $e), Pe.length === 0 || $e.length === 0 || Pe.length !== $e.length ? false : a(Pe, 0, $e, 0, Pe.length) === 0;
      }, e.setPRNG = function(Pe) {
        i = Pe;
      }, function() {
        var Pe = typeof self < "u" ? self.crypto || self.msCrypto : null;
        if (Pe && Pe.getRandomValues) {
          var $e = 65536;
          e.setPRNG(function(le, re) {
            var Le, nt = new Uint8Array(re);
            for (Le = 0; Le < re; Le += $e) Pe.getRandomValues(nt.subarray(Le, Le + Math.min(re - Le, $e)));
            for (Le = 0; Le < re; Le++) le[Le] = nt[Le];
            Ur(nt);
          });
        } else typeof By < "u" && (Pe = Jd, Pe && Pe.randomBytes && e.setPRNG(function(le, re) {
          var Le, nt = Pe.randomBytes(re);
          for (Le = 0; Le < re; Le++) le[Le] = nt[Le];
          Ur(nt);
        }));
      }();
    })(v.exports ? v.exports : self.nacl = self.nacl || {});
  }(Wc)), Wc.exports;
}
var Zf;
function tm() {
  if (Zf) return Oo;
  Zf = 1, Object.defineProperty(Oo, "__esModule", { value: true }), Oo.FastSigning = void 0, Oo.generate = i, Oo.sign = e, Oo.verify = n;
  var v = {};
  Oo.FastSigning = s();
  function e(o, u) {
    return v.sign(o, u);
  }
  function n(o, u, c) {
    return v.verify(o, u, c);
  }
  function i(o) {
    return v.generate(o);
  }
  function s() {
    return typeof window > "u" ? y() : t();
  }
  function y() {
    var o;
    try {
      o = Jd;
    } catch {
      return t();
    }
    return Object.keys(o).length ? (v.generate = function(u) {
      var c = Buffer.alloc(o.crypto_sign_PUBLICKEYBYTES), h = Buffer.alloc(o.crypto_sign_SECRETKEYBYTES);
      return o.crypto_sign_seed_keypair(c, h, u), c;
    }, v.sign = function(u, c) {
      u = Buffer.from(u);
      var h = Buffer.alloc(o.crypto_sign_BYTES);
      return o.crypto_sign_detached(h, u, c), h;
    }, v.verify = function(u, c, h) {
      u = Buffer.from(u);
      try {
        return o.crypto_sign_verify_detached(c, u, h);
      } catch {
        return false;
      }
    }, true) : t();
  }
  function t() {
    var o = em();
    return v.generate = function(u) {
      var c = new Uint8Array(u), h = o.sign.keyPair.fromSeed(c);
      return Buffer.from(h.publicKey);
    }, v.sign = function(u, c) {
      u = Buffer.from(u), u = new Uint8Array(u.toJSON().data), c = new Uint8Array(c.toJSON().data);
      var h = o.sign.detached(u, c);
      return Buffer.from(h);
    }, v.verify = function(u, c, h) {
      return u = Buffer.from(u), u = new Uint8Array(u.toJSON().data), c = new Uint8Array(c.toJSON().data), h = new Uint8Array(h.toJSON().data), o.sign.detached.verify(u, c, h);
    }, false;
  }
  return Oo;
}
var fa = {}, za = {}, Ha = {}, Jf;
function rm() {
  return Jf || (Jf = 1, Object.defineProperty(Ha, "__esModule", { value: true }), Ha.trimEnd = void 0, Ha.trimEnd = function(e, n) {
    for (var i = typeof e == "number", s = String(e); s.endsWith(n); ) s = s.slice(0, -1);
    return i ? Number(s) : s;
  }), Ha;
}
var Ga = {}, Vo = {}, Kc = {}, ep;
function Ny() {
  return ep || (ep = 1, function(v) {
    var e = function(o, u) {
      return u || (u = {}), o.split("").forEach(function(c, h) {
        c in u || (u[c] = h);
      }), u;
    }, n = { alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", charmap: { 0: 14, 1: 8 } };
    n.charmap = e(n.alphabet, n.charmap);
    var i = { alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ", charmap: { O: 0, I: 1, L: 1 } };
    i.charmap = e(i.alphabet, i.charmap);
    var s = { alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", charmap: {} };
    s.charmap = e(s.alphabet, s.charmap);
    function y(o) {
      if (this.buf = [], this.shift = 8, this.carry = 0, o) {
        switch (o.type) {
          case "rfc4648":
            this.charmap = v.rfc4648.charmap;
            break;
          case "crockford":
            this.charmap = v.crockford.charmap;
            break;
          case "base32hex":
            this.charmap = v.base32hex.charmap;
            break;
          default:
            throw new Error("invalid type");
        }
        o.charmap && (this.charmap = o.charmap);
      }
    }
    y.prototype.charmap = n.charmap, y.prototype.write = function(o) {
      var u = this.charmap, c = this.buf, h = this.shift, f = this.carry;
      return o.toUpperCase().split("").forEach(function(r) {
        if (r != "=") {
          var m = u[r] & 255;
          h -= 5, h > 0 ? f |= m << h : h < 0 ? (c.push(f | m >> -h), h += 8, f = m << h & 255) : (c.push(f | m), h = 8, f = 0);
        }
      }), this.shift = h, this.carry = f, this;
    }, y.prototype.finalize = function(o) {
      return o && this.write(o), this.shift !== 8 && this.carry !== 0 && (this.buf.push(this.carry), this.shift = 8, this.carry = 0), this.buf;
    };
    function t(o) {
      if (this.buf = "", this.shift = 3, this.carry = 0, o) {
        switch (o.type) {
          case "rfc4648":
            this.alphabet = v.rfc4648.alphabet;
            break;
          case "crockford":
            this.alphabet = v.crockford.alphabet;
            break;
          case "base32hex":
            this.alphabet = v.base32hex.alphabet;
            break;
          default:
            throw new Error("invalid type");
        }
        o.alphabet ? this.alphabet = o.alphabet : o.lc && (this.alphabet = this.alphabet.toLowerCase());
      }
    }
    t.prototype.alphabet = n.alphabet, t.prototype.write = function(o) {
      var u = this.shift, c = this.carry, h, f, r;
      for (r = 0; r < o.length; r++) f = o[r], h = c | f >> u, this.buf += this.alphabet[h & 31], u > 5 && (u -= 5, h = f >> u, this.buf += this.alphabet[h & 31]), u = 5 - u, c = f << u, u = 8 - u;
      return this.shift = u, this.carry = c, this;
    }, t.prototype.finalize = function(o) {
      return o && this.write(o), this.shift !== 3 && (this.buf += this.alphabet[this.carry & 31], this.shift = 3, this.carry = 0), this.buf;
    }, v.encode = function(o, u) {
      return new t(u).finalize(o);
    }, v.decode = function(o, u) {
      return new y(u).finalize(o);
    }, v.Decoder = y, v.Encoder = t, v.charmap = e, v.crockford = i, v.rfc4648 = n, v.base32hex = s;
  }(Kc)), Kc;
}
var Qs = {}, tp;
function Dy() {
  if (tp) return Qs;
  tp = 1, Object.defineProperty(Qs, "__esModule", { value: true }), Qs.verifyChecksum = v;
  function v(e, n) {
    if (e.length !== n.length) return false;
    if (e.length === 0) return true;
    for (var i = 0; i < e.length; i += 1) if (e[i] !== n[i]) return false;
    return true;
  }
  return Qs;
}
var rp;
function ni() {
  if (rp) return Vo;
  rp = 1, Object.defineProperty(Vo, "__esModule", { value: true }), Vo.StrKey = void 0, Vo.decodeCheck = r, Vo.encodeCheck = m;
  var v = n(Ny()), e = Dy();
  function n(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function i(a) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, i(a);
  }
  function s(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function y(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, o(b.key), b);
    }
  }
  function t(a, l, d) {
    return d && y(a, d), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function o(a) {
    var l = u(a, "string");
    return i(l) == "symbol" ? l : l + "";
  }
  function u(a, l) {
    if (i(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (i(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  var c = { ed25519PublicKey: 48, ed25519SecretSeed: 144, med25519PublicKey: 96, preAuthTx: 152, sha256Hash: 184, signedPayload: 120, contract: 16 }, h = { G: "ed25519PublicKey", S: "ed25519SecretSeed", M: "med25519PublicKey", T: "preAuthTx", X: "sha256Hash", P: "signedPayload", C: "contract" };
  Vo.StrKey = function() {
    function a() {
      s(this, a);
    }
    return t(a, null, [{ key: "encodeEd25519PublicKey", value: function(d) {
      return m("ed25519PublicKey", d);
    } }, { key: "decodeEd25519PublicKey", value: function(d) {
      return r("ed25519PublicKey", d);
    } }, { key: "isValidEd25519PublicKey", value: function(d) {
      return f("ed25519PublicKey", d);
    } }, { key: "encodeEd25519SecretSeed", value: function(d) {
      return m("ed25519SecretSeed", d);
    } }, { key: "decodeEd25519SecretSeed", value: function(d) {
      return r("ed25519SecretSeed", d);
    } }, { key: "isValidEd25519SecretSeed", value: function(d) {
      return f("ed25519SecretSeed", d);
    } }, { key: "encodeMed25519PublicKey", value: function(d) {
      return m("med25519PublicKey", d);
    } }, { key: "decodeMed25519PublicKey", value: function(d) {
      return r("med25519PublicKey", d);
    } }, { key: "isValidMed25519PublicKey", value: function(d) {
      return f("med25519PublicKey", d);
    } }, { key: "encodePreAuthTx", value: function(d) {
      return m("preAuthTx", d);
    } }, { key: "decodePreAuthTx", value: function(d) {
      return r("preAuthTx", d);
    } }, { key: "encodeSha256Hash", value: function(d) {
      return m("sha256Hash", d);
    } }, { key: "decodeSha256Hash", value: function(d) {
      return r("sha256Hash", d);
    } }, { key: "encodeSignedPayload", value: function(d) {
      return m("signedPayload", d);
    } }, { key: "decodeSignedPayload", value: function(d) {
      return r("signedPayload", d);
    } }, { key: "isValidSignedPayload", value: function(d) {
      return f("signedPayload", d);
    } }, { key: "encodeContract", value: function(d) {
      return m("contract", d);
    } }, { key: "decodeContract", value: function(d) {
      return r("contract", d);
    } }, { key: "isValidContract", value: function(d) {
      return f("contract", d);
    } }, { key: "getVersionByteForPrefix", value: function(d) {
      return h[d[0]];
    } }]);
  }();
  function f(a, l) {
    if (typeof l != "string") return false;
    switch (a) {
      case "ed25519PublicKey":
      case "ed25519SecretSeed":
      case "preAuthTx":
      case "sha256Hash":
      case "contract":
        if (l.length !== 56) return false;
        break;
      case "med25519PublicKey":
        if (l.length !== 69) return false;
        break;
      case "signedPayload":
        if (l.length < 56 || l.length > 165) return false;
        break;
      default:
        return false;
    }
    var d = "";
    try {
      d = r(a, l);
    } catch {
      return false;
    }
    switch (a) {
      case "ed25519PublicKey":
      case "ed25519SecretSeed":
      case "preAuthTx":
      case "sha256Hash":
      case "contract":
        return d.length === 32;
      case "med25519PublicKey":
        return d.length === 40;
      case "signedPayload":
        return d.length >= 40 && d.length <= 100;
      default:
        return false;
    }
  }
  function r(a, l) {
    if (typeof l != "string") throw new TypeError("encoded argument must be of type String");
    var d = v.default.decode(l), b = d[0], S = d.slice(0, -2), E = S.slice(1), R = d.slice(-2);
    if (l !== v.default.encode(d)) throw new Error("invalid encoded string");
    var k = c[a];
    if (k === void 0) throw new Error("".concat(a, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(c).join(", ")));
    if (b !== k) throw new Error("invalid version byte. expected ".concat(k, ", got ").concat(b));
    var w = g(S);
    if (!(0, e.verifyChecksum)(w, R)) throw new Error("invalid checksum");
    return Buffer.from(E);
  }
  function m(a, l) {
    if (l == null) throw new Error("cannot encode null data");
    var d = c[a];
    if (d === void 0) throw new Error("".concat(a, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(c).join(", ")));
    l = Buffer.from(l);
    var b = Buffer.from([d]), S = Buffer.concat([b, l]), E = Buffer.from(g(S)), R = Buffer.concat([S, E]);
    return v.default.encode(R);
  }
  function g(a) {
    for (var l = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920], d = 0, b = 0; b < a.length; b += 1) {
      var S = a[b], E = d >> 8 ^ S;
      d = d << 8 ^ l[E], d &= 65535;
    }
    var R = new Uint8Array(2);
    return R[0] = d & 255, R[1] = d >> 8 & 255, R;
  }
  return Vo;
}
var np;
function Ii() {
  if (np) return Ga;
  np = 1, Object.defineProperty(Ga, "__esModule", { value: true }), Ga.Keypair = void 0;
  var v = y(em()), e = tm(), n = ni(), i = Uo(), s = y(bn());
  function y(r) {
    return r && r.__esModule ? r : { default: r };
  }
  function t(r) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, t(r);
  }
  function o(r, m) {
    if (!(r instanceof m)) throw new TypeError("Cannot call a class as a function");
  }
  function u(r, m) {
    for (var g = 0; g < m.length; g++) {
      var a = m[g];
      a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(r, h(a.key), a);
    }
  }
  function c(r, m, g) {
    return m && u(r.prototype, m), g && u(r, g), Object.defineProperty(r, "prototype", { writable: false }), r;
  }
  function h(r) {
    var m = f(r, "string");
    return t(m) == "symbol" ? m : m + "";
  }
  function f(r, m) {
    if (t(r) != "object" || !r) return r;
    var g = r[Symbol.toPrimitive];
    if (g !== void 0) {
      var a = g.call(r, m);
      if (t(a) != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(r);
  }
  return Ga.Keypair = function() {
    function r(m) {
      if (o(this, r), m.type !== "ed25519") throw new Error("Invalid keys type");
      if (this.type = m.type, m.secretKey) {
        if (m.secretKey = Buffer.from(m.secretKey), m.secretKey.length !== 32) throw new Error("secretKey length is invalid");
        if (this._secretSeed = m.secretKey, this._publicKey = (0, e.generate)(m.secretKey), this._secretKey = Buffer.concat([m.secretKey, this._publicKey]), m.publicKey && !this._publicKey.equals(Buffer.from(m.publicKey))) throw new Error("secretKey does not match publicKey");
      } else if (this._publicKey = Buffer.from(m.publicKey), this._publicKey.length !== 32) throw new Error("publicKey length is invalid");
    }
    return c(r, [{ key: "xdrAccountId", value: function() {
      return new s.default.AccountId.publicKeyTypeEd25519(this._publicKey);
    } }, { key: "xdrPublicKey", value: function() {
      return new s.default.PublicKey.publicKeyTypeEd25519(this._publicKey);
    } }, { key: "xdrMuxedAccount", value: function(g) {
      if (typeof g < "u") {
        if (typeof g != "string") throw new TypeError("expected string for ID, got ".concat(t(g)));
        return s.default.MuxedAccount.keyTypeMuxedEd25519(new s.default.MuxedAccountMed25519({ id: s.default.Uint64.fromString(g), ed25519: this._publicKey }));
      }
      return new s.default.MuxedAccount.keyTypeEd25519(this._publicKey);
    } }, { key: "rawPublicKey", value: function() {
      return this._publicKey;
    } }, { key: "signatureHint", value: function() {
      var g = this.xdrAccountId().toXDR();
      return g.slice(g.length - 4);
    } }, { key: "publicKey", value: function() {
      return n.StrKey.encodeEd25519PublicKey(this._publicKey);
    } }, { key: "secret", value: function() {
      if (!this._secretSeed) throw new Error("no secret key available");
      if (this.type === "ed25519") return n.StrKey.encodeEd25519SecretSeed(this._secretSeed);
      throw new Error("Invalid Keypair type");
    } }, { key: "rawSecretKey", value: function() {
      return this._secretSeed;
    } }, { key: "canSign", value: function() {
      return !!this._secretKey;
    } }, { key: "sign", value: function(g) {
      if (!this.canSign()) throw new Error("cannot sign: no secret key available");
      return (0, e.sign)(g, this._secretKey);
    } }, { key: "verify", value: function(g, a) {
      return (0, e.verify)(g, a, this._publicKey);
    } }, { key: "signDecorated", value: function(g) {
      var a = this.sign(g), l = this.signatureHint();
      return new s.default.DecoratedSignature({ hint: l, signature: a });
    } }, { key: "signPayloadDecorated", value: function(g) {
      var a = this.sign(g), l = this.signatureHint(), d = Buffer.from(g.slice(-4));
      return d.length < 4 && (d = Buffer.concat([d, Buffer.alloc(4 - g.length, 0)])), new s.default.DecoratedSignature({ hint: d.map(function(b, S) {
        return b ^ l[S];
      }), signature: a });
    } }], [{ key: "fromSecret", value: function(g) {
      var a = n.StrKey.decodeEd25519SecretSeed(g);
      return this.fromRawEd25519Seed(a);
    } }, { key: "fromRawEd25519Seed", value: function(g) {
      return new this({ type: "ed25519", secretKey: g });
    } }, { key: "master", value: function(g) {
      if (!g) throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
      return this.fromRawEd25519Seed((0, i.hash)(g));
    } }, { key: "fromPublicKey", value: function(g) {
      if (g = n.StrKey.decodeEd25519PublicKey(g), g.length !== 32) throw new Error("Invalid Stellar public key");
      return new this({ type: "ed25519", publicKey: g });
    } }, { key: "random", value: function() {
      var g = v.default.randomBytes(32);
      return this.fromRawEd25519Seed(g);
    } }]);
  }(), Ga;
}
var ip;
function To() {
  if (ip) return za;
  ip = 1, Object.defineProperty(za, "__esModule", { value: true }), za.Asset = void 0;
  var v = rm(), e = y(bn()), n = Ii(), i = ni(), s = Uo();
  function y(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function t(m) {
    "@babel/helpers - typeof";
    return t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
      return typeof g;
    } : function(g) {
      return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
    }, t(m);
  }
  function o(m, g) {
    if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
  }
  function u(m, g) {
    for (var a = 0; a < g.length; a++) {
      var l = g[a];
      l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(m, h(l.key), l);
    }
  }
  function c(m, g, a) {
    return g && u(m.prototype, g), a && u(m, a), Object.defineProperty(m, "prototype", { writable: false }), m;
  }
  function h(m) {
    var g = f(m, "string");
    return t(g) == "symbol" ? g : g + "";
  }
  function f(m, g) {
    if (t(m) != "object" || !m) return m;
    var a = m[Symbol.toPrimitive];
    if (a !== void 0) {
      var l = a.call(m, g);
      if (t(l) != "object") return l;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(m);
  }
  za.Asset = function() {
    function m(g, a) {
      if (o(this, m), !/^[a-zA-Z0-9]{1,12}$/.test(g)) throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
      if (String(g).toLowerCase() !== "xlm" && !a) throw new Error("Issuer cannot be null");
      if (a && !i.StrKey.isValidEd25519PublicKey(a)) throw new Error("Issuer is invalid");
      String(g).toLowerCase() === "xlm" ? this.code = "XLM" : this.code = g, this.issuer = a;
    }
    return c(m, [{ key: "toXDRObject", value: function() {
      return this._toXDRObject(e.default.Asset);
    } }, { key: "toChangeTrustXDRObject", value: function() {
      return this._toXDRObject(e.default.ChangeTrustAsset);
    } }, { key: "toTrustLineXDRObject", value: function() {
      return this._toXDRObject(e.default.TrustLineAsset);
    } }, { key: "contractId", value: function(a) {
      var l = (0, s.hash)(Buffer.from(a)), d = e.default.HashIdPreimage.envelopeTypeContractId(new e.default.HashIdPreimageContractId({ networkId: l, contractIdPreimage: e.default.ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject()) }));
      return i.StrKey.encodeContract((0, s.hash)(d.toXDR()));
    } }, { key: "_toXDRObject", value: function() {
      var a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.default.Asset;
      if (this.isNative()) return a.assetTypeNative();
      var l, d;
      this.code.length <= 4 ? (l = e.default.AlphaNum4, d = "assetTypeCreditAlphanum4") : (l = e.default.AlphaNum12, d = "assetTypeCreditAlphanum12");
      var b = this.code.length <= 4 ? 4 : 12, S = this.code.padEnd(b, "\0"), E = new l({ assetCode: S, issuer: n.Keypair.fromPublicKey(this.issuer).xdrAccountId() });
      return new a(d, E);
    } }, { key: "getCode", value: function() {
      if (this.code !== void 0) return String(this.code);
    } }, { key: "getIssuer", value: function() {
      if (this.issuer !== void 0) return String(this.issuer);
    } }, { key: "getAssetType", value: function() {
      switch (this.getRawAssetType().value) {
        case e.default.AssetType.assetTypeNative().value:
          return "native";
        case e.default.AssetType.assetTypeCreditAlphanum4().value:
          return "credit_alphanum4";
        case e.default.AssetType.assetTypeCreditAlphanum12().value:
          return "credit_alphanum12";
        default:
          return "unknown";
      }
    } }, { key: "getRawAssetType", value: function() {
      return this.isNative() ? e.default.AssetType.assetTypeNative() : this.code.length <= 4 ? e.default.AssetType.assetTypeCreditAlphanum4() : e.default.AssetType.assetTypeCreditAlphanum12();
    } }, { key: "isNative", value: function() {
      return !this.issuer;
    } }, { key: "equals", value: function(a) {
      return this.code === a.getCode() && this.issuer === a.getIssuer();
    } }, { key: "toString", value: function() {
      return this.isNative() ? "native" : "".concat(this.getCode(), ":").concat(this.getIssuer());
    } }], [{ key: "native", value: function() {
      return new m("XLM");
    } }, { key: "fromOperation", value: function(a) {
      var l, d, b;
      switch (a.switch()) {
        case e.default.AssetType.assetTypeNative():
          return this.native();
        case e.default.AssetType.assetTypeCreditAlphanum4():
          l = a.alphaNum4();
        case e.default.AssetType.assetTypeCreditAlphanum12():
          return l = l || a.alphaNum12(), b = i.StrKey.encodeEd25519PublicKey(l.issuer().ed25519()), d = (0, v.trimEnd)(l.assetCode(), "\0"), new this(d, b);
        default:
          throw new Error("Invalid asset type: ".concat(a.switch().name));
      }
    } }, { key: "compare", value: function(a, l) {
      if (!a || !(a instanceof m)) throw new Error("assetA is invalid");
      if (!l || !(l instanceof m)) throw new Error("assetB is invalid");
      if (a.equals(l)) return 0;
      var d = a.getRawAssetType().value, b = l.getRawAssetType().value;
      if (d !== b) return d < b ? -1 : 1;
      var S = r(a.getCode(), l.getCode());
      return S !== 0 ? S : r(a.getIssuer(), l.getIssuer());
    } }]);
  }();
  function r(m, g) {
    return Buffer.compare(Buffer.from(m, "ascii"), Buffer.from(g, "ascii"));
  }
  return za;
}
var op;
function nm() {
  if (op) return fa;
  op = 1, Object.defineProperty(fa, "__esModule", { value: true }), fa.LiquidityPoolFeeV18 = void 0, fa.getLiquidityPoolId = y;
  var v = i(bn()), e = To(), n = Uo();
  function i(t) {
    return t && t.__esModule ? t : { default: t };
  }
  var s = fa.LiquidityPoolFeeV18 = 30;
  function y(t) {
    var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (t !== "constant_product") throw new Error("liquidityPoolType is invalid");
    var u = o.assetA, c = o.assetB, h = o.fee;
    if (!u || !(u instanceof e.Asset)) throw new Error("assetA is invalid");
    if (!c || !(c instanceof e.Asset)) throw new Error("assetB is invalid");
    if (!h || h !== s) throw new Error("fee is invalid");
    if (e.Asset.compare(u, c) !== -1) throw new Error("Assets are not in lexicographic order");
    var f = v.default.LiquidityPoolType.liquidityPoolConstantProduct().toXDR(), r = new v.default.LiquidityPoolConstantProductParameters({ assetA: u.toXDRObject(), assetB: c.toXDRObject(), fee: h }).toXDR(), m = Buffer.concat([f, r]);
    return (0, n.hash)(m);
  }
  return fa;
}
var Wa = {}, ap;
function Yl() {
  if (ap) return Wa;
  ap = 1, Object.defineProperty(Wa, "__esModule", { value: true }), Wa.TransactionBase = void 0;
  var v = i(bn()), e = Uo(), n = Ii();
  function i(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function s(h) {
    "@babel/helpers - typeof";
    return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
      return typeof f;
    } : function(f) {
      return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
    }, s(h);
  }
  function y(h, f) {
    if (!(h instanceof f)) throw new TypeError("Cannot call a class as a function");
  }
  function t(h, f) {
    for (var r = 0; r < f.length; r++) {
      var m = f[r];
      m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(h, u(m.key), m);
    }
  }
  function o(h, f, r) {
    return f && t(h.prototype, f), Object.defineProperty(h, "prototype", { writable: false }), h;
  }
  function u(h) {
    var f = c(h, "string");
    return s(f) == "symbol" ? f : f + "";
  }
  function c(h, f) {
    if (s(h) != "object" || !h) return h;
    var r = h[Symbol.toPrimitive];
    if (r !== void 0) {
      var m = r.call(h, f);
      if (s(m) != "object") return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(h);
  }
  return Wa.TransactionBase = function() {
    function h(f, r, m, g) {
      if (y(this, h), typeof g != "string") throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(s(g)));
      this._networkPassphrase = g, this._tx = f, this._signatures = r, this._fee = m;
    }
    return o(h, [{ key: "signatures", get: function() {
      return this._signatures;
    }, set: function(r) {
      throw new Error("Transaction is immutable");
    } }, { key: "tx", get: function() {
      return this._tx;
    }, set: function(r) {
      throw new Error("Transaction is immutable");
    } }, { key: "fee", get: function() {
      return this._fee;
    }, set: function(r) {
      throw new Error("Transaction is immutable");
    } }, { key: "networkPassphrase", get: function() {
      return this._networkPassphrase;
    }, set: function(r) {
      this._networkPassphrase = r;
    } }, { key: "sign", value: function() {
      for (var r = this, m = this.hash(), g = arguments.length, a = new Array(g), l = 0; l < g; l++) a[l] = arguments[l];
      a.forEach(function(d) {
        var b = d.signDecorated(m);
        r.signatures.push(b);
      });
    } }, { key: "getKeypairSignature", value: function(r) {
      return r.sign(this.hash()).toString("base64");
    } }, { key: "addSignature", value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (!m || typeof m != "string") throw new Error("Invalid signature");
      if (!r || typeof r != "string") throw new Error("Invalid publicKey");
      var g, a, l = Buffer.from(m, "base64");
      try {
        g = n.Keypair.fromPublicKey(r), a = g.signatureHint();
      } catch {
        throw new Error("Invalid publicKey");
      }
      if (!g.verify(this.hash(), l)) throw new Error("Invalid signature");
      this.signatures.push(new v.default.DecoratedSignature({ hint: a, signature: l }));
    } }, { key: "addDecoratedSignature", value: function(r) {
      this.signatures.push(r);
    } }, { key: "signHashX", value: function(r) {
      if (typeof r == "string" && (r = Buffer.from(r, "hex")), r.length > 64) throw new Error("preimage cannnot be longer than 64 bytes");
      var m = r, g = (0, e.hash)(r), a = g.slice(g.length - 4);
      this.signatures.push(new v.default.DecoratedSignature({ hint: a, signature: m }));
    } }, { key: "hash", value: function() {
      return (0, e.hash)(this.signatureBase());
    } }, { key: "signatureBase", value: function() {
      throw new Error("Implement in subclass");
    } }, { key: "toEnvelope", value: function() {
      throw new Error("Implement in subclass");
    } }, { key: "toXDR", value: function() {
      return this.toEnvelope().toXDR().toString("base64");
    } }]);
  }(), Wa;
}
var Ka = {}, ki = {}, Xc = {}, uc = { exports: {} }, Fy = uc.exports, sp;
function Uy() {
  return sp || (sp = 1, function(v) {
    (function(e) {
      var n, i = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, s = Math.ceil, y = Math.floor, t = "[BigNumber Error] ", o = t + "Number primitive has more than 15 significant digits: ", u = 1e14, c = 14, h = 9007199254740991, f = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], r = 1e7, m = 1e9;
      function g(k) {
        var w, F, I, q = Z.prototype = { constructor: Z, toString: null, valueOf: null }, D = new Z(1), H = 20, _ = 4, T = -7, L = 21, j = -1e7, z = 1e7, Y = false, te = 1, G = 0, K = { prefix: "", groupSize: 3, secondaryGroupSize: 0, groupSeparator: ",", decimalSeparator: ".", fractionGroupSize: 0, fractionGroupSeparator: "\xA0", suffix: "" }, J = "0123456789abcdefghijklmnopqrstuvwxyz", B = true;
        function Z(ae, ue) {
          var ne, ge, Te, pe, Oe, xe, Ve, _e, Be = this;
          if (!(Be instanceof Z)) return new Z(ae, ue);
          if (ue == null) {
            if (ae && ae._isBigNumber === true) {
              Be.s = ae.s, !ae.c || ae.e > z ? Be.c = Be.e = null : ae.e < j ? Be.c = [Be.e = 0] : (Be.e = ae.e, Be.c = ae.c.slice());
              return;
            }
            if ((xe = typeof ae == "number") && ae * 0 == 0) {
              if (Be.s = 1 / ae < 0 ? (ae = -ae, -1) : 1, ae === ~~ae) {
                for (pe = 0, Oe = ae; Oe >= 10; Oe /= 10, pe++) ;
                pe > z ? Be.c = Be.e = null : (Be.e = pe, Be.c = [ae]);
                return;
              }
              _e = String(ae);
            } else {
              if (!i.test(_e = String(ae))) return I(Be, _e, xe);
              Be.s = _e.charCodeAt(0) == 45 ? (_e = _e.slice(1), -1) : 1;
            }
            (pe = _e.indexOf(".")) > -1 && (_e = _e.replace(".", "")), (Oe = _e.search(/e/i)) > 0 ? (pe < 0 && (pe = Oe), pe += +_e.slice(Oe + 1), _e = _e.substring(0, Oe)) : pe < 0 && (pe = _e.length);
          } else {
            if (b(ue, 2, J.length, "Base"), ue == 10 && B) return Be = new Z(ae), ce(Be, H + Be.e + 1, _);
            if (_e = String(ae), xe = typeof ae == "number") {
              if (ae * 0 != 0) return I(Be, _e, xe, ue);
              if (Be.s = 1 / ae < 0 ? (_e = _e.slice(1), -1) : 1, Z.DEBUG && _e.replace(/^0\.0*|\./, "").length > 15) throw Error(o + ae);
            } else Be.s = _e.charCodeAt(0) === 45 ? (_e = _e.slice(1), -1) : 1;
            for (ne = J.slice(0, ue), pe = Oe = 0, Ve = _e.length; Oe < Ve; Oe++) if (ne.indexOf(ge = _e.charAt(Oe)) < 0) {
              if (ge == ".") {
                if (Oe > pe) {
                  pe = Ve;
                  continue;
                }
              } else if (!Te && (_e == _e.toUpperCase() && (_e = _e.toLowerCase()) || _e == _e.toLowerCase() && (_e = _e.toUpperCase()))) {
                Te = true, Oe = -1, pe = 0;
                continue;
              }
              return I(Be, String(ae), xe, ue);
            }
            xe = false, _e = F(_e, ue, 10, Be.s), (pe = _e.indexOf(".")) > -1 ? _e = _e.replace(".", "") : pe = _e.length;
          }
          for (Oe = 0; _e.charCodeAt(Oe) === 48; Oe++) ;
          for (Ve = _e.length; _e.charCodeAt(--Ve) === 48; ) ;
          if (_e = _e.slice(Oe, ++Ve)) {
            if (Ve -= Oe, xe && Z.DEBUG && Ve > 15 && (ae > h || ae !== y(ae))) throw Error(o + Be.s * ae);
            if ((pe = pe - Oe - 1) > z) Be.c = Be.e = null;
            else if (pe < j) Be.c = [Be.e = 0];
            else {
              if (Be.e = pe, Be.c = [], Oe = (pe + 1) % c, pe < 0 && (Oe += c), Oe < Ve) {
                for (Oe && Be.c.push(+_e.slice(0, Oe)), Ve -= c; Oe < Ve; ) Be.c.push(+_e.slice(Oe, Oe += c));
                Oe = c - (_e = _e.slice(Oe)).length;
              } else Oe -= Ve;
              for (; Oe--; _e += "0") ;
              Be.c.push(+_e);
            }
          } else Be.c = [Be.e = 0];
        }
        Z.clone = g, Z.ROUND_UP = 0, Z.ROUND_DOWN = 1, Z.ROUND_CEIL = 2, Z.ROUND_FLOOR = 3, Z.ROUND_HALF_UP = 4, Z.ROUND_HALF_DOWN = 5, Z.ROUND_HALF_EVEN = 6, Z.ROUND_HALF_CEIL = 7, Z.ROUND_HALF_FLOOR = 8, Z.EUCLID = 9, Z.config = Z.set = function(ae) {
          var ue, ne;
          if (ae != null) if (typeof ae == "object") {
            if (ae.hasOwnProperty(ue = "DECIMAL_PLACES") && (ne = ae[ue], b(ne, 0, m, ue), H = ne), ae.hasOwnProperty(ue = "ROUNDING_MODE") && (ne = ae[ue], b(ne, 0, 8, ue), _ = ne), ae.hasOwnProperty(ue = "EXPONENTIAL_AT") && (ne = ae[ue], ne && ne.pop ? (b(ne[0], -1e9, 0, ue), b(ne[1], 0, m, ue), T = ne[0], L = ne[1]) : (b(ne, -1e9, m, ue), T = -(L = ne < 0 ? -ne : ne))), ae.hasOwnProperty(ue = "RANGE")) if (ne = ae[ue], ne && ne.pop) b(ne[0], -1e9, -1, ue), b(ne[1], 1, m, ue), j = ne[0], z = ne[1];
            else if (b(ne, -1e9, m, ue), ne) j = -(z = ne < 0 ? -ne : ne);
            else throw Error(t + ue + " cannot be zero: " + ne);
            if (ae.hasOwnProperty(ue = "CRYPTO")) if (ne = ae[ue], ne === !!ne) if (ne) if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes)) Y = ne;
            else throw Y = !ne, Error(t + "crypto unavailable");
            else Y = ne;
            else throw Error(t + ue + " not true or false: " + ne);
            if (ae.hasOwnProperty(ue = "MODULO_MODE") && (ne = ae[ue], b(ne, 0, 9, ue), te = ne), ae.hasOwnProperty(ue = "POW_PRECISION") && (ne = ae[ue], b(ne, 0, m, ue), G = ne), ae.hasOwnProperty(ue = "FORMAT")) if (ne = ae[ue], typeof ne == "object") K = ne;
            else throw Error(t + ue + " not an object: " + ne);
            if (ae.hasOwnProperty(ue = "ALPHABET")) if (ne = ae[ue], typeof ne == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(ne)) B = ne.slice(0, 10) == "0123456789", J = ne;
            else throw Error(t + ue + " invalid: " + ne);
          } else throw Error(t + "Object expected: " + ae);
          return { DECIMAL_PLACES: H, ROUNDING_MODE: _, EXPONENTIAL_AT: [T, L], RANGE: [j, z], CRYPTO: Y, MODULO_MODE: te, POW_PRECISION: G, FORMAT: K, ALPHABET: J };
        }, Z.isBigNumber = function(ae) {
          if (!ae || ae._isBigNumber !== true) return false;
          if (!Z.DEBUG) return true;
          var ue, ne, ge = ae.c, Te = ae.e, pe = ae.s;
          e: if ({}.toString.call(ge) == "[object Array]") {
            if ((pe === 1 || pe === -1) && Te >= -1e9 && Te <= m && Te === y(Te)) {
              if (ge[0] === 0) {
                if (Te === 0 && ge.length === 1) return true;
                break e;
              }
              if (ue = (Te + 1) % c, ue < 1 && (ue += c), String(ge[0]).length == ue) {
                for (ue = 0; ue < ge.length; ue++) if (ne = ge[ue], ne < 0 || ne >= u || ne !== y(ne)) break e;
                if (ne !== 0) return true;
              }
            }
          } else if (ge === null && Te === null && (pe === null || pe === 1 || pe === -1)) return true;
          throw Error(t + "Invalid BigNumber: " + ae);
        }, Z.maximum = Z.max = function() {
          return $(arguments, -1);
        }, Z.minimum = Z.min = function() {
          return $(arguments, 1);
        }, Z.random = function() {
          var ae = 9007199254740992, ue = Math.random() * ae & 2097151 ? function() {
            return y(Math.random() * ae);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(ne) {
            var ge, Te, pe, Oe, xe, Ve = 0, _e = [], Be = new Z(D);
            if (ne == null ? ne = H : b(ne, 0, m), Oe = s(ne / c), Y) if (crypto.getRandomValues) {
              for (ge = crypto.getRandomValues(new Uint32Array(Oe *= 2)); Ve < Oe; ) xe = ge[Ve] * 131072 + (ge[Ve + 1] >>> 11), xe >= 9e15 ? (Te = crypto.getRandomValues(new Uint32Array(2)), ge[Ve] = Te[0], ge[Ve + 1] = Te[1]) : (_e.push(xe % 1e14), Ve += 2);
              Ve = Oe / 2;
            } else if (crypto.randomBytes) {
              for (ge = crypto.randomBytes(Oe *= 7); Ve < Oe; ) xe = (ge[Ve] & 31) * 281474976710656 + ge[Ve + 1] * 1099511627776 + ge[Ve + 2] * 4294967296 + ge[Ve + 3] * 16777216 + (ge[Ve + 4] << 16) + (ge[Ve + 5] << 8) + ge[Ve + 6], xe >= 9e15 ? crypto.randomBytes(7).copy(ge, Ve) : (_e.push(xe % 1e14), Ve += 7);
              Ve = Oe / 7;
            } else throw Y = false, Error(t + "crypto unavailable");
            if (!Y) for (; Ve < Oe; ) xe = ue(), xe < 9e15 && (_e[Ve++] = xe % 1e14);
            for (Oe = _e[--Ve], ne %= c, Oe && ne && (xe = f[c - ne], _e[Ve] = y(Oe / xe) * xe); _e[Ve] === 0; _e.pop(), Ve--) ;
            if (Ve < 0) _e = [pe = 0];
            else {
              for (pe = -1; _e[0] === 0; _e.splice(0, 1), pe -= c) ;
              for (Ve = 1, xe = _e[0]; xe >= 10; xe /= 10, Ve++) ;
              Ve < c && (pe -= c - Ve);
            }
            return Be.e = pe, Be.c = _e, Be;
          };
        }(), Z.sum = function() {
          for (var ae = 1, ue = arguments, ne = new Z(ue[0]); ae < ue.length; ) ne = ne.plus(ue[ae++]);
          return ne;
        }, F = /* @__PURE__ */ function() {
          var ae = "0123456789";
          function ue(ne, ge, Te, pe) {
            for (var Oe, xe = [0], Ve, _e = 0, Be = ne.length; _e < Be; ) {
              for (Ve = xe.length; Ve--; xe[Ve] *= ge) ;
              for (xe[0] += pe.indexOf(ne.charAt(_e++)), Oe = 0; Oe < xe.length; Oe++) xe[Oe] > Te - 1 && (xe[Oe + 1] == null && (xe[Oe + 1] = 0), xe[Oe + 1] += xe[Oe] / Te | 0, xe[Oe] %= Te);
            }
            return xe.reverse();
          }
          return function(ne, ge, Te, pe, Oe) {
            var xe, Ve, _e, Be, Qe, ee, P, x, O = ne.indexOf("."), V = H, N = _;
            for (O >= 0 && (Be = G, G = 0, ne = ne.replace(".", ""), x = new Z(ge), ee = x.pow(ne.length - O), G = Be, x.c = ue(R(l(ee.c), ee.e, "0"), 10, Te, ae), x.e = x.c.length), P = ue(ne, ge, Te, Oe ? (xe = J, ae) : (xe = ae, J)), _e = Be = P.length; P[--Be] == 0; P.pop()) ;
            if (!P[0]) return xe.charAt(0);
            if (O < 0 ? --_e : (ee.c = P, ee.e = _e, ee.s = pe, ee = w(ee, x, V, N, Te), P = ee.c, Qe = ee.r, _e = ee.e), Ve = _e + V + 1, O = P[Ve], Be = Te / 2, Qe = Qe || Ve < 0 || P[Ve + 1] != null, Qe = N < 4 ? (O != null || Qe) && (N == 0 || N == (ee.s < 0 ? 3 : 2)) : O > Be || O == Be && (N == 4 || Qe || N == 6 && P[Ve - 1] & 1 || N == (ee.s < 0 ? 8 : 7)), Ve < 1 || !P[0]) ne = Qe ? R(xe.charAt(1), -V, xe.charAt(0)) : xe.charAt(0);
            else {
              if (P.length = Ve, Qe) for (--Te; ++P[--Ve] > Te; ) P[Ve] = 0, Ve || (++_e, P = [1].concat(P));
              for (Be = P.length; !P[--Be]; ) ;
              for (O = 0, ne = ""; O <= Be; ne += xe.charAt(P[O++])) ;
              ne = R(ne, _e, xe.charAt(0));
            }
            return ne;
          };
        }(), w = /* @__PURE__ */ function() {
          function ae(ge, Te, pe) {
            var Oe, xe, Ve, _e, Be = 0, Qe = ge.length, ee = Te % r, P = Te / r | 0;
            for (ge = ge.slice(); Qe--; ) Ve = ge[Qe] % r, _e = ge[Qe] / r | 0, Oe = P * Ve + _e * ee, xe = ee * Ve + Oe % r * r + Be, Be = (xe / pe | 0) + (Oe / r | 0) + P * _e, ge[Qe] = xe % pe;
            return Be && (ge = [Be].concat(ge)), ge;
          }
          function ue(ge, Te, pe, Oe) {
            var xe, Ve;
            if (pe != Oe) Ve = pe > Oe ? 1 : -1;
            else for (xe = Ve = 0; xe < pe; xe++) if (ge[xe] != Te[xe]) {
              Ve = ge[xe] > Te[xe] ? 1 : -1;
              break;
            }
            return Ve;
          }
          function ne(ge, Te, pe, Oe) {
            for (var xe = 0; pe--; ) ge[pe] -= xe, xe = ge[pe] < Te[pe] ? 1 : 0, ge[pe] = xe * Oe + ge[pe] - Te[pe];
            for (; !ge[0] && ge.length > 1; ge.splice(0, 1)) ;
          }
          return function(ge, Te, pe, Oe, xe) {
            var Ve, _e, Be, Qe, ee, P, x, O, V, N, C, p, A, U, Q, se, X, de = ge.s == Te.s ? 1 : -1, tt = ge.c, Ne = Te.c;
            if (!tt || !tt[0] || !Ne || !Ne[0]) return new Z(!ge.s || !Te.s || (tt ? Ne && tt[0] == Ne[0] : !Ne) ? NaN : tt && tt[0] == 0 || !Ne ? de * 0 : de / 0);
            for (O = new Z(de), V = O.c = [], _e = ge.e - Te.e, de = pe + _e + 1, xe || (xe = u, _e = a(ge.e / c) - a(Te.e / c), de = de / c | 0), Be = 0; Ne[Be] == (tt[Be] || 0); Be++) ;
            if (Ne[Be] > (tt[Be] || 0) && _e--, de < 0) V.push(1), Qe = true;
            else {
              for (U = tt.length, se = Ne.length, Be = 0, de += 2, ee = y(xe / (Ne[0] + 1)), ee > 1 && (Ne = ae(Ne, ee, xe), tt = ae(tt, ee, xe), se = Ne.length, U = tt.length), A = se, N = tt.slice(0, se), C = N.length; C < se; N[C++] = 0) ;
              X = Ne.slice(), X = [0].concat(X), Q = Ne[0], Ne[1] >= xe / 2 && Q++;
              do {
                if (ee = 0, Ve = ue(Ne, N, se, C), Ve < 0) {
                  if (p = N[0], se != C && (p = p * xe + (N[1] || 0)), ee = y(p / Q), ee > 1) for (ee >= xe && (ee = xe - 1), P = ae(Ne, ee, xe), x = P.length, C = N.length; ue(P, N, x, C) == 1; ) ee--, ne(P, se < x ? X : Ne, x, xe), x = P.length, Ve = 1;
                  else ee == 0 && (Ve = ee = 1), P = Ne.slice(), x = P.length;
                  if (x < C && (P = [0].concat(P)), ne(N, P, C, xe), C = N.length, Ve == -1) for (; ue(Ne, N, se, C) < 1; ) ee++, ne(N, se < C ? X : Ne, C, xe), C = N.length;
                } else Ve === 0 && (ee++, N = [0]);
                V[Be++] = ee, N[0] ? N[C++] = tt[A] || 0 : (N = [tt[A]], C = 1);
              } while ((A++ < U || N[0] != null) && de--);
              Qe = N[0] != null, V[0] || V.splice(0, 1);
            }
            if (xe == u) {
              for (Be = 1, de = V[0]; de >= 10; de /= 10, Be++) ;
              ce(O, pe + (O.e = Be + _e * c - 1) + 1, Oe, Qe);
            } else O.e = _e, O.r = +Qe;
            return O;
          };
        }();
        function ie(ae, ue, ne, ge) {
          var Te, pe, Oe, xe, Ve;
          if (ne == null ? ne = _ : b(ne, 0, 8), !ae.c) return ae.toString();
          if (Te = ae.c[0], Oe = ae.e, ue == null) Ve = l(ae.c), Ve = ge == 1 || ge == 2 && (Oe <= T || Oe >= L) ? E(Ve, Oe) : R(Ve, Oe, "0");
          else if (ae = ce(new Z(ae), ue, ne), pe = ae.e, Ve = l(ae.c), xe = Ve.length, ge == 1 || ge == 2 && (ue <= pe || pe <= T)) {
            for (; xe < ue; Ve += "0", xe++) ;
            Ve = E(Ve, pe);
          } else if (ue -= Oe, Ve = R(Ve, pe, "0"), pe + 1 > xe) {
            if (--ue > 0) for (Ve += "."; ue--; Ve += "0") ;
          } else if (ue += pe - xe, ue > 0) for (pe + 1 == xe && (Ve += "."); ue--; Ve += "0") ;
          return ae.s < 0 && Te ? "-" + Ve : Ve;
        }
        function $(ae, ue) {
          for (var ne, ge, Te = 1, pe = new Z(ae[0]); Te < ae.length; Te++) ge = new Z(ae[Te]), (!ge.s || (ne = d(pe, ge)) === ue || ne === 0 && pe.s === ue) && (pe = ge);
          return pe;
        }
        function oe(ae, ue, ne) {
          for (var ge = 1, Te = ue.length; !ue[--Te]; ue.pop()) ;
          for (Te = ue[0]; Te >= 10; Te /= 10, ge++) ;
          return (ne = ge + ne * c - 1) > z ? ae.c = ae.e = null : ne < j ? ae.c = [ae.e = 0] : (ae.e = ne, ae.c = ue), ae;
        }
        I = /* @__PURE__ */ function() {
          var ae = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ue = /^([^.]+)\.$/, ne = /^\.([^.]+)$/, ge = /^-?(Infinity|NaN)$/, Te = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(pe, Oe, xe, Ve) {
            var _e, Be = xe ? Oe : Oe.replace(Te, "");
            if (ge.test(Be)) pe.s = isNaN(Be) ? null : Be < 0 ? -1 : 1;
            else {
              if (!xe && (Be = Be.replace(ae, function(Qe, ee, P) {
                return _e = (P = P.toLowerCase()) == "x" ? 16 : P == "b" ? 2 : 8, !Ve || Ve == _e ? ee : Qe;
              }), Ve && (_e = Ve, Be = Be.replace(ue, "$1").replace(ne, "0.$1")), Oe != Be)) return new Z(Be, _e);
              if (Z.DEBUG) throw Error(t + "Not a" + (Ve ? " base " + Ve : "") + " number: " + Oe);
              pe.s = null;
            }
            pe.c = pe.e = null;
          };
        }();
        function ce(ae, ue, ne, ge) {
          var Te, pe, Oe, xe, Ve, _e, Be, Qe = ae.c, ee = f;
          if (Qe) {
            e: {
              for (Te = 1, xe = Qe[0]; xe >= 10; xe /= 10, Te++) ;
              if (pe = ue - Te, pe < 0) pe += c, Oe = ue, Ve = Qe[_e = 0], Be = y(Ve / ee[Te - Oe - 1] % 10);
              else if (_e = s((pe + 1) / c), _e >= Qe.length) if (ge) {
                for (; Qe.length <= _e; Qe.push(0)) ;
                Ve = Be = 0, Te = 1, pe %= c, Oe = pe - c + 1;
              } else break e;
              else {
                for (Ve = xe = Qe[_e], Te = 1; xe >= 10; xe /= 10, Te++) ;
                pe %= c, Oe = pe - c + Te, Be = Oe < 0 ? 0 : y(Ve / ee[Te - Oe - 1] % 10);
              }
              if (ge = ge || ue < 0 || Qe[_e + 1] != null || (Oe < 0 ? Ve : Ve % ee[Te - Oe - 1]), ge = ne < 4 ? (Be || ge) && (ne == 0 || ne == (ae.s < 0 ? 3 : 2)) : Be > 5 || Be == 5 && (ne == 4 || ge || ne == 6 && (pe > 0 ? Oe > 0 ? Ve / ee[Te - Oe] : 0 : Qe[_e - 1]) % 10 & 1 || ne == (ae.s < 0 ? 8 : 7)), ue < 1 || !Qe[0]) return Qe.length = 0, ge ? (ue -= ae.e + 1, Qe[0] = ee[(c - ue % c) % c], ae.e = -ue || 0) : Qe[0] = ae.e = 0, ae;
              if (pe == 0 ? (Qe.length = _e, xe = 1, _e--) : (Qe.length = _e + 1, xe = ee[c - pe], Qe[_e] = Oe > 0 ? y(Ve / ee[Te - Oe] % ee[Oe]) * xe : 0), ge) for (; ; ) if (_e == 0) {
                for (pe = 1, Oe = Qe[0]; Oe >= 10; Oe /= 10, pe++) ;
                for (Oe = Qe[0] += xe, xe = 1; Oe >= 10; Oe /= 10, xe++) ;
                pe != xe && (ae.e++, Qe[0] == u && (Qe[0] = 1));
                break;
              } else {
                if (Qe[_e] += xe, Qe[_e] != u) break;
                Qe[_e--] = 0, xe = 1;
              }
              for (pe = Qe.length; Qe[--pe] === 0; Qe.pop()) ;
            }
            ae.e > z ? ae.c = ae.e = null : ae.e < j && (ae.c = [ae.e = 0]);
          }
          return ae;
        }
        function ye(ae) {
          var ue, ne = ae.e;
          return ne === null ? ae.toString() : (ue = l(ae.c), ue = ne <= T || ne >= L ? E(ue, ne) : R(ue, ne, "0"), ae.s < 0 ? "-" + ue : ue);
        }
        return q.absoluteValue = q.abs = function() {
          var ae = new Z(this);
          return ae.s < 0 && (ae.s = 1), ae;
        }, q.comparedTo = function(ae, ue) {
          return d(this, new Z(ae, ue));
        }, q.decimalPlaces = q.dp = function(ae, ue) {
          var ne, ge, Te, pe = this;
          if (ae != null) return b(ae, 0, m), ue == null ? ue = _ : b(ue, 0, 8), ce(new Z(pe), ae + pe.e + 1, ue);
          if (!(ne = pe.c)) return null;
          if (ge = ((Te = ne.length - 1) - a(this.e / c)) * c, Te = ne[Te]) for (; Te % 10 == 0; Te /= 10, ge--) ;
          return ge < 0 && (ge = 0), ge;
        }, q.dividedBy = q.div = function(ae, ue) {
          return w(this, new Z(ae, ue), H, _);
        }, q.dividedToIntegerBy = q.idiv = function(ae, ue) {
          return w(this, new Z(ae, ue), 0, 1);
        }, q.exponentiatedBy = q.pow = function(ae, ue) {
          var ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe = this;
          if (ae = new Z(ae), ae.c && !ae.isInteger()) throw Error(t + "Exponent not an integer: " + ye(ae));
          if (ue != null && (ue = new Z(ue)), xe = ae.e > 14, !Qe.c || !Qe.c[0] || Qe.c[0] == 1 && !Qe.e && Qe.c.length == 1 || !ae.c || !ae.c[0]) return Be = new Z(Math.pow(+ye(Qe), xe ? ae.s * (2 - S(ae)) : +ye(ae))), ue ? Be.mod(ue) : Be;
          if (Ve = ae.s < 0, ue) {
            if (ue.c ? !ue.c[0] : !ue.s) return new Z(NaN);
            ge = !Ve && Qe.isInteger() && ue.isInteger(), ge && (Qe = Qe.mod(ue));
          } else {
            if (ae.e > 9 && (Qe.e > 0 || Qe.e < -1 || (Qe.e == 0 ? Qe.c[0] > 1 || xe && Qe.c[1] >= 24e7 : Qe.c[0] < 8e13 || xe && Qe.c[0] <= 9999975e7))) return pe = Qe.s < 0 && S(ae) ? -0 : 0, Qe.e > -1 && (pe = 1 / pe), new Z(Ve ? 1 / pe : pe);
            G && (pe = s(G / c + 2));
          }
          for (xe ? (ne = new Z(0.5), Ve && (ae.s = 1), _e = S(ae)) : (Te = Math.abs(+ye(ae)), _e = Te % 2), Be = new Z(D); ; ) {
            if (_e) {
              if (Be = Be.times(Qe), !Be.c) break;
              pe ? Be.c.length > pe && (Be.c.length = pe) : ge && (Be = Be.mod(ue));
            }
            if (Te) {
              if (Te = y(Te / 2), Te === 0) break;
              _e = Te % 2;
            } else if (ae = ae.times(ne), ce(ae, ae.e + 1, 1), ae.e > 14) _e = S(ae);
            else {
              if (Te = +ye(ae), Te === 0) break;
              _e = Te % 2;
            }
            Qe = Qe.times(Qe), pe ? Qe.c && Qe.c.length > pe && (Qe.c.length = pe) : ge && (Qe = Qe.mod(ue));
          }
          return ge ? Be : (Ve && (Be = D.div(Be)), ue ? Be.mod(ue) : pe ? ce(Be, G, _, Oe) : Be);
        }, q.integerValue = function(ae) {
          var ue = new Z(this);
          return ae == null ? ae = _ : b(ae, 0, 8), ce(ue, ue.e + 1, ae);
        }, q.isEqualTo = q.eq = function(ae, ue) {
          return d(this, new Z(ae, ue)) === 0;
        }, q.isFinite = function() {
          return !!this.c;
        }, q.isGreaterThan = q.gt = function(ae, ue) {
          return d(this, new Z(ae, ue)) > 0;
        }, q.isGreaterThanOrEqualTo = q.gte = function(ae, ue) {
          return (ue = d(this, new Z(ae, ue))) === 1 || ue === 0;
        }, q.isInteger = function() {
          return !!this.c && a(this.e / c) > this.c.length - 2;
        }, q.isLessThan = q.lt = function(ae, ue) {
          return d(this, new Z(ae, ue)) < 0;
        }, q.isLessThanOrEqualTo = q.lte = function(ae, ue) {
          return (ue = d(this, new Z(ae, ue))) === -1 || ue === 0;
        }, q.isNaN = function() {
          return !this.s;
        }, q.isNegative = function() {
          return this.s < 0;
        }, q.isPositive = function() {
          return this.s > 0;
        }, q.isZero = function() {
          return !!this.c && this.c[0] == 0;
        }, q.minus = function(ae, ue) {
          var ne, ge, Te, pe, Oe = this, xe = Oe.s;
          if (ae = new Z(ae, ue), ue = ae.s, !xe || !ue) return new Z(NaN);
          if (xe != ue) return ae.s = -ue, Oe.plus(ae);
          var Ve = Oe.e / c, _e = ae.e / c, Be = Oe.c, Qe = ae.c;
          if (!Ve || !_e) {
            if (!Be || !Qe) return Be ? (ae.s = -ue, ae) : new Z(Qe ? Oe : NaN);
            if (!Be[0] || !Qe[0]) return Qe[0] ? (ae.s = -ue, ae) : new Z(Be[0] ? Oe : _ == 3 ? -0 : 0);
          }
          if (Ve = a(Ve), _e = a(_e), Be = Be.slice(), xe = Ve - _e) {
            for ((pe = xe < 0) ? (xe = -xe, Te = Be) : (_e = Ve, Te = Qe), Te.reverse(), ue = xe; ue--; Te.push(0)) ;
            Te.reverse();
          } else for (ge = (pe = (xe = Be.length) < (ue = Qe.length)) ? xe : ue, xe = ue = 0; ue < ge; ue++) if (Be[ue] != Qe[ue]) {
            pe = Be[ue] < Qe[ue];
            break;
          }
          if (pe && (Te = Be, Be = Qe, Qe = Te, ae.s = -ae.s), ue = (ge = Qe.length) - (ne = Be.length), ue > 0) for (; ue--; Be[ne++] = 0) ;
          for (ue = u - 1; ge > xe; ) {
            if (Be[--ge] < Qe[ge]) {
              for (ne = ge; ne && !Be[--ne]; Be[ne] = ue) ;
              --Be[ne], Be[ge] += u;
            }
            Be[ge] -= Qe[ge];
          }
          for (; Be[0] == 0; Be.splice(0, 1), --_e) ;
          return Be[0] ? oe(ae, Be, _e) : (ae.s = _ == 3 ? -1 : 1, ae.c = [ae.e = 0], ae);
        }, q.modulo = q.mod = function(ae, ue) {
          var ne, ge, Te = this;
          return ae = new Z(ae, ue), !Te.c || !ae.s || ae.c && !ae.c[0] ? new Z(NaN) : !ae.c || Te.c && !Te.c[0] ? new Z(Te) : (te == 9 ? (ge = ae.s, ae.s = 1, ne = w(Te, ae, 0, 3), ae.s = ge, ne.s *= ge) : ne = w(Te, ae, 0, te), ae = Te.minus(ne.times(ae)), !ae.c[0] && te == 1 && (ae.s = Te.s), ae);
        }, q.multipliedBy = q.times = function(ae, ue) {
          var ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P, x, O, V, N = this, C = N.c, p = (ae = new Z(ae, ue)).c;
          if (!C || !p || !C[0] || !p[0]) return !N.s || !ae.s || C && !C[0] && !p || p && !p[0] && !C ? ae.c = ae.e = ae.s = null : (ae.s *= N.s, !C || !p ? ae.c = ae.e = null : (ae.c = [0], ae.e = 0)), ae;
          for (ge = a(N.e / c) + a(ae.e / c), ae.s *= N.s, Ve = C.length, Qe = p.length, Ve < Qe && (x = C, C = p, p = x, Te = Ve, Ve = Qe, Qe = Te), Te = Ve + Qe, x = []; Te--; x.push(0)) ;
          for (O = u, V = r, Te = Qe; --Te >= 0; ) {
            for (ne = 0, ee = p[Te] % V, P = p[Te] / V | 0, Oe = Ve, pe = Te + Oe; pe > Te; ) _e = C[--Oe] % V, Be = C[Oe] / V | 0, xe = P * _e + Be * ee, _e = ee * _e + xe % V * V + x[pe] + ne, ne = (_e / O | 0) + (xe / V | 0) + P * Be, x[pe--] = _e % O;
            x[pe] = ne;
          }
          return ne ? ++ge : x.splice(0, 1), oe(ae, x, ge);
        }, q.negated = function() {
          var ae = new Z(this);
          return ae.s = -ae.s || null, ae;
        }, q.plus = function(ae, ue) {
          var ne, ge = this, Te = ge.s;
          if (ae = new Z(ae, ue), ue = ae.s, !Te || !ue) return new Z(NaN);
          if (Te != ue) return ae.s = -ue, ge.minus(ae);
          var pe = ge.e / c, Oe = ae.e / c, xe = ge.c, Ve = ae.c;
          if (!pe || !Oe) {
            if (!xe || !Ve) return new Z(Te / 0);
            if (!xe[0] || !Ve[0]) return Ve[0] ? ae : new Z(xe[0] ? ge : Te * 0);
          }
          if (pe = a(pe), Oe = a(Oe), xe = xe.slice(), Te = pe - Oe) {
            for (Te > 0 ? (Oe = pe, ne = Ve) : (Te = -Te, ne = xe), ne.reverse(); Te--; ne.push(0)) ;
            ne.reverse();
          }
          for (Te = xe.length, ue = Ve.length, Te - ue < 0 && (ne = Ve, Ve = xe, xe = ne, ue = Te), Te = 0; ue; ) Te = (xe[--ue] = xe[ue] + Ve[ue] + Te) / u | 0, xe[ue] = u === xe[ue] ? 0 : xe[ue] % u;
          return Te && (xe = [Te].concat(xe), ++Oe), oe(ae, xe, Oe);
        }, q.precision = q.sd = function(ae, ue) {
          var ne, ge, Te, pe = this;
          if (ae != null && ae !== !!ae) return b(ae, 1, m), ue == null ? ue = _ : b(ue, 0, 8), ce(new Z(pe), ae, ue);
          if (!(ne = pe.c)) return null;
          if (Te = ne.length - 1, ge = Te * c + 1, Te = ne[Te]) {
            for (; Te % 10 == 0; Te /= 10, ge--) ;
            for (Te = ne[0]; Te >= 10; Te /= 10, ge++) ;
          }
          return ae && pe.e + 1 > ge && (ge = pe.e + 1), ge;
        }, q.shiftedBy = function(ae) {
          return b(ae, -9007199254740991, h), this.times("1e" + ae);
        }, q.squareRoot = q.sqrt = function() {
          var ae, ue, ne, ge, Te, pe = this, Oe = pe.c, xe = pe.s, Ve = pe.e, _e = H + 4, Be = new Z("0.5");
          if (xe !== 1 || !Oe || !Oe[0]) return new Z(!xe || xe < 0 && (!Oe || Oe[0]) ? NaN : Oe ? pe : 1 / 0);
          if (xe = Math.sqrt(+ye(pe)), xe == 0 || xe == 1 / 0 ? (ue = l(Oe), (ue.length + Ve) % 2 == 0 && (ue += "0"), xe = Math.sqrt(+ue), Ve = a((Ve + 1) / 2) - (Ve < 0 || Ve % 2), xe == 1 / 0 ? ue = "5e" + Ve : (ue = xe.toExponential(), ue = ue.slice(0, ue.indexOf("e") + 1) + Ve), ne = new Z(ue)) : ne = new Z(xe + ""), ne.c[0]) {
            for (Ve = ne.e, xe = Ve + _e, xe < 3 && (xe = 0); ; ) if (Te = ne, ne = Be.times(Te.plus(w(pe, Te, _e, 1))), l(Te.c).slice(0, xe) === (ue = l(ne.c)).slice(0, xe)) if (ne.e < Ve && --xe, ue = ue.slice(xe - 3, xe + 1), ue == "9999" || !ge && ue == "4999") {
              if (!ge && (ce(Te, Te.e + H + 2, 0), Te.times(Te).eq(pe))) {
                ne = Te;
                break;
              }
              _e += 4, xe += 4, ge = 1;
            } else {
              (!+ue || !+ue.slice(1) && ue.charAt(0) == "5") && (ce(ne, ne.e + H + 2, 1), ae = !ne.times(ne).eq(pe));
              break;
            }
          }
          return ce(ne, ne.e + H + 1, _, ae);
        }, q.toExponential = function(ae, ue) {
          return ae != null && (b(ae, 0, m), ae++), ie(this, ae, ue, 1);
        }, q.toFixed = function(ae, ue) {
          return ae != null && (b(ae, 0, m), ae = ae + this.e + 1), ie(this, ae, ue);
        }, q.toFormat = function(ae, ue, ne) {
          var ge, Te = this;
          if (ne == null) ae != null && ue && typeof ue == "object" ? (ne = ue, ue = null) : ae && typeof ae == "object" ? (ne = ae, ae = ue = null) : ne = K;
          else if (typeof ne != "object") throw Error(t + "Argument not an object: " + ne);
          if (ge = Te.toFixed(ae, ue), Te.c) {
            var pe, Oe = ge.split("."), xe = +ne.groupSize, Ve = +ne.secondaryGroupSize, _e = ne.groupSeparator || "", Be = Oe[0], Qe = Oe[1], ee = Te.s < 0, P = ee ? Be.slice(1) : Be, x = P.length;
            if (Ve && (pe = xe, xe = Ve, Ve = pe, x -= pe), xe > 0 && x > 0) {
              for (pe = x % xe || xe, Be = P.substr(0, pe); pe < x; pe += xe) Be += _e + P.substr(pe, xe);
              Ve > 0 && (Be += _e + P.slice(pe)), ee && (Be = "-" + Be);
            }
            ge = Qe ? Be + (ne.decimalSeparator || "") + ((Ve = +ne.fractionGroupSize) ? Qe.replace(new RegExp("\\d{" + Ve + "}\\B", "g"), "$&" + (ne.fractionGroupSeparator || "")) : Qe) : Be;
          }
          return (ne.prefix || "") + ge + (ne.suffix || "");
        }, q.toFraction = function(ae) {
          var ue, ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P = this, x = P.c;
          if (ae != null && (xe = new Z(ae), !xe.isInteger() && (xe.c || xe.s !== 1) || xe.lt(D))) throw Error(t + "Argument " + (xe.isInteger() ? "out of range: " : "not an integer: ") + ye(xe));
          if (!x) return new Z(P);
          for (ue = new Z(D), _e = ne = new Z(D), ge = Ve = new Z(D), ee = l(x), pe = ue.e = ee.length - P.e - 1, ue.c[0] = f[(Oe = pe % c) < 0 ? c + Oe : Oe], ae = !ae || xe.comparedTo(ue) > 0 ? pe > 0 ? ue : _e : xe, Oe = z, z = 1 / 0, xe = new Z(ee), Ve.c[0] = 0; Be = w(xe, ue, 0, 1), Te = ne.plus(Be.times(ge)), Te.comparedTo(ae) != 1; ) ne = ge, ge = Te, _e = Ve.plus(Be.times(Te = _e)), Ve = Te, ue = xe.minus(Be.times(Te = ue)), xe = Te;
          return Te = w(ae.minus(ne), ge, 0, 1), Ve = Ve.plus(Te.times(_e)), ne = ne.plus(Te.times(ge)), Ve.s = _e.s = P.s, pe = pe * 2, Qe = w(_e, ge, pe, _).minus(P).abs().comparedTo(w(Ve, ne, pe, _).minus(P).abs()) < 1 ? [_e, ge] : [Ve, ne], z = Oe, Qe;
        }, q.toNumber = function() {
          return +ye(this);
        }, q.toPrecision = function(ae, ue) {
          return ae != null && b(ae, 1, m), ie(this, ae, ue, 2);
        }, q.toString = function(ae) {
          var ue, ne = this, ge = ne.s, Te = ne.e;
          return Te === null ? ge ? (ue = "Infinity", ge < 0 && (ue = "-" + ue)) : ue = "NaN" : (ae == null ? ue = Te <= T || Te >= L ? E(l(ne.c), Te) : R(l(ne.c), Te, "0") : ae === 10 && B ? (ne = ce(new Z(ne), H + Te + 1, _), ue = R(l(ne.c), ne.e, "0")) : (b(ae, 2, J.length, "Base"), ue = F(R(l(ne.c), Te, "0"), 10, ae, ge, true)), ge < 0 && ne.c[0] && (ue = "-" + ue)), ue;
        }, q.valueOf = q.toJSON = function() {
          return ye(this);
        }, q._isBigNumber = true, k != null && Z.set(k), Z;
      }
      function a(k) {
        var w = k | 0;
        return k > 0 || k === w ? w : w - 1;
      }
      function l(k) {
        for (var w, F, I = 1, q = k.length, D = k[0] + ""; I < q; ) {
          for (w = k[I++] + "", F = c - w.length; F--; w = "0" + w) ;
          D += w;
        }
        for (q = D.length; D.charCodeAt(--q) === 48; ) ;
        return D.slice(0, q + 1 || 1);
      }
      function d(k, w) {
        var F, I, q = k.c, D = w.c, H = k.s, _ = w.s, T = k.e, L = w.e;
        if (!H || !_) return null;
        if (F = q && !q[0], I = D && !D[0], F || I) return F ? I ? 0 : -_ : H;
        if (H != _) return H;
        if (F = H < 0, I = T == L, !q || !D) return I ? 0 : !q ^ F ? 1 : -1;
        if (!I) return T > L ^ F ? 1 : -1;
        for (_ = (T = q.length) < (L = D.length) ? T : L, H = 0; H < _; H++) if (q[H] != D[H]) return q[H] > D[H] ^ F ? 1 : -1;
        return T == L ? 0 : T > L ^ F ? 1 : -1;
      }
      function b(k, w, F, I) {
        if (k < w || k > F || k !== y(k)) throw Error(t + (I || "Argument") + (typeof k == "number" ? k < w || k > F ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(k));
      }
      function S(k) {
        var w = k.c.length - 1;
        return a(k.e / c) == w && k.c[w] % 2 != 0;
      }
      function E(k, w) {
        return (k.length > 1 ? k.charAt(0) + "." + k.slice(1) : k) + (w < 0 ? "e" : "e+") + w;
      }
      function R(k, w, F) {
        var I, q;
        if (w < 0) {
          for (q = F + "."; ++w; q += F) ;
          k = q + k;
        } else if (I = k.length, ++w > I) {
          for (q = F, w -= I; --w; q += F) ;
          k += q;
        } else w < I && (k = k.slice(0, w) + "." + k.slice(w));
        return k;
      }
      n = g(), n.default = n.BigNumber = n, v.exports ? v.exports = n : (e || (e = typeof self < "u" && self ? self : window), e.BigNumber = n);
    })(Fy);
  }(uc)), uc.exports;
}
var up;
function ua() {
  return up || (up = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true }), v.default = void 0;
    var e = n(Uy());
    function n(s) {
      return s && s.__esModule ? s : { default: s };
    }
    var i = e.default.clone();
    i.DEBUG = true, v.default = i;
  }(Xc)), Xc;
}
var Zs = {}, cp;
function jy() {
  if (cp) return Zs;
  cp = 1, Object.defineProperty(Zs, "__esModule", { value: true }), Zs.best_r = c;
  var v = e(ua());
  function e(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function n(h, f) {
    return o(h) || t(h, f) || s(h, f) || i();
  }
  function i() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function s(h, f) {
    if (h) {
      if (typeof h == "string") return y(h, f);
      var r = {}.toString.call(h).slice(8, -1);
      return r === "Object" && h.constructor && (r = h.constructor.name), r === "Map" || r === "Set" ? Array.from(h) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? y(h, f) : void 0;
    }
  }
  function y(h, f) {
    (f == null || f > h.length) && (f = h.length);
    for (var r = 0, m = Array(f); r < f; r++) m[r] = h[r];
    return m;
  }
  function t(h, f) {
    var r = h == null ? null : typeof Symbol < "u" && h[Symbol.iterator] || h["@@iterator"];
    if (r != null) {
      var m, g, a, l, d = [], b = true, S = false;
      try {
        if (a = (r = r.call(h)).next, f !== 0) for (; !(b = (m = a.call(r)).done) && (d.push(m.value), d.length !== f); b = true) ;
      } catch (E) {
        S = true, g = E;
      } finally {
        try {
          if (!b && r.return != null && (l = r.return(), Object(l) !== l)) return;
        } finally {
          if (S) throw g;
        }
      }
      return d;
    }
  }
  function o(h) {
    if (Array.isArray(h)) return h;
  }
  var u = (1 << 31 >>> 0) - 1;
  function c(h) {
    for (var f = new v.default(h), r, m, g = [[new v.default(0), new v.default(1)], [new v.default(1), new v.default(0)]], a = 2; !f.gt(u); ) {
      r = f.integerValue(v.default.ROUND_FLOOR), m = f.minus(r);
      var l = r.times(g[a - 1][0]).plus(g[a - 2][0]), d = r.times(g[a - 1][1]).plus(g[a - 2][1]);
      if (l.gt(u) || d.gt(u) || (g.push([l, d]), m.eq(0))) break;
      f = new v.default(1).div(m), a += 1;
    }
    var b = n(g[g.length - 1], 2), S = b[0], E = b[1];
    if (S.isZero() || E.isZero()) throw new Error("Couldn't find approximation");
    return [S.toNumber(), E.toNumber()];
  }
  return Zs;
}
var Xa = {}, lp;
function Ql() {
  if (lp) return Xa;
  lp = 1, Object.defineProperty(Xa, "__esModule", { value: true }), Xa.LiquidityPoolAsset = void 0;
  var v = i(bn()), e = To(), n = nm();
  function i(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function s(m) {
    "@babel/helpers - typeof";
    return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(g) {
      return typeof g;
    } : function(g) {
      return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
    }, s(m);
  }
  function y(m, g) {
    var a = Object.keys(m);
    if (Object.getOwnPropertySymbols) {
      var l = Object.getOwnPropertySymbols(m);
      g && (l = l.filter(function(d) {
        return Object.getOwnPropertyDescriptor(m, d).enumerable;
      })), a.push.apply(a, l);
    }
    return a;
  }
  function t(m) {
    for (var g = 1; g < arguments.length; g++) {
      var a = arguments[g] != null ? arguments[g] : {};
      g % 2 ? y(Object(a), true).forEach(function(l) {
        o(m, l, a[l]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(m, Object.getOwnPropertyDescriptors(a)) : y(Object(a)).forEach(function(l) {
        Object.defineProperty(m, l, Object.getOwnPropertyDescriptor(a, l));
      });
    }
    return m;
  }
  function o(m, g, a) {
    return (g = f(g)) in m ? Object.defineProperty(m, g, { value: a, enumerable: true, configurable: true, writable: true }) : m[g] = a, m;
  }
  function u(m, g) {
    if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function");
  }
  function c(m, g) {
    for (var a = 0; a < g.length; a++) {
      var l = g[a];
      l.enumerable = l.enumerable || false, l.configurable = true, "value" in l && (l.writable = true), Object.defineProperty(m, f(l.key), l);
    }
  }
  function h(m, g, a) {
    return g && c(m.prototype, g), a && c(m, a), Object.defineProperty(m, "prototype", { writable: false }), m;
  }
  function f(m) {
    var g = r(m, "string");
    return s(g) == "symbol" ? g : g + "";
  }
  function r(m, g) {
    if (s(m) != "object" || !m) return m;
    var a = m[Symbol.toPrimitive];
    if (a !== void 0) {
      var l = a.call(m, g);
      if (s(l) != "object") return l;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(m);
  }
  return Xa.LiquidityPoolAsset = function() {
    function m(g, a, l) {
      if (u(this, m), !g || !(g instanceof e.Asset)) throw new Error("assetA is invalid");
      if (!a || !(a instanceof e.Asset)) throw new Error("assetB is invalid");
      if (e.Asset.compare(g, a) !== -1) throw new Error("Assets are not in lexicographic order");
      if (!l || l !== n.LiquidityPoolFeeV18) throw new Error("fee is invalid");
      this.assetA = g, this.assetB = a, this.fee = l;
    }
    return h(m, [{ key: "toXDRObject", value: function() {
      var a = new v.default.LiquidityPoolConstantProductParameters({ assetA: this.assetA.toXDRObject(), assetB: this.assetB.toXDRObject(), fee: this.fee }), l = new v.default.LiquidityPoolParameters("liquidityPoolConstantProduct", a);
      return new v.default.ChangeTrustAsset("assetTypePoolShare", l);
    } }, { key: "getLiquidityPoolParameters", value: function() {
      return t(t({}, this), {}, { assetA: this.assetA, assetB: this.assetB, fee: this.fee });
    } }, { key: "getAssetType", value: function() {
      return "liquidity_pool_shares";
    } }, { key: "equals", value: function(a) {
      return this.assetA.equals(a.assetA) && this.assetB.equals(a.assetB) && this.fee === a.fee;
    } }, { key: "toString", value: function() {
      var a = (0, n.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
      return "liquidity_pool:".concat(a);
    } }], [{ key: "fromOperation", value: function(a) {
      var l = a.switch();
      if (l === v.default.AssetType.assetTypePoolShare()) {
        var d = a.liquidityPool().constantProduct();
        return new this(e.Asset.fromOperation(d.assetA()), e.Asset.fromOperation(d.assetB()), d.fee());
      }
      throw new Error("Invalid asset type: ".concat(l.name));
    } }]);
  }(), Xa;
}
var $a = {}, fp;
function im() {
  if (fp) return $a;
  fp = 1, Object.defineProperty($a, "__esModule", { value: true }), $a.Claimant = void 0;
  var v = i(bn()), e = Ii(), n = ni();
  function i(h) {
    return h && h.__esModule ? h : { default: h };
  }
  function s(h) {
    "@babel/helpers - typeof";
    return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
      return typeof f;
    } : function(f) {
      return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
    }, s(h);
  }
  function y(h, f) {
    if (!(h instanceof f)) throw new TypeError("Cannot call a class as a function");
  }
  function t(h, f) {
    for (var r = 0; r < f.length; r++) {
      var m = f[r];
      m.enumerable = m.enumerable || false, m.configurable = true, "value" in m && (m.writable = true), Object.defineProperty(h, u(m.key), m);
    }
  }
  function o(h, f, r) {
    return f && t(h.prototype, f), r && t(h, r), Object.defineProperty(h, "prototype", { writable: false }), h;
  }
  function u(h) {
    var f = c(h, "string");
    return s(f) == "symbol" ? f : f + "";
  }
  function c(h, f) {
    if (s(h) != "object" || !h) return h;
    var r = h[Symbol.toPrimitive];
    if (r !== void 0) {
      var m = r.call(h, f);
      if (s(m) != "object") return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(h);
  }
  return $a.Claimant = function() {
    function h(f, r) {
      if (y(this, h), f && !n.StrKey.isValidEd25519PublicKey(f)) throw new Error("Destination is invalid");
      if (this._destination = f, !r) this._predicate = v.default.ClaimPredicate.claimPredicateUnconditional();
      else if (r instanceof v.default.ClaimPredicate) this._predicate = r;
      else throw new Error("Predicate should be an xdr.ClaimPredicate");
    }
    return o(h, [{ key: "toXDRObject", value: function() {
      var r = new v.default.ClaimantV0({ destination: e.Keypair.fromPublicKey(this._destination).xdrAccountId(), predicate: this._predicate });
      return v.default.Claimant.claimantTypeV0(r);
    } }, { key: "destination", get: function() {
      return this._destination;
    }, set: function(r) {
      throw new Error("Claimant is immutable");
    } }, { key: "predicate", get: function() {
      return this._predicate;
    }, set: function(r) {
      throw new Error("Claimant is immutable");
    } }], [{ key: "predicateUnconditional", value: function() {
      return v.default.ClaimPredicate.claimPredicateUnconditional();
    } }, { key: "predicateAnd", value: function(r, m) {
      if (!(r instanceof v.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
      if (!(m instanceof v.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
      return v.default.ClaimPredicate.claimPredicateAnd([r, m]);
    } }, { key: "predicateOr", value: function(r, m) {
      if (!(r instanceof v.default.ClaimPredicate)) throw new Error("left Predicate should be an xdr.ClaimPredicate");
      if (!(m instanceof v.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
      return v.default.ClaimPredicate.claimPredicateOr([r, m]);
    } }, { key: "predicateNot", value: function(r) {
      if (!(r instanceof v.default.ClaimPredicate)) throw new Error("right Predicate should be an xdr.ClaimPredicate");
      return v.default.ClaimPredicate.claimPredicateNot(r);
    } }, { key: "predicateBeforeAbsoluteTime", value: function(r) {
      return v.default.ClaimPredicate.claimPredicateBeforeAbsoluteTime(v.default.Int64.fromString(r));
    } }, { key: "predicateBeforeRelativeTime", value: function(r) {
      return v.default.ClaimPredicate.claimPredicateBeforeRelativeTime(v.default.Int64.fromString(r));
    } }, { key: "fromXDR", value: function(r) {
      var m;
      switch (r.switch()) {
        case v.default.ClaimantType.claimantTypeV0():
          return m = r.v0(), new this(n.StrKey.encodeEd25519PublicKey(m.destination().ed25519()), m.predicate());
        default:
          throw new Error("Invalid claimant type: ".concat(r.switch().name));
      }
    } }]);
  }(), $a;
}
var Ya = {}, pp;
function Zl() {
  if (pp) return Ya;
  pp = 1, Object.defineProperty(Ya, "__esModule", { value: true }), Ya.LiquidityPoolId = void 0;
  var v = e(bn());
  function e(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function n(u) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(c) {
      return typeof c;
    } : function(c) {
      return c && typeof Symbol == "function" && c.constructor === Symbol && c !== Symbol.prototype ? "symbol" : typeof c;
    }, n(u);
  }
  function i(u, c) {
    if (!(u instanceof c)) throw new TypeError("Cannot call a class as a function");
  }
  function s(u, c) {
    for (var h = 0; h < c.length; h++) {
      var f = c[h];
      f.enumerable = f.enumerable || false, f.configurable = true, "value" in f && (f.writable = true), Object.defineProperty(u, t(f.key), f);
    }
  }
  function y(u, c, h) {
    return c && s(u.prototype, c), h && s(u, h), Object.defineProperty(u, "prototype", { writable: false }), u;
  }
  function t(u) {
    var c = o(u, "string");
    return n(c) == "symbol" ? c : c + "";
  }
  function o(u, c) {
    if (n(u) != "object" || !u) return u;
    var h = u[Symbol.toPrimitive];
    if (h !== void 0) {
      var f = h.call(u, c);
      if (n(f) != "object") return f;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(u);
  }
  return Ya.LiquidityPoolId = function() {
    function u(c) {
      if (i(this, u), !c) throw new Error("liquidityPoolId cannot be empty");
      if (!/^[a-f0-9]{64}$/.test(c)) throw new Error("Liquidity pool ID is not a valid hash");
      this.liquidityPoolId = c;
    }
    return y(u, [{ key: "toXDRObject", value: function() {
      var h = v.default.PoolId.fromXDR(this.liquidityPoolId, "hex");
      return new v.default.TrustLineAsset("assetTypePoolShare", h);
    } }, { key: "getLiquidityPoolId", value: function() {
      return String(this.liquidityPoolId);
    } }, { key: "getAssetType", value: function() {
      return "liquidity_pool_shares";
    } }, { key: "equals", value: function(h) {
      return this.liquidityPoolId === h.getLiquidityPoolId();
    } }, { key: "toString", value: function() {
      return "liquidity_pool:".concat(this.liquidityPoolId);
    } }], [{ key: "fromOperation", value: function(h) {
      var f = h.switch();
      if (f === v.default.AssetType.assetTypePoolShare()) {
        var r = h.liquidityPoolId().toString("hex");
        return new this(r);
      }
      throw new Error("Invalid asset type: ".concat(f.name));
    } }]);
  }(), Ya;
}
var $c = {}, Js = {}, hp;
function Vy() {
  if (hp) return Js;
  hp = 1, Object.defineProperty(Js, "__esModule", { value: true }), Js.manageSellOffer = i;
  var v = Ai(), e = n(bn());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var y = {};
    if (y.selling = s.selling.toXDRObject(), y.buying = s.buying.toXDRObject(), !this.isValidAmount(s.amount, true)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    if (y.amount = this._toXDRAmount(s.amount), s.price === void 0) throw new TypeError("price argument is required");
    y.price = this._toXDRPrice(s.price), s.offerId !== void 0 ? s.offerId = s.offerId.toString() : s.offerId = "0", y.offerId = v.Hyper.fromString(s.offerId);
    var t = new e.default.ManageSellOfferOp(y), o = {};
    return o.body = e.default.OperationBody.manageSellOffer(t), this.setSourceAccount(o, s), new e.default.Operation(o);
  }
  return Js;
}
var eu = {}, dp;
function qy() {
  if (dp) return eu;
  dp = 1, Object.defineProperty(eu, "__esModule", { value: true }), eu.createPassiveSellOffer = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n(i) {
    var s = {};
    if (s.selling = i.selling.toXDRObject(), s.buying = i.buying.toXDRObject(), !this.isValidAmount(i.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    if (s.amount = this._toXDRAmount(i.amount), i.price === void 0) throw new TypeError("price argument is required");
    s.price = this._toXDRPrice(i.price);
    var y = new v.default.CreatePassiveSellOfferOp(s), t = {};
    return t.body = v.default.OperationBody.createPassiveSellOffer(y), this.setSourceAccount(t, i), new v.default.Operation(t);
  }
  return eu;
}
var tu = {}, qo = {}, mp;
function $i() {
  if (mp) return qo;
  mp = 1, Object.defineProperty(qo, "__esModule", { value: true }), qo.decodeAddressToMuxedAccount = i, qo.encodeMuxedAccount = y, qo.encodeMuxedAccountToAddress = s, qo.extractBaseAddress = t;
  var v = n(bn()), e = ni();
  function n(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function i(c) {
    return e.StrKey.isValidMed25519PublicKey(c) ? o(c) : v.default.MuxedAccount.keyTypeEd25519(e.StrKey.decodeEd25519PublicKey(c));
  }
  function s(c) {
    return c.switch().value === v.default.CryptoKeyType.keyTypeMuxedEd25519().value ? u(c) : e.StrKey.encodeEd25519PublicKey(c.ed25519());
  }
  function y(c, h) {
    if (!e.StrKey.isValidEd25519PublicKey(c)) throw new Error("address should be a Stellar account ID (G...)");
    if (typeof h != "string") throw new Error("id should be a string representing a number (uint64)");
    return v.default.MuxedAccount.keyTypeMuxedEd25519(new v.default.MuxedAccountMed25519({ id: v.default.Uint64.fromString(h), ed25519: e.StrKey.decodeEd25519PublicKey(c) }));
  }
  function t(c) {
    if (e.StrKey.isValidEd25519PublicKey(c)) return c;
    if (!e.StrKey.isValidMed25519PublicKey(c)) throw new TypeError("expected muxed account (M...), got ".concat(c));
    var h = i(c);
    return e.StrKey.encodeEd25519PublicKey(h.med25519().ed25519());
  }
  function o(c) {
    var h = e.StrKey.decodeMed25519PublicKey(c);
    return v.default.MuxedAccount.keyTypeMuxedEd25519(new v.default.MuxedAccountMed25519({ id: v.default.Uint64.fromXDR(h.subarray(-8)), ed25519: h.subarray(0, -8) }));
  }
  function u(c) {
    if (c.switch() === v.default.CryptoKeyType.keyTypeEd25519()) return s(c);
    var h = c.med25519();
    return e.StrKey.encodeMed25519PublicKey(Buffer.concat([h.ed25519(), h.id().toXDR("raw")]));
  }
  return qo;
}
var yp;
function zy() {
  if (yp) return tu;
  yp = 1, Object.defineProperty(tu, "__esModule", { value: true }), tu.accountMerge = i;
  var v = n(bn()), e = $i();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var y = {};
    try {
      y.body = v.default.OperationBody.accountMerge((0, e.decodeAddressToMuxedAccount)(s.destination));
    } catch {
      throw new Error("destination is invalid");
    }
    return this.setSourceAccount(y, s), new v.default.Operation(y);
  }
  return tu;
}
var ru = {}, gp;
function Hy() {
  if (gp) return ru;
  gp = 1, Object.defineProperty(ru, "__esModule", { value: true }), ru.allowTrust = s;
  var v = i(bn()), e = Ii(), n = ni();
  function i(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function s(y) {
    if (!n.StrKey.isValidEd25519PublicKey(y.trustor)) throw new Error("trustor is invalid");
    var t = {};
    if (t.trustor = e.Keypair.fromPublicKey(y.trustor).xdrAccountId(), y.assetCode.length <= 4) {
      var o = y.assetCode.padEnd(4, "\0");
      t.asset = v.default.AssetCode.assetTypeCreditAlphanum4(o);
    } else if (y.assetCode.length <= 12) {
      var u = y.assetCode.padEnd(12, "\0");
      t.asset = v.default.AssetCode.assetTypeCreditAlphanum12(u);
    } else throw new Error("Asset code must be 12 characters at max.");
    typeof y.authorize == "boolean" ? y.authorize ? t.authorize = v.default.TrustLineFlags.authorizedFlag().value : t.authorize = 0 : t.authorize = y.authorize;
    var c = new v.default.AllowTrustOp(t), h = {};
    return h.body = v.default.OperationBody.allowTrust(c), this.setSourceAccount(h, y), new v.default.Operation(h);
  }
  return ru;
}
var nu = {}, vp;
function Gy() {
  if (vp) return nu;
  vp = 1, Object.defineProperty(nu, "__esModule", { value: true }), nu.bumpSequence = s;
  var v = Ai(), e = i(ua()), n = i(bn());
  function i(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function s(y) {
    var t = {};
    if (typeof y.bumpTo != "string") throw new Error("bumpTo must be a string");
    try {
      new e.default(y.bumpTo);
    } catch {
      throw new Error("bumpTo must be a stringified number");
    }
    t.bumpTo = v.Hyper.fromString(y.bumpTo);
    var o = new n.default.BumpSequenceOp(t), u = {};
    return u.body = n.default.OperationBody.bumpSequence(o), this.setSourceAccount(u, y), new n.default.Operation(u);
  }
  return nu;
}
var iu = {}, bp;
function Wy() {
  if (bp) return iu;
  bp = 1, Object.defineProperty(iu, "__esModule", { value: true }), iu.changeTrust = o;
  var v = Ai(), e = y(ua()), n = y(bn()), i = To(), s = Ql();
  function y(u) {
    return u && u.__esModule ? u : { default: u };
  }
  var t = "9223372036854775807";
  function o(u) {
    var c = {};
    if (u.asset instanceof i.Asset) c.line = u.asset.toChangeTrustXDRObject();
    else if (u.asset instanceof s.LiquidityPoolAsset) c.line = u.asset.toXDRObject();
    else throw new TypeError("asset must be Asset or LiquidityPoolAsset");
    if (u.limit !== void 0 && !this.isValidAmount(u.limit, true)) throw new TypeError(this.constructAmountRequirementsError("limit"));
    u.limit ? c.limit = this._toXDRAmount(u.limit) : c.limit = v.Hyper.fromString(new e.default(t).toString()), u.source && (c.source = u.source.masterKeypair);
    var h = new n.default.ChangeTrustOp(c), f = {};
    return f.body = n.default.OperationBody.changeTrust(h), this.setSourceAccount(f, u), new n.default.Operation(f);
  }
  return iu;
}
var ou = {}, wp;
function Ky() {
  if (wp) return ou;
  wp = 1, Object.defineProperty(ou, "__esModule", { value: true }), ou.createAccount = s;
  var v = i(bn()), e = Ii(), n = ni();
  function i(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function s(y) {
    if (!n.StrKey.isValidEd25519PublicKey(y.destination)) throw new Error("destination is invalid");
    if (!this.isValidAmount(y.startingBalance, true)) throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
    var t = {};
    t.destination = e.Keypair.fromPublicKey(y.destination).xdrAccountId(), t.startingBalance = this._toXDRAmount(y.startingBalance);
    var o = new v.default.CreateAccountOp(t), u = {};
    return u.body = v.default.OperationBody.createAccount(o), this.setSourceAccount(u, y), new v.default.Operation(u);
  }
  return ou;
}
var au = {}, Sp;
function Xy() {
  if (Sp) return au;
  Sp = 1, Object.defineProperty(au, "__esModule", { value: true }), au.createClaimableBalance = i;
  var v = n(bn()), e = To();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    if (!(s.asset instanceof e.Asset)) throw new Error("must provide an asset for create claimable balance operation");
    if (!this.isValidAmount(s.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    if (!Array.isArray(s.claimants) || s.claimants.length === 0) throw new Error("must provide at least one claimant");
    var y = {};
    y.asset = s.asset.toXDRObject(), y.amount = this._toXDRAmount(s.amount), y.claimants = Object.values(s.claimants).map(function(u) {
      return u.toXDRObject();
    });
    var t = new v.default.CreateClaimableBalanceOp(y), o = {};
    return o.body = v.default.OperationBody.createClaimableBalance(t), this.setSourceAccount(o, s), new v.default.Operation(o);
  }
  return au;
}
var Qa = {}, _p;
function om() {
  if (_p) return Qa;
  _p = 1, Object.defineProperty(Qa, "__esModule", { value: true }), Qa.claimClaimableBalance = n, Qa.validateClaimableBalanceId = i;
  var v = e(bn());
  function e(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function n() {
    var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    i(s.balanceId);
    var y = {};
    y.balanceId = v.default.ClaimableBalanceId.fromXDR(s.balanceId, "hex");
    var t = new v.default.ClaimClaimableBalanceOp(y), o = {};
    return o.body = v.default.OperationBody.claimClaimableBalance(t), this.setSourceAccount(o, s), new v.default.Operation(o);
  }
  function i(s) {
    if (typeof s != "string" || s.length !== 72) throw new Error("must provide a valid claimable balance id");
  }
  return Qa;
}
var su = {}, Ep;
function $y() {
  if (Ep) return su;
  Ep = 1, Object.defineProperty(su, "__esModule", { value: true }), su.clawbackClaimableBalance = i;
  var v = n(bn()), e = om();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i() {
    var s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    (0, e.validateClaimableBalanceId)(s.balanceId);
    var y = { balanceId: v.default.ClaimableBalanceId.fromXDR(s.balanceId, "hex") }, t = { body: v.default.OperationBody.clawbackClaimableBalance(new v.default.ClawbackClaimableBalanceOp(y)) };
    return this.setSourceAccount(t, s), new v.default.Operation(t);
  }
  return su;
}
var uu = {}, Ap;
function Yy() {
  if (Ap) return uu;
  Ap = 1, Object.defineProperty(uu, "__esModule", { value: true }), uu.inflation = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = {};
    return s.body = v.default.OperationBody.inflation(), this.setSourceAccount(s, i), new v.default.Operation(s);
  }
  return uu;
}
var cu = {}, xp;
function Qy() {
  if (xp) return cu;
  xp = 1, Object.defineProperty(cu, "__esModule", { value: true }), cu.manageData = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n(i) {
    var s = {};
    if (!(typeof i.name == "string" && i.name.length <= 64)) throw new Error("name must be a string, up to 64 characters");
    if (s.dataName = i.name, typeof i.value != "string" && !Buffer.isBuffer(i.value) && i.value !== null) throw new Error("value must be a string, Buffer or null");
    if (typeof i.value == "string" ? s.dataValue = Buffer.from(i.value) : s.dataValue = i.value, s.dataValue !== null && s.dataValue.length > 64) throw new Error("value cannot be longer that 64 bytes");
    var y = new v.default.ManageDataOp(s), t = {};
    return t.body = v.default.OperationBody.manageData(y), this.setSourceAccount(t, i), new v.default.Operation(t);
  }
  return cu;
}
var lu = {}, Tp;
function Zy() {
  if (Tp) return lu;
  Tp = 1, Object.defineProperty(lu, "__esModule", { value: true }), lu.manageBuyOffer = i;
  var v = Ai(), e = n(bn());
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var y = {};
    if (y.selling = s.selling.toXDRObject(), y.buying = s.buying.toXDRObject(), !this.isValidAmount(s.buyAmount, true)) throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
    if (y.buyAmount = this._toXDRAmount(s.buyAmount), s.price === void 0) throw new TypeError("price argument is required");
    y.price = this._toXDRPrice(s.price), s.offerId !== void 0 ? s.offerId = s.offerId.toString() : s.offerId = "0", y.offerId = v.Hyper.fromString(s.offerId);
    var t = new e.default.ManageBuyOfferOp(y), o = {};
    return o.body = e.default.OperationBody.manageBuyOffer(t), this.setSourceAccount(o, s), new e.default.Operation(o);
  }
  return lu;
}
var fu = {}, kp;
function Jy() {
  if (kp) return fu;
  kp = 1, Object.defineProperty(fu, "__esModule", { value: true }), fu.pathPaymentStrictReceive = i;
  var v = n(bn()), e = $i();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    switch (true) {
      case !s.sendAsset:
        throw new Error("Must specify a send asset");
      case !this.isValidAmount(s.sendMax):
        throw new TypeError(this.constructAmountRequirementsError("sendMax"));
      case !s.destAsset:
        throw new Error("Must provide a destAsset for a payment operation");
      case !this.isValidAmount(s.destAmount):
        throw new TypeError(this.constructAmountRequirementsError("destAmount"));
    }
    var y = {};
    y.sendAsset = s.sendAsset.toXDRObject(), y.sendMax = this._toXDRAmount(s.sendMax);
    try {
      y.destination = (0, e.decodeAddressToMuxedAccount)(s.destination);
    } catch {
      throw new Error("destination is invalid");
    }
    y.destAsset = s.destAsset.toXDRObject(), y.destAmount = this._toXDRAmount(s.destAmount);
    var t = s.path ? s.path : [];
    y.path = t.map(function(c) {
      return c.toXDRObject();
    });
    var o = new v.default.PathPaymentStrictReceiveOp(y), u = {};
    return u.body = v.default.OperationBody.pathPaymentStrictReceive(o), this.setSourceAccount(u, s), new v.default.Operation(u);
  }
  return fu;
}
var pu = {}, Op;
function eg() {
  if (Op) return pu;
  Op = 1, Object.defineProperty(pu, "__esModule", { value: true }), pu.pathPaymentStrictSend = i;
  var v = n(bn()), e = $i();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    switch (true) {
      case !s.sendAsset:
        throw new Error("Must specify a send asset");
      case !this.isValidAmount(s.sendAmount):
        throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
      case !s.destAsset:
        throw new Error("Must provide a destAsset for a payment operation");
      case !this.isValidAmount(s.destMin):
        throw new TypeError(this.constructAmountRequirementsError("destMin"));
    }
    var y = {};
    y.sendAsset = s.sendAsset.toXDRObject(), y.sendAmount = this._toXDRAmount(s.sendAmount);
    try {
      y.destination = (0, e.decodeAddressToMuxedAccount)(s.destination);
    } catch {
      throw new Error("destination is invalid");
    }
    y.destAsset = s.destAsset.toXDRObject(), y.destMin = this._toXDRAmount(s.destMin);
    var t = s.path ? s.path : [];
    y.path = t.map(function(c) {
      return c.toXDRObject();
    });
    var o = new v.default.PathPaymentStrictSendOp(y), u = {};
    return u.body = v.default.OperationBody.pathPaymentStrictSend(o), this.setSourceAccount(u, s), new v.default.Operation(u);
  }
  return pu;
}
var hu = {}, Pp;
function tg() {
  if (Pp) return hu;
  Pp = 1, Object.defineProperty(hu, "__esModule", { value: true }), hu.payment = i;
  var v = n(bn()), e = $i();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    if (!s.asset) throw new Error("Must provide an asset for a payment operation");
    if (!this.isValidAmount(s.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    var y = {};
    try {
      y.destination = (0, e.decodeAddressToMuxedAccount)(s.destination);
    } catch {
      throw new Error("destination is invalid");
    }
    y.asset = s.asset.toXDRObject(), y.amount = this._toXDRAmount(s.amount);
    var t = new v.default.PaymentOp(y), o = {};
    return o.body = v.default.OperationBody.payment(t), this.setSourceAccount(o, s), new v.default.Operation(o);
  }
  return hu;
}
var du = {}, Cp;
function rg() {
  if (Cp) return du;
  Cp = 1, Object.defineProperty(du, "__esModule", { value: true }), du.setOptions = y;
  var v = i(bn()), e = Ii(), n = ni();
  function i(t) {
    return t && t.__esModule ? t : { default: t };
  }
  function s(t, o) {
    if (t >= 0 && t <= 255) return true;
    throw new Error("".concat(o, " value must be between 0 and 255"));
  }
  function y(t) {
    var o = {};
    if (t.inflationDest) {
      if (!n.StrKey.isValidEd25519PublicKey(t.inflationDest)) throw new Error("inflationDest is invalid");
      o.inflationDest = e.Keypair.fromPublicKey(t.inflationDest).xdrAccountId();
    }
    if (o.clearFlags = this._checkUnsignedIntValue("clearFlags", t.clearFlags), o.setFlags = this._checkUnsignedIntValue("setFlags", t.setFlags), o.masterWeight = this._checkUnsignedIntValue("masterWeight", t.masterWeight, s), o.lowThreshold = this._checkUnsignedIntValue("lowThreshold", t.lowThreshold, s), o.medThreshold = this._checkUnsignedIntValue("medThreshold", t.medThreshold, s), o.highThreshold = this._checkUnsignedIntValue("highThreshold", t.highThreshold, s), t.homeDomain !== void 0 && typeof t.homeDomain != "string") throw new TypeError("homeDomain argument must be of type String");
    if (o.homeDomain = t.homeDomain, t.signer) {
      var u = this._checkUnsignedIntValue("signer.weight", t.signer.weight, s), c, h = 0;
      if (t.signer.ed25519PublicKey) {
        if (!n.StrKey.isValidEd25519PublicKey(t.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
        var f = n.StrKey.decodeEd25519PublicKey(t.signer.ed25519PublicKey);
        c = new v.default.SignerKey.signerKeyTypeEd25519(f), h += 1;
      }
      if (t.signer.preAuthTx) {
        if (typeof t.signer.preAuthTx == "string" && (t.signer.preAuthTx = Buffer.from(t.signer.preAuthTx, "hex")), !(Buffer.isBuffer(t.signer.preAuthTx) && t.signer.preAuthTx.length === 32)) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        c = new v.default.SignerKey.signerKeyTypePreAuthTx(t.signer.preAuthTx), h += 1;
      }
      if (t.signer.sha256Hash) {
        if (typeof t.signer.sha256Hash == "string" && (t.signer.sha256Hash = Buffer.from(t.signer.sha256Hash, "hex")), !(Buffer.isBuffer(t.signer.sha256Hash) && t.signer.sha256Hash.length === 32)) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        c = new v.default.SignerKey.signerKeyTypeHashX(t.signer.sha256Hash), h += 1;
      }
      if (t.signer.ed25519SignedPayload) {
        if (!n.StrKey.isValidSignedPayload(t.signer.ed25519SignedPayload)) throw new Error("signer.ed25519SignedPayload is invalid.");
        var r = n.StrKey.decodeSignedPayload(t.signer.ed25519SignedPayload), m = v.default.SignerKeyEd25519SignedPayload.fromXDR(r);
        c = v.default.SignerKey.signerKeyTypeEd25519SignedPayload(m), h += 1;
      }
      if (h !== 1) throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
      o.signer = new v.default.Signer({ key: c, weight: u });
    }
    var g = new v.default.SetOptionsOp(o), a = {};
    return a.body = v.default.OperationBody.setOptions(g), this.setSourceAccount(a, t), new v.default.Operation(a);
  }
  return du;
}
var mu = {}, Rp;
function ng() {
  if (Rp) return mu;
  Rp = 1, Object.defineProperty(mu, "__esModule", { value: true }), mu.beginSponsoringFutureReserves = s;
  var v = i(bn()), e = ni(), n = Ii();
  function i(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function s() {
    var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(y.sponsoredId)) throw new Error("sponsoredId is invalid");
    var t = new v.default.BeginSponsoringFutureReservesOp({ sponsoredId: n.Keypair.fromPublicKey(y.sponsoredId).xdrAccountId() }), o = {};
    return o.body = v.default.OperationBody.beginSponsoringFutureReserves(t), this.setSourceAccount(o, y), new v.default.Operation(o);
  }
  return mu;
}
var yu = {}, Mp;
function ig() {
  if (Mp) return yu;
  Mp = 1, Object.defineProperty(yu, "__esModule", { value: true }), yu.endSponsoringFutureReserves = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = {};
    return s.body = v.default.OperationBody.endSponsoringFutureReserves(), this.setSourceAccount(s, i), new v.default.Operation(s);
  }
  return yu;
}
var Qi = {}, Ip;
function og() {
  if (Ip) return Qi;
  Ip = 1, Object.defineProperty(Qi, "__esModule", { value: true }), Qi.revokeAccountSponsorship = t, Qi.revokeClaimableBalanceSponsorship = h, Qi.revokeDataSponsorship = c, Qi.revokeLiquidityPoolSponsorship = f, Qi.revokeOfferSponsorship = u, Qi.revokeSignerSponsorship = r, Qi.revokeTrustlineSponsorship = o;
  var v = y(bn()), e = ni(), n = Ii(), i = To(), s = Zl();
  function y(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function t() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(m.account)) throw new Error("account is invalid");
    var g = v.default.LedgerKey.account(new v.default.LedgerKeyAccount({ accountId: n.Keypair.fromPublicKey(m.account).xdrAccountId() })), a = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(g), l = {};
    return l.body = v.default.OperationBody.revokeSponsorship(a), this.setSourceAccount(l, m), new v.default.Operation(l);
  }
  function o() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(m.account)) throw new Error("account is invalid");
    var g;
    if (m.asset instanceof i.Asset) g = m.asset.toTrustLineXDRObject();
    else if (m.asset instanceof s.LiquidityPoolId) g = m.asset.toXDRObject();
    else throw new TypeError("asset must be an Asset or LiquidityPoolId");
    var a = v.default.LedgerKey.trustline(new v.default.LedgerKeyTrustLine({ accountId: n.Keypair.fromPublicKey(m.account).xdrAccountId(), asset: g })), l = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(a), d = {};
    return d.body = v.default.OperationBody.revokeSponsorship(l), this.setSourceAccount(d, m), new v.default.Operation(d);
  }
  function u() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(m.seller)) throw new Error("seller is invalid");
    if (typeof m.offerId != "string") throw new Error("offerId is invalid");
    var g = v.default.LedgerKey.offer(new v.default.LedgerKeyOffer({ sellerId: n.Keypair.fromPublicKey(m.seller).xdrAccountId(), offerId: v.default.Int64.fromString(m.offerId) })), a = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(g), l = {};
    return l.body = v.default.OperationBody.revokeSponsorship(a), this.setSourceAccount(l, m), new v.default.Operation(l);
  }
  function c() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(m.account)) throw new Error("account is invalid");
    if (typeof m.name != "string" || m.name.length > 64) throw new Error("name must be a string, up to 64 characters");
    var g = v.default.LedgerKey.data(new v.default.LedgerKeyData({ accountId: n.Keypair.fromPublicKey(m.account).xdrAccountId(), dataName: m.name })), a = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(g), l = {};
    return l.body = v.default.OperationBody.revokeSponsorship(a), this.setSourceAccount(l, m), new v.default.Operation(l);
  }
  function h() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof m.balanceId != "string") throw new Error("balanceId is invalid");
    var g = v.default.LedgerKey.claimableBalance(new v.default.LedgerKeyClaimableBalance({ balanceId: v.default.ClaimableBalanceId.fromXDR(m.balanceId, "hex") })), a = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(g), l = {};
    return l.body = v.default.OperationBody.revokeSponsorship(a), this.setSourceAccount(l, m), new v.default.Operation(l);
  }
  function f() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (typeof m.liquidityPoolId != "string") throw new Error("liquidityPoolId is invalid");
    var g = v.default.LedgerKey.liquidityPool(new v.default.LedgerKeyLiquidityPool({ liquidityPoolId: v.default.PoolId.fromXDR(m.liquidityPoolId, "hex") })), a = v.default.RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(g), l = { body: v.default.OperationBody.revokeSponsorship(a) };
    return this.setSourceAccount(l, m), new v.default.Operation(l);
  }
  function r() {
    var m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!e.StrKey.isValidEd25519PublicKey(m.account)) throw new Error("account is invalid");
    var g;
    if (m.signer.ed25519PublicKey) {
      if (!e.StrKey.isValidEd25519PublicKey(m.signer.ed25519PublicKey)) throw new Error("signer.ed25519PublicKey is invalid.");
      var a = e.StrKey.decodeEd25519PublicKey(m.signer.ed25519PublicKey);
      g = new v.default.SignerKey.signerKeyTypeEd25519(a);
    } else if (m.signer.preAuthTx) {
      var l;
      if (typeof m.signer.preAuthTx == "string" ? l = Buffer.from(m.signer.preAuthTx, "hex") : l = m.signer.preAuthTx, !(Buffer.isBuffer(l) && l.length === 32)) throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
      g = new v.default.SignerKey.signerKeyTypePreAuthTx(l);
    } else if (m.signer.sha256Hash) {
      var d;
      if (typeof m.signer.sha256Hash == "string" ? d = Buffer.from(m.signer.sha256Hash, "hex") : d = m.signer.sha256Hash, !(Buffer.isBuffer(d) && d.length === 32)) throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
      g = new v.default.SignerKey.signerKeyTypeHashX(d);
    } else throw new Error("signer is invalid");
    var b = new v.default.RevokeSponsorshipOpSigner({ accountId: n.Keypair.fromPublicKey(m.account).xdrAccountId(), signerKey: g }), S = v.default.RevokeSponsorshipOp.revokeSponsorshipSigner(b), E = {};
    return E.body = v.default.OperationBody.revokeSponsorship(S), this.setSourceAccount(E, m), new v.default.Operation(E);
  }
  return Qi;
}
var gu = {}, Lp;
function ag() {
  if (Lp) return gu;
  Lp = 1, Object.defineProperty(gu, "__esModule", { value: true }), gu.clawback = i;
  var v = n(bn()), e = $i();
  function n(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s) {
    var y = {};
    if (!this.isValidAmount(s.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    y.amount = this._toXDRAmount(s.amount), y.asset = s.asset.toXDRObject();
    try {
      y.from = (0, e.decodeAddressToMuxedAccount)(s.from);
    } catch {
      throw new Error("from address is invalid");
    }
    var t = { body: v.default.OperationBody.clawback(new v.default.ClawbackOp(y)) };
    return this.setSourceAccount(t, s), new v.default.Operation(t);
  }
  return gu;
}
var vu = {}, Bp;
function sg() {
  if (Bp) return vu;
  Bp = 1, Object.defineProperty(vu, "__esModule", { value: true }), vu.setTrustLineFlags = s;
  var v = n(bn()), e = Ii();
  function n(y) {
    return y && y.__esModule ? y : { default: y };
  }
  function i(y) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, i(y);
  }
  function s() {
    var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = {};
    if (i(y.flags) !== "object" || Object.keys(y.flags).length === 0) throw new Error("opts.flags must be a map of boolean flags to modify");
    var o = { authorized: v.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: v.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: v.default.TrustLineFlags.trustlineClawbackEnabledFlag() }, u = 0, c = 0;
    Object.keys(y.flags).forEach(function(f) {
      if (!Object.prototype.hasOwnProperty.call(o, f)) throw new Error("unsupported flag name specified: ".concat(f));
      var r = y.flags[f], m = o[f].value;
      r === true ? c |= m : r === false && (u |= m);
    }), t.trustor = e.Keypair.fromPublicKey(y.trustor).xdrAccountId(), t.asset = y.asset.toXDRObject(), t.clearFlags = u, t.setFlags = c;
    var h = { body: v.default.OperationBody.setTrustLineFlags(new v.default.SetTrustLineFlagsOp(t)) };
    return this.setSourceAccount(h, y), new v.default.Operation(h);
  }
  return vu;
}
var bu = {}, Np;
function ug() {
  if (Np) return bu;
  Np = 1, Object.defineProperty(bu, "__esModule", { value: true }), bu.liquidityPoolDeposit = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = i.liquidityPoolId, y = i.maxAmountA, t = i.maxAmountB, o = i.minPrice, u = i.maxPrice, c = {};
    if (!s) throw new TypeError("liquidityPoolId argument is required");
    if (c.liquidityPoolId = v.default.PoolId.fromXDR(s, "hex"), !this.isValidAmount(y, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
    if (c.maxAmountA = this._toXDRAmount(y), !this.isValidAmount(t, true)) throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
    if (c.maxAmountB = this._toXDRAmount(t), o === void 0) throw new TypeError("minPrice argument is required");
    if (c.minPrice = this._toXDRPrice(o), u === void 0) throw new TypeError("maxPrice argument is required");
    c.maxPrice = this._toXDRPrice(u);
    var h = new v.default.LiquidityPoolDepositOp(c), f = { body: v.default.OperationBody.liquidityPoolDeposit(h) };
    return this.setSourceAccount(f, i), new v.default.Operation(f);
  }
  return bu;
}
var wu = {}, Dp;
function cg() {
  if (Dp) return wu;
  Dp = 1, Object.defineProperty(wu, "__esModule", { value: true }), wu.liquidityPoolWithdraw = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = {};
    if (!i.liquidityPoolId) throw new TypeError("liquidityPoolId argument is required");
    if (s.liquidityPoolId = v.default.PoolId.fromXDR(i.liquidityPoolId, "hex"), !this.isValidAmount(i.amount)) throw new TypeError(this.constructAmountRequirementsError("amount"));
    if (s.amount = this._toXDRAmount(i.amount), !this.isValidAmount(i.minAmountA, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
    if (s.minAmountA = this._toXDRAmount(i.minAmountA), !this.isValidAmount(i.minAmountB, true)) throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
    s.minAmountB = this._toXDRAmount(i.minAmountB);
    var y = new v.default.LiquidityPoolWithdrawOp(s), t = { body: v.default.OperationBody.liquidityPoolWithdraw(y) };
    return this.setSourceAccount(t, i), new v.default.Operation(t);
  }
  return wu;
}
var Po = {}, Za = {}, Fp;
function Na() {
  if (Fp) return Za;
  Fp = 1, Object.defineProperty(Za, "__esModule", { value: true }), Za.Address = void 0;
  var v = ni(), e = n(bn());
  function n(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function i(c) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, i(c);
  }
  function s(c, h) {
    if (!(c instanceof h)) throw new TypeError("Cannot call a class as a function");
  }
  function y(c, h) {
    for (var f = 0; f < h.length; f++) {
      var r = h[f];
      r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(c, o(r.key), r);
    }
  }
  function t(c, h, f) {
    return h && y(c.prototype, h), f && y(c, f), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function o(c) {
    var h = u(c, "string");
    return i(h) == "symbol" ? h : h + "";
  }
  function u(c, h) {
    if (i(c) != "object" || !c) return c;
    var f = c[Symbol.toPrimitive];
    if (f !== void 0) {
      var r = f.call(c, h);
      if (i(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(c);
  }
  return Za.Address = function() {
    function c(h) {
      if (s(this, c), v.StrKey.isValidEd25519PublicKey(h)) this._type = "account", this._key = v.StrKey.decodeEd25519PublicKey(h);
      else if (v.StrKey.isValidContract(h)) this._type = "contract", this._key = v.StrKey.decodeContract(h);
      else throw new Error("Unsupported address type: ".concat(h));
    }
    return t(c, [{ key: "toString", value: function() {
      switch (this._type) {
        case "account":
          return v.StrKey.encodeEd25519PublicKey(this._key);
        case "contract":
          return v.StrKey.encodeContract(this._key);
        default:
          throw new Error("Unsupported address type");
      }
    } }, { key: "toScVal", value: function() {
      return e.default.ScVal.scvAddress(this.toScAddress());
    } }, { key: "toScAddress", value: function() {
      switch (this._type) {
        case "account":
          return e.default.ScAddress.scAddressTypeAccount(e.default.PublicKey.publicKeyTypeEd25519(this._key));
        case "contract":
          return e.default.ScAddress.scAddressTypeContract(this._key);
        default:
          throw new Error("Unsupported address type");
      }
    } }, { key: "toBuffer", value: function() {
      return this._key;
    } }], [{ key: "fromString", value: function(f) {
      return new c(f);
    } }, { key: "account", value: function(f) {
      return new c(v.StrKey.encodeEd25519PublicKey(f));
    } }, { key: "contract", value: function(f) {
      return new c(v.StrKey.encodeContract(f));
    } }, { key: "fromScVal", value: function(f) {
      return c.fromScAddress(f.address());
    } }, { key: "fromScAddress", value: function(f) {
      switch (f.switch().value) {
        case e.default.ScAddressType.scAddressTypeAccount().value:
          return c.account(f.accountId().ed25519());
        case e.default.ScAddressType.scAddressTypeContract().value:
          return c.contract(f.contractId());
        default:
          throw new Error("Unsupported address type");
      }
    } }]);
  }(), Za;
}
var Up;
function lg() {
  if (Up) return Po;
  Up = 1, Object.defineProperty(Po, "__esModule", { value: true }), Po.createCustomContract = m, Po.createStellarAssetContract = g, Po.invokeContractFunction = r, Po.invokeHostFunction = f, Po.uploadContractWasm = a;
  var v = s(bn()), e = Ii(), n = Na(), i = To();
  function s(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function y(d, b) {
    return h(d) || c(d, b) || o(d, b) || t();
  }
  function t() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function o(d, b) {
    if (d) {
      if (typeof d == "string") return u(d, b);
      var S = {}.toString.call(d).slice(8, -1);
      return S === "Object" && d.constructor && (S = d.constructor.name), S === "Map" || S === "Set" ? Array.from(d) : S === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(S) ? u(d, b) : void 0;
    }
  }
  function u(d, b) {
    (b == null || b > d.length) && (b = d.length);
    for (var S = 0, E = Array(b); S < b; S++) E[S] = d[S];
    return E;
  }
  function c(d, b) {
    var S = d == null ? null : typeof Symbol < "u" && d[Symbol.iterator] || d["@@iterator"];
    if (S != null) {
      var E, R, k, w, F = [], I = true, q = false;
      try {
        if (k = (S = S.call(d)).next, b !== 0) for (; !(I = (E = k.call(S)).done) && (F.push(E.value), F.length !== b); I = true) ;
      } catch (D) {
        q = true, R = D;
      } finally {
        try {
          if (!I && S.return != null && (w = S.return(), Object(w) !== w)) return;
        } finally {
          if (q) throw R;
        }
      }
      return F;
    }
  }
  function h(d) {
    if (Array.isArray(d)) return d;
  }
  function f(d) {
    if (!d.func) throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(d), ")"));
    var b = new v.default.InvokeHostFunctionOp({ hostFunction: d.func, auth: d.auth || [] }), S = { body: v.default.OperationBody.invokeHostFunction(b) };
    return this.setSourceAccount(S, d), new v.default.Operation(S);
  }
  function r(d) {
    var b = new n.Address(d.contract);
    if (b._type !== "contract") throw new TypeError("expected contract strkey instance, got ".concat(b));
    return this.invokeHostFunction({ source: d.source, auth: d.auth, func: v.default.HostFunction.hostFunctionTypeInvokeContract(new v.default.InvokeContractArgs({ contractAddress: b.toScAddress(), functionName: d.function, args: d.args })) });
  }
  function m(d) {
    var b, S = Buffer.from(d.salt || l());
    if (!d.wasmHash || d.wasmHash.length !== 32) throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(d.wasmHash));
    if (S.length !== 32) throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(d.wasmHash));
    return this.invokeHostFunction({ source: d.source, auth: d.auth, func: v.default.HostFunction.hostFunctionTypeCreateContractV2(new v.default.CreateContractArgsV2({ executable: v.default.ContractExecutable.contractExecutableWasm(Buffer.from(d.wasmHash)), contractIdPreimage: v.default.ContractIdPreimage.contractIdPreimageFromAddress(new v.default.ContractIdPreimageFromAddress({ address: d.address.toScAddress(), salt: S })), constructorArgs: (b = d.constructorArgs) !== null && b !== void 0 ? b : [] })) });
  }
  function g(d) {
    var b = d.asset;
    if (typeof b == "string") {
      var S = b.split(":"), E = y(S, 2), R = E[0], k = E[1];
      b = new i.Asset(R, k);
    }
    if (!(b instanceof i.Asset)) throw new TypeError("expected Asset in 'opts.asset', got ".concat(b));
    return this.invokeHostFunction({ source: d.source, auth: d.auth, func: v.default.HostFunction.hostFunctionTypeCreateContract(new v.default.CreateContractArgs({ executable: v.default.ContractExecutable.contractExecutableStellarAsset(), contractIdPreimage: v.default.ContractIdPreimage.contractIdPreimageFromAsset(b.toXDRObject()) })) });
  }
  function a(d) {
    return this.invokeHostFunction({ source: d.source, auth: d.auth, func: v.default.HostFunction.hostFunctionTypeUploadContractWasm(Buffer.from(d.wasm)) });
  }
  function l() {
    return e.Keypair.random().xdrPublicKey().value();
  }
  return Po;
}
var Su = {}, jp;
function fg() {
  if (jp) return Su;
  jp = 1, Object.defineProperty(Su, "__esModule", { value: true }), Su.extendFootprintTtl = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n(i) {
    var s;
    if (((s = i.extendTo) !== null && s !== void 0 ? s : -1) <= 0) throw new RangeError("extendTo has to be positive");
    var y = new v.default.ExtendFootprintTtlOp({ ext: new v.default.ExtensionPoint(0), extendTo: i.extendTo }), t = { body: v.default.OperationBody.extendFootprintTtl(y) };
    return this.setSourceAccount(t, i), new v.default.Operation(t);
  }
  return Su;
}
var _u = {}, Vp;
function pg() {
  if (Vp) return _u;
  Vp = 1, Object.defineProperty(_u, "__esModule", { value: true }), _u.restoreFootprint = n;
  var v = e(bn());
  function e(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function n() {
    var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = new v.default.RestoreFootprintOp({ ext: new v.default.ExtensionPoint(0) }), y = { body: v.default.OperationBody.restoreFootprint(s) };
    return this.setSourceAccount(y, i ?? {}), new v.default.Operation(y);
  }
  return _u;
}
var qp;
function hg() {
  return qp || (qp = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true }), Object.defineProperty(v, "accountMerge", { enumerable: true, get: function() {
      return i.accountMerge;
    } }), Object.defineProperty(v, "allowTrust", { enumerable: true, get: function() {
      return s.allowTrust;
    } }), Object.defineProperty(v, "beginSponsoringFutureReserves", { enumerable: true, get: function() {
      return b.beginSponsoringFutureReserves;
    } }), Object.defineProperty(v, "bumpSequence", { enumerable: true, get: function() {
      return y.bumpSequence;
    } }), Object.defineProperty(v, "changeTrust", { enumerable: true, get: function() {
      return t.changeTrust;
    } }), Object.defineProperty(v, "claimClaimableBalance", { enumerable: true, get: function() {
      return c.claimClaimableBalance;
    } }), Object.defineProperty(v, "clawback", { enumerable: true, get: function() {
      return R.clawback;
    } }), Object.defineProperty(v, "clawbackClaimableBalance", { enumerable: true, get: function() {
      return h.clawbackClaimableBalance;
    } }), Object.defineProperty(v, "createAccount", { enumerable: true, get: function() {
      return o.createAccount;
    } }), Object.defineProperty(v, "createClaimableBalance", { enumerable: true, get: function() {
      return u.createClaimableBalance;
    } }), Object.defineProperty(v, "createCustomContract", { enumerable: true, get: function() {
      return I.createCustomContract;
    } }), Object.defineProperty(v, "createPassiveSellOffer", { enumerable: true, get: function() {
      return n.createPassiveSellOffer;
    } }), Object.defineProperty(v, "createStellarAssetContract", { enumerable: true, get: function() {
      return I.createStellarAssetContract;
    } }), Object.defineProperty(v, "endSponsoringFutureReserves", { enumerable: true, get: function() {
      return S.endSponsoringFutureReserves;
    } }), Object.defineProperty(v, "extendFootprintTtl", { enumerable: true, get: function() {
      return q.extendFootprintTtl;
    } }), Object.defineProperty(v, "inflation", { enumerable: true, get: function() {
      return f.inflation;
    } }), Object.defineProperty(v, "invokeContractFunction", { enumerable: true, get: function() {
      return I.invokeContractFunction;
    } }), Object.defineProperty(v, "invokeHostFunction", { enumerable: true, get: function() {
      return I.invokeHostFunction;
    } }), Object.defineProperty(v, "liquidityPoolDeposit", { enumerable: true, get: function() {
      return w.liquidityPoolDeposit;
    } }), Object.defineProperty(v, "liquidityPoolWithdraw", { enumerable: true, get: function() {
      return F.liquidityPoolWithdraw;
    } }), Object.defineProperty(v, "manageBuyOffer", { enumerable: true, get: function() {
      return m.manageBuyOffer;
    } }), Object.defineProperty(v, "manageData", { enumerable: true, get: function() {
      return r.manageData;
    } }), Object.defineProperty(v, "manageSellOffer", { enumerable: true, get: function() {
      return e.manageSellOffer;
    } }), Object.defineProperty(v, "pathPaymentStrictReceive", { enumerable: true, get: function() {
      return g.pathPaymentStrictReceive;
    } }), Object.defineProperty(v, "pathPaymentStrictSend", { enumerable: true, get: function() {
      return a.pathPaymentStrictSend;
    } }), Object.defineProperty(v, "payment", { enumerable: true, get: function() {
      return l.payment;
    } }), Object.defineProperty(v, "restoreFootprint", { enumerable: true, get: function() {
      return D.restoreFootprint;
    } }), Object.defineProperty(v, "revokeAccountSponsorship", { enumerable: true, get: function() {
      return E.revokeAccountSponsorship;
    } }), Object.defineProperty(v, "revokeClaimableBalanceSponsorship", { enumerable: true, get: function() {
      return E.revokeClaimableBalanceSponsorship;
    } }), Object.defineProperty(v, "revokeDataSponsorship", { enumerable: true, get: function() {
      return E.revokeDataSponsorship;
    } }), Object.defineProperty(v, "revokeLiquidityPoolSponsorship", { enumerable: true, get: function() {
      return E.revokeLiquidityPoolSponsorship;
    } }), Object.defineProperty(v, "revokeOfferSponsorship", { enumerable: true, get: function() {
      return E.revokeOfferSponsorship;
    } }), Object.defineProperty(v, "revokeSignerSponsorship", { enumerable: true, get: function() {
      return E.revokeSignerSponsorship;
    } }), Object.defineProperty(v, "revokeTrustlineSponsorship", { enumerable: true, get: function() {
      return E.revokeTrustlineSponsorship;
    } }), Object.defineProperty(v, "setOptions", { enumerable: true, get: function() {
      return d.setOptions;
    } }), Object.defineProperty(v, "setTrustLineFlags", { enumerable: true, get: function() {
      return k.setTrustLineFlags;
    } }), Object.defineProperty(v, "uploadContractWasm", { enumerable: true, get: function() {
      return I.uploadContractWasm;
    } });
    var e = Vy(), n = qy(), i = zy(), s = Hy(), y = Gy(), t = Wy(), o = Ky(), u = Xy(), c = om(), h = $y(), f = Yy(), r = Qy(), m = Zy(), g = Jy(), a = eg(), l = tg(), d = rg(), b = ng(), S = ig(), E = og(), R = ag(), k = sg(), w = ug(), F = cg(), I = lg(), q = fg(), D = pg();
  }($c)), $c;
}
var zp;
function Jl() {
  if (zp) return ki;
  zp = 1, Object.defineProperty(ki, "__esModule", { value: true }), ki.Operation = ki.AuthRevocableFlag = ki.AuthRequiredFlag = ki.AuthImmutableFlag = ki.AuthClawbackEnabledFlag = void 0;
  var v = Ai(), e = g(ua()), n = rm(), i = jy(), s = To(), y = Ql(), t = im(), o = ni(), u = Zl(), c = g(bn()), h = m(hg()), f = $i();
  function r(D) {
    if (typeof WeakMap != "function") return null;
    var H = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
    return (r = function(L) {
      return L ? _ : H;
    })(D);
  }
  function m(D, H) {
    if (D && D.__esModule) return D;
    if (D === null || a(D) != "object" && typeof D != "function") return { default: D };
    var _ = r(H);
    if (_ && _.has(D)) return _.get(D);
    var T = { __proto__: null }, L = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var j in D) if (j !== "default" && {}.hasOwnProperty.call(D, j)) {
      var z = L ? Object.getOwnPropertyDescriptor(D, j) : null;
      z && (z.get || z.set) ? Object.defineProperty(T, j, z) : T[j] = D[j];
    }
    return T.default = D, _ && _.set(D, T), T;
  }
  function g(D) {
    return D && D.__esModule ? D : { default: D };
  }
  function a(D) {
    "@babel/helpers - typeof";
    return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(H) {
      return typeof H;
    } : function(H) {
      return H && typeof Symbol == "function" && H.constructor === Symbol && H !== Symbol.prototype ? "symbol" : typeof H;
    }, a(D);
  }
  function l(D, H) {
    if (!(D instanceof H)) throw new TypeError("Cannot call a class as a function");
  }
  function d(D, H) {
    for (var _ = 0; _ < H.length; _++) {
      var T = H[_];
      T.enumerable = T.enumerable || false, T.configurable = true, "value" in T && (T.writable = true), Object.defineProperty(D, S(T.key), T);
    }
  }
  function b(D, H, _) {
    return _ && d(D, _), Object.defineProperty(D, "prototype", { writable: false }), D;
  }
  function S(D) {
    var H = E(D, "string");
    return a(H) == "symbol" ? H : H + "";
  }
  function E(D, H) {
    if (a(D) != "object" || !D) return D;
    var _ = D[Symbol.toPrimitive];
    if (_ !== void 0) {
      var T = _.call(D, H);
      if (a(T) != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(D);
  }
  var R = 1e7, k = "9223372036854775807";
  ki.AuthRequiredFlag = 1, ki.AuthRevocableFlag = 2, ki.AuthImmutableFlag = 4, ki.AuthClawbackEnabledFlag = 8;
  var w = ki.Operation = function() {
    function D() {
      l(this, D);
    }
    return b(D, null, [{ key: "setSourceAccount", value: function(_, T) {
      if (T.source) try {
        _.sourceAccount = (0, f.decodeAddressToMuxedAccount)(T.source);
      } catch {
        throw new Error("Source address is invalid");
      }
    } }, { key: "fromXDRObject", value: function(_) {
      var T = {};
      _.sourceAccount() && (T.source = (0, f.encodeMuxedAccountToAddress)(_.sourceAccount()));
      var L = _.body().value(), j = _.body().switch().name;
      switch (j) {
        case "createAccount": {
          T.type = "createAccount", T.destination = q(L.destination()), T.startingBalance = this._fromXDRAmount(L.startingBalance());
          break;
        }
        case "payment": {
          T.type = "payment", T.destination = (0, f.encodeMuxedAccountToAddress)(L.destination()), T.asset = s.Asset.fromOperation(L.asset()), T.amount = this._fromXDRAmount(L.amount());
          break;
        }
        case "pathPaymentStrictReceive": {
          T.type = "pathPaymentStrictReceive", T.sendAsset = s.Asset.fromOperation(L.sendAsset()), T.sendMax = this._fromXDRAmount(L.sendMax()), T.destination = (0, f.encodeMuxedAccountToAddress)(L.destination()), T.destAsset = s.Asset.fromOperation(L.destAsset()), T.destAmount = this._fromXDRAmount(L.destAmount()), T.path = [];
          var z = L.path();
          Object.keys(z).forEach(function(oe) {
            T.path.push(s.Asset.fromOperation(z[oe]));
          });
          break;
        }
        case "pathPaymentStrictSend": {
          T.type = "pathPaymentStrictSend", T.sendAsset = s.Asset.fromOperation(L.sendAsset()), T.sendAmount = this._fromXDRAmount(L.sendAmount()), T.destination = (0, f.encodeMuxedAccountToAddress)(L.destination()), T.destAsset = s.Asset.fromOperation(L.destAsset()), T.destMin = this._fromXDRAmount(L.destMin()), T.path = [];
          var Y = L.path();
          Object.keys(Y).forEach(function(oe) {
            T.path.push(s.Asset.fromOperation(Y[oe]));
          });
          break;
        }
        case "changeTrust": {
          switch (T.type = "changeTrust", L.line().switch()) {
            case c.default.AssetType.assetTypePoolShare():
              T.line = y.LiquidityPoolAsset.fromOperation(L.line());
              break;
            default:
              T.line = s.Asset.fromOperation(L.line());
              break;
          }
          T.limit = this._fromXDRAmount(L.limit());
          break;
        }
        case "allowTrust": {
          T.type = "allowTrust", T.trustor = q(L.trustor()), T.assetCode = L.asset().value().toString(), T.assetCode = (0, n.trimEnd)(T.assetCode, "\0"), T.authorize = L.authorize();
          break;
        }
        case "setOptions": {
          if (T.type = "setOptions", L.inflationDest() && (T.inflationDest = q(L.inflationDest())), T.clearFlags = L.clearFlags(), T.setFlags = L.setFlags(), T.masterWeight = L.masterWeight(), T.lowThreshold = L.lowThreshold(), T.medThreshold = L.medThreshold(), T.highThreshold = L.highThreshold(), T.homeDomain = L.homeDomain() !== void 0 ? L.homeDomain().toString("ascii") : void 0, L.signer()) {
            var te = {}, G = L.signer().key().arm();
            if (G === "ed25519") te.ed25519PublicKey = q(L.signer().key());
            else if (G === "preAuthTx") te.preAuthTx = L.signer().key().preAuthTx();
            else if (G === "hashX") te.sha256Hash = L.signer().key().hashX();
            else if (G === "ed25519SignedPayload") {
              var K = L.signer().key().ed25519SignedPayload();
              te.ed25519SignedPayload = o.StrKey.encodeSignedPayload(K.toXDR());
            }
            te.weight = L.signer().weight(), T.signer = te;
          }
          break;
        }
        case "manageOffer":
        case "manageSellOffer": {
          T.type = "manageSellOffer", T.selling = s.Asset.fromOperation(L.selling()), T.buying = s.Asset.fromOperation(L.buying()), T.amount = this._fromXDRAmount(L.amount()), T.price = this._fromXDRPrice(L.price()), T.offerId = L.offerId().toString();
          break;
        }
        case "manageBuyOffer": {
          T.type = "manageBuyOffer", T.selling = s.Asset.fromOperation(L.selling()), T.buying = s.Asset.fromOperation(L.buying()), T.buyAmount = this._fromXDRAmount(L.buyAmount()), T.price = this._fromXDRPrice(L.price()), T.offerId = L.offerId().toString();
          break;
        }
        case "createPassiveOffer":
        case "createPassiveSellOffer": {
          T.type = "createPassiveSellOffer", T.selling = s.Asset.fromOperation(L.selling()), T.buying = s.Asset.fromOperation(L.buying()), T.amount = this._fromXDRAmount(L.amount()), T.price = this._fromXDRPrice(L.price());
          break;
        }
        case "accountMerge": {
          T.type = "accountMerge", T.destination = (0, f.encodeMuxedAccountToAddress)(L);
          break;
        }
        case "manageData": {
          T.type = "manageData", T.name = L.dataName().toString("ascii"), T.value = L.dataValue();
          break;
        }
        case "inflation": {
          T.type = "inflation";
          break;
        }
        case "bumpSequence": {
          T.type = "bumpSequence", T.bumpTo = L.bumpTo().toString();
          break;
        }
        case "createClaimableBalance": {
          T.type = "createClaimableBalance", T.asset = s.Asset.fromOperation(L.asset()), T.amount = this._fromXDRAmount(L.amount()), T.claimants = [], L.claimants().forEach(function(oe) {
            T.claimants.push(t.Claimant.fromXDR(oe));
          });
          break;
        }
        case "claimClaimableBalance": {
          T.type = "claimClaimableBalance", T.balanceId = L.toXDR("hex");
          break;
        }
        case "beginSponsoringFutureReserves": {
          T.type = "beginSponsoringFutureReserves", T.sponsoredId = q(L.sponsoredId());
          break;
        }
        case "endSponsoringFutureReserves": {
          T.type = "endSponsoringFutureReserves";
          break;
        }
        case "revokeSponsorship": {
          F(L, T);
          break;
        }
        case "clawback": {
          T.type = "clawback", T.amount = this._fromXDRAmount(L.amount()), T.from = (0, f.encodeMuxedAccountToAddress)(L.from()), T.asset = s.Asset.fromOperation(L.asset());
          break;
        }
        case "clawbackClaimableBalance": {
          T.type = "clawbackClaimableBalance", T.balanceId = L.toXDR("hex");
          break;
        }
        case "setTrustLineFlags": {
          T.type = "setTrustLineFlags", T.asset = s.Asset.fromOperation(L.asset()), T.trustor = q(L.trustor());
          var J = L.clearFlags(), B = L.setFlags(), Z = { authorized: c.default.TrustLineFlags.authorizedFlag(), authorizedToMaintainLiabilities: c.default.TrustLineFlags.authorizedToMaintainLiabilitiesFlag(), clawbackEnabled: c.default.TrustLineFlags.trustlineClawbackEnabledFlag() }, ie = function(ce) {
            var ye = Z[ce].value;
            if (B & ye) return true;
            if (J & ye) return false;
          };
          T.flags = {}, Object.keys(Z).forEach(function(oe) {
            T.flags[oe] = ie(oe);
          });
          break;
        }
        case "liquidityPoolDeposit": {
          T.type = "liquidityPoolDeposit", T.liquidityPoolId = L.liquidityPoolId().toString("hex"), T.maxAmountA = this._fromXDRAmount(L.maxAmountA()), T.maxAmountB = this._fromXDRAmount(L.maxAmountB()), T.minPrice = this._fromXDRPrice(L.minPrice()), T.maxPrice = this._fromXDRPrice(L.maxPrice());
          break;
        }
        case "liquidityPoolWithdraw": {
          T.type = "liquidityPoolWithdraw", T.liquidityPoolId = L.liquidityPoolId().toString("hex"), T.amount = this._fromXDRAmount(L.amount()), T.minAmountA = this._fromXDRAmount(L.minAmountA()), T.minAmountB = this._fromXDRAmount(L.minAmountB());
          break;
        }
        case "invokeHostFunction": {
          var $;
          T.type = "invokeHostFunction", T.func = L.hostFunction(), T.auth = ($ = L.auth()) !== null && $ !== void 0 ? $ : [];
          break;
        }
        case "extendFootprintTtl": {
          T.type = "extendFootprintTtl", T.extendTo = L.extendTo();
          break;
        }
        case "restoreFootprint": {
          T.type = "restoreFootprint";
          break;
        }
        default:
          throw new Error("Unknown operation: ".concat(j));
      }
      return T;
    } }, { key: "isValidAmount", value: function(_) {
      var T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (typeof _ != "string") return false;
      var L;
      try {
        L = new e.default(_);
      } catch {
        return false;
      }
      return !(!T && L.isZero() || L.isNegative() || L.times(R).gt(new e.default(k).toString()) || L.decimalPlaces() > 7 || L.isNaN() || !L.isFinite());
    } }, { key: "constructAmountRequirementsError", value: function(_) {
      return "".concat(_, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
    } }, { key: "_checkUnsignedIntValue", value: function(_, T) {
      var L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!(typeof T > "u")) switch (typeof T == "string" && (T = parseFloat(T)), true) {
        case (typeof T != "number" || !Number.isFinite(T) || T % 1 !== 0):
          throw new Error("".concat(_, " value is invalid"));
        case T < 0:
          throw new Error("".concat(_, " value must be unsigned"));
        case (!L || L && L(T, _)):
          return T;
        default:
          throw new Error("".concat(_, " value is invalid"));
      }
    } }, { key: "_toXDRAmount", value: function(_) {
      var T = new e.default(_).times(R);
      return v.Hyper.fromString(T.toString());
    } }, { key: "_fromXDRAmount", value: function(_) {
      return new e.default(_).div(R).toFixed(7);
    } }, { key: "_fromXDRPrice", value: function(_) {
      var T = new e.default(_.n());
      return T.div(new e.default(_.d())).toString();
    } }, { key: "_toXDRPrice", value: function(_) {
      var T;
      if (_.n && _.d) T = new c.default.Price(_);
      else {
        var L = (0, i.best_r)(_);
        T = new c.default.Price({ n: parseInt(L[0], 10), d: parseInt(L[1], 10) });
      }
      if (T.n() < 0 || T.d() < 0) throw new Error("price must be positive");
      return T;
    } }]);
  }();
  function F(D, H) {
    switch (D.switch().name) {
      case "revokeSponsorshipLedgerEntry": {
        var _ = D.ledgerKey();
        switch (_.switch().name) {
          case c.default.LedgerEntryType.account().name: {
            H.type = "revokeAccountSponsorship", H.account = q(_.account().accountId());
            break;
          }
          case c.default.LedgerEntryType.trustline().name: {
            H.type = "revokeTrustlineSponsorship", H.account = q(_.trustLine().accountId());
            var T = _.trustLine().asset();
            switch (T.switch()) {
              case c.default.AssetType.assetTypePoolShare():
                H.asset = u.LiquidityPoolId.fromOperation(T);
                break;
              default:
                H.asset = s.Asset.fromOperation(T);
                break;
            }
            break;
          }
          case c.default.LedgerEntryType.offer().name: {
            H.type = "revokeOfferSponsorship", H.seller = q(_.offer().sellerId()), H.offerId = _.offer().offerId().toString();
            break;
          }
          case c.default.LedgerEntryType.data().name: {
            H.type = "revokeDataSponsorship", H.account = q(_.data().accountId()), H.name = _.data().dataName().toString("ascii");
            break;
          }
          case c.default.LedgerEntryType.claimableBalance().name: {
            H.type = "revokeClaimableBalanceSponsorship", H.balanceId = _.claimableBalance().balanceId().toXDR("hex");
            break;
          }
          case c.default.LedgerEntryType.liquidityPool().name: {
            H.type = "revokeLiquidityPoolSponsorship", H.liquidityPoolId = _.liquidityPool().liquidityPoolId().toString("hex");
            break;
          }
          default:
            throw new Error("Unknown ledgerKey: ".concat(D.switch().name));
        }
        break;
      }
      case "revokeSponsorshipSigner": {
        H.type = "revokeSignerSponsorship", H.account = q(D.signer().accountId()), H.signer = I(D.signer().signerKey());
        break;
      }
      default:
        throw new Error("Unknown revokeSponsorship: ".concat(D.switch().name));
    }
  }
  function I(D) {
    var H = {};
    switch (D.switch().name) {
      case c.default.SignerKeyType.signerKeyTypeEd25519().name: {
        H.ed25519PublicKey = o.StrKey.encodeEd25519PublicKey(D.ed25519());
        break;
      }
      case c.default.SignerKeyType.signerKeyTypePreAuthTx().name: {
        H.preAuthTx = D.preAuthTx().toString("hex");
        break;
      }
      case c.default.SignerKeyType.signerKeyTypeHashX().name: {
        H.sha256Hash = D.hashX().toString("hex");
        break;
      }
      default:
        throw new Error("Unknown signerKey: ".concat(D.switch().name));
    }
    return H;
  }
  function q(D) {
    return o.StrKey.encodeEd25519PublicKey(D.ed25519());
  }
  return w.accountMerge = h.accountMerge, w.allowTrust = h.allowTrust, w.bumpSequence = h.bumpSequence, w.changeTrust = h.changeTrust, w.createAccount = h.createAccount, w.createClaimableBalance = h.createClaimableBalance, w.claimClaimableBalance = h.claimClaimableBalance, w.clawbackClaimableBalance = h.clawbackClaimableBalance, w.createPassiveSellOffer = h.createPassiveSellOffer, w.inflation = h.inflation, w.manageData = h.manageData, w.manageSellOffer = h.manageSellOffer, w.manageBuyOffer = h.manageBuyOffer, w.pathPaymentStrictReceive = h.pathPaymentStrictReceive, w.pathPaymentStrictSend = h.pathPaymentStrictSend, w.payment = h.payment, w.setOptions = h.setOptions, w.beginSponsoringFutureReserves = h.beginSponsoringFutureReserves, w.endSponsoringFutureReserves = h.endSponsoringFutureReserves, w.revokeAccountSponsorship = h.revokeAccountSponsorship, w.revokeTrustlineSponsorship = h.revokeTrustlineSponsorship, w.revokeOfferSponsorship = h.revokeOfferSponsorship, w.revokeDataSponsorship = h.revokeDataSponsorship, w.revokeClaimableBalanceSponsorship = h.revokeClaimableBalanceSponsorship, w.revokeLiquidityPoolSponsorship = h.revokeLiquidityPoolSponsorship, w.revokeSignerSponsorship = h.revokeSignerSponsorship, w.clawback = h.clawback, w.setTrustLineFlags = h.setTrustLineFlags, w.liquidityPoolDeposit = h.liquidityPoolDeposit, w.liquidityPoolWithdraw = h.liquidityPoolWithdraw, w.invokeHostFunction = h.invokeHostFunction, w.extendFootprintTtl = h.extendFootprintTtl, w.restoreFootprint = h.restoreFootprint, w.createStellarAssetContract = h.createStellarAssetContract, w.invokeContractFunction = h.invokeContractFunction, w.createCustomContract = h.createCustomContract, w.uploadContractWasm = h.uploadContractWasm, ki;
}
var wi = {}, Hp;
function ef() {
  if (Hp) return wi;
  Hp = 1, Object.defineProperty(wi, "__esModule", { value: true }), wi.MemoText = wi.MemoReturn = wi.MemoNone = wi.MemoID = wi.MemoHash = wi.Memo = void 0;
  var v = Ai(), e = i(ua()), n = i(bn());
  function i(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function s(a) {
    "@babel/helpers - typeof";
    return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, s(a);
  }
  function y(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function t(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, u(b.key), b);
    }
  }
  function o(a, l, d) {
    return l && t(a.prototype, l), d && t(a, d), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function u(a) {
    var l = c(a, "string");
    return s(l) == "symbol" ? l : l + "";
  }
  function c(a, l) {
    if (s(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (s(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  var h = wi.MemoNone = "none", f = wi.MemoID = "id", r = wi.MemoText = "text", m = wi.MemoHash = "hash", g = wi.MemoReturn = "return";
  return wi.Memo = function() {
    function a(l) {
      var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      switch (y(this, a), this._type = l, this._value = d, this._type) {
        case h:
          break;
        case f:
          a._validateIdValue(d);
          break;
        case r:
          a._validateTextValue(d);
          break;
        case m:
        case g:
          a._validateHashValue(d), typeof d == "string" && (this._value = Buffer.from(d, "hex"));
          break;
        default:
          throw new Error("Invalid memo type");
      }
    }
    return o(a, [{ key: "type", get: function() {
      return this._type;
    }, set: function(d) {
      throw new Error("Memo is immutable");
    } }, { key: "value", get: function() {
      switch (this._type) {
        case h:
          return null;
        case f:
        case r:
          return this._value;
        case m:
        case g:
          return Buffer.from(this._value);
        default:
          throw new Error("Invalid memo type");
      }
    }, set: function(d) {
      throw new Error("Memo is immutable");
    } }, { key: "toXDRObject", value: function() {
      switch (this._type) {
        case h:
          return n.default.Memo.memoNone();
        case f:
          return n.default.Memo.memoId(v.UnsignedHyper.fromString(this._value));
        case r:
          return n.default.Memo.memoText(this._value);
        case m:
          return n.default.Memo.memoHash(this._value);
        case g:
          return n.default.Memo.memoReturn(this._value);
        default:
          return null;
      }
    } }], [{ key: "_validateIdValue", value: function(d) {
      var b = new Error("Expects a int64 as a string. Got ".concat(d));
      if (typeof d != "string") throw b;
      var S;
      try {
        S = new e.default(d);
      } catch {
        throw b;
      }
      if (!S.isFinite() || S.isNaN()) throw b;
    } }, { key: "_validateTextValue", value: function(d) {
      if (!n.default.Memo.armTypeForArm("text").isValid(d)) throw new Error("Expects string, array or buffer, max 28 bytes");
    } }, { key: "_validateHashValue", value: function(d) {
      var b = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(d));
      if (d === null || typeof d > "u") throw b;
      var S;
      if (typeof d == "string") {
        if (!/^[0-9A-Fa-f]{64}$/g.test(d)) throw b;
        S = Buffer.from(d, "hex");
      } else if (Buffer.isBuffer(d)) S = Buffer.from(d);
      else throw b;
      if (!S.length || S.length !== 32) throw b;
    } }, { key: "none", value: function() {
      return new a(h);
    } }, { key: "text", value: function(d) {
      return new a(r, d);
    } }, { key: "id", value: function(d) {
      return new a(f, d);
    } }, { key: "hash", value: function(d) {
      return new a(m, d);
    } }, { key: "return", value: function(d) {
      return new a(g, d);
    } }, { key: "fromXDRObject", value: function(d) {
      switch (d.arm()) {
        case "id":
          return a.id(d.value().toString());
        case "text":
          return a.text(d.value());
        case "hash":
          return a.hash(d.value());
        case "retHash":
          return a.return(d.value());
      }
      if (typeof d.value() > "u") return a.none();
      throw new Error("Unknown type");
    } }]);
  }(), wi;
}
var Gp;
function tf() {
  if (Gp) return Ka;
  Gp = 1;
  function v(R) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(k) {
      return typeof k;
    } : function(k) {
      return k && typeof Symbol == "function" && k.constructor === Symbol && k !== Symbol.prototype ? "symbol" : typeof k;
    }, v(R);
  }
  Object.defineProperty(Ka, "__esModule", { value: true }), Ka.Transaction = void 0;
  var e = u(bn()), n = Uo(), i = ni(), s = Jl(), y = ef(), t = Yl(), o = $i();
  function u(R) {
    return R && R.__esModule ? R : { default: R };
  }
  function c(R, k) {
    if (!(R instanceof k)) throw new TypeError("Cannot call a class as a function");
  }
  function h(R, k) {
    for (var w = 0; w < k.length; w++) {
      var F = k[w];
      F.enumerable = F.enumerable || false, F.configurable = true, "value" in F && (F.writable = true), Object.defineProperty(R, r(F.key), F);
    }
  }
  function f(R, k, w) {
    return k && h(R.prototype, k), Object.defineProperty(R, "prototype", { writable: false }), R;
  }
  function r(R) {
    var k = m(R, "string");
    return v(k) == "symbol" ? k : k + "";
  }
  function m(R, k) {
    if (v(R) != "object" || !R) return R;
    var w = R[Symbol.toPrimitive];
    if (w !== void 0) {
      var F = w.call(R, k);
      if (v(F) != "object") return F;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(R);
  }
  function g(R, k, w) {
    return k = b(k), a(R, d() ? Reflect.construct(k, w || [], b(R).constructor) : k.apply(R, w));
  }
  function a(R, k) {
    if (k && (v(k) == "object" || typeof k == "function")) return k;
    if (k !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return l(R);
  }
  function l(R) {
    if (R === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return R;
  }
  function d() {
    try {
      var R = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (d = function() {
      return !!R;
    })();
  }
  function b(R) {
    return b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(k) {
      return k.__proto__ || Object.getPrototypeOf(k);
    }, b(R);
  }
  function S(R, k) {
    if (typeof k != "function" && k !== null) throw new TypeError("Super expression must either be null or a function");
    R.prototype = Object.create(k && k.prototype, { constructor: { value: R, writable: true, configurable: true } }), Object.defineProperty(R, "prototype", { writable: false }), k && E(R, k);
  }
  function E(R, k) {
    return E = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(w, F) {
      return w.__proto__ = F, w;
    }, E(R, k);
  }
  return Ka.Transaction = function(R) {
    function k(w, F) {
      var I;
      if (c(this, k), typeof w == "string") {
        var q = Buffer.from(w, "base64");
        w = e.default.TransactionEnvelope.fromXDR(q);
      }
      var D = w.switch();
      if (!(D === e.default.EnvelopeType.envelopeTypeTxV0() || D === e.default.EnvelopeType.envelopeTypeTx())) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(D.name, "."));
      var H = w.value(), _ = H.tx(), T = _.fee().toString(), L = (H.signatures() || []).slice();
      switch (I = g(this, k, [_, L, T, F]), I._envelopeType = D, I._memo = _.memo(), I._sequence = _.seqNum().toString(), I._envelopeType) {
        case e.default.EnvelopeType.envelopeTypeTxV0():
          I._source = i.StrKey.encodeEd25519PublicKey(I.tx.sourceAccountEd25519());
          break;
        default:
          I._source = (0, o.encodeMuxedAccountToAddress)(I.tx.sourceAccount());
          break;
      }
      var j = null, z = null;
      switch (I._envelopeType) {
        case e.default.EnvelopeType.envelopeTypeTxV0():
          z = _.timeBounds();
          break;
        case e.default.EnvelopeType.envelopeTypeTx():
          switch (_.cond().switch()) {
            case e.default.PreconditionType.precondTime():
              z = _.cond().timeBounds();
              break;
            case e.default.PreconditionType.precondV2():
              j = _.cond().v2(), z = j.timeBounds();
              break;
          }
          break;
      }
      if (z && (I._timeBounds = { minTime: z.minTime().toString(), maxTime: z.maxTime().toString() }), j) {
        var Y = j.ledgerBounds();
        Y && (I._ledgerBounds = { minLedger: Y.minLedger(), maxLedger: Y.maxLedger() });
        var te = j.minSeqNum();
        te && (I._minAccountSequence = te.toString()), I._minAccountSequenceAge = j.minSeqAge(), I._minAccountSequenceLedgerGap = j.minSeqLedgerGap(), I._extraSigners = j.extraSigners();
      }
      var G = _.operations() || [];
      return I._operations = G.map(function(K) {
        return s.Operation.fromXDRObject(K);
      }), I;
    }
    return S(k, R), f(k, [{ key: "timeBounds", get: function() {
      return this._timeBounds;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "ledgerBounds", get: function() {
      return this._ledgerBounds;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "minAccountSequence", get: function() {
      return this._minAccountSequence;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "minAccountSequenceAge", get: function() {
      return this._minAccountSequenceAge;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "minAccountSequenceLedgerGap", get: function() {
      return this._minAccountSequenceLedgerGap;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "extraSigners", get: function() {
      return this._extraSigners;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "sequence", get: function() {
      return this._sequence;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "source", get: function() {
      return this._source;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "operations", get: function() {
      return this._operations;
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "memo", get: function() {
      return y.Memo.fromXDRObject(this._memo);
    }, set: function(F) {
      throw new Error("Transaction is immutable");
    } }, { key: "signatureBase", value: function() {
      var F = this.tx;
      this._envelopeType === e.default.EnvelopeType.envelopeTypeTxV0() && (F = e.default.Transaction.fromXDR(Buffer.concat([e.default.PublicKeyType.publicKeyTypeEd25519().toXDR(), F.toXDR()])));
      var I = new e.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(F), q = new e.default.TransactionSignaturePayload({ networkId: e.default.Hash.fromXDR((0, n.hash)(this.networkPassphrase)), taggedTransaction: I });
      return q.toXDR();
    } }, { key: "toEnvelope", value: function() {
      var F = this.tx.toXDR(), I = this.signatures.slice(), q;
      switch (this._envelopeType) {
        case e.default.EnvelopeType.envelopeTypeTxV0():
          q = new e.default.TransactionEnvelope.envelopeTypeTxV0(new e.default.TransactionV0Envelope({ tx: e.default.TransactionV0.fromXDR(F), signatures: I }));
          break;
        case e.default.EnvelopeType.envelopeTypeTx():
          q = new e.default.TransactionEnvelope.envelopeTypeTx(new e.default.TransactionV1Envelope({ tx: e.default.Transaction.fromXDR(F), signatures: I }));
          break;
        default:
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
      }
      return q;
    } }, { key: "getClaimableBalanceId", value: function(F) {
      if (!Number.isInteger(F) || F < 0 || F >= this.operations.length) throw new RangeError("invalid operation index");
      var I = this.operations[F];
      try {
        I = s.Operation.createClaimableBalance(I);
      } catch (T) {
        throw new TypeError("expected createClaimableBalance, got ".concat(I.type, ": ").concat(T));
      }
      var q = i.StrKey.decodeEd25519PublicKey((0, o.extractBaseAddress)(this.source)), D = e.default.HashIdPreimage.envelopeTypeOpId(new e.default.HashIdPreimageOperationId({ sourceAccount: e.default.AccountId.publicKeyTypeEd25519(q), seqNum: e.default.SequenceNumber.fromString(this.sequence), opNum: F })), H = (0, n.hash)(D.toXDR("raw")), _ = e.default.ClaimableBalanceId.claimableBalanceIdTypeV0(H);
      return _.toXDR("hex");
    } }]);
  }(t.TransactionBase), Ka;
}
var Ja = {}, Wp;
function am() {
  if (Wp) return Ja;
  Wp = 1;
  function v(S) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(E) {
      return typeof E;
    } : function(E) {
      return E && typeof Symbol == "function" && E.constructor === Symbol && E !== Symbol.prototype ? "symbol" : typeof E;
    }, v(S);
  }
  Object.defineProperty(Ja, "__esModule", { value: true }), Ja.FeeBumpTransaction = void 0;
  var e = t(bn()), n = Uo(), i = tf(), s = Yl(), y = $i();
  function t(S) {
    return S && S.__esModule ? S : { default: S };
  }
  function o(S, E) {
    if (!(S instanceof E)) throw new TypeError("Cannot call a class as a function");
  }
  function u(S, E) {
    for (var R = 0; R < E.length; R++) {
      var k = E[R];
      k.enumerable = k.enumerable || false, k.configurable = true, "value" in k && (k.writable = true), Object.defineProperty(S, h(k.key), k);
    }
  }
  function c(S, E, R) {
    return E && u(S.prototype, E), Object.defineProperty(S, "prototype", { writable: false }), S;
  }
  function h(S) {
    var E = f(S, "string");
    return v(E) == "symbol" ? E : E + "";
  }
  function f(S, E) {
    if (v(S) != "object" || !S) return S;
    var R = S[Symbol.toPrimitive];
    if (R !== void 0) {
      var k = R.call(S, E);
      if (v(k) != "object") return k;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(S);
  }
  function r(S, E, R) {
    return E = l(E), m(S, a() ? Reflect.construct(E, R || [], l(S).constructor) : E.apply(S, R));
  }
  function m(S, E) {
    if (E && (v(E) == "object" || typeof E == "function")) return E;
    if (E !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return g(S);
  }
  function g(S) {
    if (S === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return S;
  }
  function a() {
    try {
      var S = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (a = function() {
      return !!S;
    })();
  }
  function l(S) {
    return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(E) {
      return E.__proto__ || Object.getPrototypeOf(E);
    }, l(S);
  }
  function d(S, E) {
    if (typeof E != "function" && E !== null) throw new TypeError("Super expression must either be null or a function");
    S.prototype = Object.create(E && E.prototype, { constructor: { value: S, writable: true, configurable: true } }), Object.defineProperty(S, "prototype", { writable: false }), E && b(S, E);
  }
  function b(S, E) {
    return b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(R, k) {
      return R.__proto__ = k, R;
    }, b(S, E);
  }
  return Ja.FeeBumpTransaction = function(S) {
    function E(R, k) {
      var w;
      if (o(this, E), typeof R == "string") {
        var F = Buffer.from(R, "base64");
        R = e.default.TransactionEnvelope.fromXDR(F);
      }
      var I = R.switch();
      if (I !== e.default.EnvelopeType.envelopeTypeTxFeeBump()) throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(I.name, "."));
      var q = R.value(), D = q.tx(), H = D.fee().toString(), _ = (q.signatures() || []).slice();
      w = r(this, E, [D, _, H, k]);
      var T = e.default.TransactionEnvelope.envelopeTypeTx(D.innerTx().v1());
      return w._feeSource = (0, y.encodeMuxedAccountToAddress)(w.tx.feeSource()), w._innerTransaction = new i.Transaction(T, k), w;
    }
    return d(E, S), c(E, [{ key: "innerTransaction", get: function() {
      return this._innerTransaction;
    } }, { key: "operations", get: function() {
      return this._innerTransaction.operations;
    } }, { key: "feeSource", get: function() {
      return this._feeSource;
    } }, { key: "signatureBase", value: function() {
      var k = new e.default.TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx), w = new e.default.TransactionSignaturePayload({ networkId: e.default.Hash.fromXDR((0, n.hash)(this.networkPassphrase)), taggedTransaction: k });
      return w.toXDR();
    } }, { key: "toEnvelope", value: function() {
      var k = new e.default.FeeBumpTransactionEnvelope({ tx: e.default.FeeBumpTransaction.fromXDR(this.tx.toXDR()), signatures: this.signatures.slice() });
      return new e.default.TransactionEnvelope.envelopeTypeTxFeeBump(k);
    } }]);
  }(s.TransactionBase), Ja;
}
var Zi = {}, es = {}, Kp;
function rf() {
  if (Kp) return es;
  Kp = 1, Object.defineProperty(es, "__esModule", { value: true }), es.Account = void 0;
  var v = n(ua()), e = ni();
  function n(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function i(c) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, i(c);
  }
  function s(c, h) {
    if (!(c instanceof h)) throw new TypeError("Cannot call a class as a function");
  }
  function y(c, h) {
    for (var f = 0; f < h.length; f++) {
      var r = h[f];
      r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(c, o(r.key), r);
    }
  }
  function t(c, h, f) {
    return h && y(c.prototype, h), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function o(c) {
    var h = u(c, "string");
    return i(h) == "symbol" ? h : h + "";
  }
  function u(c, h) {
    if (i(c) != "object" || !c) return c;
    var f = c[Symbol.toPrimitive];
    if (f !== void 0) {
      var r = f.call(c, h);
      if (i(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(c);
  }
  return es.Account = function() {
    function c(h, f) {
      if (s(this, c), e.StrKey.isValidMed25519PublicKey(h)) throw new Error("accountId is an M-address; use MuxedAccount instead");
      if (!e.StrKey.isValidEd25519PublicKey(h)) throw new Error("accountId is invalid");
      if (typeof f != "string") throw new Error("sequence must be of type string");
      this._accountId = h, this.sequence = new v.default(f);
    }
    return t(c, [{ key: "accountId", value: function() {
      return this._accountId;
    } }, { key: "sequenceNumber", value: function() {
      return this.sequence.toString();
    } }, { key: "incrementSequenceNumber", value: function() {
      this.sequence = this.sequence.plus(1);
    } }]);
  }(), es;
}
var ts = {}, Xp;
function sm() {
  if (Xp) return ts;
  Xp = 1, Object.defineProperty(ts, "__esModule", { value: true }), ts.MuxedAccount = void 0;
  var v = s(bn()), e = rf(), n = ni(), i = $i();
  function s(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function y(f) {
    "@babel/helpers - typeof";
    return y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
      return typeof r;
    } : function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, y(f);
  }
  function t(f, r) {
    if (!(f instanceof r)) throw new TypeError("Cannot call a class as a function");
  }
  function o(f, r) {
    for (var m = 0; m < r.length; m++) {
      var g = r[m];
      g.enumerable = g.enumerable || false, g.configurable = true, "value" in g && (g.writable = true), Object.defineProperty(f, c(g.key), g);
    }
  }
  function u(f, r, m) {
    return r && o(f.prototype, r), m && o(f, m), Object.defineProperty(f, "prototype", { writable: false }), f;
  }
  function c(f) {
    var r = h(f, "string");
    return y(r) == "symbol" ? r : r + "";
  }
  function h(f, r) {
    if (y(f) != "object" || !f) return f;
    var m = f[Symbol.toPrimitive];
    if (m !== void 0) {
      var g = m.call(f, r);
      if (y(g) != "object") return g;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(f);
  }
  return ts.MuxedAccount = function() {
    function f(r, m) {
      t(this, f);
      var g = r.accountId();
      if (!n.StrKey.isValidEd25519PublicKey(g)) throw new Error("accountId is invalid");
      this.account = r, this._muxedXdr = (0, i.encodeMuxedAccount)(g, m), this._mAddress = (0, i.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = m;
    }
    return u(f, [{ key: "baseAccount", value: function() {
      return this.account;
    } }, { key: "accountId", value: function() {
      return this._mAddress;
    } }, { key: "id", value: function() {
      return this._id;
    } }, { key: "setId", value: function(m) {
      if (typeof m != "string") throw new Error("id should be a string representing a number (uint64)");
      return this._muxedXdr.med25519().id(v.default.Uint64.fromString(m)), this._mAddress = (0, i.encodeMuxedAccountToAddress)(this._muxedXdr), this._id = m, this;
    } }, { key: "sequenceNumber", value: function() {
      return this.account.sequenceNumber();
    } }, { key: "incrementSequenceNumber", value: function() {
      return this.account.incrementSequenceNumber();
    } }, { key: "toXDRObject", value: function() {
      return this._muxedXdr;
    } }, { key: "equals", value: function(m) {
      return this.accountId() === m.accountId();
    } }], [{ key: "fromAddress", value: function(m, g) {
      var a = (0, i.decodeAddressToMuxedAccount)(m), l = (0, i.extractBaseAddress)(m), d = a.med25519().id().toString();
      return new f(new e.Account(l, g), d);
    } }]);
  }(), ts;
}
var rs = {}, $p;
function um() {
  if ($p) return rs;
  $p = 1, Object.defineProperty(rs, "__esModule", { value: true }), rs.SorobanDataBuilder = void 0;
  var v = e(bn());
  function e(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function n(c) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, n(c);
  }
  function i(c, h) {
    if (!(c instanceof h)) throw new TypeError("Cannot call a class as a function");
  }
  function s(c, h) {
    for (var f = 0; f < h.length; f++) {
      var r = h[f];
      r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(c, o(r.key), r);
    }
  }
  function y(c, h, f) {
    return h && s(c.prototype, h), f && s(c, f), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function t(c, h, f) {
    return (h = o(h)) in c ? Object.defineProperty(c, h, { value: f, enumerable: true, configurable: true, writable: true }) : c[h] = f, c;
  }
  function o(c) {
    var h = u(c, "string");
    return n(h) == "symbol" ? h : h + "";
  }
  function u(c, h) {
    if (n(c) != "object" || !c) return c;
    var f = c[Symbol.toPrimitive];
    if (f !== void 0) {
      var r = f.call(c, h);
      if (n(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(c);
  }
  return rs.SorobanDataBuilder = function() {
    function c(h) {
      i(this, c), t(this, "_data", void 0);
      var f;
      h ? typeof h == "string" || ArrayBuffer.isView(h) ? f = c.fromXDR(h) : f = c.fromXDR(h.toXDR()) : f = new v.default.SorobanTransactionData({ resources: new v.default.SorobanResources({ footprint: new v.default.LedgerFootprint({ readOnly: [], readWrite: [] }), instructions: 0, readBytes: 0, writeBytes: 0 }), ext: new v.default.ExtensionPoint(0), resourceFee: new v.default.Int64(0) }), this._data = f;
    }
    return y(c, [{ key: "setResourceFee", value: function(f) {
      return this._data.resourceFee(new v.default.Int64(f)), this;
    } }, { key: "setResources", value: function(f, r, m) {
      return this._data.resources().instructions(f), this._data.resources().readBytes(r), this._data.resources().writeBytes(m), this;
    } }, { key: "appendFootprint", value: function(f, r) {
      return this.setFootprint(this.getReadOnly().concat(f), this.getReadWrite().concat(r));
    } }, { key: "setFootprint", value: function(f, r) {
      return f !== null && this.setReadOnly(f), r !== null && this.setReadWrite(r), this;
    } }, { key: "setReadOnly", value: function(f) {
      return this._data.resources().footprint().readOnly(f ?? []), this;
    } }, { key: "setReadWrite", value: function(f) {
      return this._data.resources().footprint().readWrite(f ?? []), this;
    } }, { key: "build", value: function() {
      return v.default.SorobanTransactionData.fromXDR(this._data.toXDR());
    } }, { key: "getReadOnly", value: function() {
      return this.getFootprint().readOnly();
    } }, { key: "getReadWrite", value: function() {
      return this.getFootprint().readWrite();
    } }, { key: "getFootprint", value: function() {
      return this._data.resources().footprint();
    } }], [{ key: "fromXDR", value: function(f) {
      return v.default.SorobanTransactionData.fromXDR(f, typeof f == "string" ? "base64" : "raw");
    } }]);
  }(), rs;
}
var ns = {}, Yp;
function cm() {
  if (Yp) return ns;
  Yp = 1, Object.defineProperty(ns, "__esModule", { value: true }), ns.SignerKey = void 0;
  var v = n(bn()), e = ni();
  function n(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function i(c) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, i(c);
  }
  function s(c, h) {
    if (!(c instanceof h)) throw new TypeError("Cannot call a class as a function");
  }
  function y(c, h) {
    for (var f = 0; f < h.length; f++) {
      var r = h[f];
      r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(c, o(r.key), r);
    }
  }
  function t(c, h, f) {
    return f && y(c, f), Object.defineProperty(c, "prototype", { writable: false }), c;
  }
  function o(c) {
    var h = u(c, "string");
    return i(h) == "symbol" ? h : h + "";
  }
  function u(c, h) {
    if (i(c) != "object" || !c) return c;
    var f = c[Symbol.toPrimitive];
    if (f !== void 0) {
      var r = f.call(c, h);
      if (i(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(c);
  }
  return ns.SignerKey = function() {
    function c() {
      s(this, c);
    }
    return t(c, null, [{ key: "decodeAddress", value: function(f) {
      var r = { ed25519PublicKey: v.default.SignerKey.signerKeyTypeEd25519, preAuthTx: v.default.SignerKey.signerKeyTypePreAuthTx, sha256Hash: v.default.SignerKey.signerKeyTypeHashX, signedPayload: v.default.SignerKey.signerKeyTypeEd25519SignedPayload }, m = e.StrKey.getVersionByteForPrefix(f), g = r[m];
      if (!g) throw new Error("invalid signer key type (".concat(m, ")"));
      var a = (0, e.decodeCheck)(m, f);
      switch (m) {
        case "signedPayload":
          return g(new v.default.SignerKeyEd25519SignedPayload({ ed25519: a.slice(0, 32), payload: a.slice(36) }));
        case "ed25519PublicKey":
        case "preAuthTx":
        case "sha256Hash":
        default:
          return g(a);
      }
    } }, { key: "encodeSignerKey", value: function(f) {
      var r, m;
      switch (f.switch()) {
        case v.default.SignerKeyType.signerKeyTypeEd25519():
          r = "ed25519PublicKey", m = f.value();
          break;
        case v.default.SignerKeyType.signerKeyTypePreAuthTx():
          r = "preAuthTx", m = f.value();
          break;
        case v.default.SignerKeyType.signerKeyTypeHashX():
          r = "sha256Hash", m = f.value();
          break;
        case v.default.SignerKeyType.signerKeyTypeEd25519SignedPayload():
          r = "signedPayload", m = f.ed25519SignedPayload().toXDR("raw");
          break;
        default:
          throw new Error("invalid SignerKey (type: ".concat(f.switch(), ")"));
      }
      return (0, e.encodeCheck)(r, m);
    } }]);
  }(), ns;
}
var Qp;
function dg() {
  if (Qp) return Zi;
  Qp = 1, Object.defineProperty(Zi, "__esModule", { value: true }), Zi.TransactionBuilder = Zi.TimeoutInfinite = Zi.BASE_FEE = void 0, Zi.isValidDate = _;
  var v = Ai(), e = r(ua()), n = r(bn()), i = rf(), s = sm(), y = $i(), t = tf(), o = am(), u = um(), c = ni(), h = cm(), f = ef();
  function r(T) {
    return T && T.__esModule ? T : { default: T };
  }
  function m(T) {
    "@babel/helpers - typeof";
    return m = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(L) {
      return typeof L;
    } : function(L) {
      return L && typeof Symbol == "function" && L.constructor === Symbol && L !== Symbol.prototype ? "symbol" : typeof L;
    }, m(T);
  }
  function g(T) {
    return b(T) || d(T) || l(T) || a();
  }
  function a() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function l(T, L) {
    if (T) {
      if (typeof T == "string") return S(T, L);
      var j = {}.toString.call(T).slice(8, -1);
      return j === "Object" && T.constructor && (j = T.constructor.name), j === "Map" || j === "Set" ? Array.from(T) : j === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(j) ? S(T, L) : void 0;
    }
  }
  function d(T) {
    if (typeof Symbol < "u" && T[Symbol.iterator] != null || T["@@iterator"] != null) return Array.from(T);
  }
  function b(T) {
    if (Array.isArray(T)) return S(T);
  }
  function S(T, L) {
    (L == null || L > T.length) && (L = T.length);
    for (var j = 0, z = Array(L); j < L; j++) z[j] = T[j];
    return z;
  }
  function E(T, L) {
    var j = Object.keys(T);
    if (Object.getOwnPropertySymbols) {
      var z = Object.getOwnPropertySymbols(T);
      L && (z = z.filter(function(Y) {
        return Object.getOwnPropertyDescriptor(T, Y).enumerable;
      })), j.push.apply(j, z);
    }
    return j;
  }
  function R(T) {
    for (var L = 1; L < arguments.length; L++) {
      var j = arguments[L] != null ? arguments[L] : {};
      L % 2 ? E(Object(j), true).forEach(function(z) {
        k(T, z, j[z]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(T, Object.getOwnPropertyDescriptors(j)) : E(Object(j)).forEach(function(z) {
        Object.defineProperty(T, z, Object.getOwnPropertyDescriptor(j, z));
      });
    }
    return T;
  }
  function k(T, L, j) {
    return (L = q(L)) in T ? Object.defineProperty(T, L, { value: j, enumerable: true, configurable: true, writable: true }) : T[L] = j, T;
  }
  function w(T, L) {
    if (!(T instanceof L)) throw new TypeError("Cannot call a class as a function");
  }
  function F(T, L) {
    for (var j = 0; j < L.length; j++) {
      var z = L[j];
      z.enumerable = z.enumerable || false, z.configurable = true, "value" in z && (z.writable = true), Object.defineProperty(T, q(z.key), z);
    }
  }
  function I(T, L, j) {
    return L && F(T.prototype, L), j && F(T, j), Object.defineProperty(T, "prototype", { writable: false }), T;
  }
  function q(T) {
    var L = D(T, "string");
    return m(L) == "symbol" ? L : L + "";
  }
  function D(T, L) {
    if (m(T) != "object" || !T) return T;
    var j = T[Symbol.toPrimitive];
    if (j !== void 0) {
      var z = j.call(T, L);
      if (m(z) != "object") return z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(T);
  }
  var H = Zi.BASE_FEE = "100";
  Zi.TimeoutInfinite = 0, Zi.TransactionBuilder = function() {
    function T(L) {
      var j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (w(this, T), !L) throw new Error("must specify source account for the transaction");
      if (j.fee === void 0) throw new Error("must specify fee for the transaction (in stroops)");
      this.source = L, this.operations = [], this.baseFee = j.fee, this.timebounds = j.timebounds ? R({}, j.timebounds) : null, this.ledgerbounds = j.ledgerbounds ? R({}, j.ledgerbounds) : null, this.minAccountSequence = j.minAccountSequence || null, this.minAccountSequenceAge = j.minAccountSequenceAge || null, this.minAccountSequenceLedgerGap = j.minAccountSequenceLedgerGap || null, this.extraSigners = j.extraSigners ? g(j.extraSigners) : null, this.memo = j.memo || f.Memo.none(), this.networkPassphrase = j.networkPassphrase || null, this.sorobanData = j.sorobanData ? new u.SorobanDataBuilder(j.sorobanData).build() : null;
    }
    return I(T, [{ key: "addOperation", value: function(j) {
      return this.operations.push(j), this;
    } }, { key: "addOperationAt", value: function(j, z) {
      return this.operations.splice(z, 0, j), this;
    } }, { key: "clearOperations", value: function() {
      return this.operations = [], this;
    } }, { key: "clearOperationAt", value: function(j) {
      return this.operations.splice(j, 1), this;
    } }, { key: "addMemo", value: function(j) {
      return this.memo = j, this;
    } }, { key: "setTimeout", value: function(j) {
      if (this.timebounds !== null && this.timebounds.maxTime > 0) throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
      if (j < 0) throw new Error("timeout cannot be negative");
      if (j > 0) {
        var z = Math.floor(Date.now() / 1e3) + j;
        this.timebounds === null ? this.timebounds = { minTime: 0, maxTime: z } : this.timebounds = { minTime: this.timebounds.minTime, maxTime: z };
      } else this.timebounds = { minTime: 0, maxTime: 0 };
      return this;
    } }, { key: "setTimebounds", value: function(j, z) {
      if (typeof j == "number" && (j = new Date(j * 1e3)), typeof z == "number" && (z = new Date(z * 1e3)), this.timebounds !== null) throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
      var Y = Math.floor(j.valueOf() / 1e3), te = Math.floor(z.valueOf() / 1e3);
      if (Y < 0) throw new Error("min_time cannot be negative");
      if (te < 0) throw new Error("max_time cannot be negative");
      if (te > 0 && Y > te) throw new Error("min_time cannot be greater than max_time");
      return this.timebounds = { minTime: Y, maxTime: te }, this;
    } }, { key: "setLedgerbounds", value: function(j, z) {
      if (this.ledgerbounds !== null) throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
      if (j < 0) throw new Error("min_ledger cannot be negative");
      if (z < 0) throw new Error("max_ledger cannot be negative");
      if (z > 0 && j > z) throw new Error("min_ledger cannot be greater than max_ledger");
      return this.ledgerbounds = { minLedger: j, maxLedger: z }, this;
    } }, { key: "setMinAccountSequence", value: function(j) {
      if (this.minAccountSequence !== null) throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
      return this.minAccountSequence = j, this;
    } }, { key: "setMinAccountSequenceAge", value: function(j) {
      if (typeof j != "number") throw new Error("min_account_sequence_age must be a number");
      if (this.minAccountSequenceAge !== null) throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
      if (j < 0) throw new Error("min_account_sequence_age cannot be negative");
      return this.minAccountSequenceAge = j, this;
    } }, { key: "setMinAccountSequenceLedgerGap", value: function(j) {
      if (this.minAccountSequenceLedgerGap !== null) throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
      if (j < 0) throw new Error("min_account_sequence_ledger_gap cannot be negative");
      return this.minAccountSequenceLedgerGap = j, this;
    } }, { key: "setExtraSigners", value: function(j) {
      if (!Array.isArray(j)) throw new Error("extra_signers must be an array of strings.");
      if (this.extraSigners !== null) throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
      if (j.length > 2) throw new Error("extra_signers cannot be longer than 2 elements.");
      return this.extraSigners = g(j), this;
    } }, { key: "setNetworkPassphrase", value: function(j) {
      return this.networkPassphrase = j, this;
    } }, { key: "setSorobanData", value: function(j) {
      return this.sorobanData = new u.SorobanDataBuilder(j).build(), this;
    } }, { key: "build", value: function() {
      var j = new e.default(this.source.sequenceNumber()).plus(1), z = new e.default(this.baseFee).times(this.operations.length).toNumber(), Y = { fee: z, seqNum: n.default.SequenceNumber.fromString(j.toString()), memo: this.memo ? this.memo.toXDRObject() : null };
      if (this.timebounds === null || typeof this.timebounds.minTime > "u" || typeof this.timebounds.maxTime > "u") throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
      _(this.timebounds.minTime) && (this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3), _(this.timebounds.maxTime) && (this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3), this.timebounds.minTime = v.UnsignedHyper.fromString(this.timebounds.minTime.toString()), this.timebounds.maxTime = v.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
      var te = new n.default.TimeBounds(this.timebounds);
      if (this.hasV2Preconditions()) {
        var G = null;
        this.ledgerbounds !== null && (G = new n.default.LedgerBounds(this.ledgerbounds));
        var K = this.minAccountSequence || "0";
        K = n.default.SequenceNumber.fromString(K);
        var J = v.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0"), B = this.minAccountSequenceLedgerGap || 0, Z = this.extraSigners !== null ? this.extraSigners.map(h.SignerKey.decodeAddress) : [];
        Y.cond = n.default.Preconditions.precondV2(new n.default.PreconditionsV2({ timeBounds: te, ledgerBounds: G, minSeqNum: K, minSeqAge: J, minSeqLedgerGap: B, extraSigners: Z }));
      } else Y.cond = n.default.Preconditions.precondTime(te);
      Y.sourceAccount = (0, y.decodeAddressToMuxedAccount)(this.source.accountId()), this.sorobanData ? Y.ext = new n.default.TransactionExt(1, this.sorobanData) : Y.ext = new n.default.TransactionExt(0, n.default.Void);
      var ie = new n.default.Transaction(Y);
      ie.operations(this.operations);
      var $ = new n.default.TransactionEnvelope.envelopeTypeTx(new n.default.TransactionV1Envelope({ tx: ie })), oe = new t.Transaction($, this.networkPassphrase);
      return this.source.incrementSequenceNumber(), oe;
    } }, { key: "hasV2Preconditions", value: function() {
      return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
    } }], [{ key: "cloneFrom", value: function(j) {
      var z = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!(j instanceof t.Transaction)) throw new TypeError("expected a 'Transaction', got: ".concat(j));
      var Y = (BigInt(j.sequence) - 1n).toString(), te;
      if (c.StrKey.isValidMed25519PublicKey(j.source)) te = s.MuxedAccount.fromAddress(j.source, Y);
      else if (c.StrKey.isValidEd25519PublicKey(j.source)) te = new i.Account(j.source, Y);
      else throw new TypeError("unsupported tx source account: ".concat(j.source));
      var G = parseInt(j.fee, 10) / j.operations.length, K = new T(te, R({ fee: (G || H).toString(), memo: j.memo, networkPassphrase: j.networkPassphrase, timebounds: j.timeBounds, ledgerbounds: j.ledgerBounds, minAccountSequence: j.minAccountSequence, minAccountSequenceAge: j.minAccountSequenceAge, minAccountSequenceLedgerGap: j.minAccountSequenceLedgerGap, extraSigners: j.extraSigners }, z));
      return j._tx.operations().forEach(function(J) {
        return K.addOperation(J);
      }), K;
    } }, { key: "buildFeeBumpTransaction", value: function(j, z, Y, te) {
      var G = Y.operations.length, K = new e.default(Y.fee).div(G), J = new e.default(z);
      if (J.lt(K)) throw new Error("Invalid baseFee, it should be at least ".concat(K, " stroops."));
      var B = new e.default(H);
      if (J.lt(B)) throw new Error("Invalid baseFee, it should be at least ".concat(B, " stroops."));
      var Z = Y.toEnvelope();
      if (Z.switch() === n.default.EnvelopeType.envelopeTypeTxV0()) {
        var ie = Z.v0().tx(), $ = new n.default.Transaction({ sourceAccount: new n.default.MuxedAccount.keyTypeEd25519(ie.sourceAccountEd25519()), fee: ie.fee(), seqNum: ie.seqNum(), cond: n.default.Preconditions.precondTime(ie.timeBounds()), memo: ie.memo(), operations: ie.operations(), ext: new n.default.TransactionExt(0) });
        Z = new n.default.TransactionEnvelope.envelopeTypeTx(new n.default.TransactionV1Envelope({ tx: $, signatures: Z.v0().signatures() }));
      }
      var oe;
      typeof j == "string" ? oe = (0, y.decodeAddressToMuxedAccount)(j) : oe = j.xdrMuxedAccount();
      var ce = new n.default.FeeBumpTransaction({ feeSource: oe, fee: n.default.Int64.fromString(J.times(G + 1).toString()), innerTx: n.default.FeeBumpTransactionInnerTx.envelopeTypeTx(Z.v1()), ext: new n.default.FeeBumpTransactionExt(0) }), ye = new n.default.FeeBumpTransactionEnvelope({ tx: ce, signatures: [] }), ae = new n.default.TransactionEnvelope.envelopeTypeTxFeeBump(ye);
      return new o.FeeBumpTransaction(ae, te);
    } }, { key: "fromXDR", value: function(j, z) {
      return typeof j == "string" && (j = n.default.TransactionEnvelope.fromXDR(j, "base64")), j.switch() === n.default.EnvelopeType.envelopeTypeTxFeeBump() ? new o.FeeBumpTransaction(j, z) : new t.Transaction(j, z);
    } }]);
  }();
  function _(T) {
    return T instanceof Date && !isNaN(T);
  }
  return Zi;
}
var is = {}, Zp;
function lm() {
  return Zp || (Zp = 1, Object.defineProperty(is, "__esModule", { value: true }), is.Networks = void 0, is.Networks = { PUBLIC: "Public Global Stellar Network ; September 2015", TESTNET: "Test SDF Network ; September 2015", FUTURENET: "Test SDF Future Network ; October 2022", SANDBOX: "Local Sandbox Stellar Network ; September 2022", STANDALONE: "Standalone Network ; February 2017" }), is;
}
var os = {}, Jp;
function mg() {
  if (Jp) return os;
  Jp = 1, Object.defineProperty(os, "__esModule", { value: true }), os.Soroban = void 0;
  function v(r) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, v(r);
  }
  function e(r) {
    return t(r) || y(r) || i(r) || n();
  }
  function n() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function i(r, m) {
    if (r) {
      if (typeof r == "string") return s(r, m);
      var g = {}.toString.call(r).slice(8, -1);
      return g === "Object" && r.constructor && (g = r.constructor.name), g === "Map" || g === "Set" ? Array.from(r) : g === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(g) ? s(r, m) : void 0;
    }
  }
  function s(r, m) {
    (m == null || m > r.length) && (m = r.length);
    for (var g = 0, a = Array(m); g < m; g++) a[g] = r[g];
    return a;
  }
  function y(r) {
    if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r);
  }
  function t(r) {
    if (Array.isArray(r)) return r;
  }
  function o(r, m) {
    if (!(r instanceof m)) throw new TypeError("Cannot call a class as a function");
  }
  function u(r, m) {
    for (var g = 0; g < m.length; g++) {
      var a = m[g];
      a.enumerable = a.enumerable || false, a.configurable = true, "value" in a && (a.writable = true), Object.defineProperty(r, h(a.key), a);
    }
  }
  function c(r, m, g) {
    return g && u(r, g), Object.defineProperty(r, "prototype", { writable: false }), r;
  }
  function h(r) {
    var m = f(r, "string");
    return v(m) == "symbol" ? m : m + "";
  }
  function f(r, m) {
    if (v(r) != "object" || !r) return r;
    var g = r[Symbol.toPrimitive];
    if (g !== void 0) {
      var a = g.call(r, m);
      if (v(a) != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(r);
  }
  return os.Soroban = function() {
    function r() {
      o(this, r);
    }
    return c(r, null, [{ key: "formatTokenAmount", value: function(g, a) {
      if (g.includes(".")) throw new TypeError("No decimals are allowed");
      var l = g;
      return a > 0 && (a > l.length ? l = ["0", l.toString().padStart(a, "0")].join(".") : l = [l.slice(0, -a), l.slice(-a)].join(".")), l.replace(/(\.\d*?)0+$/, "$1");
    } }, { key: "parseTokenAmount", value: function(g, a) {
      var l, d = g.split(".").slice(), b = e(d), S = b[0], E = b[1], R = b.slice(2);
      if (R.length) throw new Error("Invalid decimal value: ".concat(g));
      var k = BigInt(S + ((l = E == null ? void 0 : E.padEnd(a, "0")) !== null && l !== void 0 ? l : "0".repeat(a)));
      return k.toString();
    } }]);
  }(), os;
}
var as = {}, eh;
function fm() {
  if (eh) return as;
  eh = 1, Object.defineProperty(as, "__esModule", { value: true }), as.Contract = void 0;
  var v = Na(), e = Jl(), n = s(bn()), i = ni();
  function s(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function y(f) {
    "@babel/helpers - typeof";
    return y = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(r) {
      return typeof r;
    } : function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, y(f);
  }
  function t(f, r) {
    if (!(f instanceof r)) throw new TypeError("Cannot call a class as a function");
  }
  function o(f, r) {
    for (var m = 0; m < r.length; m++) {
      var g = r[m];
      g.enumerable = g.enumerable || false, g.configurable = true, "value" in g && (g.writable = true), Object.defineProperty(f, c(g.key), g);
    }
  }
  function u(f, r, m) {
    return r && o(f.prototype, r), Object.defineProperty(f, "prototype", { writable: false }), f;
  }
  function c(f) {
    var r = h(f, "string");
    return y(r) == "symbol" ? r : r + "";
  }
  function h(f, r) {
    if (y(f) != "object" || !f) return f;
    var m = f[Symbol.toPrimitive];
    if (m !== void 0) {
      var g = m.call(f, r);
      if (y(g) != "object") return g;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(f);
  }
  return as.Contract = function() {
    function f(r) {
      t(this, f);
      try {
        this._id = i.StrKey.decodeContract(r);
      } catch {
        throw new Error("Invalid contract ID: ".concat(r));
      }
    }
    return u(f, [{ key: "contractId", value: function() {
      return i.StrKey.encodeContract(this._id);
    } }, { key: "toString", value: function() {
      return this.contractId();
    } }, { key: "address", value: function() {
      return v.Address.contract(this._id);
    } }, { key: "call", value: function(m) {
      for (var g = arguments.length, a = new Array(g > 1 ? g - 1 : 0), l = 1; l < g; l++) a[l - 1] = arguments[l];
      return e.Operation.invokeContractFunction({ contract: this.address().toString(), function: m, args: a });
    } }, { key: "getFootprint", value: function() {
      return n.default.LedgerKey.contractData(new n.default.LedgerKeyContractData({ contract: this.address().toScAddress(), key: n.default.ScVal.scvLedgerKeyContractInstance(), durability: n.default.ContractDataDurability.persistent() }));
    } }]);
  }(), as;
}
var Yc = {}, ss = {}, us = {}, th;
function pm() {
  if (th) return us;
  th = 1;
  function v(a) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, v(a);
  }
  Object.defineProperty(us, "__esModule", { value: true }), us.Uint128 = void 0;
  var e = Ai();
  function n(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function i(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, y(b.key), b);
    }
  }
  function s(a, l, d) {
    return l && i(a.prototype, l), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function y(a) {
    var l = t(a, "string");
    return v(l) == "symbol" ? l : l + "";
  }
  function t(a, l) {
    if (v(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (v(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  function o(a, l, d) {
    return l = f(l), u(a, h() ? Reflect.construct(l, d || [], f(a).constructor) : l.apply(a, d));
  }
  function u(a, l) {
    if (l && (v(l) == "object" || typeof l == "function")) return l;
    if (l !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return c(a);
  }
  function c(a) {
    if (a === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return a;
  }
  function h() {
    try {
      var a = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (h = function() {
      return !!a;
    })();
  }
  function f(a) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
      return l.__proto__ || Object.getPrototypeOf(l);
    }, f(a);
  }
  function r(a, l) {
    if (typeof l != "function" && l !== null) throw new TypeError("Super expression must either be null or a function");
    a.prototype = Object.create(l && l.prototype, { constructor: { value: a, writable: true, configurable: true } }), Object.defineProperty(a, "prototype", { writable: false }), l && m(a, l);
  }
  function m(a, l) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, b) {
      return d.__proto__ = b, d;
    }, m(a, l);
  }
  var g = us.Uint128 = function(a) {
    function l() {
      n(this, l);
      for (var d = arguments.length, b = new Array(d), S = 0; S < d; S++) b[S] = arguments[S];
      return o(this, l, [b]);
    }
    return r(l, a), s(l, [{ key: "unsigned", get: function() {
      return true;
    } }, { key: "size", get: function() {
      return 128;
    } }]);
  }(e.LargeInt);
  return g.defineIntBoundaries(), us;
}
var cs = {}, rh;
function hm() {
  if (rh) return cs;
  rh = 1;
  function v(a) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, v(a);
  }
  Object.defineProperty(cs, "__esModule", { value: true }), cs.Uint256 = void 0;
  var e = Ai();
  function n(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function i(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, y(b.key), b);
    }
  }
  function s(a, l, d) {
    return l && i(a.prototype, l), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function y(a) {
    var l = t(a, "string");
    return v(l) == "symbol" ? l : l + "";
  }
  function t(a, l) {
    if (v(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (v(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  function o(a, l, d) {
    return l = f(l), u(a, h() ? Reflect.construct(l, d || [], f(a).constructor) : l.apply(a, d));
  }
  function u(a, l) {
    if (l && (v(l) == "object" || typeof l == "function")) return l;
    if (l !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return c(a);
  }
  function c(a) {
    if (a === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return a;
  }
  function h() {
    try {
      var a = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (h = function() {
      return !!a;
    })();
  }
  function f(a) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
      return l.__proto__ || Object.getPrototypeOf(l);
    }, f(a);
  }
  function r(a, l) {
    if (typeof l != "function" && l !== null) throw new TypeError("Super expression must either be null or a function");
    a.prototype = Object.create(l && l.prototype, { constructor: { value: a, writable: true, configurable: true } }), Object.defineProperty(a, "prototype", { writable: false }), l && m(a, l);
  }
  function m(a, l) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, b) {
      return d.__proto__ = b, d;
    }, m(a, l);
  }
  var g = cs.Uint256 = function(a) {
    function l() {
      n(this, l);
      for (var d = arguments.length, b = new Array(d), S = 0; S < d; S++) b[S] = arguments[S];
      return o(this, l, [b]);
    }
    return r(l, a), s(l, [{ key: "unsigned", get: function() {
      return true;
    } }, { key: "size", get: function() {
      return 256;
    } }]);
  }(e.LargeInt);
  return g.defineIntBoundaries(), cs;
}
var ls = {}, nh;
function dm() {
  if (nh) return ls;
  nh = 1;
  function v(a) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, v(a);
  }
  Object.defineProperty(ls, "__esModule", { value: true }), ls.Int128 = void 0;
  var e = Ai();
  function n(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function i(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, y(b.key), b);
    }
  }
  function s(a, l, d) {
    return l && i(a.prototype, l), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function y(a) {
    var l = t(a, "string");
    return v(l) == "symbol" ? l : l + "";
  }
  function t(a, l) {
    if (v(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (v(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  function o(a, l, d) {
    return l = f(l), u(a, h() ? Reflect.construct(l, d || [], f(a).constructor) : l.apply(a, d));
  }
  function u(a, l) {
    if (l && (v(l) == "object" || typeof l == "function")) return l;
    if (l !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return c(a);
  }
  function c(a) {
    if (a === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return a;
  }
  function h() {
    try {
      var a = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (h = function() {
      return !!a;
    })();
  }
  function f(a) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
      return l.__proto__ || Object.getPrototypeOf(l);
    }, f(a);
  }
  function r(a, l) {
    if (typeof l != "function" && l !== null) throw new TypeError("Super expression must either be null or a function");
    a.prototype = Object.create(l && l.prototype, { constructor: { value: a, writable: true, configurable: true } }), Object.defineProperty(a, "prototype", { writable: false }), l && m(a, l);
  }
  function m(a, l) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, b) {
      return d.__proto__ = b, d;
    }, m(a, l);
  }
  var g = ls.Int128 = function(a) {
    function l() {
      n(this, l);
      for (var d = arguments.length, b = new Array(d), S = 0; S < d; S++) b[S] = arguments[S];
      return o(this, l, [b]);
    }
    return r(l, a), s(l, [{ key: "unsigned", get: function() {
      return false;
    } }, { key: "size", get: function() {
      return 128;
    } }]);
  }(e.LargeInt);
  return g.defineIntBoundaries(), ls;
}
var fs = {}, ih;
function mm() {
  if (ih) return fs;
  ih = 1;
  function v(a) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, v(a);
  }
  Object.defineProperty(fs, "__esModule", { value: true }), fs.Int256 = void 0;
  var e = Ai();
  function n(a, l) {
    if (!(a instanceof l)) throw new TypeError("Cannot call a class as a function");
  }
  function i(a, l) {
    for (var d = 0; d < l.length; d++) {
      var b = l[d];
      b.enumerable = b.enumerable || false, b.configurable = true, "value" in b && (b.writable = true), Object.defineProperty(a, y(b.key), b);
    }
  }
  function s(a, l, d) {
    return l && i(a.prototype, l), Object.defineProperty(a, "prototype", { writable: false }), a;
  }
  function y(a) {
    var l = t(a, "string");
    return v(l) == "symbol" ? l : l + "";
  }
  function t(a, l) {
    if (v(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (v(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(a);
  }
  function o(a, l, d) {
    return l = f(l), u(a, h() ? Reflect.construct(l, d || [], f(a).constructor) : l.apply(a, d));
  }
  function u(a, l) {
    if (l && (v(l) == "object" || typeof l == "function")) return l;
    if (l !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return c(a);
  }
  function c(a) {
    if (a === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return a;
  }
  function h() {
    try {
      var a = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (h = function() {
      return !!a;
    })();
  }
  function f(a) {
    return f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
      return l.__proto__ || Object.getPrototypeOf(l);
    }, f(a);
  }
  function r(a, l) {
    if (typeof l != "function" && l !== null) throw new TypeError("Super expression must either be null or a function");
    a.prototype = Object.create(l && l.prototype, { constructor: { value: a, writable: true, configurable: true } }), Object.defineProperty(a, "prototype", { writable: false }), l && m(a, l);
  }
  function m(a, l) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(d, b) {
      return d.__proto__ = b, d;
    }, m(a, l);
  }
  var g = fs.Int256 = function(a) {
    function l() {
      n(this, l);
      for (var d = arguments.length, b = new Array(d), S = 0; S < d; S++) b[S] = arguments[S];
      return o(this, l, [b]);
    }
    return r(l, a), s(l, [{ key: "unsigned", get: function() {
      return false;
    } }, { key: "size", get: function() {
      return 256;
    } }]);
  }(e.LargeInt);
  return g.defineIntBoundaries(), fs;
}
var oh;
function ym() {
  if (oh) return ss;
  oh = 1, Object.defineProperty(ss, "__esModule", { value: true }), ss.XdrLargeInt = void 0;
  var v = Ai(), e = pm(), n = hm(), i = dm(), s = mm(), y = t(bn());
  function t(g) {
    return g && g.__esModule ? g : { default: g };
  }
  function o(g) {
    "@babel/helpers - typeof";
    return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(a) {
      return typeof a;
    } : function(a) {
      return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
    }, o(g);
  }
  function u(g, a) {
    if (!(g instanceof a)) throw new TypeError("Cannot call a class as a function");
  }
  function c(g, a) {
    for (var l = 0; l < a.length; l++) {
      var d = a[l];
      d.enumerable = d.enumerable || false, d.configurable = true, "value" in d && (d.writable = true), Object.defineProperty(g, r(d.key), d);
    }
  }
  function h(g, a, l) {
    return a && c(g.prototype, a), l && c(g, l), Object.defineProperty(g, "prototype", { writable: false }), g;
  }
  function f(g, a, l) {
    return (a = r(a)) in g ? Object.defineProperty(g, a, { value: l, enumerable: true, configurable: true, writable: true }) : g[a] = l, g;
  }
  function r(g) {
    var a = m(g, "string");
    return o(a) == "symbol" ? a : a + "";
  }
  function m(g, a) {
    if (o(g) != "object" || !g) return g;
    var l = g[Symbol.toPrimitive];
    if (l !== void 0) {
      var d = l.call(g, a);
      if (o(d) != "object") return d;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(g);
  }
  return ss.XdrLargeInt = function() {
    function g(a, l) {
      switch (u(this, g), f(this, "int", void 0), f(this, "type", void 0), l instanceof Array || (l = [l]), l = l.map(function(d) {
        return typeof d == "bigint" ? d : d instanceof g ? d.toBigInt() : BigInt(d);
      }), a) {
        case "i64":
          this.int = new v.Hyper(l);
          break;
        case "i128":
          this.int = new i.Int128(l);
          break;
        case "i256":
          this.int = new s.Int256(l);
          break;
        case "u64":
          this.int = new v.UnsignedHyper(l);
          break;
        case "u128":
          this.int = new e.Uint128(l);
          break;
        case "u256":
          this.int = new n.Uint256(l);
          break;
        default:
          throw TypeError("invalid type: ".concat(a));
      }
      this.type = a;
    }
    return h(g, [{ key: "toNumber", value: function() {
      var l = this.int.toBigInt();
      if (l > Number.MAX_SAFE_INTEGER || l < Number.MIN_SAFE_INTEGER) throw RangeError("value ".concat(l, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
      return Number(l);
    } }, { key: "toBigInt", value: function() {
      return this.int.toBigInt();
    } }, { key: "toI64", value: function() {
      this._sizeCheck(64);
      var l = this.toBigInt();
      if (BigInt.asIntN(64, l) !== l) throw RangeError("value too large for i64: ".concat(l));
      return y.default.ScVal.scvI64(new y.default.Int64(l));
    } }, { key: "toU64", value: function() {
      return this._sizeCheck(64), y.default.ScVal.scvU64(new y.default.Uint64(BigInt.asUintN(64, this.toBigInt())));
    } }, { key: "toI128", value: function() {
      this._sizeCheck(128);
      var l = this.int.toBigInt(), d = BigInt.asIntN(64, l >> 64n), b = BigInt.asUintN(64, l);
      return y.default.ScVal.scvI128(new y.default.Int128Parts({ hi: new y.default.Int64(d), lo: new y.default.Uint64(b) }));
    } }, { key: "toU128", value: function() {
      this._sizeCheck(128);
      var l = this.int.toBigInt();
      return y.default.ScVal.scvU128(new y.default.UInt128Parts({ hi: new y.default.Uint64(BigInt.asUintN(64, l >> 64n)), lo: new y.default.Uint64(BigInt.asUintN(64, l)) }));
    } }, { key: "toI256", value: function() {
      var l = this.int.toBigInt(), d = BigInt.asIntN(64, l >> 192n), b = BigInt.asUintN(64, l >> 128n), S = BigInt.asUintN(64, l >> 64n), E = BigInt.asUintN(64, l);
      return y.default.ScVal.scvI256(new y.default.Int256Parts({ hiHi: new y.default.Int64(d), hiLo: new y.default.Uint64(b), loHi: new y.default.Uint64(S), loLo: new y.default.Uint64(E) }));
    } }, { key: "toU256", value: function() {
      var l = this.int.toBigInt(), d = BigInt.asUintN(64, l >> 192n), b = BigInt.asUintN(64, l >> 128n), S = BigInt.asUintN(64, l >> 64n), E = BigInt.asUintN(64, l);
      return y.default.ScVal.scvU256(new y.default.UInt256Parts({ hiHi: new y.default.Uint64(d), hiLo: new y.default.Uint64(b), loHi: new y.default.Uint64(S), loLo: new y.default.Uint64(E) }));
    } }, { key: "toScVal", value: function() {
      switch (this.type) {
        case "i64":
          return this.toI64();
        case "i128":
          return this.toI128();
        case "i256":
          return this.toI256();
        case "u64":
          return this.toU64();
        case "u128":
          return this.toU128();
        case "u256":
          return this.toU256();
        default:
          throw TypeError("invalid type: ".concat(this.type));
      }
    } }, { key: "valueOf", value: function() {
      return this.int.valueOf();
    } }, { key: "toString", value: function() {
      return this.int.toString();
    } }, { key: "toJSON", value: function() {
      return { value: this.toBigInt().toString(), type: this.type };
    } }, { key: "_sizeCheck", value: function(l) {
      if (this.int.size > l) throw RangeError("value too large for ".concat(l, " bits (").concat(this.type, ")"));
    } }], [{ key: "isType", value: function(l) {
      switch (l) {
        case "i64":
        case "i128":
        case "i256":
        case "u64":
        case "u128":
        case "u256":
          return true;
        default:
          return false;
      }
    } }, { key: "getType", value: function(l) {
      return l.slice(3).toLowerCase();
    } }]);
  }(), ss;
}
var ps = {}, ah;
function yg() {
  if (ah) return ps;
  ah = 1;
  function v(r) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, v(r);
  }
  Object.defineProperty(ps, "__esModule", { value: true }), ps.ScInt = void 0;
  var e = ym();
  function n(r, m, g) {
    return Object.defineProperty(r, "prototype", { writable: false }), r;
  }
  function i(r, m) {
    if (!(r instanceof m)) throw new TypeError("Cannot call a class as a function");
  }
  function s(r, m, g) {
    return m = u(m), y(r, o() ? Reflect.construct(m, g || [], u(r).constructor) : m.apply(r, g));
  }
  function y(r, m) {
    if (m && (v(m) == "object" || typeof m == "function")) return m;
    if (m !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return t(r);
  }
  function t(r) {
    if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r;
  }
  function o() {
    try {
      var r = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (o = function() {
      return !!r;
    })();
  }
  function u(r) {
    return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(m) {
      return m.__proto__ || Object.getPrototypeOf(m);
    }, u(r);
  }
  function c(r, m) {
    if (typeof m != "function" && m !== null) throw new TypeError("Super expression must either be null or a function");
    r.prototype = Object.create(m && m.prototype, { constructor: { value: r, writable: true, configurable: true } }), Object.defineProperty(r, "prototype", { writable: false }), m && h(r, m);
  }
  function h(r, m) {
    return h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(g, a) {
      return g.__proto__ = a, g;
    }, h(r, m);
  }
  ps.ScInt = function(r) {
    function m(g, a) {
      var l;
      i(this, m);
      var d = g < 0, b = (l = a == null ? void 0 : a.type) !== null && l !== void 0 ? l : "";
      if (b.startsWith("u") && d) throw TypeError("specified type ".concat(a.type, " yet negative (").concat(g, ")"));
      if (b === "") {
        b = d ? "i" : "u";
        var S = f(g);
        switch (S) {
          case 64:
          case 128:
          case 256:
            b += S.toString();
            break;
          default:
            throw RangeError("expected 64/128/256 bits for input (".concat(g, "), got ").concat(S));
        }
      }
      return s(this, m, [b, g]);
    }
    return c(m, r), n(m);
  }(e.XdrLargeInt);
  function f(r) {
    var m, g = r.toString(2).length;
    return (m = [64, 128, 256].find(function(a) {
      return g <= a;
    })) !== null && m !== void 0 ? m : g;
  }
  return ps;
}
var sh;
function gm() {
  return sh || (sh = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true }), Object.defineProperty(v, "Int128", { enumerable: true, get: function() {
      return s.Int128;
    } }), Object.defineProperty(v, "Int256", { enumerable: true, get: function() {
      return y.Int256;
    } }), Object.defineProperty(v, "ScInt", { enumerable: true, get: function() {
      return t.ScInt;
    } }), Object.defineProperty(v, "Uint128", { enumerable: true, get: function() {
      return n.Uint128;
    } }), Object.defineProperty(v, "Uint256", { enumerable: true, get: function() {
      return i.Uint256;
    } }), Object.defineProperty(v, "XdrLargeInt", { enumerable: true, get: function() {
      return e.XdrLargeInt;
    } }), v.scValToBigInt = o;
    var e = ym(), n = pm(), i = hm(), s = dm(), y = mm(), t = yg();
    function o(u) {
      var c = e.XdrLargeInt.getType(u.switch().name);
      switch (u.switch().name) {
        case "scvU32":
        case "scvI32":
          return BigInt(u.value());
        case "scvU64":
        case "scvI64":
          return new e.XdrLargeInt(c, u.value()).toBigInt();
        case "scvU128":
        case "scvI128":
          return new e.XdrLargeInt(c, [u.value().lo(), u.value().hi()]).toBigInt();
        case "scvU256":
        case "scvI256":
          return new e.XdrLargeInt(c, [u.value().loLo(), u.value().loHi(), u.value().hiLo(), u.value().hiHi()]).toBigInt();
        default:
          throw TypeError("expected integer type, got ".concat(u.switch()));
      }
    }
  }(Yc)), Yc;
}
var hs = {}, uh;
function Ec() {
  if (uh) return hs;
  uh = 1, Object.defineProperty(hs, "__esModule", { value: true }), hs.nativeToScVal = m, hs.scValToNative = g;
  var v = y(bn()), e = Ii(), n = Na(), i = fm(), s = gm();
  function y(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function t(a, l) {
    return f(a) || h(a, l) || u(a, l) || o();
  }
  function o() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function u(a, l) {
    if (a) {
      if (typeof a == "string") return c(a, l);
      var d = {}.toString.call(a).slice(8, -1);
      return d === "Object" && a.constructor && (d = a.constructor.name), d === "Map" || d === "Set" ? Array.from(a) : d === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d) ? c(a, l) : void 0;
    }
  }
  function c(a, l) {
    (l == null || l > a.length) && (l = a.length);
    for (var d = 0, b = Array(l); d < l; d++) b[d] = a[d];
    return b;
  }
  function h(a, l) {
    var d = a == null ? null : typeof Symbol < "u" && a[Symbol.iterator] || a["@@iterator"];
    if (d != null) {
      var b, S, E, R, k = [], w = true, F = false;
      try {
        if (E = (d = d.call(a)).next, l === 0) {
          if (Object(d) !== d) return;
          w = false;
        } else for (; !(w = (b = E.call(d)).done) && (k.push(b.value), k.length !== l); w = true) ;
      } catch (I) {
        F = true, S = I;
      } finally {
        try {
          if (!w && d.return != null && (R = d.return(), Object(R) !== R)) return;
        } finally {
          if (F) throw S;
        }
      }
      return k;
    }
  }
  function f(a) {
    if (Array.isArray(a)) return a;
  }
  function r(a) {
    "@babel/helpers - typeof";
    return r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, r(a);
  }
  function m(a) {
    var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (r(a)) {
      case "object": {
        var d, b;
        if (a === null) return v.default.ScVal.scvVoid();
        if (a instanceof v.default.ScVal) return a;
        if (a instanceof n.Address) return a.toScVal();
        if (a instanceof e.Keypair) return m(a.publicKey(), { type: "address" });
        if (a instanceof i.Contract) return a.address().toScVal();
        if (a instanceof Uint8Array || Buffer.isBuffer(a)) {
          var S, E = Uint8Array.from(a);
          switch ((S = l == null ? void 0 : l.type) !== null && S !== void 0 ? S : "bytes") {
            case "bytes":
              return v.default.ScVal.scvBytes(E);
            case "symbol":
              return v.default.ScVal.scvSymbol(E);
            case "string":
              return v.default.ScVal.scvString(E);
            default:
              throw new TypeError("invalid type (".concat(l.type, ") specified for bytes-like value"));
          }
        }
        if (Array.isArray(a)) return v.default.ScVal.scvVec(a.map(function(F) {
          return m(F, l);
        }));
        if (((d = (b = a.constructor) === null || b === void 0 ? void 0 : b.name) !== null && d !== void 0 ? d : "") !== "Object") {
          var R;
          throw new TypeError("cannot interpret ".concat((R = a.constructor) === null || R === void 0 ? void 0 : R.name, " value as ScVal (").concat(JSON.stringify(a), ")"));
        }
        return v.default.ScVal.scvMap(Object.entries(a).sort(function(F, I) {
          var q = t(F, 1), D = q[0], H = t(I, 1), _ = H[0];
          return D.localeCompare(_);
        }).map(function(F) {
          var I, q, D = t(F, 2), H = D[0], _ = D[1], T = (I = ((q = l == null ? void 0 : l.type) !== null && q !== void 0 ? q : {})[H]) !== null && I !== void 0 ? I : [null, null], L = t(T, 2), j = L[0], z = L[1], Y = j ? { type: j } : {}, te = z ? { type: z } : {};
          return new v.default.ScMapEntry({ key: m(H, Y), val: m(_, te) });
        }));
      }
      case "number":
      case "bigint":
        switch (l == null ? void 0 : l.type) {
          case "u32":
            return v.default.ScVal.scvU32(a);
          case "i32":
            return v.default.ScVal.scvI32(a);
        }
        return new s.ScInt(a, { type: l == null ? void 0 : l.type }).toScVal();
      case "string": {
        var k, w = (k = l == null ? void 0 : l.type) !== null && k !== void 0 ? k : "string";
        switch (w) {
          case "string":
            return v.default.ScVal.scvString(a);
          case "symbol":
            return v.default.ScVal.scvSymbol(a);
          case "address":
            return new n.Address(a).toScVal();
          case "u32":
            return v.default.ScVal.scvU32(parseInt(a, 10));
          case "i32":
            return v.default.ScVal.scvI32(parseInt(a, 10));
          default:
            if (s.XdrLargeInt.isType(w)) return new s.XdrLargeInt(w, a).toScVal();
            throw new TypeError("invalid type (".concat(l.type, ") specified for string value"));
        }
      }
      case "boolean":
        return v.default.ScVal.scvBool(a);
      case "undefined":
        return v.default.ScVal.scvVoid();
      case "function":
        return m(a());
      default:
        throw new TypeError("failed to convert typeof ".concat(r(a), " (").concat(a, ")"));
    }
  }
  function g(a) {
    var l, d;
    switch (a.switch().value) {
      case v.default.ScValType.scvVoid().value:
        return null;
      case v.default.ScValType.scvU64().value:
      case v.default.ScValType.scvI64().value:
        return a.value().toBigInt();
      case v.default.ScValType.scvU128().value:
      case v.default.ScValType.scvI128().value:
      case v.default.ScValType.scvU256().value:
      case v.default.ScValType.scvI256().value:
        return (0, s.scValToBigInt)(a);
      case v.default.ScValType.scvVec().value:
        return ((l = a.vec()) !== null && l !== void 0 ? l : []).map(g);
      case v.default.ScValType.scvAddress().value:
        return n.Address.fromScVal(a).toString();
      case v.default.ScValType.scvMap().value:
        return Object.fromEntries(((d = a.map()) !== null && d !== void 0 ? d : []).map(function(E) {
          return [g(E.key()), g(E.val())];
        }));
      case v.default.ScValType.scvBool().value:
      case v.default.ScValType.scvU32().value:
      case v.default.ScValType.scvI32().value:
      case v.default.ScValType.scvBytes().value:
        return a.value();
      case v.default.ScValType.scvSymbol().value:
      case v.default.ScValType.scvString().value: {
        var b = a.value();
        if (Buffer.isBuffer(b) || ArrayBuffer.isView(b)) try {
          return new TextDecoder().decode(b);
        } catch {
          return new Uint8Array(b.buffer);
        }
        return b;
      }
      case v.default.ScValType.scvTimepoint().value:
      case v.default.ScValType.scvDuration().value:
        return new v.default.Uint64(a.value()).toBigInt();
      case v.default.ScValType.scvError().value:
        switch (a.error().switch().value) {
          case v.default.ScErrorType.sceContract().value:
            return { type: "contract", code: a.error().contractCode() };
          default: {
            var S = a.error();
            return { type: "system", code: S.code().value, value: S.code().name };
          }
        }
      default:
        return a.value();
    }
  }
  return v.default.scvSortedMap = function(a) {
    var l = Array.from(a).sort(function(d, b) {
      var S = g(d.key()), E = g(b.key());
      switch (r(S)) {
        case "number":
        case "bigint":
          return S < E ? -1 : 1;
        default:
          return S.toString().localeCompare(E.toString());
      }
    });
    return v.default.ScVal.scvMap(l);
  }, hs;
}
var Eu = {}, ch;
function gg() {
  if (ch) return Eu;
  ch = 1, Object.defineProperty(Eu, "__esModule", { value: true }), Eu.humanizeEvents = u;
  var v = ni(), e = Ec();
  function n(h) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(f) {
      return typeof f;
    } : function(f) {
      return f && typeof Symbol == "function" && f.constructor === Symbol && f !== Symbol.prototype ? "symbol" : typeof f;
    }, n(h);
  }
  function i(h, f) {
    var r = Object.keys(h);
    if (Object.getOwnPropertySymbols) {
      var m = Object.getOwnPropertySymbols(h);
      f && (m = m.filter(function(g) {
        return Object.getOwnPropertyDescriptor(h, g).enumerable;
      })), r.push.apply(r, m);
    }
    return r;
  }
  function s(h) {
    for (var f = 1; f < arguments.length; f++) {
      var r = arguments[f] != null ? arguments[f] : {};
      f % 2 ? i(Object(r), true).forEach(function(m) {
        y(h, m, r[m]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(h, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(function(m) {
        Object.defineProperty(h, m, Object.getOwnPropertyDescriptor(r, m));
      });
    }
    return h;
  }
  function y(h, f, r) {
    return (f = t(f)) in h ? Object.defineProperty(h, f, { value: r, enumerable: true, configurable: true, writable: true }) : h[f] = r, h;
  }
  function t(h) {
    var f = o(h, "string");
    return n(f) == "symbol" ? f : f + "";
  }
  function o(h, f) {
    if (n(h) != "object" || !h) return h;
    var r = h[Symbol.toPrimitive];
    if (r !== void 0) {
      var m = r.call(h, f);
      if (n(m) != "object") return m;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (f === "string" ? String : Number)(h);
  }
  function u(h) {
    return h.map(function(f) {
      return f.inSuccessfulContractCall ? c(f.event()) : c(f);
    });
  }
  function c(h) {
    return s(s({}, typeof h.contractId == "function" && h.contractId() != null && { contractId: v.StrKey.encodeContract(h.contractId()) }), {}, { type: h.type().name, topics: h.body().value().topics().map(function(f) {
      return (0, e.scValToNative)(f);
    }), data: (0, e.scValToNative)(h.body().value().data()) });
  }
  return Eu;
}
var ds = {}, lh;
function vg() {
  if (lh) return ds;
  lh = 1, Object.defineProperty(ds, "__esModule", { value: true }), ds.authorizeEntry = r, ds.authorizeInvocation = g;
  var v = o(bn()), e = Ii(), n = ni(), i = lm(), s = Uo(), y = Na(), t = Ec();
  function o(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function u(l) {
    "@babel/helpers - typeof";
    return u = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
      return typeof d;
    } : function(d) {
      return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
    }, u(l);
  }
  function c() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    c = function() {
      return d;
    };
    var l, d = {}, b = Object.prototype, S = b.hasOwnProperty, E = Object.defineProperty || function(ne, ge, Te) {
      ne[ge] = Te.value;
    }, R = typeof Symbol == "function" ? Symbol : {}, k = R.iterator || "@@iterator", w = R.asyncIterator || "@@asyncIterator", F = R.toStringTag || "@@toStringTag";
    function I(ne, ge, Te) {
      return Object.defineProperty(ne, ge, { value: Te, enumerable: true, configurable: true, writable: true }), ne[ge];
    }
    try {
      I({}, "");
    } catch {
      I = function(Te, pe, Oe) {
        return Te[pe] = Oe;
      };
    }
    function q(ne, ge, Te, pe) {
      var Oe = ge && ge.prototype instanceof z ? ge : z, xe = Object.create(Oe.prototype), Ve = new ae(pe || []);
      return E(xe, "_invoke", { value: $(ne, Te, Ve) }), xe;
    }
    function D(ne, ge, Te) {
      try {
        return { type: "normal", arg: ne.call(ge, Te) };
      } catch (pe) {
        return { type: "throw", arg: pe };
      }
    }
    d.wrap = q;
    var H = "suspendedStart", _ = "suspendedYield", T = "executing", L = "completed", j = {};
    function z() {
    }
    function Y() {
    }
    function te() {
    }
    var G = {};
    I(G, k, function() {
      return this;
    });
    var K = Object.getPrototypeOf, J = K && K(K(ue([])));
    J && J !== b && S.call(J, k) && (G = J);
    var B = te.prototype = z.prototype = Object.create(G);
    function Z(ne) {
      ["next", "throw", "return"].forEach(function(ge) {
        I(ne, ge, function(Te) {
          return this._invoke(ge, Te);
        });
      });
    }
    function ie(ne, ge) {
      function Te(Oe, xe, Ve, _e) {
        var Be = D(ne[Oe], ne, xe);
        if (Be.type !== "throw") {
          var Qe = Be.arg, ee = Qe.value;
          return ee && u(ee) == "object" && S.call(ee, "__await") ? ge.resolve(ee.__await).then(function(P) {
            Te("next", P, Ve, _e);
          }, function(P) {
            Te("throw", P, Ve, _e);
          }) : ge.resolve(ee).then(function(P) {
            Qe.value = P, Ve(Qe);
          }, function(P) {
            return Te("throw", P, Ve, _e);
          });
        }
        _e(Be.arg);
      }
      var pe;
      E(this, "_invoke", { value: function(xe, Ve) {
        function _e() {
          return new ge(function(Be, Qe) {
            Te(xe, Ve, Be, Qe);
          });
        }
        return pe = pe ? pe.then(_e, _e) : _e();
      } });
    }
    function $(ne, ge, Te) {
      var pe = H;
      return function(Oe, xe) {
        if (pe === T) throw Error("Generator is already running");
        if (pe === L) {
          if (Oe === "throw") throw xe;
          return { value: l, done: true };
        }
        for (Te.method = Oe, Te.arg = xe; ; ) {
          var Ve = Te.delegate;
          if (Ve) {
            var _e = oe(Ve, Te);
            if (_e) {
              if (_e === j) continue;
              return _e;
            }
          }
          if (Te.method === "next") Te.sent = Te._sent = Te.arg;
          else if (Te.method === "throw") {
            if (pe === H) throw pe = L, Te.arg;
            Te.dispatchException(Te.arg);
          } else Te.method === "return" && Te.abrupt("return", Te.arg);
          pe = T;
          var Be = D(ne, ge, Te);
          if (Be.type === "normal") {
            if (pe = Te.done ? L : _, Be.arg === j) continue;
            return { value: Be.arg, done: Te.done };
          }
          Be.type === "throw" && (pe = L, Te.method = "throw", Te.arg = Be.arg);
        }
      };
    }
    function oe(ne, ge) {
      var Te = ge.method, pe = ne.iterator[Te];
      if (pe === l) return ge.delegate = null, Te === "throw" && ne.iterator.return && (ge.method = "return", ge.arg = l, oe(ne, ge), ge.method === "throw") || Te !== "return" && (ge.method = "throw", ge.arg = new TypeError("The iterator does not provide a '" + Te + "' method")), j;
      var Oe = D(pe, ne.iterator, ge.arg);
      if (Oe.type === "throw") return ge.method = "throw", ge.arg = Oe.arg, ge.delegate = null, j;
      var xe = Oe.arg;
      return xe ? xe.done ? (ge[ne.resultName] = xe.value, ge.next = ne.nextLoc, ge.method !== "return" && (ge.method = "next", ge.arg = l), ge.delegate = null, j) : xe : (ge.method = "throw", ge.arg = new TypeError("iterator result is not an object"), ge.delegate = null, j);
    }
    function ce(ne) {
      var ge = { tryLoc: ne[0] };
      1 in ne && (ge.catchLoc = ne[1]), 2 in ne && (ge.finallyLoc = ne[2], ge.afterLoc = ne[3]), this.tryEntries.push(ge);
    }
    function ye(ne) {
      var ge = ne.completion || {};
      ge.type = "normal", delete ge.arg, ne.completion = ge;
    }
    function ae(ne) {
      this.tryEntries = [{ tryLoc: "root" }], ne.forEach(ce, this), this.reset(true);
    }
    function ue(ne) {
      if (ne || ne === "") {
        var ge = ne[k];
        if (ge) return ge.call(ne);
        if (typeof ne.next == "function") return ne;
        if (!isNaN(ne.length)) {
          var Te = -1, pe = function Oe() {
            for (; ++Te < ne.length; ) if (S.call(ne, Te)) return Oe.value = ne[Te], Oe.done = false, Oe;
            return Oe.value = l, Oe.done = true, Oe;
          };
          return pe.next = pe;
        }
      }
      throw new TypeError(u(ne) + " is not iterable");
    }
    return Y.prototype = te, E(B, "constructor", { value: te, configurable: true }), E(te, "constructor", { value: Y, configurable: true }), Y.displayName = I(te, F, "GeneratorFunction"), d.isGeneratorFunction = function(ne) {
      var ge = typeof ne == "function" && ne.constructor;
      return !!ge && (ge === Y || (ge.displayName || ge.name) === "GeneratorFunction");
    }, d.mark = function(ne) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(ne, te) : (ne.__proto__ = te, I(ne, F, "GeneratorFunction")), ne.prototype = Object.create(B), ne;
    }, d.awrap = function(ne) {
      return { __await: ne };
    }, Z(ie.prototype), I(ie.prototype, w, function() {
      return this;
    }), d.AsyncIterator = ie, d.async = function(ne, ge, Te, pe, Oe) {
      Oe === void 0 && (Oe = Promise);
      var xe = new ie(q(ne, ge, Te, pe), Oe);
      return d.isGeneratorFunction(ge) ? xe : xe.next().then(function(Ve) {
        return Ve.done ? Ve.value : xe.next();
      });
    }, Z(B), I(B, F, "Generator"), I(B, k, function() {
      return this;
    }), I(B, "toString", function() {
      return "[object Generator]";
    }), d.keys = function(ne) {
      var ge = Object(ne), Te = [];
      for (var pe in ge) Te.push(pe);
      return Te.reverse(), function Oe() {
        for (; Te.length; ) {
          var xe = Te.pop();
          if (xe in ge) return Oe.value = xe, Oe.done = false, Oe;
        }
        return Oe.done = true, Oe;
      };
    }, d.values = ue, ae.prototype = { constructor: ae, reset: function(ge) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = l, this.done = false, this.delegate = null, this.method = "next", this.arg = l, this.tryEntries.forEach(ye), !ge) for (var Te in this) Te.charAt(0) === "t" && S.call(this, Te) && !isNaN(+Te.slice(1)) && (this[Te] = l);
    }, stop: function() {
      this.done = true;
      var ge = this.tryEntries[0].completion;
      if (ge.type === "throw") throw ge.arg;
      return this.rval;
    }, dispatchException: function(ge) {
      if (this.done) throw ge;
      var Te = this;
      function pe(Qe, ee) {
        return Ve.type = "throw", Ve.arg = ge, Te.next = Qe, ee && (Te.method = "next", Te.arg = l), !!ee;
      }
      for (var Oe = this.tryEntries.length - 1; Oe >= 0; --Oe) {
        var xe = this.tryEntries[Oe], Ve = xe.completion;
        if (xe.tryLoc === "root") return pe("end");
        if (xe.tryLoc <= this.prev) {
          var _e = S.call(xe, "catchLoc"), Be = S.call(xe, "finallyLoc");
          if (_e && Be) {
            if (this.prev < xe.catchLoc) return pe(xe.catchLoc, true);
            if (this.prev < xe.finallyLoc) return pe(xe.finallyLoc);
          } else if (_e) {
            if (this.prev < xe.catchLoc) return pe(xe.catchLoc, true);
          } else {
            if (!Be) throw Error("try statement without catch or finally");
            if (this.prev < xe.finallyLoc) return pe(xe.finallyLoc);
          }
        }
      }
    }, abrupt: function(ge, Te) {
      for (var pe = this.tryEntries.length - 1; pe >= 0; --pe) {
        var Oe = this.tryEntries[pe];
        if (Oe.tryLoc <= this.prev && S.call(Oe, "finallyLoc") && this.prev < Oe.finallyLoc) {
          var xe = Oe;
          break;
        }
      }
      xe && (ge === "break" || ge === "continue") && xe.tryLoc <= Te && Te <= xe.finallyLoc && (xe = null);
      var Ve = xe ? xe.completion : {};
      return Ve.type = ge, Ve.arg = Te, xe ? (this.method = "next", this.next = xe.finallyLoc, j) : this.complete(Ve);
    }, complete: function(ge, Te) {
      if (ge.type === "throw") throw ge.arg;
      return ge.type === "break" || ge.type === "continue" ? this.next = ge.arg : ge.type === "return" ? (this.rval = this.arg = ge.arg, this.method = "return", this.next = "end") : ge.type === "normal" && Te && (this.next = Te), j;
    }, finish: function(ge) {
      for (var Te = this.tryEntries.length - 1; Te >= 0; --Te) {
        var pe = this.tryEntries[Te];
        if (pe.finallyLoc === ge) return this.complete(pe.completion, pe.afterLoc), ye(pe), j;
      }
    }, catch: function(ge) {
      for (var Te = this.tryEntries.length - 1; Te >= 0; --Te) {
        var pe = this.tryEntries[Te];
        if (pe.tryLoc === ge) {
          var Oe = pe.completion;
          if (Oe.type === "throw") {
            var xe = Oe.arg;
            ye(pe);
          }
          return xe;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(ge, Te, pe) {
      return this.delegate = { iterator: ue(ge), resultName: Te, nextLoc: pe }, this.method === "next" && (this.arg = l), j;
    } }, d;
  }
  function h(l, d, b, S, E, R, k) {
    try {
      var w = l[R](k), F = w.value;
    } catch (I) {
      return void b(I);
    }
    w.done ? d(F) : Promise.resolve(F).then(S, E);
  }
  function f(l) {
    return function() {
      var d = this, b = arguments;
      return new Promise(function(S, E) {
        var R = l.apply(d, b);
        function k(F) {
          h(R, S, E, k, w, "next", F);
        }
        function w(F) {
          h(R, S, E, k, w, "throw", F);
        }
        k(void 0);
      });
    };
  }
  function r(l, d, b) {
    return m.apply(this, arguments);
  }
  function m() {
    return m = f(c().mark(function l(d, b, S) {
      var E, R, k, w, F, I, q, D, H, _, T = arguments;
      return c().wrap(function(j) {
        for (; ; ) switch (j.prev = j.next) {
          case 0:
            if (E = T.length > 3 && T[3] !== void 0 ? T[3] : i.Networks.FUTURENET, d.credentials().switch().value === v.default.SorobanCredentialsType.sorobanCredentialsAddress().value) {
              j.next = 3;
              break;
            }
            return j.abrupt("return", d);
          case 3:
            if (R = v.default.SorobanAuthorizationEntry.fromXDR(d.toXDR()), k = R.credentials().address(), k.signatureExpirationLedger(S), w = (0, s.hash)(Buffer.from(E)), F = v.default.HashIdPreimage.envelopeTypeSorobanAuthorization(new v.default.HashIdPreimageSorobanAuthorization({ networkId: w, nonce: k.nonce(), invocation: R.rootInvocation(), signatureExpirationLedger: k.signatureExpirationLedger() })), I = (0, s.hash)(F.toXDR()), typeof b != "function") {
              j.next = 16;
              break;
            }
            return j.next = 12, b(F);
          case 12:
            H = j.sent, H != null && H.signature ? (q = Buffer.from(H.signature), D = H.publicKey) : (q = Buffer.from(H), D = y.Address.fromScAddress(k.address()).toString()), j.next = 18;
            break;
          case 16:
            q = Buffer.from(b.sign(I)), D = b.publicKey();
          case 18:
            if (e.Keypair.fromPublicKey(D).verify(I, q)) {
              j.next = 20;
              break;
            }
            throw new Error("signature doesn't match payload");
          case 20:
            return _ = (0, t.nativeToScVal)({ public_key: n.StrKey.decodeEd25519PublicKey(D), signature: q }, { type: { public_key: ["symbol", null], signature: ["symbol", null] } }), k.signature(v.default.ScVal.scvVec([_])), j.abrupt("return", R);
          case 23:
          case "end":
            return j.stop();
        }
      }, l);
    })), m.apply(this, arguments);
  }
  function g(l, d, b) {
    var S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "", E = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : i.Networks.FUTURENET, R = e.Keypair.random().rawPublicKey(), k = new v.default.Int64(a(R)), w = S || l.publicKey();
    if (!w) throw new Error("authorizeInvocation requires publicKey parameter");
    var F = new v.default.SorobanAuthorizationEntry({ rootInvocation: b, credentials: v.default.SorobanCredentials.sorobanCredentialsAddress(new v.default.SorobanAddressCredentials({ address: new y.Address(w).toScAddress(), nonce: k, signatureExpirationLedger: 0, signature: v.default.ScVal.scvVec([]) })) });
    return r(F, l, d, E);
  }
  function a(l) {
    return l.subarray(0, 8).reduce(function(d, b) {
      return d << 8 | b;
    }, 0);
  }
  return ds;
}
var ms = {}, fh;
function bg() {
  if (fh) return ms;
  fh = 1, Object.defineProperty(ms, "__esModule", { value: true }), ms.buildInvocationTree = c, ms.walkInvocationTree = h;
  var v = To(), e = Na(), n = Ec();
  function i(r) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, i(r);
  }
  function s(r, m) {
    var g = Object.keys(r);
    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(r);
      m && (a = a.filter(function(l) {
        return Object.getOwnPropertyDescriptor(r, l).enumerable;
      })), g.push.apply(g, a);
    }
    return g;
  }
  function y(r) {
    for (var m = 1; m < arguments.length; m++) {
      var g = arguments[m] != null ? arguments[m] : {};
      m % 2 ? s(Object(g), true).forEach(function(a) {
        t(r, a, g[a]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(g)) : s(Object(g)).forEach(function(a) {
        Object.defineProperty(r, a, Object.getOwnPropertyDescriptor(g, a));
      });
    }
    return r;
  }
  function t(r, m, g) {
    return (m = o(m)) in r ? Object.defineProperty(r, m, { value: g, enumerable: true, configurable: true, writable: true }) : r[m] = g, r;
  }
  function o(r) {
    var m = u(r, "string");
    return i(m) == "symbol" ? m : m + "";
  }
  function u(r, m) {
    if (i(r) != "object" || !r) return r;
    var g = r[Symbol.toPrimitive];
    if (g !== void 0) {
      var a = g.call(r, m);
      if (i(a) != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (m === "string" ? String : Number)(r);
  }
  function c(r) {
    var m = r.function(), g = {}, a = m.value();
    switch (m.switch().value) {
      case 0:
        g.type = "execute", g.args = { source: e.Address.fromScAddress(a.contractAddress()).toString(), function: a.functionName(), args: a.args().map(function(R) {
          return (0, n.scValToNative)(R);
        }) };
        break;
      case 1:
      case 2: {
        var l = m.switch().value === 2;
        g.type = "create", g.args = {};
        var d = [a.executable(), a.contractIdPreimage()], b = d[0], S = d[1];
        if (!!b.switch().value != !!S.switch().value) throw new Error("creation function appears invalid: ".concat(JSON.stringify(a), " (should be wasm+address or token+asset)"));
        switch (b.switch().value) {
          case 0: {
            var E = S.fromAddress();
            g.args.type = "wasm", g.args.wasm = y({ salt: E.salt().toString("hex"), hash: b.wasmHash().toString("hex"), address: e.Address.fromScAddress(E.address()).toString() }, l && { constructorArgs: a.constructorArgs().map(function(R) {
              return (0, n.scValToNative)(R);
            }) });
            break;
          }
          case 1:
            g.args.type = "sac", g.args.asset = v.Asset.fromOperation(S.fromAsset()).toString();
            break;
          default:
            throw new Error("unknown creation type: ".concat(JSON.stringify(b)));
        }
        break;
      }
      default:
        throw new Error("unknown invocation type (".concat(m.switch(), "): ").concat(JSON.stringify(m)));
    }
    return g.invocations = r.subInvocations().map(function(R) {
      return c(R);
    }), g;
  }
  function h(r, m) {
    f(r, 1, m);
  }
  function f(r, m, g, a) {
    g(r, m, a) !== false && r.subInvocations().forEach(function(l) {
      return f(l, m + 1, g, r);
    });
  }
  return ms;
}
var ph;
function ko() {
  return ph || (ph = 1, function(v, e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var n = { xdr: true, cereal: true, hash: true, sign: true, verify: true, FastSigning: true, getLiquidityPoolId: true, LiquidityPoolFeeV18: true, Keypair: true, UnsignedHyper: true, Hyper: true, TransactionBase: true, Transaction: true, FeeBumpTransaction: true, TransactionBuilder: true, TimeoutInfinite: true, BASE_FEE: true, Asset: true, LiquidityPoolAsset: true, LiquidityPoolId: true, Operation: true, AuthRequiredFlag: true, AuthRevocableFlag: true, AuthImmutableFlag: true, AuthClawbackEnabledFlag: true, Account: true, MuxedAccount: true, Claimant: true, Networks: true, StrKey: true, SignerKey: true, Soroban: true, decodeAddressToMuxedAccount: true, encodeMuxedAccountToAddress: true, extractBaseAddress: true, encodeMuxedAccount: true, Contract: true, Address: true };
    Object.defineProperty(e, "Account", { enumerable: true, get: function() {
      return S.Account;
    } }), Object.defineProperty(e, "Address", { enumerable: true, get: function() {
      return H.Address;
    } }), Object.defineProperty(e, "Asset", { enumerable: true, get: function() {
      return g.Asset;
    } }), Object.defineProperty(e, "AuthClawbackEnabledFlag", { enumerable: true, get: function() {
      return d.AuthClawbackEnabledFlag;
    } }), Object.defineProperty(e, "AuthImmutableFlag", { enumerable: true, get: function() {
      return d.AuthImmutableFlag;
    } }), Object.defineProperty(e, "AuthRequiredFlag", { enumerable: true, get: function() {
      return d.AuthRequiredFlag;
    } }), Object.defineProperty(e, "AuthRevocableFlag", { enumerable: true, get: function() {
      return d.AuthRevocableFlag;
    } }), Object.defineProperty(e, "BASE_FEE", { enumerable: true, get: function() {
      return m.BASE_FEE;
    } }), Object.defineProperty(e, "Claimant", { enumerable: true, get: function() {
      return R.Claimant;
    } }), Object.defineProperty(e, "Contract", { enumerable: true, get: function() {
      return D.Contract;
    } }), Object.defineProperty(e, "FastSigning", { enumerable: true, get: function() {
      return t.FastSigning;
    } }), Object.defineProperty(e, "FeeBumpTransaction", { enumerable: true, get: function() {
      return r.FeeBumpTransaction;
    } }), Object.defineProperty(e, "Hyper", { enumerable: true, get: function() {
      return c.Hyper;
    } }), Object.defineProperty(e, "Keypair", { enumerable: true, get: function() {
      return u.Keypair;
    } }), Object.defineProperty(e, "LiquidityPoolAsset", { enumerable: true, get: function() {
      return a.LiquidityPoolAsset;
    } }), Object.defineProperty(e, "LiquidityPoolFeeV18", { enumerable: true, get: function() {
      return o.LiquidityPoolFeeV18;
    } }), Object.defineProperty(e, "LiquidityPoolId", { enumerable: true, get: function() {
      return l.LiquidityPoolId;
    } }), Object.defineProperty(e, "MuxedAccount", { enumerable: true, get: function() {
      return E.MuxedAccount;
    } }), Object.defineProperty(e, "Networks", { enumerable: true, get: function() {
      return k.Networks;
    } }), Object.defineProperty(e, "Operation", { enumerable: true, get: function() {
      return d.Operation;
    } }), Object.defineProperty(e, "SignerKey", { enumerable: true, get: function() {
      return F.SignerKey;
    } }), Object.defineProperty(e, "Soroban", { enumerable: true, get: function() {
      return I.Soroban;
    } }), Object.defineProperty(e, "StrKey", { enumerable: true, get: function() {
      return w.StrKey;
    } }), Object.defineProperty(e, "TimeoutInfinite", { enumerable: true, get: function() {
      return m.TimeoutInfinite;
    } }), Object.defineProperty(e, "Transaction", { enumerable: true, get: function() {
      return f.Transaction;
    } }), Object.defineProperty(e, "TransactionBase", { enumerable: true, get: function() {
      return h.TransactionBase;
    } }), Object.defineProperty(e, "TransactionBuilder", { enumerable: true, get: function() {
      return m.TransactionBuilder;
    } }), Object.defineProperty(e, "UnsignedHyper", { enumerable: true, get: function() {
      return c.UnsignedHyper;
    } }), Object.defineProperty(e, "cereal", { enumerable: true, get: function() {
      return s.default;
    } }), Object.defineProperty(e, "decodeAddressToMuxedAccount", { enumerable: true, get: function() {
      return q.decodeAddressToMuxedAccount;
    } }), e.default = void 0, Object.defineProperty(e, "encodeMuxedAccount", { enumerable: true, get: function() {
      return q.encodeMuxedAccount;
    } }), Object.defineProperty(e, "encodeMuxedAccountToAddress", { enumerable: true, get: function() {
      return q.encodeMuxedAccountToAddress;
    } }), Object.defineProperty(e, "extractBaseAddress", { enumerable: true, get: function() {
      return q.extractBaseAddress;
    } }), Object.defineProperty(e, "getLiquidityPoolId", { enumerable: true, get: function() {
      return o.getLiquidityPoolId;
    } }), Object.defineProperty(e, "hash", { enumerable: true, get: function() {
      return y.hash;
    } }), Object.defineProperty(e, "sign", { enumerable: true, get: function() {
      return t.sign;
    } }), Object.defineProperty(e, "verify", { enumerable: true, get: function() {
      return t.verify;
    } }), Object.defineProperty(e, "xdr", { enumerable: true, get: function() {
      return i.default;
    } });
    var i = te(bn()), s = te(ky()), y = Uo(), t = tm(), o = nm(), u = Ii(), c = Ai(), h = Yl(), f = tf(), r = am(), m = dg(), g = To(), a = Ql(), l = Zl(), d = Jl(), b = ef();
    Object.keys(b).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === b[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return b[G];
      } });
    });
    var S = rf(), E = sm(), R = im(), k = lm(), w = ni(), F = cm(), I = mg(), q = $i(), D = fm(), H = Na(), _ = gm();
    Object.keys(_).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === _[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return _[G];
      } });
    });
    var T = Ec();
    Object.keys(T).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === T[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return T[G];
      } });
    });
    var L = gg();
    Object.keys(L).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === L[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return L[G];
      } });
    });
    var j = um();
    Object.keys(j).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === j[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return j[G];
      } });
    });
    var z = vg();
    Object.keys(z).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === z[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return z[G];
      } });
    });
    var Y = bg();
    Object.keys(Y).forEach(function(G) {
      G === "default" || G === "__esModule" || Object.prototype.hasOwnProperty.call(n, G) || G in e && e[G] === Y[G] || Object.defineProperty(e, G, { enumerable: true, get: function() {
        return Y[G];
      } });
    });
    function te(G) {
      return G && G.__esModule ? G : { default: G };
    }
    e.default = v.exports;
  }(Ks, Ks.exports)), Ks.exports;
}
var co = {}, Qc = {}, ys = {}, hh;
function wg() {
  if (hh) return ys;
  hh = 1, Object.defineProperty(ys, "__esModule", { value: true }), ys.CancelToken = void 0;
  function v(t) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, v(t);
  }
  function e(t, o) {
    if (!(t instanceof o)) throw new TypeError("Cannot call a class as a function");
  }
  function n(t, o) {
    for (var u = 0; u < o.length; u++) {
      var c = o[u];
      c.enumerable = c.enumerable || false, c.configurable = true, "value" in c && (c.writable = true), Object.defineProperty(t, s(c.key), c);
    }
  }
  function i(t, o, u) {
    return o && n(t.prototype, o), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function s(t) {
    var o = y(t, "string");
    return v(o) == "symbol" ? o : o + "";
  }
  function y(t, o) {
    if (v(t) != "object" || !t) return t;
    var u = t[Symbol.toPrimitive];
    if (u !== void 0) {
      var c = u.call(t, o);
      if (v(c) != "object") return c;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t);
  }
  return ys.CancelToken = function() {
    function t(o) {
      var u = this;
      e(this, t);
      var c;
      this.promise = new Promise(function(h) {
        c = h;
      }), o(function(h) {
        u.reason = h, c();
      });
    }
    return i(t, [{ key: "throwIfRequested", value: function() {
      if (this.reason) throw new Error(this.reason);
    } }]);
  }(), ys;
}
var zo = {};
/*! Axios v1.8.4 Copyright (c) 2025 Matt Zabriskie and contributors */
var Zc, dh;
function Sg() {
  if (dh) return Zc;
  dh = 1;
  function v(Xe, Ye) {
    return function() {
      return Xe.apply(Ye, arguments);
    };
  }
  const { toString: e } = Object.prototype, { getPrototypeOf: n } = Object, i = /* @__PURE__ */ ((Xe) => (Ye) => {
    const bt = e.call(Ye);
    return Xe[bt] || (Xe[bt] = bt.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), s = (Xe) => (Xe = Xe.toLowerCase(), (Ye) => i(Ye) === Xe), y = (Xe) => (Ye) => typeof Ye === Xe, { isArray: t } = Array, o = y("undefined");
  function u(Xe) {
    return Xe !== null && !o(Xe) && Xe.constructor !== null && !o(Xe.constructor) && r(Xe.constructor.isBuffer) && Xe.constructor.isBuffer(Xe);
  }
  const c = s("ArrayBuffer");
  function h(Xe) {
    let Ye;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? Ye = ArrayBuffer.isView(Xe) : Ye = Xe && Xe.buffer && c(Xe.buffer), Ye;
  }
  const f = y("string"), r = y("function"), m = y("number"), g = (Xe) => Xe !== null && typeof Xe == "object", a = (Xe) => Xe === true || Xe === false, l = (Xe) => {
    if (i(Xe) !== "object") return false;
    const Ye = n(Xe);
    return (Ye === null || Ye === Object.prototype || Object.getPrototypeOf(Ye) === null) && !(Symbol.toStringTag in Xe) && !(Symbol.iterator in Xe);
  }, d = s("Date"), b = s("File"), S = s("Blob"), E = s("FileList"), R = (Xe) => g(Xe) && r(Xe.pipe), k = (Xe) => {
    let Ye;
    return Xe && (typeof FormData == "function" && Xe instanceof FormData || r(Xe.append) && ((Ye = i(Xe)) === "formdata" || Ye === "object" && r(Xe.toString) && Xe.toString() === "[object FormData]"));
  }, w = s("URLSearchParams"), [F, I, q, D] = ["ReadableStream", "Request", "Response", "Headers"].map(s), H = (Xe) => Xe.trim ? Xe.trim() : Xe.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function _(Xe, Ye, { allOwnKeys: bt = false } = {}) {
    if (Xe === null || typeof Xe > "u") return;
    let xt, $t;
    if (typeof Xe != "object" && (Xe = [Xe]), t(Xe)) for (xt = 0, $t = Xe.length; xt < $t; xt++) Ye.call(null, Xe[xt], xt, Xe);
    else {
      const fr = bt ? Object.getOwnPropertyNames(Xe) : Object.keys(Xe), M = fr.length;
      let W;
      for (xt = 0; xt < M; xt++) W = fr[xt], Ye.call(null, Xe[W], W, Xe);
    }
  }
  function T(Xe, Ye) {
    Ye = Ye.toLowerCase();
    const bt = Object.keys(Xe);
    let xt = bt.length, $t;
    for (; xt-- > 0; ) if ($t = bt[xt], Ye === $t.toLowerCase()) return $t;
    return null;
  }
  const L = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : vc, j = (Xe) => !o(Xe) && Xe !== L;
  function z() {
    const { caseless: Xe } = j(this) && this || {}, Ye = {}, bt = (xt, $t) => {
      const fr = Xe && T(Ye, $t) || $t;
      l(Ye[fr]) && l(xt) ? Ye[fr] = z(Ye[fr], xt) : l(xt) ? Ye[fr] = z({}, xt) : t(xt) ? Ye[fr] = xt.slice() : Ye[fr] = xt;
    };
    for (let xt = 0, $t = arguments.length; xt < $t; xt++) arguments[xt] && _(arguments[xt], bt);
    return Ye;
  }
  const Y = (Xe, Ye, bt, { allOwnKeys: xt } = {}) => (_(Ye, ($t, fr) => {
    bt && r($t) ? Xe[fr] = v($t, bt) : Xe[fr] = $t;
  }, { allOwnKeys: xt }), Xe), te = (Xe) => (Xe.charCodeAt(0) === 65279 && (Xe = Xe.slice(1)), Xe), G = (Xe, Ye, bt, xt) => {
    Xe.prototype = Object.create(Ye.prototype, xt), Xe.prototype.constructor = Xe, Object.defineProperty(Xe, "super", { value: Ye.prototype }), bt && Object.assign(Xe.prototype, bt);
  }, K = (Xe, Ye, bt, xt) => {
    let $t, fr, M;
    const W = {};
    if (Ye = Ye || {}, Xe == null) return Ye;
    do {
      for ($t = Object.getOwnPropertyNames(Xe), fr = $t.length; fr-- > 0; ) M = $t[fr], (!xt || xt(M, Xe, Ye)) && !W[M] && (Ye[M] = Xe[M], W[M] = true);
      Xe = bt !== false && n(Xe);
    } while (Xe && (!bt || bt(Xe, Ye)) && Xe !== Object.prototype);
    return Ye;
  }, J = (Xe, Ye, bt) => {
    Xe = String(Xe), (bt === void 0 || bt > Xe.length) && (bt = Xe.length), bt -= Ye.length;
    const xt = Xe.indexOf(Ye, bt);
    return xt !== -1 && xt === bt;
  }, B = (Xe) => {
    if (!Xe) return null;
    if (t(Xe)) return Xe;
    let Ye = Xe.length;
    if (!m(Ye)) return null;
    const bt = new Array(Ye);
    for (; Ye-- > 0; ) bt[Ye] = Xe[Ye];
    return bt;
  }, Z = /* @__PURE__ */ ((Xe) => (Ye) => Xe && Ye instanceof Xe)(typeof Uint8Array < "u" && n(Uint8Array)), ie = (Xe, Ye) => {
    const xt = (Xe && Xe[Symbol.iterator]).call(Xe);
    let $t;
    for (; ($t = xt.next()) && !$t.done; ) {
      const fr = $t.value;
      Ye.call(Xe, fr[0], fr[1]);
    }
  }, $ = (Xe, Ye) => {
    let bt;
    const xt = [];
    for (; (bt = Xe.exec(Ye)) !== null; ) xt.push(bt);
    return xt;
  }, oe = s("HTMLFormElement"), ce = (Xe) => Xe.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(bt, xt, $t) {
    return xt.toUpperCase() + $t;
  }), ye = (({ hasOwnProperty: Xe }) => (Ye, bt) => Xe.call(Ye, bt))(Object.prototype), ae = s("RegExp"), ue = (Xe, Ye) => {
    const bt = Object.getOwnPropertyDescriptors(Xe), xt = {};
    _(bt, ($t, fr) => {
      let M;
      (M = Ye($t, fr, Xe)) !== false && (xt[fr] = M || $t);
    }), Object.defineProperties(Xe, xt);
  }, ne = (Xe) => {
    ue(Xe, (Ye, bt) => {
      if (r(Xe) && ["arguments", "caller", "callee"].indexOf(bt) !== -1) return false;
      const xt = Xe[bt];
      if (r(xt)) {
        if (Ye.enumerable = false, "writable" in Ye) {
          Ye.writable = false;
          return;
        }
        Ye.set || (Ye.set = () => {
          throw Error("Can not rewrite read-only method '" + bt + "'");
        });
      }
    });
  }, ge = (Xe, Ye) => {
    const bt = {}, xt = ($t) => {
      $t.forEach((fr) => {
        bt[fr] = true;
      });
    };
    return t(Xe) ? xt(Xe) : xt(String(Xe).split(Ye)), bt;
  }, Te = () => {
  }, pe = (Xe, Ye) => Xe != null && Number.isFinite(Xe = +Xe) ? Xe : Ye;
  function Oe(Xe) {
    return !!(Xe && r(Xe.append) && Xe[Symbol.toStringTag] === "FormData" && Xe[Symbol.iterator]);
  }
  const xe = (Xe) => {
    const Ye = new Array(10), bt = (xt, $t) => {
      if (g(xt)) {
        if (Ye.indexOf(xt) >= 0) return;
        if (!("toJSON" in xt)) {
          Ye[$t] = xt;
          const fr = t(xt) ? [] : {};
          return _(xt, (M, W) => {
            const fe = bt(M, $t + 1);
            !o(fe) && (fr[W] = fe);
          }), Ye[$t] = void 0, fr;
        }
      }
      return xt;
    };
    return bt(Xe, 0);
  }, Ve = s("AsyncFunction"), _e = (Xe) => Xe && (g(Xe) || r(Xe)) && r(Xe.then) && r(Xe.catch), Be = ((Xe, Ye) => Xe ? setImmediate : Ye ? ((bt, xt) => (L.addEventListener("message", ({ source: $t, data: fr }) => {
    $t === L && fr === bt && xt.length && xt.shift()();
  }, false), ($t) => {
    xt.push($t), L.postMessage(bt, "*");
  }))(`axios@${Math.random()}`, []) : (bt) => setTimeout(bt))(typeof setImmediate == "function", r(L.postMessage)), Qe = typeof queueMicrotask < "u" ? queueMicrotask.bind(L) : typeof process < "u" && process.nextTick || Be;
  var ee = { isArray: t, isArrayBuffer: c, isBuffer: u, isFormData: k, isArrayBufferView: h, isString: f, isNumber: m, isBoolean: a, isObject: g, isPlainObject: l, isReadableStream: F, isRequest: I, isResponse: q, isHeaders: D, isUndefined: o, isDate: d, isFile: b, isBlob: S, isRegExp: ae, isFunction: r, isStream: R, isURLSearchParams: w, isTypedArray: Z, isFileList: E, forEach: _, merge: z, extend: Y, trim: H, stripBOM: te, inherits: G, toFlatObject: K, kindOf: i, kindOfTest: s, endsWith: J, toArray: B, forEachEntry: ie, matchAll: $, isHTMLForm: oe, hasOwnProperty: ye, hasOwnProp: ye, reduceDescriptors: ue, freezeMethods: ne, toObjectSet: ge, toCamelCase: ce, noop: Te, toFiniteNumber: pe, findKey: T, global: L, isContextDefined: j, isSpecCompliantForm: Oe, toJSONObject: xe, isAsyncFn: Ve, isThenable: _e, setImmediate: Be, asap: Qe };
  function P(Xe, Ye, bt, xt, $t) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = Xe, this.name = "AxiosError", Ye && (this.code = Ye), bt && (this.config = bt), xt && (this.request = xt), $t && (this.response = $t, this.status = $t.status ? $t.status : null);
  }
  ee.inherits(P, Error, { toJSON: function() {
    return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: ee.toJSONObject(this.config), code: this.code, status: this.status };
  } });
  const x = P.prototype, O = {};
  ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach((Xe) => {
    O[Xe] = { value: Xe };
  }), Object.defineProperties(P, O), Object.defineProperty(x, "isAxiosError", { value: true }), P.from = (Xe, Ye, bt, xt, $t, fr) => {
    const M = Object.create(x);
    return ee.toFlatObject(Xe, M, function(fe) {
      return fe !== Error.prototype;
    }, (W) => W !== "isAxiosError"), P.call(M, Xe.message, Ye, bt, xt, $t), M.cause = Xe, M.name = Xe.name, fr && Object.assign(M, fr), M;
  };
  var V = null;
  function N(Xe) {
    return ee.isPlainObject(Xe) || ee.isArray(Xe);
  }
  function C(Xe) {
    return ee.endsWith(Xe, "[]") ? Xe.slice(0, -2) : Xe;
  }
  function p(Xe, Ye, bt) {
    return Xe ? Xe.concat(Ye).map(function($t, fr) {
      return $t = C($t), !bt && fr ? "[" + $t + "]" : $t;
    }).join(bt ? "." : "") : Ye;
  }
  function A(Xe) {
    return ee.isArray(Xe) && !Xe.some(N);
  }
  const U = ee.toFlatObject(ee, {}, null, function(Ye) {
    return /^is[A-Z]/.test(Ye);
  });
  function Q(Xe, Ye, bt) {
    if (!ee.isObject(Xe)) throw new TypeError("target must be an object");
    Ye = Ye || new FormData(), bt = ee.toFlatObject(bt, { metaTokens: true, dots: false, indexes: false }, false, function(Ht, tr) {
      return !ee.isUndefined(tr[Ht]);
    });
    const xt = bt.metaTokens, $t = bt.visitor || Ce, fr = bt.dots, M = bt.indexes, fe = (bt.Blob || typeof Blob < "u" && Blob) && ee.isSpecCompliantForm(Ye);
    if (!ee.isFunction($t)) throw new TypeError("visitor must be a function");
    function Se(_t) {
      if (_t === null) return "";
      if (ee.isDate(_t)) return _t.toISOString();
      if (!fe && ee.isBlob(_t)) throw new P("Blob is not supported. Use a Buffer instead.");
      return ee.isArrayBuffer(_t) || ee.isTypedArray(_t) ? fe && typeof Blob == "function" ? new Blob([_t]) : Buffer.from(_t) : _t;
    }
    function Ce(_t, Ht, tr) {
      let Sr = _t;
      if (_t && !tr && typeof _t == "object") {
        if (ee.endsWith(Ht, "{}")) Ht = xt ? Ht : Ht.slice(0, -2), _t = JSON.stringify(_t);
        else if (ee.isArray(_t) && A(_t) || (ee.isFileList(_t) || ee.endsWith(Ht, "[]")) && (Sr = ee.toArray(_t))) return Ht = C(Ht), Sr.forEach(function(ot, Mt) {
          !(ee.isUndefined(ot) || ot === null) && Ye.append(M === true ? p([Ht], Mt, fr) : M === null ? Ht : Ht + "[]", Se(ot));
        }), false;
      }
      return N(_t) ? true : (Ye.append(p(tr, Ht, fr), Se(_t)), false);
    }
    const Re = [], Je = Object.assign(U, { defaultVisitor: Ce, convertValue: Se, isVisitable: N });
    function Ut(_t, Ht) {
      if (!ee.isUndefined(_t)) {
        if (Re.indexOf(_t) !== -1) throw Error("Circular reference detected in " + Ht.join("."));
        Re.push(_t), ee.forEach(_t, function(Sr, Ee) {
          (!(ee.isUndefined(Sr) || Sr === null) && $t.call(Ye, Sr, ee.isString(Ee) ? Ee.trim() : Ee, Ht, Je)) === true && Ut(Sr, Ht ? Ht.concat(Ee) : [Ee]);
        }), Re.pop();
      }
    }
    if (!ee.isObject(Xe)) throw new TypeError("data must be an object");
    return Ut(Xe), Ye;
  }
  function se(Xe) {
    const Ye = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" };
    return encodeURIComponent(Xe).replace(/[!'()~]|%20|%00/g, function(xt) {
      return Ye[xt];
    });
  }
  function X(Xe, Ye) {
    this._pairs = [], Xe && Q(Xe, this, Ye);
  }
  const de = X.prototype;
  de.append = function(Ye, bt) {
    this._pairs.push([Ye, bt]);
  }, de.toString = function(Ye) {
    const bt = Ye ? function(xt) {
      return Ye.call(this, xt, se);
    } : se;
    return this._pairs.map(function($t) {
      return bt($t[0]) + "=" + bt($t[1]);
    }, "").join("&");
  };
  function tt(Xe) {
    return encodeURIComponent(Xe).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function Ne(Xe, Ye, bt) {
    if (!Ye) return Xe;
    const xt = bt && bt.encode || tt;
    ee.isFunction(bt) && (bt = { serialize: bt });
    const $t = bt && bt.serialize;
    let fr;
    if ($t ? fr = $t(Ye, bt) : fr = ee.isURLSearchParams(Ye) ? Ye.toString() : new X(Ye, bt).toString(xt), fr) {
      const M = Xe.indexOf("#");
      M !== -1 && (Xe = Xe.slice(0, M)), Xe += (Xe.indexOf("?") === -1 ? "?" : "&") + fr;
    }
    return Xe;
  }
  class ut {
    constructor() {
      this.handlers = [];
    }
    use(Ye, bt, xt) {
      return this.handlers.push({ fulfilled: Ye, rejected: bt, synchronous: xt ? xt.synchronous : false, runWhen: xt ? xt.runWhen : null }), this.handlers.length - 1;
    }
    eject(Ye) {
      this.handlers[Ye] && (this.handlers[Ye] = null);
    }
    clear() {
      this.handlers && (this.handlers = []);
    }
    forEach(Ye) {
      ee.forEach(this.handlers, function(xt) {
        xt !== null && Ye(xt);
      });
    }
  }
  var Ze = ut, Et = { silentJSONParsing: true, forcedJSONParsing: true, clarifyTimeoutError: false }, rr = typeof URLSearchParams < "u" ? URLSearchParams : X, je = typeof FormData < "u" ? FormData : null, Ge = typeof Blob < "u" ? Blob : null, at = { isBrowser: true, classes: { URLSearchParams: rr, FormData: je, Blob: Ge }, protocols: ["http", "https", "file", "blob", "url", "data"] };
  const Ae = typeof window < "u" && typeof document < "u", qe = typeof navigator == "object" && navigator || void 0, Ft = Ae && (!qe || ["ReactNative", "NativeScript", "NS"].indexOf(qe.product) < 0), Dt = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", wr = Ae && window.location.href || "http://localhost";
  var Nt = Object.freeze({ __proto__: null, hasBrowserEnv: Ae, hasStandardBrowserWebWorkerEnv: Dt, hasStandardBrowserEnv: Ft, navigator: qe, origin: wr }), yr = { ...Nt, ...at };
  function Ur(Xe, Ye) {
    return Q(Xe, new yr.classes.URLSearchParams(), Object.assign({ visitor: function(bt, xt, $t, fr) {
      return yr.isNode && ee.isBuffer(bt) ? (this.append(xt, bt.toString("base64")), false) : fr.defaultVisitor.apply(this, arguments);
    } }, Ye));
  }
  function Pe(Xe) {
    return ee.matchAll(/\w+|\[(\w*)]/g, Xe).map((Ye) => Ye[0] === "[]" ? "" : Ye[1] || Ye[0]);
  }
  function $e(Xe) {
    const Ye = {}, bt = Object.keys(Xe);
    let xt;
    const $t = bt.length;
    let fr;
    for (xt = 0; xt < $t; xt++) fr = bt[xt], Ye[fr] = Xe[fr];
    return Ye;
  }
  function le(Xe) {
    function Ye(bt, xt, $t, fr) {
      let M = bt[fr++];
      if (M === "__proto__") return true;
      const W = Number.isFinite(+M), fe = fr >= bt.length;
      return M = !M && ee.isArray($t) ? $t.length : M, fe ? (ee.hasOwnProp($t, M) ? $t[M] = [$t[M], xt] : $t[M] = xt, !W) : ((!$t[M] || !ee.isObject($t[M])) && ($t[M] = []), Ye(bt, xt, $t[M], fr) && ee.isArray($t[M]) && ($t[M] = $e($t[M])), !W);
    }
    if (ee.isFormData(Xe) && ee.isFunction(Xe.entries)) {
      const bt = {};
      return ee.forEachEntry(Xe, (xt, $t) => {
        Ye(Pe(xt), $t, bt, 0);
      }), bt;
    }
    return null;
  }
  function re(Xe, Ye, bt) {
    if (ee.isString(Xe)) try {
      return (Ye || JSON.parse)(Xe), ee.trim(Xe);
    } catch (xt) {
      if (xt.name !== "SyntaxError") throw xt;
    }
    return (bt || JSON.stringify)(Xe);
  }
  const Le = { transitional: Et, adapter: ["xhr", "http", "fetch"], transformRequest: [function(Ye, bt) {
    const xt = bt.getContentType() || "", $t = xt.indexOf("application/json") > -1, fr = ee.isObject(Ye);
    if (fr && ee.isHTMLForm(Ye) && (Ye = new FormData(Ye)), ee.isFormData(Ye)) return $t ? JSON.stringify(le(Ye)) : Ye;
    if (ee.isArrayBuffer(Ye) || ee.isBuffer(Ye) || ee.isStream(Ye) || ee.isFile(Ye) || ee.isBlob(Ye) || ee.isReadableStream(Ye)) return Ye;
    if (ee.isArrayBufferView(Ye)) return Ye.buffer;
    if (ee.isURLSearchParams(Ye)) return bt.setContentType("application/x-www-form-urlencoded;charset=utf-8", false), Ye.toString();
    let W;
    if (fr) {
      if (xt.indexOf("application/x-www-form-urlencoded") > -1) return Ur(Ye, this.formSerializer).toString();
      if ((W = ee.isFileList(Ye)) || xt.indexOf("multipart/form-data") > -1) {
        const fe = this.env && this.env.FormData;
        return Q(W ? { "files[]": Ye } : Ye, fe && new fe(), this.formSerializer);
      }
    }
    return fr || $t ? (bt.setContentType("application/json", false), re(Ye)) : Ye;
  }], transformResponse: [function(Ye) {
    const bt = this.transitional || Le.transitional, xt = bt && bt.forcedJSONParsing, $t = this.responseType === "json";
    if (ee.isResponse(Ye) || ee.isReadableStream(Ye)) return Ye;
    if (Ye && ee.isString(Ye) && (xt && !this.responseType || $t)) {
      const M = !(bt && bt.silentJSONParsing) && $t;
      try {
        return JSON.parse(Ye);
      } catch (W) {
        if (M) throw W.name === "SyntaxError" ? P.from(W, P.ERR_BAD_RESPONSE, this, null, this.response) : W;
      }
    }
    return Ye;
  }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: yr.classes.FormData, Blob: yr.classes.Blob }, validateStatus: function(Ye) {
    return Ye >= 200 && Ye < 300;
  }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } };
  ee.forEach(["delete", "get", "head", "post", "put", "patch"], (Xe) => {
    Le.headers[Xe] = {};
  });
  var nt = Le;
  const ft = ee.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]);
  var zt = (Xe) => {
    const Ye = {};
    let bt, xt, $t;
    return Xe && Xe.split(`
`).forEach(function(M) {
      $t = M.indexOf(":"), bt = M.substring(0, $t).trim().toLowerCase(), xt = M.substring($t + 1).trim(), !(!bt || Ye[bt] && ft[bt]) && (bt === "set-cookie" ? Ye[bt] ? Ye[bt].push(xt) : Ye[bt] = [xt] : Ye[bt] = Ye[bt] ? Ye[bt] + ", " + xt : xt);
    }), Ye;
  };
  const st = Symbol("internals");
  function ct(Xe) {
    return Xe && String(Xe).trim().toLowerCase();
  }
  function yt(Xe) {
    return Xe === false || Xe == null ? Xe : ee.isArray(Xe) ? Xe.map(yt) : String(Xe);
  }
  function Zt(Xe) {
    const Ye = /* @__PURE__ */ Object.create(null), bt = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let xt;
    for (; xt = bt.exec(Xe); ) Ye[xt[1]] = xt[2];
    return Ye;
  }
  const Ct = (Xe) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(Xe.trim());
  function Lt(Xe, Ye, bt, xt, $t) {
    if (ee.isFunction(xt)) return xt.call(this, Ye, bt);
    if ($t && (Ye = bt), !!ee.isString(Ye)) {
      if (ee.isString(xt)) return Ye.indexOf(xt) !== -1;
      if (ee.isRegExp(xt)) return xt.test(Ye);
    }
  }
  function Wt(Xe) {
    return Xe.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (Ye, bt, xt) => bt.toUpperCase() + xt);
  }
  function vr(Xe, Ye) {
    const bt = ee.toCamelCase(" " + Ye);
    ["get", "set", "has"].forEach((xt) => {
      Object.defineProperty(Xe, xt + bt, { value: function($t, fr, M) {
        return this[xt].call(this, Ye, $t, fr, M);
      }, configurable: true });
    });
  }
  class ar {
    constructor(Ye) {
      Ye && this.set(Ye);
    }
    set(Ye, bt, xt) {
      const $t = this;
      function fr(W, fe, Se) {
        const Ce = ct(fe);
        if (!Ce) throw new Error("header name must be a non-empty string");
        const Re = ee.findKey($t, Ce);
        (!Re || $t[Re] === void 0 || Se === true || Se === void 0 && $t[Re] !== false) && ($t[Re || fe] = yt(W));
      }
      const M = (W, fe) => ee.forEach(W, (Se, Ce) => fr(Se, Ce, fe));
      if (ee.isPlainObject(Ye) || Ye instanceof this.constructor) M(Ye, bt);
      else if (ee.isString(Ye) && (Ye = Ye.trim()) && !Ct(Ye)) M(zt(Ye), bt);
      else if (ee.isHeaders(Ye)) for (const [W, fe] of Ye.entries()) fr(fe, W, xt);
      else Ye != null && fr(bt, Ye, xt);
      return this;
    }
    get(Ye, bt) {
      if (Ye = ct(Ye), Ye) {
        const xt = ee.findKey(this, Ye);
        if (xt) {
          const $t = this[xt];
          if (!bt) return $t;
          if (bt === true) return Zt($t);
          if (ee.isFunction(bt)) return bt.call(this, $t, xt);
          if (ee.isRegExp(bt)) return bt.exec($t);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(Ye, bt) {
      if (Ye = ct(Ye), Ye) {
        const xt = ee.findKey(this, Ye);
        return !!(xt && this[xt] !== void 0 && (!bt || Lt(this, this[xt], xt, bt)));
      }
      return false;
    }
    delete(Ye, bt) {
      const xt = this;
      let $t = false;
      function fr(M) {
        if (M = ct(M), M) {
          const W = ee.findKey(xt, M);
          W && (!bt || Lt(xt, xt[W], W, bt)) && (delete xt[W], $t = true);
        }
      }
      return ee.isArray(Ye) ? Ye.forEach(fr) : fr(Ye), $t;
    }
    clear(Ye) {
      const bt = Object.keys(this);
      let xt = bt.length, $t = false;
      for (; xt--; ) {
        const fr = bt[xt];
        (!Ye || Lt(this, this[fr], fr, Ye, true)) && (delete this[fr], $t = true);
      }
      return $t;
    }
    normalize(Ye) {
      const bt = this, xt = {};
      return ee.forEach(this, ($t, fr) => {
        const M = ee.findKey(xt, fr);
        if (M) {
          bt[M] = yt($t), delete bt[fr];
          return;
        }
        const W = Ye ? Wt(fr) : String(fr).trim();
        W !== fr && delete bt[fr], bt[W] = yt($t), xt[W] = true;
      }), this;
    }
    concat(...Ye) {
      return this.constructor.concat(this, ...Ye);
    }
    toJSON(Ye) {
      const bt = /* @__PURE__ */ Object.create(null);
      return ee.forEach(this, (xt, $t) => {
        xt != null && xt !== false && (bt[$t] = Ye && ee.isArray(xt) ? xt.join(", ") : xt);
      }), bt;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([Ye, bt]) => Ye + ": " + bt).join(`
`);
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(Ye) {
      return Ye instanceof this ? Ye : new this(Ye);
    }
    static concat(Ye, ...bt) {
      const xt = new this(Ye);
      return bt.forEach(($t) => xt.set($t)), xt;
    }
    static accessor(Ye) {
      const xt = (this[st] = this[st] = { accessors: {} }).accessors, $t = this.prototype;
      function fr(M) {
        const W = ct(M);
        xt[W] || (vr($t, M), xt[W] = true);
      }
      return ee.isArray(Ye) ? Ye.forEach(fr) : fr(Ye), this;
    }
  }
  ar.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), ee.reduceDescriptors(ar.prototype, ({ value: Xe }, Ye) => {
    let bt = Ye[0].toUpperCase() + Ye.slice(1);
    return { get: () => Xe, set(xt) {
      this[bt] = xt;
    } };
  }), ee.freezeMethods(ar);
  var sr = ar;
  function gr(Xe, Ye) {
    const bt = this || nt, xt = Ye || bt, $t = sr.from(xt.headers);
    let fr = xt.data;
    return ee.forEach(Xe, function(W) {
      fr = W.call(bt, fr, $t.normalize(), Ye ? Ye.status : void 0);
    }), $t.normalize(), fr;
  }
  function Tr(Xe) {
    return !!(Xe && Xe.__CANCEL__);
  }
  function Mr(Xe, Ye, bt) {
    P.call(this, Xe ?? "canceled", P.ERR_CANCELED, Ye, bt), this.name = "CanceledError";
  }
  ee.inherits(Mr, P, { __CANCEL__: true });
  function Nr(Xe, Ye, bt) {
    const xt = bt.config.validateStatus;
    !bt.status || !xt || xt(bt.status) ? Xe(bt) : Ye(new P("Request failed with status code " + bt.status, [P.ERR_BAD_REQUEST, P.ERR_BAD_RESPONSE][Math.floor(bt.status / 100) - 4], bt.config, bt.request, bt));
  }
  function Lr(Xe) {
    const Ye = /^([-+\w]{1,25})(:?\/\/|:)/.exec(Xe);
    return Ye && Ye[1] || "";
  }
  function jr(Xe, Ye) {
    Xe = Xe || 10;
    const bt = new Array(Xe), xt = new Array(Xe);
    let $t = 0, fr = 0, M;
    return Ye = Ye !== void 0 ? Ye : 1e3, function(fe) {
      const Se = Date.now(), Ce = xt[fr];
      M || (M = Se), bt[$t] = fe, xt[$t] = Se;
      let Re = fr, Je = 0;
      for (; Re !== $t; ) Je += bt[Re++], Re = Re % Xe;
      if ($t = ($t + 1) % Xe, $t === fr && (fr = (fr + 1) % Xe), Se - M < Ye) return;
      const Ut = Ce && Se - Ce;
      return Ut ? Math.round(Je * 1e3 / Ut) : void 0;
    };
  }
  function Hr(Xe, Ye) {
    let bt = 0, xt = 1e3 / Ye, $t, fr;
    const M = (Se, Ce = Date.now()) => {
      bt = Ce, $t = null, fr && (clearTimeout(fr), fr = null), Xe.apply(null, Se);
    };
    return [(...Se) => {
      const Ce = Date.now(), Re = Ce - bt;
      Re >= xt ? M(Se, Ce) : ($t = Se, fr || (fr = setTimeout(() => {
        fr = null, M($t);
      }, xt - Re)));
    }, () => $t && M($t)];
  }
  const kr = (Xe, Ye, bt = 3) => {
    let xt = 0;
    const $t = jr(50, 250);
    return Hr((fr) => {
      const M = fr.loaded, W = fr.lengthComputable ? fr.total : void 0, fe = M - xt, Se = $t(fe), Ce = M <= W;
      xt = M;
      const Re = { loaded: M, total: W, progress: W ? M / W : void 0, bytes: fe, rate: Se || void 0, estimated: Se && W && Ce ? (W - M) / Se : void 0, event: fr, lengthComputable: W != null, [Ye ? "download" : "upload"]: true };
      Xe(Re);
    }, bt);
  }, Xt = (Xe, Ye) => {
    const bt = Xe != null;
    return [(xt) => Ye[0]({ lengthComputable: bt, total: Xe, loaded: xt }), Ye[1]];
  }, Qt = (Xe) => (...Ye) => ee.asap(() => Xe(...Ye));
  var br = yr.hasStandardBrowserEnv ? /* @__PURE__ */ ((Xe, Ye) => (bt) => (bt = new URL(bt, yr.origin), Xe.protocol === bt.protocol && Xe.host === bt.host && (Ye || Xe.port === bt.port)))(new URL(yr.origin), yr.navigator && /(msie|trident)/i.test(yr.navigator.userAgent)) : () => true, we = yr.hasStandardBrowserEnv ? { write(Xe, Ye, bt, xt, $t, fr) {
    const M = [Xe + "=" + encodeURIComponent(Ye)];
    ee.isNumber(bt) && M.push("expires=" + new Date(bt).toGMTString()), ee.isString(xt) && M.push("path=" + xt), ee.isString($t) && M.push("domain=" + $t), fr === true && M.push("secure"), document.cookie = M.join("; ");
  }, read(Xe) {
    const Ye = document.cookie.match(new RegExp("(^|;\\s*)(" + Xe + ")=([^;]*)"));
    return Ye ? decodeURIComponent(Ye[3]) : null;
  }, remove(Xe) {
    this.write(Xe, "", Date.now() - 864e5);
  } } : { write() {
  }, read() {
    return null;
  }, remove() {
  } };
  function me(Xe) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(Xe);
  }
  function ze(Xe, Ye) {
    return Ye ? Xe.replace(/\/?\/$/, "") + "/" + Ye.replace(/^\/+/, "") : Xe;
  }
  function rt(Xe, Ye, bt) {
    let xt = !me(Ye);
    return Xe && (xt || bt == false) ? ze(Xe, Ye) : Ye;
  }
  const Tt = (Xe) => Xe instanceof sr ? { ...Xe } : Xe;
  function Ot(Xe, Ye) {
    Ye = Ye || {};
    const bt = {};
    function xt(Se, Ce, Re, Je) {
      return ee.isPlainObject(Se) && ee.isPlainObject(Ce) ? ee.merge.call({ caseless: Je }, Se, Ce) : ee.isPlainObject(Ce) ? ee.merge({}, Ce) : ee.isArray(Ce) ? Ce.slice() : Ce;
    }
    function $t(Se, Ce, Re, Je) {
      if (ee.isUndefined(Ce)) {
        if (!ee.isUndefined(Se)) return xt(void 0, Se, Re, Je);
      } else return xt(Se, Ce, Re, Je);
    }
    function fr(Se, Ce) {
      if (!ee.isUndefined(Ce)) return xt(void 0, Ce);
    }
    function M(Se, Ce) {
      if (ee.isUndefined(Ce)) {
        if (!ee.isUndefined(Se)) return xt(void 0, Se);
      } else return xt(void 0, Ce);
    }
    function W(Se, Ce, Re) {
      if (Re in Ye) return xt(Se, Ce);
      if (Re in Xe) return xt(void 0, Se);
    }
    const fe = { url: fr, method: fr, data: fr, baseURL: M, transformRequest: M, transformResponse: M, paramsSerializer: M, timeout: M, timeoutMessage: M, withCredentials: M, withXSRFToken: M, adapter: M, responseType: M, xsrfCookieName: M, xsrfHeaderName: M, onUploadProgress: M, onDownloadProgress: M, decompress: M, maxContentLength: M, maxBodyLength: M, beforeRedirect: M, transport: M, httpAgent: M, httpsAgent: M, cancelToken: M, socketPath: M, responseEncoding: M, validateStatus: W, headers: (Se, Ce, Re) => $t(Tt(Se), Tt(Ce), Re, true) };
    return ee.forEach(Object.keys(Object.assign({}, Xe, Ye)), function(Ce) {
      const Re = fe[Ce] || $t, Je = Re(Xe[Ce], Ye[Ce], Ce);
      ee.isUndefined(Je) && Re !== W || (bt[Ce] = Je);
    }), bt;
  }
  var It = (Xe) => {
    const Ye = Ot({}, Xe);
    let { data: bt, withXSRFToken: xt, xsrfHeaderName: $t, xsrfCookieName: fr, headers: M, auth: W } = Ye;
    Ye.headers = M = sr.from(M), Ye.url = Ne(rt(Ye.baseURL, Ye.url, Ye.allowAbsoluteUrls), Xe.params, Xe.paramsSerializer), W && M.set("Authorization", "Basic " + btoa((W.username || "") + ":" + (W.password ? unescape(encodeURIComponent(W.password)) : "")));
    let fe;
    if (ee.isFormData(bt)) {
      if (yr.hasStandardBrowserEnv || yr.hasStandardBrowserWebWorkerEnv) M.setContentType(void 0);
      else if ((fe = M.getContentType()) !== false) {
        const [Se, ...Ce] = fe ? fe.split(";").map((Re) => Re.trim()).filter(Boolean) : [];
        M.setContentType([Se || "multipart/form-data", ...Ce].join("; "));
      }
    }
    if (yr.hasStandardBrowserEnv && (xt && ee.isFunction(xt) && (xt = xt(Ye)), xt || xt !== false && br(Ye.url))) {
      const Se = $t && fr && we.read(fr);
      Se && M.set($t, Se);
    }
    return Ye;
  }, mt = typeof XMLHttpRequest < "u" && function(Xe) {
    return new Promise(function(bt, xt) {
      const $t = It(Xe);
      let fr = $t.data;
      const M = sr.from($t.headers).normalize();
      let { responseType: W, onUploadProgress: fe, onDownloadProgress: Se } = $t, Ce, Re, Je, Ut, _t;
      function Ht() {
        Ut && Ut(), _t && _t(), $t.cancelToken && $t.cancelToken.unsubscribe(Ce), $t.signal && $t.signal.removeEventListener("abort", Ce);
      }
      let tr = new XMLHttpRequest();
      tr.open($t.method.toUpperCase(), $t.url, true), tr.timeout = $t.timeout;
      function Sr() {
        if (!tr) return;
        const ot = sr.from("getAllResponseHeaders" in tr && tr.getAllResponseHeaders()), gt = { data: !W || W === "text" || W === "json" ? tr.responseText : tr.response, status: tr.status, statusText: tr.statusText, headers: ot, config: Xe, request: tr };
        Nr(function(or) {
          bt(or), Ht();
        }, function(or) {
          xt(or), Ht();
        }, gt), tr = null;
      }
      "onloadend" in tr ? tr.onloadend = Sr : tr.onreadystatechange = function() {
        !tr || tr.readyState !== 4 || tr.status === 0 && !(tr.responseURL && tr.responseURL.indexOf("file:") === 0) || setTimeout(Sr);
      }, tr.onabort = function() {
        tr && (xt(new P("Request aborted", P.ECONNABORTED, Xe, tr)), tr = null);
      }, tr.onerror = function() {
        xt(new P("Network Error", P.ERR_NETWORK, Xe, tr)), tr = null;
      }, tr.ontimeout = function() {
        let Mt = $t.timeout ? "timeout of " + $t.timeout + "ms exceeded" : "timeout exceeded";
        const gt = $t.transitional || Et;
        $t.timeoutErrorMessage && (Mt = $t.timeoutErrorMessage), xt(new P(Mt, gt.clarifyTimeoutError ? P.ETIMEDOUT : P.ECONNABORTED, Xe, tr)), tr = null;
      }, fr === void 0 && M.setContentType(null), "setRequestHeader" in tr && ee.forEach(M.toJSON(), function(Mt, gt) {
        tr.setRequestHeader(gt, Mt);
      }), ee.isUndefined($t.withCredentials) || (tr.withCredentials = !!$t.withCredentials), W && W !== "json" && (tr.responseType = $t.responseType), Se && ([Je, _t] = kr(Se, true), tr.addEventListener("progress", Je)), fe && tr.upload && ([Re, Ut] = kr(fe), tr.upload.addEventListener("progress", Re), tr.upload.addEventListener("loadend", Ut)), ($t.cancelToken || $t.signal) && (Ce = (ot) => {
        tr && (xt(!ot || ot.type ? new Mr(null, Xe, tr) : ot), tr.abort(), tr = null);
      }, $t.cancelToken && $t.cancelToken.subscribe(Ce), $t.signal && ($t.signal.aborted ? Ce() : $t.signal.addEventListener("abort", Ce)));
      const Ee = Lr($t.url);
      if (Ee && yr.protocols.indexOf(Ee) === -1) {
        xt(new P("Unsupported protocol " + Ee + ":", P.ERR_BAD_REQUEST, Xe));
        return;
      }
      tr.send(fr || null);
    });
  }, ir = (Xe, Ye) => {
    const { length: bt } = Xe = Xe ? Xe.filter(Boolean) : [];
    if (Ye || bt) {
      let xt = new AbortController(), $t;
      const fr = function(Se) {
        if (!$t) {
          $t = true, W();
          const Ce = Se instanceof Error ? Se : this.reason;
          xt.abort(Ce instanceof P ? Ce : new Mr(Ce instanceof Error ? Ce.message : Ce));
        }
      };
      let M = Ye && setTimeout(() => {
        M = null, fr(new P(`timeout ${Ye} of ms exceeded`, P.ETIMEDOUT));
      }, Ye);
      const W = () => {
        Xe && (M && clearTimeout(M), M = null, Xe.forEach((Se) => {
          Se.unsubscribe ? Se.unsubscribe(fr) : Se.removeEventListener("abort", fr);
        }), Xe = null);
      };
      Xe.forEach((Se) => Se.addEventListener("abort", fr));
      const { signal: fe } = xt;
      return fe.unsubscribe = () => ee.asap(W), fe;
    }
  };
  const dr = function* (Xe, Ye) {
    let bt = Xe.byteLength;
    if (bt < Ye) {
      yield Xe;
      return;
    }
    let xt = 0, $t;
    for (; xt < bt; ) $t = xt + Ye, yield Xe.slice(xt, $t), xt = $t;
  }, hr = async function* (Xe, Ye) {
    for await (const bt of Fr(Xe)) yield* dr(bt, Ye);
  }, Fr = async function* (Xe) {
    if (Xe[Symbol.asyncIterator]) {
      yield* Xe;
      return;
    }
    const Ye = Xe.getReader();
    try {
      for (; ; ) {
        const { done: bt, value: xt } = await Ye.read();
        if (bt) break;
        yield xt;
      }
    } finally {
      await Ye.cancel();
    }
  }, Gr = (Xe, Ye, bt, xt) => {
    const $t = hr(Xe, Ye);
    let fr = 0, M, W = (fe) => {
      M || (M = true, xt && xt(fe));
    };
    return new ReadableStream({ async pull(fe) {
      try {
        const { done: Se, value: Ce } = await $t.next();
        if (Se) {
          W(), fe.close();
          return;
        }
        let Re = Ce.byteLength;
        if (bt) {
          let Je = fr += Re;
          bt(Je);
        }
        fe.enqueue(new Uint8Array(Ce));
      } catch (Se) {
        throw W(Se), Se;
      }
    }, cancel(fe) {
      return W(fe), $t.return();
    } }, { highWaterMark: 2 });
  }, Br = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Dr = Br && typeof ReadableStream == "function", Vr = Br && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((Xe) => (Ye) => Xe.encode(Ye))(new TextEncoder()) : async (Xe) => new Uint8Array(await new Response(Xe).arrayBuffer())), be = (Xe, ...Ye) => {
    try {
      return !!Xe(...Ye);
    } catch {
      return false;
    }
  }, Or = Dr && be(() => {
    let Xe = false;
    const Ye = new Request(yr.origin, { body: new ReadableStream(), method: "POST", get duplex() {
      return Xe = true, "half";
    } }).headers.has("Content-Type");
    return Xe && !Ye;
  }), Ue = 64 * 1024, it = Dr && be(() => ee.isReadableStream(new Response("").body)), dt = { stream: it && ((Xe) => Xe.body) };
  Br && ((Xe) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((Ye) => {
      !dt[Ye] && (dt[Ye] = ee.isFunction(Xe[Ye]) ? (bt) => bt[Ye]() : (bt, xt) => {
        throw new P(`Response type '${Ye}' is not supported`, P.ERR_NOT_SUPPORT, xt);
      });
    });
  })(new Response());
  const vt = async (Xe) => {
    if (Xe == null) return 0;
    if (ee.isBlob(Xe)) return Xe.size;
    if (ee.isSpecCompliantForm(Xe)) return (await new Request(yr.origin, { method: "POST", body: Xe }).arrayBuffer()).byteLength;
    if (ee.isArrayBufferView(Xe) || ee.isArrayBuffer(Xe)) return Xe.byteLength;
    if (ee.isURLSearchParams(Xe) && (Xe = Xe + ""), ee.isString(Xe)) return (await Vr(Xe)).byteLength;
  }, wt = async (Xe, Ye) => {
    const bt = ee.toFiniteNumber(Xe.getContentLength());
    return bt ?? vt(Ye);
  };
  var Pt = Br && (async (Xe) => {
    let { url: Ye, method: bt, data: xt, signal: $t, cancelToken: fr, timeout: M, onDownloadProgress: W, onUploadProgress: fe, responseType: Se, headers: Ce, withCredentials: Re = "same-origin", fetchOptions: Je } = It(Xe);
    Se = Se ? (Se + "").toLowerCase() : "text";
    let Ut = ir([$t, fr && fr.toAbortSignal()], M), _t;
    const Ht = Ut && Ut.unsubscribe && (() => {
      Ut.unsubscribe();
    });
    let tr;
    try {
      if (fe && Or && bt !== "get" && bt !== "head" && (tr = await wt(Ce, xt)) !== 0) {
        let gt = new Request(Ye, { method: "POST", body: xt, duplex: "half" }), Rt;
        if (ee.isFormData(xt) && (Rt = gt.headers.get("content-type")) && Ce.setContentType(Rt), gt.body) {
          const [or, nr] = Xt(tr, kr(Qt(fe)));
          xt = Gr(gt.body, Ue, or, nr);
        }
      }
      ee.isString(Re) || (Re = Re ? "include" : "omit");
      const Sr = "credentials" in Request.prototype;
      _t = new Request(Ye, { ...Je, signal: Ut, method: bt.toUpperCase(), headers: Ce.normalize().toJSON(), body: xt, duplex: "half", credentials: Sr ? Re : void 0 });
      let Ee = await fetch(_t);
      const ot = it && (Se === "stream" || Se === "response");
      if (it && (W || ot && Ht)) {
        const gt = {};
        ["status", "statusText", "headers"].forEach((Qr) => {
          gt[Qr] = Ee[Qr];
        });
        const Rt = ee.toFiniteNumber(Ee.headers.get("content-length")), [or, nr] = W && Xt(Rt, kr(Qt(W), true)) || [];
        Ee = new Response(Gr(Ee.body, Ue, or, () => {
          nr && nr(), Ht && Ht();
        }), gt);
      }
      Se = Se || "text";
      let Mt = await dt[ee.findKey(dt, Se) || "text"](Ee, Xe);
      return !ot && Ht && Ht(), await new Promise((gt, Rt) => {
        Nr(gt, Rt, { data: Mt, headers: sr.from(Ee.headers), status: Ee.status, statusText: Ee.statusText, config: Xe, request: _t });
      });
    } catch (Sr) {
      throw Ht && Ht(), Sr && Sr.name === "TypeError" && /fetch/i.test(Sr.message) ? Object.assign(new P("Network Error", P.ERR_NETWORK, Xe, _t), { cause: Sr.cause || Sr }) : P.from(Sr, Sr && Sr.code, Xe, _t);
    }
  });
  const Yt = { http: V, xhr: mt, fetch: Pt };
  ee.forEach(Yt, (Xe, Ye) => {
    if (Xe) {
      try {
        Object.defineProperty(Xe, "name", { value: Ye });
      } catch {
      }
      Object.defineProperty(Xe, "adapterName", { value: Ye });
    }
  });
  const cr = (Xe) => `- ${Xe}`, qr = (Xe) => ee.isFunction(Xe) || Xe === null || Xe === false;
  var Vt = { getAdapter: (Xe) => {
    Xe = ee.isArray(Xe) ? Xe : [Xe];
    const { length: Ye } = Xe;
    let bt, xt;
    const $t = {};
    for (let fr = 0; fr < Ye; fr++) {
      bt = Xe[fr];
      let M;
      if (xt = bt, !qr(bt) && (xt = Yt[(M = String(bt)).toLowerCase()], xt === void 0)) throw new P(`Unknown adapter '${M}'`);
      if (xt) break;
      $t[M || "#" + fr] = xt;
    }
    if (!xt) {
      const fr = Object.entries($t).map(([W, fe]) => `adapter ${W} ` + (fe === false ? "is not supported by the environment" : "is not available in the build"));
      let M = Ye ? fr.length > 1 ? `since :
` + fr.map(cr).join(`
`) : " " + cr(fr[0]) : "as no adapter specified";
      throw new P("There is no suitable adapter to dispatch the request " + M, "ERR_NOT_SUPPORT");
    }
    return xt;
  }, adapters: Yt };
  function zr(Xe) {
    if (Xe.cancelToken && Xe.cancelToken.throwIfRequested(), Xe.signal && Xe.signal.aborted) throw new Mr(null, Xe);
  }
  function en(Xe) {
    return zr(Xe), Xe.headers = sr.from(Xe.headers), Xe.data = gr.call(Xe, Xe.transformRequest), ["post", "put", "patch"].indexOf(Xe.method) !== -1 && Xe.headers.setContentType("application/x-www-form-urlencoded", false), Vt.getAdapter(Xe.adapter || nt.adapter)(Xe).then(function(xt) {
      return zr(Xe), xt.data = gr.call(Xe, Xe.transformResponse, xt), xt.headers = sr.from(xt.headers), xt;
    }, function(xt) {
      return Tr(xt) || (zr(Xe), xt && xt.response && (xt.response.data = gr.call(Xe, Xe.transformResponse, xt.response), xt.response.headers = sr.from(xt.response.headers))), Promise.reject(xt);
    });
  }
  const Me = "1.8.4", De = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((Xe, Ye) => {
    De[Xe] = function(xt) {
      return typeof xt === Xe || "a" + (Ye < 1 ? "n " : " ") + Xe;
    };
  });
  const Ke = {};
  De.transitional = function(Ye, bt, xt) {
    function $t(fr, M) {
      return "[Axios v" + Me + "] Transitional option '" + fr + "'" + M + (xt ? ". " + xt : "");
    }
    return (fr, M, W) => {
      if (Ye === false) throw new P($t(M, " has been removed" + (bt ? " in " + bt : "")), P.ERR_DEPRECATED);
      return bt && !Ke[M] && (Ke[M] = true, console.warn($t(M, " has been deprecated since v" + bt + " and will be removed in the near future"))), Ye ? Ye(fr, M, W) : true;
    };
  }, De.spelling = function(Ye) {
    return (bt, xt) => (console.warn(`${xt} is likely a misspelling of ${Ye}`), true);
  };
  function Bt(Xe, Ye, bt) {
    if (typeof Xe != "object") throw new P("options must be an object", P.ERR_BAD_OPTION_VALUE);
    const xt = Object.keys(Xe);
    let $t = xt.length;
    for (; $t-- > 0; ) {
      const fr = xt[$t], M = Ye[fr];
      if (M) {
        const W = Xe[fr], fe = W === void 0 || M(W, fr, Xe);
        if (fe !== true) throw new P("option " + fr + " must be " + fe, P.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (bt !== true) throw new P("Unknown option " + fr, P.ERR_BAD_OPTION);
    }
  }
  var St = { assertOptions: Bt, validators: De };
  const ur = St.validators;
  class Cr {
    constructor(Ye) {
      this.defaults = Ye, this.interceptors = { request: new Ze(), response: new Ze() };
    }
    async request(Ye, bt) {
      try {
        return await this._request(Ye, bt);
      } catch (xt) {
        if (xt instanceof Error) {
          let $t = {};
          Error.captureStackTrace ? Error.captureStackTrace($t) : $t = new Error();
          const fr = $t.stack ? $t.stack.replace(/^.+\n/, "") : "";
          try {
            xt.stack ? fr && !String(xt.stack).endsWith(fr.replace(/^.+\n.+\n/, "")) && (xt.stack += `
` + fr) : xt.stack = fr;
          } catch {
          }
        }
        throw xt;
      }
    }
    _request(Ye, bt) {
      typeof Ye == "string" ? (bt = bt || {}, bt.url = Ye) : bt = Ye || {}, bt = Ot(this.defaults, bt);
      const { transitional: xt, paramsSerializer: $t, headers: fr } = bt;
      xt !== void 0 && St.assertOptions(xt, { silentJSONParsing: ur.transitional(ur.boolean), forcedJSONParsing: ur.transitional(ur.boolean), clarifyTimeoutError: ur.transitional(ur.boolean) }, false), $t != null && (ee.isFunction($t) ? bt.paramsSerializer = { serialize: $t } : St.assertOptions($t, { encode: ur.function, serialize: ur.function }, true)), bt.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? bt.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : bt.allowAbsoluteUrls = true), St.assertOptions(bt, { baseUrl: ur.spelling("baseURL"), withXsrfToken: ur.spelling("withXSRFToken") }, true), bt.method = (bt.method || this.defaults.method || "get").toLowerCase();
      let M = fr && ee.merge(fr.common, fr[bt.method]);
      fr && ee.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (_t) => {
        delete fr[_t];
      }), bt.headers = sr.concat(M, fr);
      const W = [];
      let fe = true;
      this.interceptors.request.forEach(function(Ht) {
        typeof Ht.runWhen == "function" && Ht.runWhen(bt) === false || (fe = fe && Ht.synchronous, W.unshift(Ht.fulfilled, Ht.rejected));
      });
      const Se = [];
      this.interceptors.response.forEach(function(Ht) {
        Se.push(Ht.fulfilled, Ht.rejected);
      });
      let Ce, Re = 0, Je;
      if (!fe) {
        const _t = [en.bind(this), void 0];
        for (_t.unshift.apply(_t, W), _t.push.apply(_t, Se), Je = _t.length, Ce = Promise.resolve(bt); Re < Je; ) Ce = Ce.then(_t[Re++], _t[Re++]);
        return Ce;
      }
      Je = W.length;
      let Ut = bt;
      for (Re = 0; Re < Je; ) {
        const _t = W[Re++], Ht = W[Re++];
        try {
          Ut = _t(Ut);
        } catch (tr) {
          Ht.call(this, tr);
          break;
        }
      }
      try {
        Ce = en.call(this, Ut);
      } catch (_t) {
        return Promise.reject(_t);
      }
      for (Re = 0, Je = Se.length; Re < Je; ) Ce = Ce.then(Se[Re++], Se[Re++]);
      return Ce;
    }
    getUri(Ye) {
      Ye = Ot(this.defaults, Ye);
      const bt = rt(Ye.baseURL, Ye.url, Ye.allowAbsoluteUrls);
      return Ne(bt, Ye.params, Ye.paramsSerializer);
    }
  }
  ee.forEach(["delete", "get", "head", "options"], function(Ye) {
    Cr.prototype[Ye] = function(bt, xt) {
      return this.request(Ot(xt || {}, { method: Ye, url: bt, data: (xt || {}).data }));
    };
  }), ee.forEach(["post", "put", "patch"], function(Ye) {
    function bt(xt) {
      return function(fr, M, W) {
        return this.request(Ot(W || {}, { method: Ye, headers: xt ? { "Content-Type": "multipart/form-data" } : {}, url: fr, data: M }));
      };
    }
    Cr.prototype[Ye] = bt(), Cr.prototype[Ye + "Form"] = bt(true);
  });
  var Wr = Cr;
  class Zr {
    constructor(Ye) {
      if (typeof Ye != "function") throw new TypeError("executor must be a function.");
      let bt;
      this.promise = new Promise(function(fr) {
        bt = fr;
      });
      const xt = this;
      this.promise.then(($t) => {
        if (!xt._listeners) return;
        let fr = xt._listeners.length;
        for (; fr-- > 0; ) xt._listeners[fr]($t);
        xt._listeners = null;
      }), this.promise.then = ($t) => {
        let fr;
        const M = new Promise((W) => {
          xt.subscribe(W), fr = W;
        }).then($t);
        return M.cancel = function() {
          xt.unsubscribe(fr);
        }, M;
      }, Ye(function(fr, M, W) {
        xt.reason || (xt.reason = new Mr(fr, M, W), bt(xt.reason));
      });
    }
    throwIfRequested() {
      if (this.reason) throw this.reason;
    }
    subscribe(Ye) {
      if (this.reason) {
        Ye(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(Ye) : this._listeners = [Ye];
    }
    unsubscribe(Ye) {
      if (!this._listeners) return;
      const bt = this._listeners.indexOf(Ye);
      bt !== -1 && this._listeners.splice(bt, 1);
    }
    toAbortSignal() {
      const Ye = new AbortController(), bt = (xt) => {
        Ye.abort(xt);
      };
      return this.subscribe(bt), Ye.signal.unsubscribe = () => this.unsubscribe(bt), Ye.signal;
    }
    static source() {
      let Ye;
      return { token: new Zr(function($t) {
        Ye = $t;
      }), cancel: Ye };
    }
  }
  var dn = Zr;
  function wn(Xe) {
    return function(bt) {
      return Xe.apply(null, bt);
    };
  }
  function yn(Xe) {
    return ee.isObject(Xe) && Xe.isAxiosError === true;
  }
  const pi = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 };
  Object.entries(pi).forEach(([Xe, Ye]) => {
    pi[Ye] = Xe;
  });
  var Bi = pi;
  function Ni(Xe) {
    const Ye = new Wr(Xe), bt = v(Wr.prototype.request, Ye);
    return ee.extend(bt, Wr.prototype, Ye, { allOwnKeys: true }), ee.extend(bt, Ye, null, { allOwnKeys: true }), bt.create = function($t) {
      return Ni(Ot(Xe, $t));
    }, bt;
  }
  const Un = Ni(nt);
  return Un.Axios = Wr, Un.CanceledError = Mr, Un.CancelToken = dn, Un.isCancel = Tr, Un.VERSION = Me, Un.toFormData = Q, Un.AxiosError = P, Un.Cancel = Un.CanceledError, Un.all = function(Ye) {
    return Promise.all(Ye);
  }, Un.spread = wn, Un.isAxiosError = yn, Un.mergeConfig = Ot, Un.AxiosHeaders = sr, Un.formToJSON = (Xe) => le(ee.isHTMLForm(Xe) ? new FormData(Xe) : Xe), Un.getAdapter = Vt.getAdapter, Un.HttpStatusCode = Bi, Un.default = Un, Zc = Un, Zc;
}
var mh;
function _g() {
  if (mh) return zo;
  mh = 1, Object.defineProperty(zo, "__esModule", { value: true }), zo.create = zo.axiosClient = void 0;
  var v = e(Sg());
  function e(n) {
    return n && n.__esModule ? n : { default: n };
  }
  return zo.axiosClient = v.default, zo.create = v.default.create, zo;
}
var yh;
function Eg() {
  return yh || (yh = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true });
    var e = { httpClient: true, create: true };
    v.httpClient = v.create = void 0;
    var n = wg();
    Object.keys(n).forEach(function(s) {
      s === "default" || s === "__esModule" || Object.prototype.hasOwnProperty.call(e, s) || s in v && v[s] === n[s] || Object.defineProperty(v, s, { enumerable: true, get: function() {
        return n[s];
      } });
    });
    {
      var i = _g();
      v.httpClient = i.axiosClient, v.create = i.create;
    }
  }(Qc)), Qc;
}
var gh;
function nf() {
  if (gh) return co;
  gh = 1, Object.defineProperty(co, "__esModule", { value: true }), co.version = co.default = co.AxiosClient = void 0;
  var v = Eg(), e = co.version = "13.2.0", n = co.AxiosClient = (0, v.create)({ headers: { "X-Client-Name": "js-soroban-client", "X-Client-Version": e } });
  return co.default = n, co;
}
var Au = {}, vh;
function Ag() {
  if (vh) return Au;
  vh = 1, Object.defineProperty(Au, "__esModule", { value: true }), Au.postObject = o;
  var v = e(nf());
  function e(c) {
    return c && c.__esModule ? c : { default: c };
  }
  function n(c) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(h) {
      return typeof h;
    } : function(h) {
      return h && typeof Symbol == "function" && h.constructor === Symbol && h !== Symbol.prototype ? "symbol" : typeof h;
    }, n(c);
  }
  function i() {
    i = function() {
      return h;
    };
    var c, h = {}, f = Object.prototype, r = f.hasOwnProperty, m = Object.defineProperty || function(ie, $, oe) {
      ie[$] = oe.value;
    }, g = typeof Symbol == "function" ? Symbol : {}, a = g.iterator || "@@iterator", l = g.asyncIterator || "@@asyncIterator", d = g.toStringTag || "@@toStringTag";
    function b(ie, $, oe) {
      return Object.defineProperty(ie, $, { value: oe, enumerable: true, configurable: true, writable: true }), ie[$];
    }
    try {
      b({}, "");
    } catch {
      b = function(oe, ce, ye) {
        return oe[ce] = ye;
      };
    }
    function S(ie, $, oe, ce) {
      var ye = $ && $.prototype instanceof q ? $ : q, ae = Object.create(ye.prototype), ue = new B(ce || []);
      return m(ae, "_invoke", { value: te(ie, oe, ue) }), ae;
    }
    function E(ie, $, oe) {
      try {
        return { type: "normal", arg: ie.call($, oe) };
      } catch (ce) {
        return { type: "throw", arg: ce };
      }
    }
    h.wrap = S;
    var R = "suspendedStart", k = "suspendedYield", w = "executing", F = "completed", I = {};
    function q() {
    }
    function D() {
    }
    function H() {
    }
    var _ = {};
    b(_, a, function() {
      return this;
    });
    var T = Object.getPrototypeOf, L = T && T(T(Z([])));
    L && L !== f && r.call(L, a) && (_ = L);
    var j = H.prototype = q.prototype = Object.create(_);
    function z(ie) {
      ["next", "throw", "return"].forEach(function($) {
        b(ie, $, function(oe) {
          return this._invoke($, oe);
        });
      });
    }
    function Y(ie, $) {
      function oe(ye, ae, ue, ne) {
        var ge = E(ie[ye], ie, ae);
        if (ge.type !== "throw") {
          var Te = ge.arg, pe = Te.value;
          return pe && n(pe) == "object" && r.call(pe, "__await") ? $.resolve(pe.__await).then(function(Oe) {
            oe("next", Oe, ue, ne);
          }, function(Oe) {
            oe("throw", Oe, ue, ne);
          }) : $.resolve(pe).then(function(Oe) {
            Te.value = Oe, ue(Te);
          }, function(Oe) {
            return oe("throw", Oe, ue, ne);
          });
        }
        ne(ge.arg);
      }
      var ce;
      m(this, "_invoke", { value: function(ae, ue) {
        function ne() {
          return new $(function(ge, Te) {
            oe(ae, ue, ge, Te);
          });
        }
        return ce = ce ? ce.then(ne, ne) : ne();
      } });
    }
    function te(ie, $, oe) {
      var ce = R;
      return function(ye, ae) {
        if (ce === w) throw Error("Generator is already running");
        if (ce === F) {
          if (ye === "throw") throw ae;
          return { value: c, done: true };
        }
        for (oe.method = ye, oe.arg = ae; ; ) {
          var ue = oe.delegate;
          if (ue) {
            var ne = G(ue, oe);
            if (ne) {
              if (ne === I) continue;
              return ne;
            }
          }
          if (oe.method === "next") oe.sent = oe._sent = oe.arg;
          else if (oe.method === "throw") {
            if (ce === R) throw ce = F, oe.arg;
            oe.dispatchException(oe.arg);
          } else oe.method === "return" && oe.abrupt("return", oe.arg);
          ce = w;
          var ge = E(ie, $, oe);
          if (ge.type === "normal") {
            if (ce = oe.done ? F : k, ge.arg === I) continue;
            return { value: ge.arg, done: oe.done };
          }
          ge.type === "throw" && (ce = F, oe.method = "throw", oe.arg = ge.arg);
        }
      };
    }
    function G(ie, $) {
      var oe = $.method, ce = ie.iterator[oe];
      if (ce === c) return $.delegate = null, oe === "throw" && ie.iterator.return && ($.method = "return", $.arg = c, G(ie, $), $.method === "throw") || oe !== "return" && ($.method = "throw", $.arg = new TypeError("The iterator does not provide a '" + oe + "' method")), I;
      var ye = E(ce, ie.iterator, $.arg);
      if (ye.type === "throw") return $.method = "throw", $.arg = ye.arg, $.delegate = null, I;
      var ae = ye.arg;
      return ae ? ae.done ? ($[ie.resultName] = ae.value, $.next = ie.nextLoc, $.method !== "return" && ($.method = "next", $.arg = c), $.delegate = null, I) : ae : ($.method = "throw", $.arg = new TypeError("iterator result is not an object"), $.delegate = null, I);
    }
    function K(ie) {
      var $ = { tryLoc: ie[0] };
      1 in ie && ($.catchLoc = ie[1]), 2 in ie && ($.finallyLoc = ie[2], $.afterLoc = ie[3]), this.tryEntries.push($);
    }
    function J(ie) {
      var $ = ie.completion || {};
      $.type = "normal", delete $.arg, ie.completion = $;
    }
    function B(ie) {
      this.tryEntries = [{ tryLoc: "root" }], ie.forEach(K, this), this.reset(true);
    }
    function Z(ie) {
      if (ie || ie === "") {
        var $ = ie[a];
        if ($) return $.call(ie);
        if (typeof ie.next == "function") return ie;
        if (!isNaN(ie.length)) {
          var oe = -1, ce = function ye() {
            for (; ++oe < ie.length; ) if (r.call(ie, oe)) return ye.value = ie[oe], ye.done = false, ye;
            return ye.value = c, ye.done = true, ye;
          };
          return ce.next = ce;
        }
      }
      throw new TypeError(n(ie) + " is not iterable");
    }
    return D.prototype = H, m(j, "constructor", { value: H, configurable: true }), m(H, "constructor", { value: D, configurable: true }), D.displayName = b(H, d, "GeneratorFunction"), h.isGeneratorFunction = function(ie) {
      var $ = typeof ie == "function" && ie.constructor;
      return !!$ && ($ === D || ($.displayName || $.name) === "GeneratorFunction");
    }, h.mark = function(ie) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(ie, H) : (ie.__proto__ = H, b(ie, d, "GeneratorFunction")), ie.prototype = Object.create(j), ie;
    }, h.awrap = function(ie) {
      return { __await: ie };
    }, z(Y.prototype), b(Y.prototype, l, function() {
      return this;
    }), h.AsyncIterator = Y, h.async = function(ie, $, oe, ce, ye) {
      ye === void 0 && (ye = Promise);
      var ae = new Y(S(ie, $, oe, ce), ye);
      return h.isGeneratorFunction($) ? ae : ae.next().then(function(ue) {
        return ue.done ? ue.value : ae.next();
      });
    }, z(j), b(j, d, "Generator"), b(j, a, function() {
      return this;
    }), b(j, "toString", function() {
      return "[object Generator]";
    }), h.keys = function(ie) {
      var $ = Object(ie), oe = [];
      for (var ce in $) oe.push(ce);
      return oe.reverse(), function ye() {
        for (; oe.length; ) {
          var ae = oe.pop();
          if (ae in $) return ye.value = ae, ye.done = false, ye;
        }
        return ye.done = true, ye;
      };
    }, h.values = Z, B.prototype = { constructor: B, reset: function($) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = c, this.done = false, this.delegate = null, this.method = "next", this.arg = c, this.tryEntries.forEach(J), !$) for (var oe in this) oe.charAt(0) === "t" && r.call(this, oe) && !isNaN(+oe.slice(1)) && (this[oe] = c);
    }, stop: function() {
      this.done = true;
      var $ = this.tryEntries[0].completion;
      if ($.type === "throw") throw $.arg;
      return this.rval;
    }, dispatchException: function($) {
      if (this.done) throw $;
      var oe = this;
      function ce(Te, pe) {
        return ue.type = "throw", ue.arg = $, oe.next = Te, pe && (oe.method = "next", oe.arg = c), !!pe;
      }
      for (var ye = this.tryEntries.length - 1; ye >= 0; --ye) {
        var ae = this.tryEntries[ye], ue = ae.completion;
        if (ae.tryLoc === "root") return ce("end");
        if (ae.tryLoc <= this.prev) {
          var ne = r.call(ae, "catchLoc"), ge = r.call(ae, "finallyLoc");
          if (ne && ge) {
            if (this.prev < ae.catchLoc) return ce(ae.catchLoc, true);
            if (this.prev < ae.finallyLoc) return ce(ae.finallyLoc);
          } else if (ne) {
            if (this.prev < ae.catchLoc) return ce(ae.catchLoc, true);
          } else {
            if (!ge) throw Error("try statement without catch or finally");
            if (this.prev < ae.finallyLoc) return ce(ae.finallyLoc);
          }
        }
      }
    }, abrupt: function($, oe) {
      for (var ce = this.tryEntries.length - 1; ce >= 0; --ce) {
        var ye = this.tryEntries[ce];
        if (ye.tryLoc <= this.prev && r.call(ye, "finallyLoc") && this.prev < ye.finallyLoc) {
          var ae = ye;
          break;
        }
      }
      ae && ($ === "break" || $ === "continue") && ae.tryLoc <= oe && oe <= ae.finallyLoc && (ae = null);
      var ue = ae ? ae.completion : {};
      return ue.type = $, ue.arg = oe, ae ? (this.method = "next", this.next = ae.finallyLoc, I) : this.complete(ue);
    }, complete: function($, oe) {
      if ($.type === "throw") throw $.arg;
      return $.type === "break" || $.type === "continue" ? this.next = $.arg : $.type === "return" ? (this.rval = this.arg = $.arg, this.method = "return", this.next = "end") : $.type === "normal" && oe && (this.next = oe), I;
    }, finish: function($) {
      for (var oe = this.tryEntries.length - 1; oe >= 0; --oe) {
        var ce = this.tryEntries[oe];
        if (ce.finallyLoc === $) return this.complete(ce.completion, ce.afterLoc), J(ce), I;
      }
    }, catch: function($) {
      for (var oe = this.tryEntries.length - 1; oe >= 0; --oe) {
        var ce = this.tryEntries[oe];
        if (ce.tryLoc === $) {
          var ye = ce.completion;
          if (ye.type === "throw") {
            var ae = ye.arg;
            J(ce);
          }
          return ae;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function($, oe, ce) {
      return this.delegate = { iterator: Z($), resultName: oe, nextLoc: ce }, this.method === "next" && (this.arg = c), I;
    } }, h;
  }
  function s(c, h, f, r, m, g, a) {
    try {
      var l = c[g](a), d = l.value;
    } catch (b) {
      return void f(b);
    }
    l.done ? h(d) : Promise.resolve(d).then(r, m);
  }
  function y(c) {
    return function() {
      var h = this, f = arguments;
      return new Promise(function(r, m) {
        var g = c.apply(h, f);
        function a(d) {
          s(g, r, m, a, l, "next", d);
        }
        function l(d) {
          s(g, r, m, a, l, "throw", d);
        }
        a(void 0);
      });
    };
  }
  function t(c, h) {
    return c.hasOwnProperty(h);
  }
  function o(c, h) {
    return u.apply(this, arguments);
  }
  function u() {
    return u = y(i().mark(function c(h, f) {
      var r, m, g, a = arguments;
      return i().wrap(function(d) {
        for (; ; ) switch (d.prev = d.next) {
          case 0:
            return r = a.length > 2 && a[2] !== void 0 ? a[2] : null, d.next = 3, v.default.post(h, { jsonrpc: "2.0", id: 1, method: f, params: r });
          case 3:
            if (m = d.sent, !t(m.data, "error")) {
              d.next = 8;
              break;
            }
            throw m.data.error;
          case 8:
            return d.abrupt("return", (g = m.data) === null || g === void 0 ? void 0 : g.result);
          case 9:
          case "end":
            return d.stop();
        }
      }, c);
    })), u.apply(this, arguments);
  }
  return Au;
}
var xu = {}, lo = {}, bh;
function of() {
  if (bh) return lo;
  bh = 1, Object.defineProperty(lo, "__esModule", { value: true }), lo.parseRawEvents = f, lo.parseRawLedgerEntries = r, lo.parseRawSendTransaction = u, lo.parseRawSimulation = g, lo.parseRawTransactions = h, lo.parseTransactionInfo = c;
  var v = ko(), e = Ia();
  function n(a) {
    "@babel/helpers - typeof";
    return n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(l) {
      return typeof l;
    } : function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, n(a);
  }
  function i(a, l) {
    var d = Object.keys(a);
    if (Object.getOwnPropertySymbols) {
      var b = Object.getOwnPropertySymbols(a);
      l && (b = b.filter(function(S) {
        return Object.getOwnPropertyDescriptor(a, S).enumerable;
      })), d.push.apply(d, b);
    }
    return d;
  }
  function s(a) {
    for (var l = 1; l < arguments.length; l++) {
      var d = arguments[l] != null ? arguments[l] : {};
      l % 2 ? i(Object(d), true).forEach(function(b) {
        y(a, b, d[b]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(d)) : i(Object(d)).forEach(function(b) {
        Object.defineProperty(a, b, Object.getOwnPropertyDescriptor(d, b));
      });
    }
    return a;
  }
  function y(a, l, d) {
    return (l = t(l)) in a ? Object.defineProperty(a, l, { value: d, enumerable: true, configurable: true, writable: true }) : a[l] = d, a;
  }
  function t(a) {
    var l = o(a, "string");
    return n(l) == "symbol" ? l : l + "";
  }
  function o(a, l) {
    if (n(a) != "object" || !a) return a;
    var d = a[Symbol.toPrimitive];
    if (d !== void 0) {
      var b = d.call(a, l);
      if (n(b) != "object") return b;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (l === "string" ? String : Number)(a);
  }
  function u(a) {
    var l = a.errorResultXdr, d = a.diagnosticEventsXdr;
    return delete a.errorResultXdr, delete a.diagnosticEventsXdr, l ? s(s(s({}, a), d !== void 0 && d.length > 0 && { diagnosticEvents: d.map(function(b) {
      return v.xdr.DiagnosticEvent.fromXDR(b, "base64");
    }) }), {}, { errorResult: v.xdr.TransactionResult.fromXDR(l, "base64") }) : s({}, a);
  }
  function c(a) {
    var l = v.xdr.TransactionMeta.fromXDR(a.resultMetaXdr, "base64"), d = { ledger: a.ledger, createdAt: a.createdAt, applicationOrder: a.applicationOrder, feeBump: a.feeBump, envelopeXdr: v.xdr.TransactionEnvelope.fromXDR(a.envelopeXdr, "base64"), resultXdr: v.xdr.TransactionResult.fromXDR(a.resultXdr, "base64"), resultMetaXdr: l };
    if (l.switch() === 3 && l.v3().sorobanMeta() !== null) {
      var b;
      d.returnValue = (b = l.v3().sorobanMeta()) === null || b === void 0 ? void 0 : b.returnValue();
    }
    return "diagnosticEventsXdr" in a && a.diagnosticEventsXdr && (d.diagnosticEventsXdr = a.diagnosticEventsXdr.map(function(S) {
      return v.xdr.DiagnosticEvent.fromXDR(S, "base64");
    })), d;
  }
  function h(a) {
    return s({ status: a.status, txHash: a.txHash }, c(a));
  }
  function f(a) {
    var l;
    return { latestLedger: a.latestLedger, cursor: a.cursor, events: ((l = a.events) !== null && l !== void 0 ? l : []).map(function(d) {
      var b = s({}, d);
      return delete b.contractId, s(s(s({}, b), d.contractId !== "" && { contractId: new v.Contract(d.contractId) }), {}, { topic: d.topic.map(function(S) {
        return v.xdr.ScVal.fromXDR(S, "base64");
      }), value: v.xdr.ScVal.fromXDR(d.value, "base64") });
    }) };
  }
  function r(a) {
    var l;
    return { latestLedger: a.latestLedger, entries: ((l = a.entries) !== null && l !== void 0 ? l : []).map(function(d) {
      if (!d.key || !d.xdr) throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(d)));
      return s({ lastModifiedLedgerSeq: d.lastModifiedLedgerSeq, key: v.xdr.LedgerKey.fromXDR(d.key, "base64"), val: v.xdr.LedgerEntryData.fromXDR(d.xdr, "base64") }, d.liveUntilLedgerSeq !== void 0 && { liveUntilLedgerSeq: d.liveUntilLedgerSeq });
    }) };
  }
  function m(a, l) {
    var d, b, S, E, R, k = s(s(s({}, l), {}, { transactionData: new v.SorobanDataBuilder(a.transactionData), minResourceFee: a.minResourceFee }, ((d = (b = a.results) === null || b === void 0 ? void 0 : b.length) !== null && d !== void 0 ? d : false) && { result: a.results.map(function(w) {
      var F;
      return { auth: ((F = w.auth) !== null && F !== void 0 ? F : []).map(function(I) {
        return v.xdr.SorobanAuthorizationEntry.fromXDR(I, "base64");
      }), retval: w.xdr ? v.xdr.ScVal.fromXDR(w.xdr, "base64") : v.xdr.ScVal.scvVoid() };
    })[0] }), ((S = (E = a.stateChanges) === null || E === void 0 ? void 0 : E.length) !== null && S !== void 0 ? S : false) && { stateChanges: (R = a.stateChanges) === null || R === void 0 ? void 0 : R.map(function(w) {
      return { type: w.type, key: v.xdr.LedgerKey.fromXDR(w.key, "base64"), before: w.before ? v.xdr.LedgerEntry.fromXDR(w.before, "base64") : null, after: w.after ? v.xdr.LedgerEntry.fromXDR(w.after, "base64") : null };
    }) });
    return !a.restorePreamble || a.restorePreamble.transactionData === "" ? k : s(s({}, k), {}, { restorePreamble: { minResourceFee: a.restorePreamble.minResourceFee, transactionData: new v.SorobanDataBuilder(a.restorePreamble.transactionData) } });
  }
  function g(a) {
    var l, d, b = e.Api.isSimulationRaw(a);
    if (!b) return a;
    var S = { _parsed: true, id: a.id, latestLedger: a.latestLedger, events: (l = (d = a.events) === null || d === void 0 ? void 0 : d.map(function(E) {
      return v.xdr.DiagnosticEvent.fromXDR(E, "base64");
    })) !== null && l !== void 0 ? l : [] };
    return typeof a.error == "string" ? s(s({}, S), {}, { error: a.error }) : m(a, S);
  }
  return lo;
}
var wh;
function af() {
  if (wh) return xu;
  wh = 1, Object.defineProperty(xu, "__esModule", { value: true }), xu.assembleTransaction = s;
  var v = ko(), e = Ia(), n = of();
  function i(y) {
    if (y.operations.length !== 1) return false;
    switch (y.operations[0].type) {
      case "invokeHostFunction":
      case "extendFootprintTtl":
      case "restoreFootprint":
        return true;
      default:
        return false;
    }
  }
  function s(y, t) {
    if ("innerTransaction" in y) return s(y.innerTransaction, t);
    if (!i(y)) throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
    var o = (0, n.parseRawSimulation)(t);
    if (!e.Api.isSimulationSuccess(o)) throw new Error("simulation incorrect: ".concat(JSON.stringify(o)));
    var u = parseInt(y.fee) || 0, c = parseInt(o.minResourceFee) || 0, h = v.TransactionBuilder.cloneFrom(y, { fee: (u + c).toString(), sorobanData: o.transactionData.build(), networkPassphrase: y.networkPassphrase });
    if (y.operations[0].type === "invokeHostFunction") {
      var f;
      h.clearOperations();
      var r = y.operations[0], m = (f = r.auth) !== null && f !== void 0 ? f : [];
      h.addOperation(v.Operation.invokeHostFunction({ source: r.source, func: r.func, auth: m.length > 0 ? m : o.result.auth }));
    }
    return h;
  }
  return xu;
}
var gs = {}, Sh;
function xg() {
  if (Sh) return gs;
  Sh = 1, Object.defineProperty(gs, "__esModule", { value: true }), gs.Utils = void 0;
  function v(t) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, v(t);
  }
  function e(t, o) {
    if (!(t instanceof o)) throw new TypeError("Cannot call a class as a function");
  }
  function n(t, o) {
    for (var u = 0; u < o.length; u++) {
      var c = o[u];
      c.enumerable = c.enumerable || false, c.configurable = true, "value" in c && (c.writable = true), Object.defineProperty(t, s(c.key), c);
    }
  }
  function i(t, o, u) {
    return u && n(t, u), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function s(t) {
    var o = y(t, "string");
    return v(o) == "symbol" ? o : o + "";
  }
  function y(t, o) {
    if (v(t) != "object" || !t) return t;
    var u = t[Symbol.toPrimitive];
    if (u !== void 0) {
      var c = u.call(t, o);
      if (v(c) != "object") return c;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t);
  }
  return gs.Utils = function() {
    function t() {
      e(this, t);
    }
    return i(t, null, [{ key: "validateTimebounds", value: function(u) {
      var c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      if (!u.timeBounds) return false;
      var h = Math.floor(Date.now() / 1e3), f = u.timeBounds, r = f.minTime, m = f.maxTime;
      return h >= Number.parseInt(r, 10) - c && h <= Number.parseInt(m, 10) + c;
    } }, { key: "sleep", value: function(u) {
      return new Promise(function(c) {
        return setTimeout(c, u);
      });
    } }]);
  }(), gs;
}
var _h;
function Tg() {
  if (_h) return Ti;
  _h = 1, Object.defineProperty(Ti, "__esModule", { value: true }), Ti.SUBMIT_TRANSACTION_TIMEOUT = Ti.RpcServer = Ti.LinearSleepStrategy = Ti.Durability = Ti.BasicSleepStrategy = void 0;
  var v = h(Ay()), e = ko(), n = h(nf()), i = c(Ag()), s = Ia(), y = af(), t = of(), o = xg();
  function u(D) {
    if (typeof WeakMap != "function") return null;
    var H = /* @__PURE__ */ new WeakMap(), _ = /* @__PURE__ */ new WeakMap();
    return (u = function(L) {
      return L ? _ : H;
    })(D);
  }
  function c(D, H) {
    if (D && D.__esModule) return D;
    if (D === null || f(D) != "object" && typeof D != "function") return { default: D };
    var _ = u(H);
    if (_ && _.has(D)) return _.get(D);
    var T = { __proto__: null }, L = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var j in D) if (j !== "default" && {}.hasOwnProperty.call(D, j)) {
      var z = L ? Object.getOwnPropertyDescriptor(D, j) : null;
      z && (z.get || z.set) ? Object.defineProperty(T, j, z) : T[j] = D[j];
    }
    return T.default = D, _ && _.set(D, T), T;
  }
  function h(D) {
    return D && D.__esModule ? D : { default: D };
  }
  function f(D) {
    "@babel/helpers - typeof";
    return f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(H) {
      return typeof H;
    } : function(H) {
      return H && typeof Symbol == "function" && H.constructor === Symbol && H !== Symbol.prototype ? "symbol" : typeof H;
    }, f(D);
  }
  function r(D, H) {
    var _ = Object.keys(D);
    if (Object.getOwnPropertySymbols) {
      var T = Object.getOwnPropertySymbols(D);
      H && (T = T.filter(function(L) {
        return Object.getOwnPropertyDescriptor(D, L).enumerable;
      })), _.push.apply(_, T);
    }
    return _;
  }
  function m(D) {
    for (var H = 1; H < arguments.length; H++) {
      var _ = arguments[H] != null ? arguments[H] : {};
      H % 2 ? r(Object(_), true).forEach(function(T) {
        g(D, T, _[T]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(D, Object.getOwnPropertyDescriptors(_)) : r(Object(_)).forEach(function(T) {
        Object.defineProperty(D, T, Object.getOwnPropertyDescriptor(_, T));
      });
    }
    return D;
  }
  function g(D, H, _) {
    return (H = R(H)) in D ? Object.defineProperty(D, H, { value: _, enumerable: true, configurable: true, writable: true }) : D[H] = _, D;
  }
  function a() {
    a = function() {
      return H;
    };
    var D, H = {}, _ = Object.prototype, T = _.hasOwnProperty, L = Object.defineProperty || function(P, x, O) {
      P[x] = O.value;
    }, j = typeof Symbol == "function" ? Symbol : {}, z = j.iterator || "@@iterator", Y = j.asyncIterator || "@@asyncIterator", te = j.toStringTag || "@@toStringTag";
    function G(P, x, O) {
      return Object.defineProperty(P, x, { value: O, enumerable: true, configurable: true, writable: true }), P[x];
    }
    try {
      G({}, "");
    } catch {
      G = function(O, V, N) {
        return O[V] = N;
      };
    }
    function K(P, x, O, V) {
      var N = x && x.prototype instanceof ce ? x : ce, C = Object.create(N.prototype), p = new Qe(V || []);
      return L(C, "_invoke", { value: xe(P, O, p) }), C;
    }
    function J(P, x, O) {
      try {
        return { type: "normal", arg: P.call(x, O) };
      } catch (V) {
        return { type: "throw", arg: V };
      }
    }
    H.wrap = K;
    var B = "suspendedStart", Z = "suspendedYield", ie = "executing", $ = "completed", oe = {};
    function ce() {
    }
    function ye() {
    }
    function ae() {
    }
    var ue = {};
    G(ue, z, function() {
      return this;
    });
    var ne = Object.getPrototypeOf, ge = ne && ne(ne(ee([])));
    ge && ge !== _ && T.call(ge, z) && (ue = ge);
    var Te = ae.prototype = ce.prototype = Object.create(ue);
    function pe(P) {
      ["next", "throw", "return"].forEach(function(x) {
        G(P, x, function(O) {
          return this._invoke(x, O);
        });
      });
    }
    function Oe(P, x) {
      function O(N, C, p, A) {
        var U = J(P[N], P, C);
        if (U.type !== "throw") {
          var Q = U.arg, se = Q.value;
          return se && f(se) == "object" && T.call(se, "__await") ? x.resolve(se.__await).then(function(X) {
            O("next", X, p, A);
          }, function(X) {
            O("throw", X, p, A);
          }) : x.resolve(se).then(function(X) {
            Q.value = X, p(Q);
          }, function(X) {
            return O("throw", X, p, A);
          });
        }
        A(U.arg);
      }
      var V;
      L(this, "_invoke", { value: function(C, p) {
        function A() {
          return new x(function(U, Q) {
            O(C, p, U, Q);
          });
        }
        return V = V ? V.then(A, A) : A();
      } });
    }
    function xe(P, x, O) {
      var V = B;
      return function(N, C) {
        if (V === ie) throw Error("Generator is already running");
        if (V === $) {
          if (N === "throw") throw C;
          return { value: D, done: true };
        }
        for (O.method = N, O.arg = C; ; ) {
          var p = O.delegate;
          if (p) {
            var A = Ve(p, O);
            if (A) {
              if (A === oe) continue;
              return A;
            }
          }
          if (O.method === "next") O.sent = O._sent = O.arg;
          else if (O.method === "throw") {
            if (V === B) throw V = $, O.arg;
            O.dispatchException(O.arg);
          } else O.method === "return" && O.abrupt("return", O.arg);
          V = ie;
          var U = J(P, x, O);
          if (U.type === "normal") {
            if (V = O.done ? $ : Z, U.arg === oe) continue;
            return { value: U.arg, done: O.done };
          }
          U.type === "throw" && (V = $, O.method = "throw", O.arg = U.arg);
        }
      };
    }
    function Ve(P, x) {
      var O = x.method, V = P.iterator[O];
      if (V === D) return x.delegate = null, O === "throw" && P.iterator.return && (x.method = "return", x.arg = D, Ve(P, x), x.method === "throw") || O !== "return" && (x.method = "throw", x.arg = new TypeError("The iterator does not provide a '" + O + "' method")), oe;
      var N = J(V, P.iterator, x.arg);
      if (N.type === "throw") return x.method = "throw", x.arg = N.arg, x.delegate = null, oe;
      var C = N.arg;
      return C ? C.done ? (x[P.resultName] = C.value, x.next = P.nextLoc, x.method !== "return" && (x.method = "next", x.arg = D), x.delegate = null, oe) : C : (x.method = "throw", x.arg = new TypeError("iterator result is not an object"), x.delegate = null, oe);
    }
    function _e(P) {
      var x = { tryLoc: P[0] };
      1 in P && (x.catchLoc = P[1]), 2 in P && (x.finallyLoc = P[2], x.afterLoc = P[3]), this.tryEntries.push(x);
    }
    function Be(P) {
      var x = P.completion || {};
      x.type = "normal", delete x.arg, P.completion = x;
    }
    function Qe(P) {
      this.tryEntries = [{ tryLoc: "root" }], P.forEach(_e, this), this.reset(true);
    }
    function ee(P) {
      if (P || P === "") {
        var x = P[z];
        if (x) return x.call(P);
        if (typeof P.next == "function") return P;
        if (!isNaN(P.length)) {
          var O = -1, V = function N() {
            for (; ++O < P.length; ) if (T.call(P, O)) return N.value = P[O], N.done = false, N;
            return N.value = D, N.done = true, N;
          };
          return V.next = V;
        }
      }
      throw new TypeError(f(P) + " is not iterable");
    }
    return ye.prototype = ae, L(Te, "constructor", { value: ae, configurable: true }), L(ae, "constructor", { value: ye, configurable: true }), ye.displayName = G(ae, te, "GeneratorFunction"), H.isGeneratorFunction = function(P) {
      var x = typeof P == "function" && P.constructor;
      return !!x && (x === ye || (x.displayName || x.name) === "GeneratorFunction");
    }, H.mark = function(P) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(P, ae) : (P.__proto__ = ae, G(P, te, "GeneratorFunction")), P.prototype = Object.create(Te), P;
    }, H.awrap = function(P) {
      return { __await: P };
    }, pe(Oe.prototype), G(Oe.prototype, Y, function() {
      return this;
    }), H.AsyncIterator = Oe, H.async = function(P, x, O, V, N) {
      N === void 0 && (N = Promise);
      var C = new Oe(K(P, x, O, V), N);
      return H.isGeneratorFunction(x) ? C : C.next().then(function(p) {
        return p.done ? p.value : C.next();
      });
    }, pe(Te), G(Te, te, "Generator"), G(Te, z, function() {
      return this;
    }), G(Te, "toString", function() {
      return "[object Generator]";
    }), H.keys = function(P) {
      var x = Object(P), O = [];
      for (var V in x) O.push(V);
      return O.reverse(), function N() {
        for (; O.length; ) {
          var C = O.pop();
          if (C in x) return N.value = C, N.done = false, N;
        }
        return N.done = true, N;
      };
    }, H.values = ee, Qe.prototype = { constructor: Qe, reset: function(x) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = D, this.done = false, this.delegate = null, this.method = "next", this.arg = D, this.tryEntries.forEach(Be), !x) for (var O in this) O.charAt(0) === "t" && T.call(this, O) && !isNaN(+O.slice(1)) && (this[O] = D);
    }, stop: function() {
      this.done = true;
      var x = this.tryEntries[0].completion;
      if (x.type === "throw") throw x.arg;
      return this.rval;
    }, dispatchException: function(x) {
      if (this.done) throw x;
      var O = this;
      function V(Q, se) {
        return p.type = "throw", p.arg = x, O.next = Q, se && (O.method = "next", O.arg = D), !!se;
      }
      for (var N = this.tryEntries.length - 1; N >= 0; --N) {
        var C = this.tryEntries[N], p = C.completion;
        if (C.tryLoc === "root") return V("end");
        if (C.tryLoc <= this.prev) {
          var A = T.call(C, "catchLoc"), U = T.call(C, "finallyLoc");
          if (A && U) {
            if (this.prev < C.catchLoc) return V(C.catchLoc, true);
            if (this.prev < C.finallyLoc) return V(C.finallyLoc);
          } else if (A) {
            if (this.prev < C.catchLoc) return V(C.catchLoc, true);
          } else {
            if (!U) throw Error("try statement without catch or finally");
            if (this.prev < C.finallyLoc) return V(C.finallyLoc);
          }
        }
      }
    }, abrupt: function(x, O) {
      for (var V = this.tryEntries.length - 1; V >= 0; --V) {
        var N = this.tryEntries[V];
        if (N.tryLoc <= this.prev && T.call(N, "finallyLoc") && this.prev < N.finallyLoc) {
          var C = N;
          break;
        }
      }
      C && (x === "break" || x === "continue") && C.tryLoc <= O && O <= C.finallyLoc && (C = null);
      var p = C ? C.completion : {};
      return p.type = x, p.arg = O, C ? (this.method = "next", this.next = C.finallyLoc, oe) : this.complete(p);
    }, complete: function(x, O) {
      if (x.type === "throw") throw x.arg;
      return x.type === "break" || x.type === "continue" ? this.next = x.arg : x.type === "return" ? (this.rval = this.arg = x.arg, this.method = "return", this.next = "end") : x.type === "normal" && O && (this.next = O), oe;
    }, finish: function(x) {
      for (var O = this.tryEntries.length - 1; O >= 0; --O) {
        var V = this.tryEntries[O];
        if (V.finallyLoc === x) return this.complete(V.completion, V.afterLoc), Be(V), oe;
      }
    }, catch: function(x) {
      for (var O = this.tryEntries.length - 1; O >= 0; --O) {
        var V = this.tryEntries[O];
        if (V.tryLoc === x) {
          var N = V.completion;
          if (N.type === "throw") {
            var C = N.arg;
            Be(V);
          }
          return C;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(x, O, V) {
      return this.delegate = { iterator: ee(x), resultName: O, nextLoc: V }, this.method === "next" && (this.arg = D), oe;
    } }, H;
  }
  function l(D, H, _, T, L, j, z) {
    try {
      var Y = D[j](z), te = Y.value;
    } catch (G) {
      return void _(G);
    }
    Y.done ? H(te) : Promise.resolve(te).then(T, L);
  }
  function d(D) {
    return function() {
      var H = this, _ = arguments;
      return new Promise(function(T, L) {
        var j = D.apply(H, _);
        function z(te) {
          l(j, T, L, z, Y, "next", te);
        }
        function Y(te) {
          l(j, T, L, z, Y, "throw", te);
        }
        z(void 0);
      });
    };
  }
  function b(D, H) {
    if (!(D instanceof H)) throw new TypeError("Cannot call a class as a function");
  }
  function S(D, H) {
    for (var _ = 0; _ < H.length; _++) {
      var T = H[_];
      T.enumerable = T.enumerable || false, T.configurable = true, "value" in T && (T.writable = true), Object.defineProperty(D, R(T.key), T);
    }
  }
  function E(D, H, _) {
    return H && S(D.prototype, H), Object.defineProperty(D, "prototype", { writable: false }), D;
  }
  function R(D) {
    var H = k(D, "string");
    return f(H) == "symbol" ? H : H + "";
  }
  function k(D, H) {
    if (f(D) != "object" || !D) return D;
    var _ = D[Symbol.toPrimitive];
    if (_ !== void 0) {
      var T = _.call(D, H);
      if (f(T) != "object") return T;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (H === "string" ? String : Number)(D);
  }
  Ti.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
  var w = Ti.Durability = function(D) {
    return D.Temporary = "temporary", D.Persistent = "persistent", D;
  }({}), F = 30, I = Ti.BasicSleepStrategy = function(H) {
    return 1e3;
  };
  Ti.LinearSleepStrategy = function(H) {
    return 1e3 * H;
  };
  function q(D) {
    var H, _ = [];
    switch (D.switch()) {
      case 0:
        _ = D.operations();
        break;
      case 1:
      case 2:
      case 3:
        _ = D.value().operations();
        break;
      default:
        throw new Error("Unexpected transaction meta switch value");
    }
    var T = (H = _.flatMap(function(L) {
      return L.changes();
    }).find(function(L) {
      return L.switch() === e.xdr.LedgerEntryChangeType.ledgerEntryCreated() && L.created().data().switch() === e.xdr.LedgerEntryType.account();
    })) === null || H === void 0 || (H = H.created()) === null || H === void 0 || (H = H.data()) === null || H === void 0 || (H = H.account()) === null || H === void 0 || (H = H.seqNum()) === null || H === void 0 ? void 0 : H.toString();
    if (T) return T;
    throw new Error("No account created in transaction");
  }
  return Ti.RpcServer = function() {
    function D(H) {
      var _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (b(this, D), this.serverURL = (0, v.default)(H), _.headers && Object.keys(_.headers).length !== 0 && n.default.interceptors.request.use(function(T) {
        return T.headers = Object.assign(T.headers, _.headers), T;
      }), this.serverURL.protocol() !== "https" && !_.allowHttp) throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
    }
    return E(D, [{ key: "getAccount", value: function() {
      var H = d(a().mark(function T(L) {
        var j, z, Y;
        return a().wrap(function(G) {
          for (; ; ) switch (G.prev = G.next) {
            case 0:
              return j = e.xdr.LedgerKey.account(new e.xdr.LedgerKeyAccount({ accountId: e.Keypair.fromPublicKey(L).xdrPublicKey() })), G.next = 3, this.getLedgerEntries(j);
            case 3:
              if (z = G.sent, z.entries.length !== 0) {
                G.next = 6;
                break;
              }
              return G.abrupt("return", Promise.reject({ code: 404, message: "Account not found: ".concat(L) }));
            case 6:
              return Y = z.entries[0].val.account(), G.abrupt("return", new e.Account(L, Y.seqNum().toString()));
            case 8:
            case "end":
              return G.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getHealth", value: function() {
      var H = d(a().mark(function T() {
        return a().wrap(function(j) {
          for (; ; ) switch (j.prev = j.next) {
            case 0:
              return j.abrupt("return", i.postObject(this.serverURL.toString(), "getHealth"));
            case 1:
            case "end":
              return j.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getContractData", value: function() {
      var H = d(a().mark(function T(L, j) {
        var z, Y, te, G, K = arguments;
        return a().wrap(function(B) {
          for (; ; ) switch (B.prev = B.next) {
            case 0:
              if (z = K.length > 2 && K[2] !== void 0 ? K[2] : w.Persistent, typeof L != "string") {
                B.next = 5;
                break;
              }
              Y = new e.Contract(L).address().toScAddress(), B.next = 14;
              break;
            case 5:
              if (!(L instanceof e.Address)) {
                B.next = 9;
                break;
              }
              Y = L.toScAddress(), B.next = 14;
              break;
            case 9:
              if (!(L instanceof e.Contract)) {
                B.next = 13;
                break;
              }
              Y = L.address().toScAddress(), B.next = 14;
              break;
            case 13:
              throw new TypeError("unknown contract type: ".concat(L));
            case 14:
              B.t0 = z, B.next = B.t0 === w.Temporary ? 17 : B.t0 === w.Persistent ? 19 : 21;
              break;
            case 17:
              return te = e.xdr.ContractDataDurability.temporary(), B.abrupt("break", 22);
            case 19:
              return te = e.xdr.ContractDataDurability.persistent(), B.abrupt("break", 22);
            case 21:
              throw new TypeError("invalid durability: ".concat(z));
            case 22:
              return G = e.xdr.LedgerKey.contractData(new e.xdr.LedgerKeyContractData({ key: j, contract: Y, durability: te })), B.abrupt("return", this.getLedgerEntries(G).then(function(Z) {
                return Z.entries.length === 0 ? Promise.reject({ code: 404, message: "Contract data not found. Contract: ".concat(e.Address.fromScAddress(Y).toString(), ", Key: ").concat(j.toXDR("base64"), ", Durability: ").concat(z) }) : Z.entries[0];
              }));
            case 24:
            case "end":
              return B.stop();
          }
        }, T, this);
      }));
      function _(T, L) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getContractWasmByContractId", value: function() {
      var H = d(a().mark(function T(L) {
        var j, z, Y, te;
        return a().wrap(function(K) {
          for (; ; ) switch (K.prev = K.next) {
            case 0:
              return z = new e.Contract(L).getFootprint(), K.next = 3, this.getLedgerEntries(z);
            case 3:
              if (Y = K.sent, !(!Y.entries.length || !((j = Y.entries[0]) !== null && j !== void 0 && j.val))) {
                K.next = 6;
                break;
              }
              return K.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract hash from server" }));
            case 6:
              return te = Y.entries[0].val.contractData().val().instance().executable().wasmHash(), K.abrupt("return", this.getContractWasmByHash(te));
            case 8:
            case "end":
              return K.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getContractWasmByHash", value: function() {
      var H = d(a().mark(function T(L) {
        var j, z, Y, te, G, K, J = arguments;
        return a().wrap(function(Z) {
          for (; ; ) switch (Z.prev = Z.next) {
            case 0:
              return z = J.length > 1 && J[1] !== void 0 ? J[1] : void 0, Y = typeof L == "string" ? Buffer.from(L, z) : L, te = e.xdr.LedgerKey.contractCode(new e.xdr.LedgerKeyContractCode({ hash: Y })), Z.next = 5, this.getLedgerEntries(te);
            case 5:
              if (G = Z.sent, !(!G.entries.length || !((j = G.entries[0]) !== null && j !== void 0 && j.val))) {
                Z.next = 8;
                break;
              }
              return Z.abrupt("return", Promise.reject({ code: 404, message: "Could not obtain contract wasm from server" }));
            case 8:
              return K = G.entries[0].val.contractCode().code(), Z.abrupt("return", K);
            case 10:
            case "end":
              return Z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getLedgerEntries", value: function() {
      var H = d(a().mark(function T() {
        var L = arguments;
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", this._getLedgerEntries.apply(this, L).then(t.parseRawLedgerEntries));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_getLedgerEntries", value: function() {
      var H = d(a().mark(function T() {
        var L, j, z, Y = arguments;
        return a().wrap(function(G) {
          for (; ; ) switch (G.prev = G.next) {
            case 0:
              for (L = Y.length, j = new Array(L), z = 0; z < L; z++) j[z] = Y[z];
              return G.abrupt("return", i.postObject(this.serverURL.toString(), "getLedgerEntries", { keys: j.map(function(K) {
                return K.toXDR("base64");
              }) }));
            case 2:
            case "end":
              return G.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "pollTransaction", value: function() {
      var H = d(a().mark(function T(L, j) {
        var z, Y, te, G, K, J;
        return a().wrap(function(Z) {
          for (; ; ) switch (Z.prev = Z.next) {
            case 0:
              te = ((z = j == null ? void 0 : j.attempts) !== null && z !== void 0 ? z : 0) < 1 ? F : (Y = j == null ? void 0 : j.attempts) !== null && Y !== void 0 ? Y : F, K = 1;
            case 2:
              if (!(K < te)) {
                Z.next = 13;
                break;
              }
              return Z.next = 5, this.getTransaction(L);
            case 5:
              if (G = Z.sent, G.status === s.Api.GetTransactionStatus.NOT_FOUND) {
                Z.next = 8;
                break;
              }
              return Z.abrupt("return", G);
            case 8:
              return Z.next = 10, o.Utils.sleep(((J = j == null ? void 0 : j.sleepStrategy) !== null && J !== void 0 ? J : I)(K));
            case 10:
              K++, Z.next = 2;
              break;
            case 13:
              return Z.abrupt("return", G);
            case 14:
            case "end":
              return Z.stop();
          }
        }, T, this);
      }));
      function _(T, L) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getTransaction", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", this._getTransaction(L).then(function(Y) {
                var te = {};
                Y.status !== s.Api.GetTransactionStatus.NOT_FOUND && Object.assign(te, (0, t.parseTransactionInfo)(Y));
                var G = m({ status: Y.status, txHash: L, latestLedger: Y.latestLedger, latestLedgerCloseTime: Y.latestLedgerCloseTime, oldestLedger: Y.oldestLedger, oldestLedgerCloseTime: Y.oldestLedgerCloseTime }, te);
                return G;
              }));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_getTransaction", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", i.postObject(this.serverURL.toString(), "getTransaction", { hash: L }));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getTransactions", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", this._getTransactions(L).then(function(Y) {
                var te = { transactions: Y.transactions.map(t.parseRawTransactions), latestLedger: Y.latestLedger, latestLedgerCloseTimestamp: Y.latestLedgerCloseTimestamp, oldestLedger: Y.oldestLedger, oldestLedgerCloseTimestamp: Y.oldestLedgerCloseTimestamp, cursor: Y.cursor };
                return te;
              }));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_getTransactions", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", i.postObject(this.serverURL.toString(), "getTransactions", L));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getEvents", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", this._getEvents(L).then(t.parseRawEvents));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_getEvents", value: function() {
      var H = d(a().mark(function T(L) {
        var j;
        return a().wrap(function(Y) {
          for (; ; ) switch (Y.prev = Y.next) {
            case 0:
              return Y.abrupt("return", i.postObject(this.serverURL.toString(), "getEvents", m(m({ filters: (j = L.filters) !== null && j !== void 0 ? j : [], pagination: m(m({}, L.cursor && { cursor: L.cursor }), L.limit && { limit: L.limit }) }, L.startLedger && { startLedger: L.startLedger }), L.endLedger && { endLedger: L.endLedger })));
            case 1:
            case "end":
              return Y.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getNetwork", value: function() {
      var H = d(a().mark(function T() {
        return a().wrap(function(j) {
          for (; ; ) switch (j.prev = j.next) {
            case 0:
              return j.abrupt("return", i.postObject(this.serverURL.toString(), "getNetwork"));
            case 1:
            case "end":
              return j.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getLatestLedger", value: function() {
      var H = d(a().mark(function T() {
        return a().wrap(function(j) {
          for (; ; ) switch (j.prev = j.next) {
            case 0:
              return j.abrupt("return", i.postObject(this.serverURL.toString(), "getLatestLedger"));
            case 1:
            case "end":
              return j.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "simulateTransaction", value: function() {
      var H = d(a().mark(function T(L, j) {
        return a().wrap(function(Y) {
          for (; ; ) switch (Y.prev = Y.next) {
            case 0:
              return Y.abrupt("return", this._simulateTransaction(L, j).then(t.parseRawSimulation));
            case 1:
            case "end":
              return Y.stop();
          }
        }, T, this);
      }));
      function _(T, L) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_simulateTransaction", value: function() {
      var H = d(a().mark(function T(L, j) {
        return a().wrap(function(Y) {
          for (; ; ) switch (Y.prev = Y.next) {
            case 0:
              return Y.abrupt("return", i.postObject(this.serverURL.toString(), "simulateTransaction", m({ transaction: L.toXDR() }, j !== void 0 && { resourceConfig: { instructionLeeway: j.cpuInstructions } })));
            case 1:
            case "end":
              return Y.stop();
          }
        }, T, this);
      }));
      function _(T, L) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "prepareTransaction", value: function() {
      var H = d(a().mark(function T(L) {
        var j;
        return a().wrap(function(Y) {
          for (; ; ) switch (Y.prev = Y.next) {
            case 0:
              return Y.next = 2, this.simulateTransaction(L);
            case 2:
              if (j = Y.sent, !s.Api.isSimulationError(j)) {
                Y.next = 5;
                break;
              }
              throw new Error(j.error);
            case 5:
              return Y.abrupt("return", (0, y.assembleTransaction)(L, j).build());
            case 6:
            case "end":
              return Y.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "sendTransaction", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", this._sendTransaction(L).then(t.parseRawSendTransaction));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "_sendTransaction", value: function() {
      var H = d(a().mark(function T(L) {
        return a().wrap(function(z) {
          for (; ; ) switch (z.prev = z.next) {
            case 0:
              return z.abrupt("return", i.postObject(this.serverURL.toString(), "sendTransaction", { transaction: L.toXDR() }));
            case 1:
            case "end":
              return z.stop();
          }
        }, T, this);
      }));
      function _(T) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "requestAirdrop", value: function() {
      var H = d(a().mark(function T(L, j) {
        var z, Y, te, G, K, J, B;
        return a().wrap(function(ie) {
          for (; ; ) switch (ie.prev = ie.next) {
            case 0:
              if (z = typeof L == "string" ? L : L.accountId(), ie.t0 = j, ie.t0) {
                ie.next = 6;
                break;
              }
              return ie.next = 5, this.getNetwork();
            case 5:
              ie.t0 = ie.sent.friendbotUrl;
            case 6:
              if (j = ie.t0, j) {
                ie.next = 9;
                break;
              }
              throw new Error("No friendbot URL configured for current network");
            case 9:
              return ie.prev = 9, ie.next = 12, n.default.post("".concat(j, "?addr=").concat(encodeURIComponent(z)));
            case 12:
              if (Y = ie.sent, Y.data.result_meta_xdr) {
                ie.next = 22;
                break;
              }
              return ie.next = 16, this.getTransaction(Y.data.hash);
            case 16:
              if (G = ie.sent, G.status === s.Api.GetTransactionStatus.SUCCESS) {
                ie.next = 19;
                break;
              }
              throw new Error("Funding account ".concat(L, " failed"));
            case 19:
              te = G.resultMetaXdr, ie.next = 23;
              break;
            case 22:
              te = e.xdr.TransactionMeta.fromXDR(Y.data.result_meta_xdr, "base64");
            case 23:
              return K = q(te), ie.abrupt("return", new e.Account(z, K));
            case 27:
              if (ie.prev = 27, ie.t1 = ie.catch(9), ((J = ie.t1.response) === null || J === void 0 ? void 0 : J.status) !== 400) {
                ie.next = 32;
                break;
              }
              if (!((B = ie.t1.response.detail) !== null && B !== void 0 && B.includes("createAccountAlreadyExist"))) {
                ie.next = 32;
                break;
              }
              return ie.abrupt("return", this.getAccount(z));
            case 32:
              throw ie.t1;
            case 33:
            case "end":
              return ie.stop();
          }
        }, T, this, [[9, 27]]);
      }));
      function _(T, L) {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getFeeStats", value: function() {
      var H = d(a().mark(function T() {
        return a().wrap(function(j) {
          for (; ; ) switch (j.prev = j.next) {
            case 0:
              return j.abrupt("return", i.postObject(this.serverURL.toString(), "getFeeStats"));
            case 1:
            case "end":
              return j.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getVersionInfo", value: function() {
      var H = d(a().mark(function T() {
        return a().wrap(function(j) {
          for (; ; ) switch (j.prev = j.next) {
            case 0:
              return j.abrupt("return", i.postObject(this.serverURL.toString(), "getVersionInfo"));
            case 1:
            case "end":
              return j.stop();
          }
        }, T, this);
      }));
      function _() {
        return H.apply(this, arguments);
      }
      return _;
    }() }, { key: "getSACBalance", value: function() {
      var H = d(a().mark(function T(L, j, z) {
        var Y, te, G, K, J, B, Z, ie, $, oe;
        return a().wrap(function(ye) {
          for (; ; ) switch (ye.prev = ye.next) {
            case 0:
              if (e.StrKey.isValidContract(L)) {
                ye.next = 2;
                break;
              }
              throw new TypeError("expected contract ID, got ".concat(L));
            case 2:
              if (z == null) {
                ye.next = 6;
                break;
              }
              ye.t0 = z, ye.next = 9;
              break;
            case 6:
              return ye.next = 8, this.getNetwork().then(function(ae) {
                return ae.passphrase;
              });
            case 8:
              ye.t0 = ye.sent;
            case 9:
              return Y = ye.t0, te = j.contractId(Y), G = e.xdr.ScVal.scvVec([(0, e.nativeToScVal)("Balance", { type: "symbol" }), (0, e.nativeToScVal)(L, { type: "address" })]), K = e.xdr.LedgerKey.contractData(new e.xdr.LedgerKeyContractData({ contract: new e.Address(te).toScAddress(), durability: e.xdr.ContractDataDurability.persistent(), key: G })), ye.next = 15, this.getLedgerEntries(K);
            case 15:
              if (J = ye.sent, J.entries.length !== 0) {
                ye.next = 18;
                break;
              }
              return ye.abrupt("return", { latestLedger: J.latestLedger });
            case 18:
              if (B = J.entries[0], Z = B.lastModifiedLedgerSeq, ie = B.liveUntilLedgerSeq, $ = B.val, $.switch().value === e.xdr.LedgerEntryType.contractData().value) {
                ye.next = 21;
                break;
              }
              return ye.abrupt("return", { latestLedger: J.latestLedger });
            case 21:
              return oe = (0, e.scValToNative)($.contractData().val()), ye.abrupt("return", { latestLedger: J.latestLedger, balanceEntry: { liveUntilLedgerSeq: ie, lastModifiedLedgerSeq: Z, amount: oe.amount.toString(), authorized: oe.authorized, clawback: oe.clawback } });
            case 23:
            case "end":
              return ye.stop();
          }
        }, T, this);
      }));
      function _(T, L, j) {
        return H.apply(this, arguments);
      }
      return _;
    }() }]);
  }(), Ti;
}
var Eh;
function Ac() {
  return Eh || (Eh = 1, function(v, e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var n = { Server: true, BasicSleepStrategy: true, LinearSleepStrategy: true, Durability: true, AxiosClient: true, parseRawSimulation: true, parseRawEvents: true };
    Object.defineProperty(e, "AxiosClient", { enumerable: true, get: function() {
      return y.default;
    } }), Object.defineProperty(e, "BasicSleepStrategy", { enumerable: true, get: function() {
      return s.BasicSleepStrategy;
    } }), Object.defineProperty(e, "Durability", { enumerable: true, get: function() {
      return s.Durability;
    } }), Object.defineProperty(e, "LinearSleepStrategy", { enumerable: true, get: function() {
      return s.LinearSleepStrategy;
    } }), Object.defineProperty(e, "Server", { enumerable: true, get: function() {
      return s.RpcServer;
    } }), e.default = void 0, Object.defineProperty(e, "parseRawEvents", { enumerable: true, get: function() {
      return t.parseRawEvents;
    } }), Object.defineProperty(e, "parseRawSimulation", { enumerable: true, get: function() {
      return t.parseRawSimulation;
    } });
    var i = Ia();
    Object.keys(i).forEach(function(c) {
      c === "default" || c === "__esModule" || Object.prototype.hasOwnProperty.call(n, c) || c in e && e[c] === i[c] || Object.defineProperty(e, c, { enumerable: true, get: function() {
        return i[c];
      } });
    });
    var s = Tg(), y = u(nf()), t = of(), o = af();
    Object.keys(o).forEach(function(c) {
      c === "default" || c === "__esModule" || Object.prototype.hasOwnProperty.call(n, c) || c in e && e[c] === o[c] || Object.defineProperty(e, c, { enumerable: true, get: function() {
        return o[c];
      } });
    });
    function u(c) {
      return c && c.__esModule ? c : { default: c };
    }
    e.default = v.exports;
  }(Ws, Ws.exports)), Ws.exports;
}
var no = Ac(), cc = { exports: {} }, kg = cc.exports, Ah;
function Og() {
  return Ah || (Ah = 1, function(v, e) {
    (function(n, i) {
      v.exports = i();
    })(kg, () => (() => {
      var n, i, s = { d: (I, q) => {
        for (var D in q) s.o(q, D) && !s.o(I, D) && Object.defineProperty(I, D, { enumerable: true, get: q[D] });
      }, o: (I, q) => Object.prototype.hasOwnProperty.call(I, q), r: (I) => {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(I, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(I, "__esModule", { value: true });
      } }, y = {};
      s.r(y), s.d(y, { WatchWalletChanges: () => k, addToken: () => r, default: () => F, getAddress: () => f, getNetwork: () => d, getNetworkDetails: () => b, isAllowed: () => S, isBrowser: () => w, isConnected: () => l, requestAccess: () => R, setAllowed: () => E, signAuthEntry: () => a, signMessage: () => g, signTransaction: () => m }), function(I) {
        I.CREATE_ACCOUNT = "CREATE_ACCOUNT", I.FUND_ACCOUNT = "FUND_ACCOUNT", I.ADD_ACCOUNT = "ADD_ACCOUNT", I.IMPORT_ACCOUNT = "IMPORT_ACCOUNT", I.IMPORT_HARDWARE_WALLET = "IMPORT_HARDWARE_WALLET", I.LOAD_ACCOUNT = "LOAD_ACCOUNT", I.MAKE_ACCOUNT_ACTIVE = "MAKE_ACCOUNT_ACTIVE", I.UPDATE_ACCOUNT_NAME = "UPDATE_ACCOUNT_NAME", I.GET_MNEMONIC_PHRASE = "GET_MNEMONIC_PHRASE", I.CONFIRM_MNEMONIC_PHRASE = "CONFIRM_MNEMONIC_PHRASE", I.CONFIRM_MIGRATED_MNEMONIC_PHRASE = "CONFIRM_MIGRATED_MNEMONIC_PHRASE", I.RECOVER_ACCOUNT = "RECOVER_ACCOUNT", I.CONFIRM_PASSWORD = "CONFIRM_PASSWORD", I.REJECT_ACCESS = "REJECT_ACCESS", I.GRANT_ACCESS = "GRANT_ACCESS", I.ADD_TOKEN = "ADD_TOKEN", I.SIGN_TRANSACTION = "SIGN_TRANSACTION", I.SIGN_BLOB = "SIGN_BLOB", I.SIGN_AUTH_ENTRY = "SIGN_AUTH_ENTRY", I.HANDLE_SIGNED_HW_PAYLOAD = "HANDLE_SIGNED_HW_PAYLOAD", I.REJECT_TRANSACTION = "REJECT_TRANSACTION", I.SIGN_FREIGHTER_TRANSACTION = "SIGN_FREIGHTER_TRANSACTION", I.SIGN_FREIGHTER_SOROBAN_TRANSACTION = "SIGN_FREIGHTER_SOROBAN_TRANSACTION", I.ADD_RECENT_ADDRESS = "ADD_RECENT_ADDRESS", I.LOAD_RECENT_ADDRESSES = "LOAD_RECENT_ADDRESSES", I.LOAD_LAST_USED_ACCOUNT = "LOAD_LAST_USED_ACCOUNT", I.SIGN_OUT = "SIGN_OUT", I.SHOW_BACKUP_PHRASE = "SHOW_BACKUP_PHRASE", I.SAVE_ALLOWLIST = "SAVE_ALLOWLIST", I.SAVE_SETTINGS = "SAVE_SETTINGS", I.SAVE_EXPERIMENTAL_FEATURES = "SAVE_EXPERIMENTAL_FEATURES", I.LOAD_SETTINGS = "LOAD_SETTINGS", I.GET_CACHED_ASSET_ICON = "GET_CACHED_ASSET_ICON", I.CACHE_ASSET_ICON = "CACHE_ASSET_ICON", I.GET_CACHED_ASSET_DOMAIN = "GET_CACHED_ASSET_DOMAIN", I.CACHE_ASSET_DOMAIN = "CACHE_ASSET_DOMAIN", I.GET_MEMO_REQUIRED_ACCOUNTS = "GET_MEMO_REQUIRED_ACCOUNTS", I.ADD_CUSTOM_NETWORK = "ADD_CUSTOM_NETWORK", I.CHANGE_NETWORK = "CHANGE_NETWORK", I.REMOVE_CUSTOM_NETWORK = "REMOVE_CUSTOM_NETWORK", I.EDIT_CUSTOM_NETWORK = "EDIT_CUSTOM_NETWORK", I.RESET_EXP_DATA = "RESET_EXP_DATA", I.ADD_TOKEN_ID = "ADD_TOKEN_ID", I.GET_TOKEN_IDS = "GET_TOKEN_IDS", I.REMOVE_TOKEN_ID = "REMOVE_TOKEN_ID", I.GET_MIGRATABLE_ACCOUNTS = "GET_MIGRATABLE_ACCOUNTS", I.GET_MIGRATED_MNEMONIC_PHRASE = "GET_MIGRATED_MNEMONIC_PHRASE", I.MIGRATE_ACCOUNTS = "MIGRATE_ACCOUNTS", I.ADD_ASSETS_LIST = "ADD_ASSETS_LIST", I.MODIFY_ASSETS_LIST = "MODIFY_ASSETS_LIST";
      }(n || (n = {})), function(I) {
        I.REQUEST_ACCESS = "REQUEST_ACCESS", I.REQUEST_PUBLIC_KEY = "REQUEST_PUBLIC_KEY", I.SUBMIT_TOKEN = "SUBMIT_TOKEN", I.SUBMIT_TRANSACTION = "SUBMIT_TRANSACTION", I.SUBMIT_BLOB = "SUBMIT_BLOB", I.SUBMIT_AUTH_ENTRY = "SUBMIT_AUTH_ENTRY", I.REQUEST_NETWORK = "REQUEST_NETWORK", I.REQUEST_NETWORK_DETAILS = "REQUEST_NETWORK_DETAILS", I.REQUEST_CONNECTION_STATUS = "REQUEST_CONNECTION_STATUS", I.REQUEST_ALLOWED_STATUS = "REQUEST_ALLOWED_STATUS", I.SET_ALLOWED_STATUS = "SET_ALLOWED_STATUS", I.REQUEST_USER_INFO = "REQUEST_USER_INFO";
      }(i || (i = {}));
      const t = (I) => {
        const q = Date.now() + Math.random();
        return window.postMessage({ source: "FREIGHTER_EXTERNAL_MSG_REQUEST", messageId: q, ...I }, window.location.origin), new Promise((D) => {
          let H = 0;
          I.type !== i.REQUEST_CONNECTION_STATUS && I.type !== i.REQUEST_PUBLIC_KEY || (H = setTimeout(() => {
            D({ isConnected: false, publicKey: "" }), window.removeEventListener("message", _);
          }, 2e3));
          const _ = (T) => {
            var L, j;
            T.source === window && ((L = T == null ? void 0 : T.data) === null || L === void 0 ? void 0 : L.source) === "FREIGHTER_EXTERNAL_MSG_RESPONSE" && ((j = T == null ? void 0 : T.data) === null || j === void 0 ? void 0 : j.messagedId) === q && (D(T.data), window.removeEventListener("message", _), clearTimeout(H));
          };
          window.addEventListener("message", _, false);
        });
      }, o = { code: -1, message: "Node environment is not supported" }, u = { code: -1, message: "The wallet encountered an internal error. Please try again or contact the wallet if the problem persists." }, c = async () => {
        let I;
        try {
          I = await t({ type: i.REQUEST_PUBLIC_KEY });
        } catch (q) {
          console.error(q);
        }
        return { publicKey: (I == null ? void 0 : I.publicKey) || "", error: I == null ? void 0 : I.apiError };
      }, h = async () => {
        let I;
        try {
          I = await t({ type: i.REQUEST_NETWORK_DETAILS });
        } catch (j) {
          console.error(j);
        }
        const { networkDetails: q, apiError: D } = I || { networkDetails: { network: "", networkUrl: "", networkPassphrase: "", sorobanRpcUrl: void 0 } }, { network: H, networkUrl: _, networkPassphrase: T, sorobanRpcUrl: L } = q;
        return { network: H, networkUrl: _, networkPassphrase: T, sorobanRpcUrl: L, error: D };
      }, f = async () => {
        let I = "";
        if (w) {
          const q = await c();
          return I = q.publicKey, q.error ? { address: I, error: q.error } : { address: I };
        }
        return { address: I, error: o };
      }, r = async (I) => {
        if (w) {
          const q = await (async (D) => {
            let H;
            try {
              H = await t({ contractId: D.contractId, networkPassphrase: D.networkPassphrase, type: i.SUBMIT_TOKEN });
            } catch {
              return { error: u };
            }
            return { contractId: H.contractId, error: H == null ? void 0 : H.apiError };
          })(I);
          return q.error ? { contractId: "", error: q.error } : { contractId: q.contractId || "" };
        }
        return { contractId: "", error: o };
      }, m = async (I, q) => {
        if (w) {
          const D = await (async (H, _) => {
            let T, L, j, z;
            typeof _ == "object" ? (L = _.accountToSign, j = _.networkPassphrase) : (T = _, L = void 0);
            try {
              z = await t({ transactionXdr: H, network: T, networkPassphrase: j, accountToSign: L, type: i.SUBMIT_TRANSACTION });
            } catch {
              return { signedTransaction: "", signerAddress: "", error: u };
            }
            const { signedTransaction: Y, signerAddress: te } = z;
            return { signedTransaction: Y, signerAddress: te, error: z == null ? void 0 : z.apiError };
          })(I, q);
          return D.error ? { signedTxXdr: "", signerAddress: "", error: D.error } : { signedTxXdr: D.signedTransaction, signerAddress: D.signerAddress };
        }
        return { signedTxXdr: "", signerAddress: "", error: o };
      }, g = async (I, q) => {
        if (w) {
          const D = await (async (H, _, T) => {
            let L;
            const j = (T || {}).address;
            try {
              L = await t({ blob: H, accountToSign: j, apiVersion: _, type: i.SUBMIT_BLOB });
            } catch {
              return { signedMessage: null, signerAddress: "", error: u };
            }
            const { signedBlob: z, signerAddress: Y } = L;
            return { signedMessage: z || null, signerAddress: Y, error: L == null ? void 0 : L.apiError };
          })(I, "4.1.0", q);
          return D.error ? { signedMessage: null, signerAddress: "", error: D.error } : { signedMessage: D.signedMessage, signerAddress: D.signerAddress };
        }
        return { signedMessage: null, signerAddress: "", error: o };
      }, a = async (I, q) => {
        if (w) {
          const D = await (async (H, _) => {
            const T = (_ || {}).address;
            let L;
            try {
              L = await t({ entryXdr: H, accountToSign: T, networkPassphrase: _ == null ? void 0 : _.networkPassphrase, type: i.SUBMIT_AUTH_ENTRY });
            } catch (Y) {
              return console.error(Y), { signedAuthEntry: null, signerAddress: "", error: u };
            }
            const { signedAuthEntry: j, signerAddress: z } = L;
            return { signedAuthEntry: j || null, signerAddress: z, error: L == null ? void 0 : L.apiError };
          })(I, q);
          return D.error ? { signedAuthEntry: null, signerAddress: "", error: D.error } : { signedAuthEntry: D.signedAuthEntry, signerAddress: D.signerAddress };
        }
        return { signedAuthEntry: null, signerAddress: "", error: o };
      }, l = async () => w ? window.freighter ? Promise.resolve({ isConnected: window.freighter }) : (async () => {
        let I = { isConnected: false };
        try {
          I = await t({ type: i.REQUEST_CONNECTION_STATUS });
        } catch (q) {
          console.error(q);
        }
        return { isConnected: I.isConnected };
      })() : { isConnected: false, error: o }, d = async () => {
        if (w) {
          const I = await (async () => {
            let q;
            try {
              q = await t({ type: i.REQUEST_NETWORK_DETAILS });
            } catch (H) {
              console.error(H);
            }
            const { networkDetails: D } = q || { networkDetails: { network: "", networkPassphrase: "" } };
            return { network: D == null ? void 0 : D.network, networkPassphrase: D == null ? void 0 : D.networkPassphrase, error: q == null ? void 0 : q.apiError };
          })();
          return I.error ? { network: "", networkPassphrase: "", error: I.error } : { network: I.network, networkPassphrase: I.networkPassphrase };
        }
        return { network: "", networkPassphrase: "", error: o };
      }, b = async () => {
        if (w) {
          const I = await h();
          return I.error ? { network: "", networkUrl: "", networkPassphrase: "", error: I.error } : { network: I.network, networkUrl: I.networkUrl, networkPassphrase: I.networkPassphrase, sorobanRpcUrl: I.sorobanRpcUrl };
        }
        return { network: "", networkUrl: "", networkPassphrase: "", error: o };
      }, S = async () => {
        let I = false;
        if (w) {
          const q = await (async () => {
            let D;
            try {
              D = await t({ type: i.REQUEST_ALLOWED_STATUS });
            } catch (_) {
              console.error(_);
            }
            const { isAllowed: H } = D || { isAllowed: false };
            return { isAllowed: H, error: D == null ? void 0 : D.apiError };
          })();
          return I = q.isAllowed, q.error ? { isAllowed: I, error: q.error } : { isAllowed: I };
        }
        return { isAllowed: I, error: o };
      }, E = async () => {
        let I = false;
        if (w) {
          const q = await (async () => {
            let D;
            try {
              D = await t({ type: i.SET_ALLOWED_STATUS });
            } catch (_) {
              console.error(_);
            }
            const { isAllowed: H } = D || { isAllowed: false };
            return { isAllowed: H, error: D == null ? void 0 : D.apiError };
          })();
          return I = q.isAllowed, q.error ? { isAllowed: I, error: q.error } : { isAllowed: I };
        }
        return { isAllowed: I, error: o };
      }, R = async () => {
        let I = "";
        if (w) {
          const q = await (async () => {
            let D;
            try {
              D = await t({ type: i.REQUEST_ACCESS });
            } catch (_) {
              console.error(_);
            }
            const { publicKey: H } = D || { publicKey: "" };
            return { publicKey: H, error: D == null ? void 0 : D.apiError };
          })();
          return I = q.publicKey, q.error ? { address: I, error: q.error } : { address: I };
        }
        return { address: I, error: o };
      };
      class k {
        constructor(q = 3e3) {
          this.fetchInfo = async (D) => {
            if (!this.isRunning) return;
            const H = await c(), _ = await h();
            (H.error || _.error) && D({ address: "", network: "", networkPassphrase: "", error: H.error || _.error }), this.currentAddress === H.publicKey && this.currentNetwork === _.network && this.currentNetworkPassphrase === _.networkPassphrase || (this.currentAddress = H.publicKey, this.currentNetwork = _.network, this.currentNetworkPassphrase = _.networkPassphrase, D({ address: H.publicKey, network: _.network, networkPassphrase: _.networkPassphrase })), setTimeout(() => this.fetchInfo(D), this.timeout);
          }, this.timeout = q, this.currentAddress = "", this.currentNetwork = "", this.currentNetworkPassphrase = "", this.isRunning = false;
        }
        watch(q) {
          return w ? (this.isRunning = true, this.fetchInfo(q), {}) : { error: o };
        }
        stop() {
          this.isRunning = false;
        }
      }
      const w = typeof window < "u", F = { getAddress: f, addToken: r, signTransaction: m, signMessage: g, signAuthEntry: a, isConnected: l, getNetwork: d, getNetworkDetails: b, isAllowed: S, setAllowed: E, requestAccess: R, WatchWalletChanges: k };
      return y;
    })());
  }(cc)), cc.exports;
}
var Pg = Og();
const Tu = $d(Pg);
var Cg = Object.defineProperty, Rg = (v, e, n) => e in v ? Cg(v, e, { enumerable: true, configurable: true, writable: true, value: n }) : v[e] = n, Mg = (v, e, n) => (Rg(v, e + "", n), n);
/**
* @license
* Copyright 2010-2022 Three.js Authors
* SPDX-License-Identifier: MIT
*/
const sf = "143", Ao = "srgb", ea = "srgb-linear", xh = "300 es";
class Da {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return false;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(n);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let s = 0, y = i.length; s < y; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const di = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], Jc = Math.PI / 180, jl = 180 / Math.PI;
function Fs() {
  const v = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (di[v & 255] + di[v >> 8 & 255] + di[v >> 16 & 255] + di[v >> 24 & 255] + "-" + di[e & 255] + di[e >> 8 & 255] + "-" + di[e >> 16 & 15 | 64] + di[e >> 24 & 255] + "-" + di[n & 63 | 128] + di[n >> 8 & 255] + "-" + di[n >> 16 & 255] + di[n >> 24 & 255] + di[i & 255] + di[i >> 8 & 255] + di[i >> 16 & 255] + di[i >> 24 & 255]).toLowerCase();
}
function Ci(v, e, n) {
  return Math.max(e, Math.min(n, v));
}
function Ig(v, e) {
  return (v % e + e) % e;
}
function el(v, e, n) {
  return (1 - n) * v + n * e;
}
function Th(v) {
  return (v & v - 1) === 0 && v !== 0;
}
function Vl(v) {
  return Math.pow(2, Math.floor(Math.log(v) / Math.LN2));
}
class In {
  constructor(e = 0, n = 0) {
    In.prototype.isVector2 = true, this.x = e, this.y = n;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return this.x = e, this.y = n, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = e.elements;
    return this.x = s[0] * n + s[3] * i + s[6], this.y = s[1] * n + s[4] * i + s[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n), s = Math.sin(n), y = this.x - e.x, t = this.y - e.y;
    return this.x = y * i - t * s + e.x, this.y = y * s + t * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Vi {
  constructor() {
    Vi.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  set(e, n, i, s, y, t, o, u, c) {
    const h = this.elements;
    return h[0] = e, h[1] = s, h[2] = o, h[3] = n, h[4] = y, h[5] = u, h[6] = i, h[7] = t, h[8] = c, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrix3Column(this, 0), n.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, y = this.elements, t = i[0], o = i[3], u = i[6], c = i[1], h = i[4], f = i[7], r = i[2], m = i[5], g = i[8], a = s[0], l = s[3], d = s[6], b = s[1], S = s[4], E = s[7], R = s[2], k = s[5], w = s[8];
    return y[0] = t * a + o * b + u * R, y[3] = t * l + o * S + u * k, y[6] = t * d + o * E + u * w, y[1] = c * a + h * b + f * R, y[4] = c * l + h * S + f * k, y[7] = c * d + h * E + f * w, y[2] = r * a + m * b + g * R, y[5] = r * l + m * S + g * k, y[8] = r * d + m * E + g * w, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= e, n[4] *= e, n[7] *= e, n[2] *= e, n[5] *= e, n[8] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], y = e[3], t = e[4], o = e[5], u = e[6], c = e[7], h = e[8];
    return n * t * h - n * o * c - i * y * h + i * o * u + s * y * c - s * t * u;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], y = e[3], t = e[4], o = e[5], u = e[6], c = e[7], h = e[8], f = h * t - o * c, r = o * u - h * y, m = c * y - t * u, g = n * f + i * r + s * m;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const a = 1 / g;
    return e[0] = f * a, e[1] = (s * c - h * i) * a, e[2] = (o * i - s * t) * a, e[3] = r * a, e[4] = (h * n - s * u) * a, e[5] = (s * y - o * n) * a, e[6] = m * a, e[7] = (i * u - c * n) * a, e[8] = (t * n - i * y) * a, this;
  }
  transpose() {
    let e;
    const n = this.elements;
    return e = n[1], n[1] = n[3], n[3] = e, e = n[2], n[2] = n[6], n[6] = e, e = n[5], n[5] = n[7], n[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return e[0] = n[0], e[1] = n[3], e[2] = n[6], e[3] = n[1], e[4] = n[4], e[5] = n[7], e[6] = n[2], e[7] = n[5], e[8] = n[8], this;
  }
  setUvTransform(e, n, i, s, y, t, o) {
    const u = Math.cos(y), c = Math.sin(y);
    return this.set(i * u, i * c, -i * (u * t + c * o) + t + e, -s * c, s * u, -s * (-c * t + u * o) + o + n, 0, 0, 1), this;
  }
  scale(e, n) {
    const i = this.elements;
    return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= n, i[4] *= n, i[7] *= n, this;
  }
  rotate(e) {
    const n = Math.cos(e), i = Math.sin(e), s = this.elements, y = s[0], t = s[3], o = s[6], u = s[1], c = s[4], h = s[7];
    return s[0] = n * y + i * u, s[3] = n * t + i * c, s[6] = n * o + i * h, s[1] = -i * y + n * u, s[4] = -i * t + n * c, s[7] = -i * o + n * h, this;
  }
  translate(e, n) {
    const i = this.elements;
    return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += n * i[2], i[4] += n * i[5], i[7] += n * i[8], this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 9; s++) if (n[s] !== i[s]) return false;
    return true;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
function vm(v) {
  for (let e = v.length - 1; e >= 0; --e) if (v[e] > 65535) return true;
  return false;
}
function bc(v) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", v);
}
function ta(v) {
  return v < 0.04045 ? v * 0.0773993808 : Math.pow(v * 0.9478672986 + 0.0521327014, 2.4);
}
function lc(v) {
  return v < 31308e-7 ? v * 12.92 : 1.055 * Math.pow(v, 0.41666) - 0.055;
}
const tl = { [Ao]: { [ea]: ta }, [ea]: { [Ao]: lc } }, qi = { legacyMode: true, get workingColorSpace() {
  return ea;
}, set workingColorSpace(v) {
  console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
}, convert: function(v, e, n) {
  if (this.legacyMode || e === n || !e || !n) return v;
  if (tl[e] && tl[e][n] !== void 0) {
    const i = tl[e][n];
    return v.r = i(v.r), v.g = i(v.g), v.b = i(v.b), v;
  }
  throw new Error("Unsupported color space conversion.");
}, fromWorkingColorSpace: function(v, e) {
  return this.convert(v, this.workingColorSpace, e);
}, toWorkingColorSpace: function(v, e) {
  return this.convert(v, e, this.workingColorSpace);
} }, bm = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, si = { r: 0, g: 0, b: 0 }, zi = { h: 0, s: 0, l: 0 }, ku = { h: 0, s: 0, l: 0 };
function rl(v, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? v + (e - v) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? v + (e - v) * 6 * (2 / 3 - n) : v;
}
function Ou(v, e) {
  return e.r = v.r, e.g = v.g, e.b = v.b, e;
}
class Mn {
  constructor(e, n, i) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, n === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, n, i);
  }
  set(e) {
    return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, n = Ao) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, qi.toWorkingColorSpace(this, n), this;
  }
  setRGB(e, n, i, s = ea) {
    return this.r = e, this.g = n, this.b = i, qi.toWorkingColorSpace(this, s), this;
  }
  setHSL(e, n, i, s = ea) {
    if (e = Ig(e, 1), n = Ci(n, 0, 1), i = Ci(i, 0, 1), n === 0) this.r = this.g = this.b = i;
    else {
      const y = i <= 0.5 ? i * (1 + n) : i + n - i * n, t = 2 * i - y;
      this.r = rl(t, y, e + 1 / 3), this.g = rl(t, y, e), this.b = rl(t, y, e - 1 / 3);
    }
    return qi.toWorkingColorSpace(this, s), this;
  }
  setStyle(e, n = Ao) {
    function i(y) {
      y !== void 0 && parseFloat(y) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let s;
    if (s = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
      let y;
      const t = s[1], o = s[2];
      switch (t) {
        case "rgb":
        case "rgba":
          if (y = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(y[1], 10)) / 255, this.g = Math.min(255, parseInt(y[2], 10)) / 255, this.b = Math.min(255, parseInt(y[3], 10)) / 255, qi.toWorkingColorSpace(this, n), i(y[4]), this;
          if (y = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(y[1], 10)) / 100, this.g = Math.min(100, parseInt(y[2], 10)) / 100, this.b = Math.min(100, parseInt(y[3], 10)) / 100, qi.toWorkingColorSpace(this, n), i(y[4]), this;
          break;
        case "hsl":
        case "hsla":
          if (y = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
            const u = parseFloat(y[1]) / 360, c = parseInt(y[2], 10) / 100, h = parseInt(y[3], 10) / 100;
            return i(y[4]), this.setHSL(u, c, h, n);
          }
          break;
      }
    } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const y = s[1], t = y.length;
      if (t === 3) return this.r = parseInt(y.charAt(0) + y.charAt(0), 16) / 255, this.g = parseInt(y.charAt(1) + y.charAt(1), 16) / 255, this.b = parseInt(y.charAt(2) + y.charAt(2), 16) / 255, qi.toWorkingColorSpace(this, n), this;
      if (t === 6) return this.r = parseInt(y.charAt(0) + y.charAt(1), 16) / 255, this.g = parseInt(y.charAt(2) + y.charAt(3), 16) / 255, this.b = parseInt(y.charAt(4) + y.charAt(5), 16) / 255, qi.toWorkingColorSpace(this, n), this;
    }
    return e && e.length > 0 ? this.setColorName(e, n) : this;
  }
  setColorName(e, n = Ao) {
    const i = bm[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, n) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = ta(e.r), this.g = ta(e.g), this.b = ta(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = lc(e.r), this.g = lc(e.g), this.b = lc(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ao) {
    return qi.fromWorkingColorSpace(Ou(this, si), e), Ci(si.r * 255, 0, 255) << 16 ^ Ci(si.g * 255, 0, 255) << 8 ^ Ci(si.b * 255, 0, 255) << 0;
  }
  getHexString(e = Ao) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = ea) {
    qi.fromWorkingColorSpace(Ou(this, si), n);
    const i = si.r, s = si.g, y = si.b, t = Math.max(i, s, y), o = Math.min(i, s, y);
    let u, c;
    const h = (o + t) / 2;
    if (o === t) u = 0, c = 0;
    else {
      const f = t - o;
      switch (c = h <= 0.5 ? f / (t + o) : f / (2 - t - o), t) {
        case i:
          u = (s - y) / f + (s < y ? 6 : 0);
          break;
        case s:
          u = (y - i) / f + 2;
          break;
        case y:
          u = (i - s) / f + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = c, e.l = h, e;
  }
  getRGB(e, n = ea) {
    return qi.fromWorkingColorSpace(Ou(this, si), n), e.r = si.r, e.g = si.g, e.b = si.b, e;
  }
  getStyle(e = Ao) {
    return qi.fromWorkingColorSpace(Ou(this, si), e), e !== Ao ? `color(${e} ${si.r} ${si.g} ${si.b})` : `rgb(${si.r * 255 | 0},${si.g * 255 | 0},${si.b * 255 | 0})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(zi), zi.h += e, zi.s += n, zi.l += i, this.setHSL(zi.h, zi.s, zi.l), this;
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, n) {
    return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, n) {
    return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
  }
  lerpColors(e, n, i) {
    return this.r = e.r + (n.r - e.r) * i, this.g = e.g + (n.g - e.g) * i, this.b = e.b + (n.b - e.b) * i, this;
  }
  lerpHSL(e, n) {
    this.getHSL(zi), e.getHSL(ku);
    const i = el(zi.h, ku.h, n), s = el(zi.s, ku.s, n), y = el(zi.l, ku.l, n);
    return this.setHSL(i, s, y), this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
  }
  fromBufferAttribute(e, n) {
    return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), e.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
Mn.NAMES = bm;
let pa;
class wm {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      pa === void 0 && (pa = bc("canvas")), pa.width = e.width, pa.height = e.height;
      const i = pa.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = pa;
    }
    return n.width > 2048 || n.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), n.toDataURL("image/jpeg", 0.6)) : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const n = bc("canvas");
      n.width = e.width, n.height = e.height;
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const s = i.getImageData(0, 0, e.width, e.height), y = s.data;
      for (let t = 0; t < y.length; t++) y[t] = ta(y[t] / 255) * 255;
      return i.putImageData(s, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++) n instanceof Uint8Array || n instanceof Uint8ClampedArray ? n[i] = Math.floor(ta(n[i] / 255) * 255) : n[i] = ta(n[i]);
      return { data: n, width: e.width, height: e.height };
    } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
class Sm {
  constructor(e = null) {
    this.isSource = true, this.uuid = Fs(), this.data = e, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" }, s = this.data;
    if (s !== null) {
      let y;
      if (Array.isArray(s)) {
        y = [];
        for (let t = 0, o = s.length; t < o; t++) s[t].isDataTexture ? y.push(nl(s[t].image)) : y.push(nl(s[t]));
      } else y = nl(s);
      i.url = y;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function nl(v) {
  return typeof HTMLImageElement < "u" && v instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && v instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && v instanceof ImageBitmap ? wm.getDataURL(v) : v.data ? { data: Array.from(v.data), width: v.width, height: v.height, type: v.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Lg = 0;
class Mi extends Da {
  constructor(e = Mi.DEFAULT_IMAGE, n = Mi.DEFAULT_MAPPING, i = 1001, s = 1001, y = 1006, t = 1008, o = 1023, u = 1009, c = 1, h = 3e3) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: Lg++ }), this.uuid = Fs(), this.name = "", this.source = new Sm(e), this.mipmaps = [], this.mapping = n, this.wrapS = i, this.wrapT = s, this.magFilter = y, this.minFilter = t, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = u, this.offset = new In(0, 0), this.repeat = new In(1, 1), this.center = new In(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Vi(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = h, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(e) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData), n || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== 300) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
      case 1e3:
        e.x = e.x - Math.floor(e.x);
        break;
      case 1001:
        e.x = e.x < 0 ? 0 : 1;
        break;
      case 1002:
        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
        break;
    }
    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
      case 1e3:
        e.y = e.y - Math.floor(e.y);
        break;
      case 1001:
        e.y = e.y < 0 ? 0 : 1;
        break;
      case 1002:
        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
        break;
    }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === true && (this.version++, this.source.needsUpdate = true);
  }
}
Mi.DEFAULT_IMAGE = null;
Mi.DEFAULT_MAPPING = 300;
class ci {
  constructor(e = 0, n = 0, i = 0, s = 1) {
    ci.prototype.isVector4 = true, this.x = e, this.y = n, this.z = i, this.w = s;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, s) {
    return this.x = e, this.y = n, this.z = i, this.w = s, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this.w = e.w + n.w, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this.w += e.w * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this.w = e.w - n.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, y = this.w, t = e.elements;
    return this.x = t[0] * n + t[4] * i + t[8] * s + t[12] * y, this.y = t[1] * n + t[5] * i + t[9] * s + t[13] * y, this.z = t[2] * n + t[6] * i + t[10] * s + t[14] * y, this.w = t[3] * n + t[7] * i + t[11] * s + t[15] * y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return n < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / n, this.y = e.y / n, this.z = e.z / n), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, s, y;
    const t = e.elements, o = t[0], u = t[4], c = t[8], h = t[1], f = t[5], r = t[9], m = t[2], g = t[6], a = t[10];
    if (Math.abs(u - h) < 0.01 && Math.abs(c - m) < 0.01 && Math.abs(r - g) < 0.01) {
      if (Math.abs(u + h) < 0.1 && Math.abs(c + m) < 0.1 && Math.abs(r + g) < 0.1 && Math.abs(o + f + a - 3) < 0.1) return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const d = (o + 1) / 2, b = (f + 1) / 2, S = (a + 1) / 2, E = (u + h) / 4, R = (c + m) / 4, k = (r + g) / 4;
      return d > b && d > S ? d < 0.01 ? (i = 0, s = 0.707106781, y = 0.707106781) : (i = Math.sqrt(d), s = E / i, y = R / i) : b > S ? b < 0.01 ? (i = 0.707106781, s = 0, y = 0.707106781) : (s = Math.sqrt(b), i = E / s, y = k / s) : S < 0.01 ? (i = 0.707106781, s = 0.707106781, y = 0) : (y = Math.sqrt(S), i = R / y, s = k / y), this.set(i, s, y, n), this;
    }
    let l = Math.sqrt((g - r) * (g - r) + (c - m) * (c - m) + (h - u) * (h - u));
    return Math.abs(l) < 1e-3 && (l = 1), this.x = (g - r) / l, this.y = (c - m) / l, this.z = (h - u) / l, this.w = Math.acos((o + f + a - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this.w = Math.max(e.w, Math.min(n.w, this.w)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this.w = Math.max(e, Math.min(n, this.w)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this.w += (e.w - this.w) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this.w = e.w + (n.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this.w = e[n + 3], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e[n + 3] = this.w, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this.w = e.getW(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class oa extends Da {
  constructor(e, n, i = {}) {
    super(), this.isWebGLRenderTarget = true, this.width = e, this.height = n, this.depth = 1, this.scissor = new ci(0, 0, e, n), this.scissorTest = false, this.viewport = new ci(0, 0, e, n);
    const s = { width: e, height: n, depth: 1 };
    this.texture = new Mi(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = i.generateMipmaps !== void 0 ? i.generateMipmaps : false, this.texture.internalFormat = i.internalFormat !== void 0 ? i.internalFormat : null, this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : 1006, this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : true, this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : false, this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null, this.samples = i.samples !== void 0 ? i.samples : 0;
  }
  setSize(e, n, i = 1) {
    (this.width !== e || this.height !== n || this.depth !== i) && (this.width = e, this.height = n, this.depth = i, this.texture.image.width = e, this.texture.image.height = n, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = true;
    const n = Object.assign({}, e.texture.image);
    return this.texture.source = new Sm(n), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class _m extends Mi {
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class Bg extends Mi {
  constructor(e = null, n = 1, i = 1, s = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e, width: n, height: i, depth: s }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class Us {
  constructor(e = 0, n = 0, i = 0, s = 1) {
    this.isQuaternion = true, this._x = e, this._y = n, this._z = i, this._w = s;
  }
  static slerpFlat(e, n, i, s, y, t, o) {
    let u = i[s + 0], c = i[s + 1], h = i[s + 2], f = i[s + 3];
    const r = y[t + 0], m = y[t + 1], g = y[t + 2], a = y[t + 3];
    if (o === 0) {
      e[n + 0] = u, e[n + 1] = c, e[n + 2] = h, e[n + 3] = f;
      return;
    }
    if (o === 1) {
      e[n + 0] = r, e[n + 1] = m, e[n + 2] = g, e[n + 3] = a;
      return;
    }
    if (f !== a || u !== r || c !== m || h !== g) {
      let l = 1 - o;
      const d = u * r + c * m + h * g + f * a, b = d >= 0 ? 1 : -1, S = 1 - d * d;
      if (S > Number.EPSILON) {
        const R = Math.sqrt(S), k = Math.atan2(R, d * b);
        l = Math.sin(l * k) / R, o = Math.sin(o * k) / R;
      }
      const E = o * b;
      if (u = u * l + r * E, c = c * l + m * E, h = h * l + g * E, f = f * l + a * E, l === 1 - o) {
        const R = 1 / Math.sqrt(u * u + c * c + h * h + f * f);
        u *= R, c *= R, h *= R, f *= R;
      }
    }
    e[n] = u, e[n + 1] = c, e[n + 2] = h, e[n + 3] = f;
  }
  static multiplyQuaternionsFlat(e, n, i, s, y, t) {
    const o = i[s], u = i[s + 1], c = i[s + 2], h = i[s + 3], f = y[t], r = y[t + 1], m = y[t + 2], g = y[t + 3];
    return e[n] = o * g + h * f + u * m - c * r, e[n + 1] = u * g + h * r + c * f - o * m, e[n + 2] = c * g + h * m + o * r - u * f, e[n + 3] = h * g - o * f - u * r - c * m, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, n, i, s) {
    return this._x = e, this._y = n, this._z = i, this._w = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, n) {
    if (!(e && e.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
    const i = e._x, s = e._y, y = e._z, t = e._order, o = Math.cos, u = Math.sin, c = o(i / 2), h = o(s / 2), f = o(y / 2), r = u(i / 2), m = u(s / 2), g = u(y / 2);
    switch (t) {
      case "XYZ":
        this._x = r * h * f + c * m * g, this._y = c * m * f - r * h * g, this._z = c * h * g + r * m * f, this._w = c * h * f - r * m * g;
        break;
      case "YXZ":
        this._x = r * h * f + c * m * g, this._y = c * m * f - r * h * g, this._z = c * h * g - r * m * f, this._w = c * h * f + r * m * g;
        break;
      case "ZXY":
        this._x = r * h * f - c * m * g, this._y = c * m * f + r * h * g, this._z = c * h * g + r * m * f, this._w = c * h * f - r * m * g;
        break;
      case "ZYX":
        this._x = r * h * f - c * m * g, this._y = c * m * f + r * h * g, this._z = c * h * g - r * m * f, this._w = c * h * f + r * m * g;
        break;
      case "YZX":
        this._x = r * h * f + c * m * g, this._y = c * m * f + r * h * g, this._z = c * h * g - r * m * f, this._w = c * h * f - r * m * g;
        break;
      case "XZY":
        this._x = r * h * f - c * m * g, this._y = c * m * f - r * h * g, this._z = c * h * g + r * m * f, this._w = c * h * f + r * m * g;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + t);
    }
    return n !== false && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2, s = Math.sin(i);
    return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const n = e.elements, i = n[0], s = n[4], y = n[8], t = n[1], o = n[5], u = n[9], c = n[2], h = n[6], f = n[10], r = i + o + f;
    if (r > 0) {
      const m = 0.5 / Math.sqrt(r + 1);
      this._w = 0.25 / m, this._x = (h - u) * m, this._y = (y - c) * m, this._z = (t - s) * m;
    } else if (i > o && i > f) {
      const m = 2 * Math.sqrt(1 + i - o - f);
      this._w = (h - u) / m, this._x = 0.25 * m, this._y = (s + t) / m, this._z = (y + c) / m;
    } else if (o > f) {
      const m = 2 * Math.sqrt(1 + o - i - f);
      this._w = (y - c) / m, this._x = (s + t) / m, this._y = 0.25 * m, this._z = (u + h) / m;
    } else {
      const m = 2 * Math.sqrt(1 + f - i - o);
      this._w = (t - s) / m, this._x = (y + c) / m, this._y = (u + h) / m, this._z = 0.25 * m;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * n.z - e.z * n.y, this._y = e.z * n.x - e.x * n.z, this._z = e.x * n.y - e.y * n.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Ci(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const s = Math.min(1, n / i);
    return this.slerp(e, s), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x, s = e._y, y = e._z, t = e._w, o = n._x, u = n._y, c = n._z, h = n._w;
    return this._x = i * h + t * o + s * c - y * u, this._y = s * h + t * u + y * o - i * c, this._z = y * h + t * c + i * u - s * o, this._w = t * h - i * o - s * u - y * c, this._onChangeCallback(), this;
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x, s = this._y, y = this._z, t = this._w;
    let o = t * e._w + i * e._x + s * e._y + y * e._z;
    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = t, this._x = i, this._y = s, this._z = y, this;
    const u = 1 - o * o;
    if (u <= Number.EPSILON) {
      const m = 1 - n;
      return this._w = m * t + n * this._w, this._x = m * i + n * this._x, this._y = m * s + n * this._y, this._z = m * y + n * this._z, this.normalize(), this._onChangeCallback(), this;
    }
    const c = Math.sqrt(u), h = Math.atan2(c, o), f = Math.sin((1 - n) * h) / c, r = Math.sin(n * h) / c;
    return this._w = t * f + this._w * r, this._x = i * f + this._x * r, this._y = s * f + this._y * r, this._z = y * f + this._z * r, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = Math.random(), n = Math.sqrt(1 - e), i = Math.sqrt(e), s = 2 * Math.PI * Math.random(), y = 2 * Math.PI * Math.random();
    return this.set(n * Math.cos(s), i * Math.sin(y), i * Math.cos(y), n * Math.sin(s));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, n = 0) {
    return this._x = e[n], this._y = e[n + 1], this._z = e[n + 2], this._w = e[n + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._w, e;
  }
  fromBufferAttribute(e, n) {
    return this._x = e.getX(n), this._y = e.getY(n), this._z = e.getZ(n), this._w = e.getW(n), this;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class _r {
  constructor(e = 0, n = 0, i = 0) {
    _r.prototype.isVector3 = true, this.x = e, this.y = n, this.z = i;
  }
  set(e, n, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = n, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, n) {
    return this.x = e.x + n.x, this.y = e.y + n.y, this.z = e.z + n.z, this;
  }
  addScaledVector(e, n) {
    return this.x += e.x * n, this.y += e.y * n, this.z += e.z * n, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, n) {
    return this.x = e.x - n.x, this.y = e.y - n.y, this.z = e.z - n.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, n) {
    return this.x = e.x * n.x, this.y = e.y * n.y, this.z = e.z * n.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(kh.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(kh.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x, i = this.y, s = this.z, y = e.elements;
    return this.x = y[0] * n + y[3] * i + y[6] * s, this.y = y[1] * n + y[4] * i + y[7] * s, this.z = y[2] * n + y[5] * i + y[8] * s, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x, i = this.y, s = this.z, y = e.elements, t = 1 / (y[3] * n + y[7] * i + y[11] * s + y[15]);
    return this.x = (y[0] * n + y[4] * i + y[8] * s + y[12]) * t, this.y = (y[1] * n + y[5] * i + y[9] * s + y[13]) * t, this.z = (y[2] * n + y[6] * i + y[10] * s + y[14]) * t, this;
  }
  applyQuaternion(e) {
    const n = this.x, i = this.y, s = this.z, y = e.x, t = e.y, o = e.z, u = e.w, c = u * n + t * s - o * i, h = u * i + o * n - y * s, f = u * s + y * i - t * n, r = -y * n - t * i - o * s;
    return this.x = c * u + r * -y + h * -o - f * -t, this.y = h * u + r * -t + f * -y - c * -o, this.z = f * u + r * -o + c * -t - h * -y, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const n = this.x, i = this.y, s = this.z, y = e.elements;
    return this.x = y[0] * n + y[4] * i + y[8] * s, this.y = y[1] * n + y[5] * i + y[9] * s, this.z = y[2] * n + y[6] * i + y[10] * s, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, n) {
    return this.x = Math.max(e.x, Math.min(n.x, this.x)), this.y = Math.max(e.y, Math.min(n.y, this.y)), this.z = Math.max(e.z, Math.min(n.z, this.z)), this;
  }
  clampScalar(e, n) {
    return this.x = Math.max(e, Math.min(n, this.x)), this.y = Math.max(e, Math.min(n, this.y)), this.z = Math.max(e, Math.min(n, this.z)), this;
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(n, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return this.x += (e.x - this.x) * n, this.y += (e.y - this.y) * n, this.z += (e.z - this.z) * n, this;
  }
  lerpVectors(e, n, i) {
    return this.x = e.x + (n.x - e.x) * i, this.y = e.y + (n.y - e.y) * i, this.z = e.z + (n.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x, s = e.y, y = e.z, t = n.x, o = n.y, u = n.z;
    return this.x = s * u - y * o, this.y = y * t - i * u, this.z = i * o - s * t, this;
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return il.copy(this).projectOnVector(e), this.sub(il);
  }
  reflect(e) {
    return this.sub(il.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Ci(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x, i = this.y - e.y, s = this.z - e.z;
    return n * n + i * i + s * s;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const s = Math.sin(n) * e;
    return this.x = s * Math.sin(i), this.y = Math.cos(n) * e, this.z = s * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return this.x = e * Math.sin(n), this.y = i, this.z = e * Math.cos(n), this;
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return this.x = n[12], this.y = n[13], this.z = n[14], this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), s = this.setFromMatrixColumn(e, 2).length();
    return this.x = n, this.y = i, this.z = s, this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return this.x = e[n], this.y = e[n + 1], this.z = e[n + 2], this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this.x, e[n + 1] = this.y, e[n + 2] = this.z, e;
  }
  fromBufferAttribute(e, n) {
    return this.x = e.getX(n), this.y = e.getY(n), this.z = e.getZ(n), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, n = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(n), this.y = i * Math.sin(n), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const il = new _r(), kh = new Us();
class js {
  constructor(e = new _r(1 / 0, 1 / 0, 1 / 0), n = new _r(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e, this.max = n;
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    let n = 1 / 0, i = 1 / 0, s = 1 / 0, y = -1 / 0, t = -1 / 0, o = -1 / 0;
    for (let u = 0, c = e.length; u < c; u += 3) {
      const h = e[u], f = e[u + 1], r = e[u + 2];
      h < n && (n = h), f < i && (i = f), r < s && (s = r), h > y && (y = h), f > t && (t = f), r > o && (o = r);
    }
    return this.min.set(n, i, s), this.max.set(y, t, o), this;
  }
  setFromBufferAttribute(e) {
    let n = 1 / 0, i = 1 / 0, s = 1 / 0, y = -1 / 0, t = -1 / 0, o = -1 / 0;
    for (let u = 0, c = e.count; u < c; u++) {
      const h = e.getX(u), f = e.getY(u), r = e.getZ(u);
      h < n && (n = h), f < i && (i = f), r < s && (s = r), h > y && (y = h), f > t && (t = f), r > o && (o = r);
    }
    return this.min.set(n, i, s), this.max.set(y, t, o), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = Ho.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = false) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = false) {
    e.updateWorldMatrix(false, false);
    const i = e.geometry;
    if (i !== void 0) if (n && i.attributes != null && i.attributes.position !== void 0) {
      const y = i.attributes.position;
      for (let t = 0, o = y.count; t < o; t++) Ho.fromBufferAttribute(y, t).applyMatrix4(e.matrixWorld), this.expandByPoint(Ho);
    } else i.boundingBox === null && i.computeBoundingBox(), ol.copy(i.boundingBox), ol.applyMatrix4(e.matrixWorld), this.union(ol);
    const s = e.children;
    for (let y = 0, t = s.length; y < t; y++) this.expandByObject(s[y], n);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, n) {
    return n.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Ho), Ho.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let n, i;
    return e.normal.x > 0 ? (n = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (n = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (n += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (n += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (n += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (n += e.normal.z * this.max.z, i += e.normal.z * this.min.z), n <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return false;
    this.getCenter(vs), Pu.subVectors(this.max, vs), ha.subVectors(e.a, vs), da.subVectors(e.b, vs), ma.subVectors(e.c, vs), Co.subVectors(da, ha), Ro.subVectors(ma, da), Go.subVectors(ha, ma);
    let n = [0, -Co.z, Co.y, 0, -Ro.z, Ro.y, 0, -Go.z, Go.y, Co.z, 0, -Co.x, Ro.z, 0, -Ro.x, Go.z, 0, -Go.x, -Co.y, Co.x, 0, -Ro.y, Ro.x, 0, -Go.y, Go.x, 0];
    return !al(n, ha, da, ma, Pu) || (n = [1, 0, 0, 0, 1, 0, 0, 0, 1], !al(n, ha, da, ma, Pu)) ? false : (Cu.crossVectors(Co, Ro), n = [Cu.x, Cu.y, Cu.z], al(n, ha, da, ma, Pu));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return Ho.copy(e).clamp(this.min, this.max).sub(e).length();
  }
  getBoundingSphere(e) {
    return this.getCenter(e.center), e.radius = this.getSize(Ho).length() * 0.5, e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (fo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), fo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), fo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), fo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), fo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), fo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), fo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), fo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(fo), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const fo = [new _r(), new _r(), new _r(), new _r(), new _r(), new _r(), new _r(), new _r()], Ho = new _r(), ol = new js(), ha = new _r(), da = new _r(), ma = new _r(), Co = new _r(), Ro = new _r(), Go = new _r(), vs = new _r(), Pu = new _r(), Cu = new _r(), Wo = new _r();
function al(v, e, n, i, s) {
  for (let y = 0, t = v.length - 3; y <= t; y += 3) {
    Wo.fromArray(v, y);
    const o = s.x * Math.abs(Wo.x) + s.y * Math.abs(Wo.y) + s.z * Math.abs(Wo.z), u = e.dot(Wo), c = n.dot(Wo), h = i.dot(Wo);
    if (Math.max(-Math.max(u, c, h), Math.min(u, c, h)) > o) return false;
  }
  return true;
}
const Ng = new js(), Oh = new _r(), Ru = new _r(), sl = new _r();
class Ds {
  constructor(e = new _r(), n = -1) {
    this.center = e, this.radius = n;
  }
  set(e, n) {
    return this.center.copy(e), this.radius = n, this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : Ng.setFromPoints(e).getCenter(i);
    let s = 0;
    for (let y = 0, t = e.length; y < t; y++) s = Math.max(s, i.distanceToSquared(e[y]));
    return this.radius = Math.sqrt(s), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    sl.subVectors(e, this.center);
    const n = sl.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n), s = (i - this.radius) * 0.5;
      this.center.add(sl.multiplyScalar(s / i)), this.radius += s;
    }
    return this;
  }
  union(e) {
    return this.center.equals(e.center) === true ? Ru.set(0, 0, 1).multiplyScalar(e.radius) : Ru.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius), this.expandByPoint(Oh.copy(e.center).add(Ru)), this.expandByPoint(Oh.copy(e.center).sub(Ru)), this;
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const po = new _r(), ul = new _r(), Mu = new _r(), Mo = new _r(), cl = new _r(), Iu = new _r(), ll = new _r();
class Dg {
  constructor(e = new _r(), n = new _r(0, 0, -1)) {
    this.origin = e, this.direction = n;
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.direction).multiplyScalar(e).add(this.origin);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, po)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = po.subVectors(e, this.origin).dot(this.direction);
    return n < 0 ? this.origin.distanceToSquared(e) : (po.copy(this.direction).multiplyScalar(n).add(this.origin), po.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, s) {
    ul.copy(e).add(n).multiplyScalar(0.5), Mu.copy(n).sub(e).normalize(), Mo.copy(this.origin).sub(ul);
    const y = e.distanceTo(n) * 0.5, t = -this.direction.dot(Mu), o = Mo.dot(this.direction), u = -Mo.dot(Mu), c = Mo.lengthSq(), h = Math.abs(1 - t * t);
    let f, r, m, g;
    if (h > 0) if (f = t * u - o, r = t * o - u, g = y * h, f >= 0) if (r >= -g) if (r <= g) {
      const a = 1 / h;
      f *= a, r *= a, m = f * (f + t * r + 2 * o) + r * (t * f + r + 2 * u) + c;
    } else r = y, f = Math.max(0, -(t * r + o)), m = -f * f + r * (r + 2 * u) + c;
    else r = -y, f = Math.max(0, -(t * r + o)), m = -f * f + r * (r + 2 * u) + c;
    else r <= -g ? (f = Math.max(0, -(-t * y + o)), r = f > 0 ? -y : Math.min(Math.max(-y, -u), y), m = -f * f + r * (r + 2 * u) + c) : r <= g ? (f = 0, r = Math.min(Math.max(-y, -u), y), m = r * (r + 2 * u) + c) : (f = Math.max(0, -(t * y + o)), r = f > 0 ? y : Math.min(Math.max(-y, -u), y), m = -f * f + r * (r + 2 * u) + c);
    else r = t > 0 ? -y : y, f = Math.max(0, -(t * r + o)), m = -f * f + r * (r + 2 * u) + c;
    return i && i.copy(this.direction).multiplyScalar(f).add(this.origin), s && s.copy(Mu).multiplyScalar(r).add(ul), m;
  }
  intersectSphere(e, n) {
    po.subVectors(e.center, this.origin);
    const i = po.dot(this.direction), s = po.dot(po) - i * i, y = e.radius * e.radius;
    if (s > y) return null;
    const t = Math.sqrt(y - s), o = i - t, u = i + t;
    return o < 0 && u < 0 ? null : o < 0 ? this.at(u, n) : this.at(o, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, s, y, t, o, u;
    const c = 1 / this.direction.x, h = 1 / this.direction.y, f = 1 / this.direction.z, r = this.origin;
    return c >= 0 ? (i = (e.min.x - r.x) * c, s = (e.max.x - r.x) * c) : (i = (e.max.x - r.x) * c, s = (e.min.x - r.x) * c), h >= 0 ? (y = (e.min.y - r.y) * h, t = (e.max.y - r.y) * h) : (y = (e.max.y - r.y) * h, t = (e.min.y - r.y) * h), i > t || y > s || ((y > i || i !== i) && (i = y), (t < s || s !== s) && (s = t), f >= 0 ? (o = (e.min.z - r.z) * f, u = (e.max.z - r.z) * f) : (o = (e.max.z - r.z) * f, u = (e.min.z - r.z) * f), i > u || o > s) || ((o > i || i !== i) && (i = o), (u < s || s !== s) && (s = u), s < 0) ? null : this.at(i >= 0 ? i : s, n);
  }
  intersectsBox(e) {
    return this.intersectBox(e, po) !== null;
  }
  intersectTriangle(e, n, i, s, y) {
    cl.subVectors(n, e), Iu.subVectors(i, e), ll.crossVectors(cl, Iu);
    let t = this.direction.dot(ll), o;
    if (t > 0) {
      if (s) return null;
      o = 1;
    } else if (t < 0) o = -1, t = -t;
    else return null;
    Mo.subVectors(this.origin, e);
    const u = o * this.direction.dot(Iu.crossVectors(Mo, Iu));
    if (u < 0) return null;
    const c = o * this.direction.dot(cl.cross(Mo));
    if (c < 0 || u + c > t) return null;
    const h = -o * Mo.dot(ll);
    return h < 0 ? null : this.at(h / t, y);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class li {
  constructor() {
    li.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  set(e, n, i, s, y, t, o, u, c, h, f, r, m, g, a, l) {
    const d = this.elements;
    return d[0] = e, d[4] = n, d[8] = i, d[12] = s, d[1] = y, d[5] = t, d[9] = o, d[13] = u, d[2] = c, d[6] = h, d[10] = f, d[14] = r, d[3] = m, d[7] = g, d[11] = a, d[15] = l, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new li().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements, i = e.elements;
    return n[0] = i[0], n[1] = i[1], n[2] = i[2], n[3] = i[3], n[4] = i[4], n[5] = i[5], n[6] = i[6], n[7] = i[7], n[8] = i[8], n[9] = i[9], n[10] = i[10], n[11] = i[11], n[12] = i[12], n[13] = i[13], n[14] = i[14], n[15] = i[15], this;
  }
  copyPosition(e) {
    const n = this.elements, i = e.elements;
    return n[12] = i[12], n[13] = i[13], n[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return this.set(n[0], n[3], n[6], 0, n[1], n[4], n[7], 0, n[2], n[5], n[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, n, i) {
    return e.setFromMatrixColumn(this, 0), n.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, n, i) {
    return this.set(e.x, n.x, i.x, 0, e.y, n.y, i.y, 0, e.z, n.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const n = this.elements, i = e.elements, s = 1 / ya.setFromMatrixColumn(e, 0).length(), y = 1 / ya.setFromMatrixColumn(e, 1).length(), t = 1 / ya.setFromMatrixColumn(e, 2).length();
    return n[0] = i[0] * s, n[1] = i[1] * s, n[2] = i[2] * s, n[3] = 0, n[4] = i[4] * y, n[5] = i[5] * y, n[6] = i[6] * y, n[7] = 0, n[8] = i[8] * t, n[9] = i[9] * t, n[10] = i[10] * t, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const n = this.elements, i = e.x, s = e.y, y = e.z, t = Math.cos(i), o = Math.sin(i), u = Math.cos(s), c = Math.sin(s), h = Math.cos(y), f = Math.sin(y);
    if (e.order === "XYZ") {
      const r = t * h, m = t * f, g = o * h, a = o * f;
      n[0] = u * h, n[4] = -u * f, n[8] = c, n[1] = m + g * c, n[5] = r - a * c, n[9] = -o * u, n[2] = a - r * c, n[6] = g + m * c, n[10] = t * u;
    } else if (e.order === "YXZ") {
      const r = u * h, m = u * f, g = c * h, a = c * f;
      n[0] = r + a * o, n[4] = g * o - m, n[8] = t * c, n[1] = t * f, n[5] = t * h, n[9] = -o, n[2] = m * o - g, n[6] = a + r * o, n[10] = t * u;
    } else if (e.order === "ZXY") {
      const r = u * h, m = u * f, g = c * h, a = c * f;
      n[0] = r - a * o, n[4] = -t * f, n[8] = g + m * o, n[1] = m + g * o, n[5] = t * h, n[9] = a - r * o, n[2] = -t * c, n[6] = o, n[10] = t * u;
    } else if (e.order === "ZYX") {
      const r = t * h, m = t * f, g = o * h, a = o * f;
      n[0] = u * h, n[4] = g * c - m, n[8] = r * c + a, n[1] = u * f, n[5] = a * c + r, n[9] = m * c - g, n[2] = -c, n[6] = o * u, n[10] = t * u;
    } else if (e.order === "YZX") {
      const r = t * u, m = t * c, g = o * u, a = o * c;
      n[0] = u * h, n[4] = a - r * f, n[8] = g * f + m, n[1] = f, n[5] = t * h, n[9] = -o * h, n[2] = -c * h, n[6] = m * f + g, n[10] = r - a * f;
    } else if (e.order === "XZY") {
      const r = t * u, m = t * c, g = o * u, a = o * c;
      n[0] = u * h, n[4] = -f, n[8] = c * h, n[1] = r * f + a, n[5] = t * h, n[9] = m * f - g, n[2] = g * f - m, n[6] = o * h, n[10] = a * f + r;
    }
    return n[3] = 0, n[7] = 0, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Fg, e, Ug);
  }
  lookAt(e, n, i) {
    const s = this.elements;
    return Oi.subVectors(e, n), Oi.lengthSq() === 0 && (Oi.z = 1), Oi.normalize(), Io.crossVectors(i, Oi), Io.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Oi.x += 1e-4 : Oi.z += 1e-4, Oi.normalize(), Io.crossVectors(i, Oi)), Io.normalize(), Lu.crossVectors(Oi, Io), s[0] = Io.x, s[4] = Lu.x, s[8] = Oi.x, s[1] = Io.y, s[5] = Lu.y, s[9] = Oi.y, s[2] = Io.z, s[6] = Lu.z, s[10] = Oi.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements, s = n.elements, y = this.elements, t = i[0], o = i[4], u = i[8], c = i[12], h = i[1], f = i[5], r = i[9], m = i[13], g = i[2], a = i[6], l = i[10], d = i[14], b = i[3], S = i[7], E = i[11], R = i[15], k = s[0], w = s[4], F = s[8], I = s[12], q = s[1], D = s[5], H = s[9], _ = s[13], T = s[2], L = s[6], j = s[10], z = s[14], Y = s[3], te = s[7], G = s[11], K = s[15];
    return y[0] = t * k + o * q + u * T + c * Y, y[4] = t * w + o * D + u * L + c * te, y[8] = t * F + o * H + u * j + c * G, y[12] = t * I + o * _ + u * z + c * K, y[1] = h * k + f * q + r * T + m * Y, y[5] = h * w + f * D + r * L + m * te, y[9] = h * F + f * H + r * j + m * G, y[13] = h * I + f * _ + r * z + m * K, y[2] = g * k + a * q + l * T + d * Y, y[6] = g * w + a * D + l * L + d * te, y[10] = g * F + a * H + l * j + d * G, y[14] = g * I + a * _ + l * z + d * K, y[3] = b * k + S * q + E * T + R * Y, y[7] = b * w + S * D + E * L + R * te, y[11] = b * F + S * H + E * j + R * G, y[15] = b * I + S * _ + E * z + R * K, this;
  }
  multiplyScalar(e) {
    const n = this.elements;
    return n[0] *= e, n[4] *= e, n[8] *= e, n[12] *= e, n[1] *= e, n[5] *= e, n[9] *= e, n[13] *= e, n[2] *= e, n[6] *= e, n[10] *= e, n[14] *= e, n[3] *= e, n[7] *= e, n[11] *= e, n[15] *= e, this;
  }
  determinant() {
    const e = this.elements, n = e[0], i = e[4], s = e[8], y = e[12], t = e[1], o = e[5], u = e[9], c = e[13], h = e[2], f = e[6], r = e[10], m = e[14], g = e[3], a = e[7], l = e[11], d = e[15];
    return g * (+y * u * f - s * c * f - y * o * r + i * c * r + s * o * m - i * u * m) + a * (+n * u * m - n * c * r + y * t * r - s * t * m + s * c * h - y * u * h) + l * (+n * c * f - n * o * m - y * t * f + i * t * m + y * o * h - i * c * h) + d * (-s * o * h - n * u * f + n * o * r + s * t * f - i * t * r + i * u * h);
  }
  transpose() {
    const e = this.elements;
    let n;
    return n = e[1], e[1] = e[4], e[4] = n, n = e[2], e[2] = e[8], e[8] = n, n = e[6], e[6] = e[9], e[9] = n, n = e[3], e[3] = e[12], e[12] = n, n = e[7], e[7] = e[13], e[13] = n, n = e[11], e[11] = e[14], e[14] = n, this;
  }
  setPosition(e, n, i) {
    const s = this.elements;
    return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = n, s[14] = i), this;
  }
  invert() {
    const e = this.elements, n = e[0], i = e[1], s = e[2], y = e[3], t = e[4], o = e[5], u = e[6], c = e[7], h = e[8], f = e[9], r = e[10], m = e[11], g = e[12], a = e[13], l = e[14], d = e[15], b = f * l * c - a * r * c + a * u * m - o * l * m - f * u * d + o * r * d, S = g * r * c - h * l * c - g * u * m + t * l * m + h * u * d - t * r * d, E = h * a * c - g * f * c + g * o * m - t * a * m - h * o * d + t * f * d, R = g * f * u - h * a * u - g * o * r + t * a * r + h * o * l - t * f * l, k = n * b + i * S + s * E + y * R;
    if (k === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const w = 1 / k;
    return e[0] = b * w, e[1] = (a * r * y - f * l * y - a * s * m + i * l * m + f * s * d - i * r * d) * w, e[2] = (o * l * y - a * u * y + a * s * c - i * l * c - o * s * d + i * u * d) * w, e[3] = (f * u * y - o * r * y - f * s * c + i * r * c + o * s * m - i * u * m) * w, e[4] = S * w, e[5] = (h * l * y - g * r * y + g * s * m - n * l * m - h * s * d + n * r * d) * w, e[6] = (g * u * y - t * l * y - g * s * c + n * l * c + t * s * d - n * u * d) * w, e[7] = (t * r * y - h * u * y + h * s * c - n * r * c - t * s * m + n * u * m) * w, e[8] = E * w, e[9] = (g * f * y - h * a * y - g * i * m + n * a * m + h * i * d - n * f * d) * w, e[10] = (t * a * y - g * o * y + g * i * c - n * a * c - t * i * d + n * o * d) * w, e[11] = (h * o * y - t * f * y - h * i * c + n * f * c + t * i * m - n * o * m) * w, e[12] = R * w, e[13] = (h * a * s - g * f * s + g * i * r - n * a * r - h * i * l + n * f * l) * w, e[14] = (g * o * s - t * a * s - g * i * u + n * a * u + t * i * l - n * o * l) * w, e[15] = (t * f * s - h * o * s + h * i * u - n * f * u - t * i * r + n * o * r) * w, this;
  }
  scale(e) {
    const n = this.elements, i = e.x, s = e.y, y = e.z;
    return n[0] *= i, n[4] *= s, n[8] *= y, n[1] *= i, n[5] *= s, n[9] *= y, n[2] *= i, n[6] *= s, n[10] *= y, n[3] *= i, n[7] *= s, n[11] *= y, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, s));
  }
  makeTranslation(e, n, i) {
    return this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e), i = Math.sin(e);
    return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n), s = Math.sin(n), y = 1 - i, t = e.x, o = e.y, u = e.z, c = y * t, h = y * o;
    return this.set(c * t + i, c * o - s * u, c * u + s * o, 0, c * o + s * u, h * o + i, h * u - s * t, 0, c * u - s * o, h * u + s * t, y * u * u + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, n, i) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, i, s, y, t) {
    return this.set(1, i, y, 0, e, 1, t, 0, n, s, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, i) {
    const s = this.elements, y = n._x, t = n._y, o = n._z, u = n._w, c = y + y, h = t + t, f = o + o, r = y * c, m = y * h, g = y * f, a = t * h, l = t * f, d = o * f, b = u * c, S = u * h, E = u * f, R = i.x, k = i.y, w = i.z;
    return s[0] = (1 - (a + d)) * R, s[1] = (m + E) * R, s[2] = (g - S) * R, s[3] = 0, s[4] = (m - E) * k, s[5] = (1 - (r + d)) * k, s[6] = (l + b) * k, s[7] = 0, s[8] = (g + S) * w, s[9] = (l - b) * w, s[10] = (1 - (r + a)) * w, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this;
  }
  decompose(e, n, i) {
    const s = this.elements;
    let y = ya.set(s[0], s[1], s[2]).length();
    const t = ya.set(s[4], s[5], s[6]).length(), o = ya.set(s[8], s[9], s[10]).length();
    this.determinant() < 0 && (y = -y), e.x = s[12], e.y = s[13], e.z = s[14], Hi.copy(this);
    const u = 1 / y, c = 1 / t, h = 1 / o;
    return Hi.elements[0] *= u, Hi.elements[1] *= u, Hi.elements[2] *= u, Hi.elements[4] *= c, Hi.elements[5] *= c, Hi.elements[6] *= c, Hi.elements[8] *= h, Hi.elements[9] *= h, Hi.elements[10] *= h, n.setFromRotationMatrix(Hi), i.x = y, i.y = t, i.z = o, this;
  }
  makePerspective(e, n, i, s, y, t) {
    const o = this.elements, u = 2 * y / (n - e), c = 2 * y / (i - s), h = (n + e) / (n - e), f = (i + s) / (i - s), r = -(t + y) / (t - y), m = -2 * t * y / (t - y);
    return o[0] = u, o[4] = 0, o[8] = h, o[12] = 0, o[1] = 0, o[5] = c, o[9] = f, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = r, o[14] = m, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this;
  }
  makeOrthographic(e, n, i, s, y, t) {
    const o = this.elements, u = 1 / (n - e), c = 1 / (i - s), h = 1 / (t - y), f = (n + e) * u, r = (i + s) * c, m = (t + y) * h;
    return o[0] = 2 * u, o[4] = 0, o[8] = 0, o[12] = -f, o[1] = 0, o[5] = 2 * c, o[9] = 0, o[13] = -r, o[2] = 0, o[6] = 0, o[10] = -2 * h, o[14] = -m, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this;
  }
  equals(e) {
    const n = this.elements, i = e.elements;
    for (let s = 0; s < 16; s++) if (n[s] !== i[s]) return false;
    return true;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return e[n] = i[0], e[n + 1] = i[1], e[n + 2] = i[2], e[n + 3] = i[3], e[n + 4] = i[4], e[n + 5] = i[5], e[n + 6] = i[6], e[n + 7] = i[7], e[n + 8] = i[8], e[n + 9] = i[9], e[n + 10] = i[10], e[n + 11] = i[11], e[n + 12] = i[12], e[n + 13] = i[13], e[n + 14] = i[14], e[n + 15] = i[15], e;
  }
}
const ya = new _r(), Hi = new li(), Fg = new _r(0, 0, 0), Ug = new _r(1, 1, 1), Io = new _r(), Lu = new _r(), Oi = new _r(), Ph = new li(), Ch = new Us();
class Vs {
  constructor(e = 0, n = 0, i = 0, s = Vs.DefaultOrder) {
    this.isEuler = true, this._x = e, this._y = n, this._z = i, this._order = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, n, i, s = this._order) {
    return this._x = e, this._y = n, this._z = i, this._order = s, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, n = this._order, i = true) {
    const s = e.elements, y = s[0], t = s[4], o = s[8], u = s[1], c = s[5], h = s[9], f = s[2], r = s[6], m = s[10];
    switch (n) {
      case "XYZ":
        this._y = Math.asin(Ci(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-h, m), this._z = Math.atan2(-t, y)) : (this._x = Math.atan2(r, c), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Ci(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(o, m), this._z = Math.atan2(u, c)) : (this._y = Math.atan2(-f, y), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Ci(r, -1, 1)), Math.abs(r) < 0.9999999 ? (this._y = Math.atan2(-f, m), this._z = Math.atan2(-t, c)) : (this._y = 0, this._z = Math.atan2(u, y));
        break;
      case "ZYX":
        this._y = Math.asin(-Ci(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(r, m), this._z = Math.atan2(u, y)) : (this._x = 0, this._z = Math.atan2(-t, c));
        break;
      case "YZX":
        this._z = Math.asin(Ci(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-f, y)) : (this._x = 0, this._y = Math.atan2(o, m));
        break;
      case "XZY":
        this._z = Math.asin(-Ci(t, -1, 1)), Math.abs(t) < 0.9999999 ? (this._x = Math.atan2(r, c), this._y = Math.atan2(o, y)) : (this._x = Math.atan2(-h, m), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + n);
    }
    return this._order = n, i === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return Ph.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Ph, n, i);
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return Ch.setFromEuler(this), this.setFromQuaternion(Ch, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], n = 0) {
    return e[n] = this._x, e[n + 1] = this._y, e[n + 2] = this._z, e[n + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
  toVector3() {
    console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
  }
}
Vs.DefaultOrder = "XYZ";
Vs.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class Em {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let jg = 0;
const Rh = new _r(), ga = new Us(), ho = new li(), Bu = new _r(), bs = new _r(), Vg = new _r(), qg = new Us(), Mh = new _r(1, 0, 0), Ih = new _r(0, 1, 0), Lh = new _r(0, 0, 1), zg = { type: "added" }, Bh = { type: "removed" };
class Si extends Da {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: jg++ }), this.uuid = Fs(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Si.DefaultUp.clone();
    const e = new _r(), n = new Vs(), i = new Us(), s = new _r(1, 1, 1);
    function y() {
      i.setFromEuler(n, false);
    }
    function t() {
      n.setFromQuaternion(i, void 0, false);
    }
    n._onChange(y), i._onChange(t), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e }, rotation: { configurable: true, enumerable: true, value: n }, quaternion: { configurable: true, enumerable: true, value: i }, scale: { configurable: true, enumerable: true, value: s }, modelViewMatrix: { value: new li() }, normalMatrix: { value: new Vi() } }), this.matrix = new li(), this.matrixWorld = new li(), this.matrixAutoUpdate = Si.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Em(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, true);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return ga.setFromAxisAngle(e, n), this.quaternion.multiply(ga), this;
  }
  rotateOnWorldAxis(e, n) {
    return ga.setFromAxisAngle(e, n), this.quaternion.premultiply(ga), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Mh, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Ih, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Lh, e);
  }
  translateOnAxis(e, n) {
    return Rh.copy(e).applyQuaternion(this.quaternion), this.position.add(Rh.multiplyScalar(n)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Mh, e);
  }
  translateY(e) {
    return this.translateOnAxis(Ih, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Lh, e);
  }
  localToWorld(e) {
    return e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return e.applyMatrix4(ho.copy(this.matrixWorld).invert());
  }
  lookAt(e, n, i) {
    e.isVector3 ? Bu.copy(e) : Bu.set(e, n, i);
    const s = this.parent;
    this.updateWorldMatrix(true, false), bs.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ho.lookAt(bs, Bu, this.up) : ho.lookAt(Bu, bs, this.up), this.quaternion.setFromRotationMatrix(ho), s && (ho.extractRotation(s.matrixWorld), ga.setFromRotationMatrix(ho), this.quaternion.premultiply(ga.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(zg)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return n !== -1 && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(Bh)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const n = this.children[e];
      n.parent = null, n.dispatchEvent(Bh);
    }
    return this.children.length = 0, this;
  }
  attach(e) {
    return this.updateWorldMatrix(true, false), ho.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), ho.multiply(e.parent.matrixWorld)), e.applyMatrix4(ho), this.add(e), e.updateWorldMatrix(false, true), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, s = this.children.length; i < s; i++) {
      const y = this.children[i].getObjectByProperty(e, n);
      if (y !== void 0) return y;
    }
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bs, e, Vg), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(bs, qg, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++) n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === false) return;
    e(this);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++) n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
    const n = this.children;
    for (let i = 0, s = n.length; i < s; i++) n[i].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), n === true) {
      const s = this.children;
      for (let y = 0, t = s.length; y < t; y++) s[y].updateWorldMatrix(false, true);
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string", i = {};
    n && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
    const s = {};
    s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === true && (s.castShadow = true), this.receiveShadow === true && (s.receiveShadow = true), this.visible === false && (s.visible = false), this.frustumCulled === false && (s.frustumCulled = false), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (s.matrixAutoUpdate = false), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON()));
    function y(o, u) {
      return o[u.uuid] === void 0 && (o[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (s.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      s.geometry = y(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const u = o.shapes;
        if (Array.isArray(u)) for (let c = 0, h = u.length; c < h; c++) {
          const f = u[c];
          y(e.shapes, f);
        }
        else y(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (y(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
      const o = [];
      for (let u = 0, c = this.material.length; u < c; u++) o.push(y(e.materials, this.material[u]));
      s.material = o;
    } else s.material = y(e.materials, this.material);
    if (this.children.length > 0) {
      s.children = [];
      for (let o = 0; o < this.children.length; o++) s.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      s.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const u = this.animations[o];
        s.animations.push(y(e.animations, u));
      }
    }
    if (n) {
      const o = t(e.geometries), u = t(e.materials), c = t(e.textures), h = t(e.images), f = t(e.shapes), r = t(e.skeletons), m = t(e.animations), g = t(e.nodes);
      o.length > 0 && (i.geometries = o), u.length > 0 && (i.materials = u), c.length > 0 && (i.textures = c), h.length > 0 && (i.images = h), f.length > 0 && (i.shapes = f), r.length > 0 && (i.skeletons = r), m.length > 0 && (i.animations = m), g.length > 0 && (i.nodes = g);
    }
    return i.object = s, i;
    function t(o) {
      const u = [];
      for (const c in o) {
        const h = o[c];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = true) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), n === true) for (let i = 0; i < e.children.length; i++) {
      const s = e.children[i];
      this.add(s.clone());
    }
    return this;
  }
}
Si.DefaultUp = new _r(0, 1, 0);
Si.DefaultMatrixAutoUpdate = true;
const Gi = new _r(), mo = new _r(), fl = new _r(), yo = new _r(), va = new _r(), ba = new _r(), Nh = new _r(), pl = new _r(), hl = new _r(), dl = new _r();
class xo {
  constructor(e = new _r(), n = new _r(), i = new _r()) {
    this.a = e, this.b = n, this.c = i;
  }
  static getNormal(e, n, i, s) {
    s.subVectors(i, n), Gi.subVectors(e, n), s.cross(Gi);
    const y = s.lengthSq();
    return y > 0 ? s.multiplyScalar(1 / Math.sqrt(y)) : s.set(0, 0, 0);
  }
  static getBarycoord(e, n, i, s, y) {
    Gi.subVectors(s, n), mo.subVectors(i, n), fl.subVectors(e, n);
    const t = Gi.dot(Gi), o = Gi.dot(mo), u = Gi.dot(fl), c = mo.dot(mo), h = mo.dot(fl), f = t * c - o * o;
    if (f === 0) return y.set(-2, -1, -1);
    const r = 1 / f, m = (c * u - o * h) * r, g = (t * h - o * u) * r;
    return y.set(1 - m - g, g, m);
  }
  static containsPoint(e, n, i, s) {
    return this.getBarycoord(e, n, i, s, yo), yo.x >= 0 && yo.y >= 0 && yo.x + yo.y <= 1;
  }
  static getUV(e, n, i, s, y, t, o, u) {
    return this.getBarycoord(e, n, i, s, yo), u.set(0, 0), u.addScaledVector(y, yo.x), u.addScaledVector(t, yo.y), u.addScaledVector(o, yo.z), u;
  }
  static isFrontFacing(e, n, i, s) {
    return Gi.subVectors(i, n), mo.subVectors(e, n), Gi.cross(mo).dot(s) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, s) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[s]), this;
  }
  setFromAttributeAndIndices(e, n, i, s) {
    return this.a.fromBufferAttribute(e, n), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Gi.subVectors(this.c, this.b), mo.subVectors(this.a, this.b), Gi.cross(mo).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return xo.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return xo.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getUV(e, n, i, s, y) {
    return xo.getUV(e, this.a, this.b, this.c, n, i, s, y);
  }
  containsPoint(e) {
    return xo.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return xo.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a, s = this.b, y = this.c;
    let t, o;
    va.subVectors(s, i), ba.subVectors(y, i), pl.subVectors(e, i);
    const u = va.dot(pl), c = ba.dot(pl);
    if (u <= 0 && c <= 0) return n.copy(i);
    hl.subVectors(e, s);
    const h = va.dot(hl), f = ba.dot(hl);
    if (h >= 0 && f <= h) return n.copy(s);
    const r = u * f - h * c;
    if (r <= 0 && u >= 0 && h <= 0) return t = u / (u - h), n.copy(i).addScaledVector(va, t);
    dl.subVectors(e, y);
    const m = va.dot(dl), g = ba.dot(dl);
    if (g >= 0 && m <= g) return n.copy(y);
    const a = m * c - u * g;
    if (a <= 0 && c >= 0 && g <= 0) return o = c / (c - g), n.copy(i).addScaledVector(ba, o);
    const l = h * g - m * f;
    if (l <= 0 && f - h >= 0 && m - g >= 0) return Nh.subVectors(y, s), o = (f - h) / (f - h + (m - g)), n.copy(s).addScaledVector(Nh, o);
    const d = 1 / (l + a + r);
    return t = a * d, o = r * d, n.copy(i).addScaledVector(va, t).addScaledVector(ba, o);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let Hg = 0;
class ca extends Da {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: Hg++ }), this.uuid = Fs(), this.name = "", this.type = "Material", this.blending = 1, this.side = 0, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = 7680, this.stencilZFail = 7680, this.stencilZPass = 7680, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0) for (const n in e) {
      const i = e[n];
      if (i === void 0) {
        console.warn("THREE.Material: '" + n + "' parameter is undefined.");
        continue;
      }
      if (n === "shading") {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i === 1;
        continue;
      }
      const s = this[n];
      if (s === void 0) {
        console.warn("THREE." + this.type + ": '" + n + "' is not a property of this material.");
        continue;
      }
      s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[n] = i;
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== 1 && (i.blending = this.blending), this.side !== 0 && (i.side = this.side), this.vertexColors && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, i.colorWrite = this.colorWrite, i.stencilWrite = this.stencilWrite, i.stencilWriteMask = this.stencilWriteMask, i.stencilFunc = this.stencilFunc, i.stencilRef = this.stencilRef, i.stencilFuncMask = this.stencilFuncMask, i.stencilFail = this.stencilFail, i.stencilZFail = this.stencilZFail, i.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaToCoverage === true && (i.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = this.flatShading), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), JSON.stringify(this.userData) !== "{}" && (i.userData = this.userData);
    function s(y) {
      const t = [];
      for (const o in y) {
        const u = y[o];
        delete u.metadata, t.push(u);
      }
      return t;
    }
    if (n) {
      const y = s(e.textures), t = s(e.images);
      y.length > 0 && (i.textures = y), t.length > 0 && (i.images = t);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const s = n.length;
      i = new Array(s);
      for (let y = 0; y !== s; ++y) i[y] = n[y].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
}
class Am extends ca {
  constructor(e) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Mn(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Jn = new _r(), Nu = new In();
class oo {
  constructor(e, n, i) {
    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = n, this.count = e !== void 0 ? e.length / n : 0, this.normalized = i === true, this.usage = 35044, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this;
  }
  copyAt(e, n, i) {
    e *= this.itemSize, i *= n.itemSize;
    for (let s = 0, y = this.itemSize; s < y; s++) this.array[e + s] = n.array[i + s];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  copyColorsArray(e) {
    const n = this.array;
    let i = 0;
    for (let s = 0, y = e.length; s < y; s++) {
      let t = e[s];
      t === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", s), t = new Mn()), n[i++] = t.r, n[i++] = t.g, n[i++] = t.b;
    }
    return this;
  }
  copyVector2sArray(e) {
    const n = this.array;
    let i = 0;
    for (let s = 0, y = e.length; s < y; s++) {
      let t = e[s];
      t === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", s), t = new In()), n[i++] = t.x, n[i++] = t.y;
    }
    return this;
  }
  copyVector3sArray(e) {
    const n = this.array;
    let i = 0;
    for (let s = 0, y = e.length; s < y; s++) {
      let t = e[s];
      t === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", s), t = new _r()), n[i++] = t.x, n[i++] = t.y, n[i++] = t.z;
    }
    return this;
  }
  copyVector4sArray(e) {
    const n = this.array;
    let i = 0;
    for (let s = 0, y = e.length; s < y; s++) {
      let t = e[s];
      t === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", s), t = new ci()), n[i++] = t.x, n[i++] = t.y, n[i++] = t.z, n[i++] = t.w;
    }
    return this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2) for (let n = 0, i = this.count; n < i; n++) Nu.fromBufferAttribute(this, n), Nu.applyMatrix3(e), this.setXY(n, Nu.x, Nu.y);
    else if (this.itemSize === 3) for (let n = 0, i = this.count; n < i; n++) Jn.fromBufferAttribute(this, n), Jn.applyMatrix3(e), this.setXYZ(n, Jn.x, Jn.y, Jn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++) Jn.fromBufferAttribute(this, n), Jn.applyMatrix4(e), this.setXYZ(n, Jn.x, Jn.y, Jn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++) Jn.fromBufferAttribute(this, n), Jn.applyNormalMatrix(e), this.setXYZ(n, Jn.x, Jn.y, Jn.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++) Jn.fromBufferAttribute(this, n), Jn.transformDirection(e), this.setXYZ(n, Jn.x, Jn.y, Jn.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getX(e) {
    return this.array[e * this.itemSize];
  }
  setX(e, n) {
    return this.array[e * this.itemSize] = n, this;
  }
  getY(e) {
    return this.array[e * this.itemSize + 1];
  }
  setY(e, n) {
    return this.array[e * this.itemSize + 1] = n, this;
  }
  getZ(e) {
    return this.array[e * this.itemSize + 2];
  }
  setZ(e, n) {
    return this.array[e * this.itemSize + 2] = n, this;
  }
  getW(e) {
    return this.array[e * this.itemSize + 3];
  }
  setW(e, n) {
    return this.array[e * this.itemSize + 3] = n, this;
  }
  setXY(e, n, i) {
    return e *= this.itemSize, this.array[e + 0] = n, this.array[e + 1] = i, this;
  }
  setXYZ(e, n, i, s) {
    return e *= this.itemSize, this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this;
  }
  setXYZW(e, n, i, s, y) {
    return e *= this.itemSize, this.array[e + 0] = n, this.array[e + 1] = i, this.array[e + 2] = s, this.array[e + 3] = y, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== 35044 && (e.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (e.updateRange = this.updateRange), e;
  }
}
class xm extends oo {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class Tm extends oo {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class gi extends oo {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let Gg = 0;
const Fi = new li(), ml = new Si(), wa = new _r(), Pi = new js(), ws = new js(), fi = new _r();
class ao extends Da {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: Gg++ }), this.uuid = Fs(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (vm(e) ? Tm : xm)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return this.attributes[e] = n, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({ start: e, count: n, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    this.drawRange.start = e, this.drawRange.count = n;
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), n.needsUpdate = true);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const y = new Vi().getNormalMatrix(e);
      i.applyNormalMatrix(y), i.needsUpdate = true;
    }
    const s = this.attributes.tangent;
    return s !== void 0 && (s.transformDirection(e), s.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Fi.makeRotationFromQuaternion(e), this.applyMatrix4(Fi), this;
  }
  rotateX(e) {
    return Fi.makeRotationX(e), this.applyMatrix4(Fi), this;
  }
  rotateY(e) {
    return Fi.makeRotationY(e), this.applyMatrix4(Fi), this;
  }
  rotateZ(e) {
    return Fi.makeRotationZ(e), this.applyMatrix4(Fi), this;
  }
  translate(e, n, i) {
    return Fi.makeTranslation(e, n, i), this.applyMatrix4(Fi), this;
  }
  scale(e, n, i) {
    return Fi.makeScale(e, n, i), this.applyMatrix4(Fi), this;
  }
  lookAt(e) {
    return ml.lookAt(e), ml.updateMatrix(), this.applyMatrix4(ml.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(wa).negate(), this.translate(wa.x, wa.y, wa.z), this;
  }
  setFromPoints(e) {
    const n = [];
    for (let i = 0, s = e.length; i < s; i++) {
      const y = e[i];
      n.push(y.x, y.y, y.z || 0);
    }
    return this.setAttribute("position", new gi(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new js());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new _r(-1 / 0, -1 / 0, -1 / 0), new _r(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), n) for (let i = 0, s = n.length; i < s; i++) {
        const y = n[i];
        Pi.setFromBufferAttribute(y), this.morphTargetsRelative ? (fi.addVectors(this.boundingBox.min, Pi.min), this.boundingBox.expandByPoint(fi), fi.addVectors(this.boundingBox.max, Pi.max), this.boundingBox.expandByPoint(fi)) : (this.boundingBox.expandByPoint(Pi.min), this.boundingBox.expandByPoint(Pi.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ds());
    const e = this.attributes.position, n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new _r(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (Pi.setFromBufferAttribute(e), n) for (let y = 0, t = n.length; y < t; y++) {
        const o = n[y];
        ws.setFromBufferAttribute(o), this.morphTargetsRelative ? (fi.addVectors(Pi.min, ws.min), Pi.expandByPoint(fi), fi.addVectors(Pi.max, ws.max), Pi.expandByPoint(fi)) : (Pi.expandByPoint(ws.min), Pi.expandByPoint(ws.max));
      }
      Pi.getCenter(i);
      let s = 0;
      for (let y = 0, t = e.count; y < t; y++) fi.fromBufferAttribute(e, y), s = Math.max(s, i.distanceToSquared(fi));
      if (n) for (let y = 0, t = n.length; y < t; y++) {
        const o = n[y], u = this.morphTargetsRelative;
        for (let c = 0, h = o.count; c < h; c++) fi.fromBufferAttribute(o, c), u && (wa.fromBufferAttribute(e, c), fi.add(wa)), s = Math.max(s, i.distanceToSquared(fi));
      }
      this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, n = this.attributes;
    if (e === null || n.position === void 0 || n.normal === void 0 || n.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, s = n.position.array, y = n.normal.array, t = n.uv.array, o = s.length / 3;
    this.hasAttribute("tangent") === false && this.setAttribute("tangent", new oo(new Float32Array(4 * o), 4));
    const u = this.getAttribute("tangent").array, c = [], h = [];
    for (let q = 0; q < o; q++) c[q] = new _r(), h[q] = new _r();
    const f = new _r(), r = new _r(), m = new _r(), g = new In(), a = new In(), l = new In(), d = new _r(), b = new _r();
    function S(q, D, H) {
      f.fromArray(s, q * 3), r.fromArray(s, D * 3), m.fromArray(s, H * 3), g.fromArray(t, q * 2), a.fromArray(t, D * 2), l.fromArray(t, H * 2), r.sub(f), m.sub(f), a.sub(g), l.sub(g);
      const _ = 1 / (a.x * l.y - l.x * a.y);
      !isFinite(_) || (d.copy(r).multiplyScalar(l.y).addScaledVector(m, -a.y).multiplyScalar(_), b.copy(m).multiplyScalar(a.x).addScaledVector(r, -l.x).multiplyScalar(_), c[q].add(d), c[D].add(d), c[H].add(d), h[q].add(b), h[D].add(b), h[H].add(b));
    }
    let E = this.groups;
    E.length === 0 && (E = [{ start: 0, count: i.length }]);
    for (let q = 0, D = E.length; q < D; ++q) {
      const H = E[q], _ = H.start, T = H.count;
      for (let L = _, j = _ + T; L < j; L += 3) S(i[L + 0], i[L + 1], i[L + 2]);
    }
    const R = new _r(), k = new _r(), w = new _r(), F = new _r();
    function I(q) {
      w.fromArray(y, q * 3), F.copy(w);
      const D = c[q];
      R.copy(D), R.sub(w.multiplyScalar(w.dot(D))).normalize(), k.crossVectors(F, D);
      const H = k.dot(h[q]) < 0 ? -1 : 1;
      u[q * 4] = R.x, u[q * 4 + 1] = R.y, u[q * 4 + 2] = R.z, u[q * 4 + 3] = H;
    }
    for (let q = 0, D = E.length; q < D; ++q) {
      const H = E[q], _ = H.start, T = H.count;
      for (let L = _, j = _ + T; L < j; L += 3) I(i[L + 0]), I(i[L + 1]), I(i[L + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0) i = new oo(new Float32Array(n.count * 3), 3), this.setAttribute("normal", i);
      else for (let r = 0, m = i.count; r < m; r++) i.setXYZ(r, 0, 0, 0);
      const s = new _r(), y = new _r(), t = new _r(), o = new _r(), u = new _r(), c = new _r(), h = new _r(), f = new _r();
      if (e) for (let r = 0, m = e.count; r < m; r += 3) {
        const g = e.getX(r + 0), a = e.getX(r + 1), l = e.getX(r + 2);
        s.fromBufferAttribute(n, g), y.fromBufferAttribute(n, a), t.fromBufferAttribute(n, l), h.subVectors(t, y), f.subVectors(s, y), h.cross(f), o.fromBufferAttribute(i, g), u.fromBufferAttribute(i, a), c.fromBufferAttribute(i, l), o.add(h), u.add(h), c.add(h), i.setXYZ(g, o.x, o.y, o.z), i.setXYZ(a, u.x, u.y, u.z), i.setXYZ(l, c.x, c.y, c.z);
      }
      else for (let r = 0, m = n.count; r < m; r += 3) s.fromBufferAttribute(n, r + 0), y.fromBufferAttribute(n, r + 1), t.fromBufferAttribute(n, r + 2), h.subVectors(t, y), f.subVectors(s, y), h.cross(f), i.setXYZ(r + 0, h.x, h.y, h.z), i.setXYZ(r + 1, h.x, h.y, h.z), i.setXYZ(r + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = true;
    }
  }
  merge(e, n) {
    if (!(e && e.isBufferGeometry)) {
      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
      return;
    }
    n === void 0 && (n = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
    const i = this.attributes;
    for (const s in i) {
      if (e.attributes[s] === void 0) continue;
      const y = i[s].array, t = e.attributes[s], o = t.array, u = t.itemSize * n, c = Math.min(o.length, y.length - u);
      for (let h = 0, f = u; h < c; h++, f++) y[f] = o[h];
    }
    return this;
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++) fi.fromBufferAttribute(e, n), fi.normalize(), e.setXYZ(n, fi.x, fi.y, fi.z);
  }
  toNonIndexed() {
    function e(o, u) {
      const c = o.array, h = o.itemSize, f = o.normalized, r = new c.constructor(u.length * h);
      let m = 0, g = 0;
      for (let a = 0, l = u.length; a < l; a++) {
        o.isInterleavedBufferAttribute ? m = u[a] * o.data.stride + o.offset : m = u[a] * h;
        for (let d = 0; d < h; d++) r[g++] = c[m++];
      }
      return new oo(r, h, f);
    }
    if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const n = new ao(), i = this.index.array, s = this.attributes;
    for (const o in s) {
      const u = s[o], c = e(u, i);
      n.setAttribute(o, c);
    }
    const y = this.morphAttributes;
    for (const o in y) {
      const u = [], c = y[o];
      for (let h = 0, f = c.length; h < f; h++) {
        const r = c[h], m = e(r, i);
        u.push(m);
      }
      n.morphAttributes[o] = u;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const t = this.groups;
    for (let o = 0, u = t.length; o < u; o++) {
      const c = t[o];
      n.addGroup(c.start, c.count, c.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const c in u) u[c] !== void 0 && (e[c] = u[c]);
      return e;
    }
    e.data = { attributes: {} };
    const n = this.index;
    n !== null && (e.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) });
    const i = this.attributes;
    for (const u in i) {
      const c = i[u];
      e.data.attributes[u] = c.toJSON(e.data);
    }
    const s = {};
    let y = false;
    for (const u in this.morphAttributes) {
      const c = this.morphAttributes[u], h = [];
      for (let f = 0, r = c.length; f < r; f++) {
        const m = c[f];
        h.push(m.toJSON(e.data));
      }
      h.length > 0 && (s[u] = h, y = true);
    }
    y && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const t = this.groups;
    t.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(t)));
    const o = this.boundingSphere;
    return o !== null && (e.data.boundingSphere = { center: o.center.toArray(), radius: o.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const s = e.attributes;
    for (const c in s) {
      const h = s[c];
      this.setAttribute(c, h.clone(n));
    }
    const y = e.morphAttributes;
    for (const c in y) {
      const h = [], f = y[c];
      for (let r = 0, m = f.length; r < m; r++) h.push(f[r].clone(n));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const t = e.groups;
    for (let c = 0, h = t.length; c < h; c++) {
      const f = t[c];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, e.parameters !== void 0 && (this.parameters = Object.assign({}, e.parameters)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Dh = new li(), Sa = new Dg(), yl = new Ds(), Lo = new _r(), Bo = new _r(), No = new _r(), gl = new _r(), vl = new _r(), bl = new _r(), Du = new _r(), Fu = new _r(), Uu = new _r(), ju = new In(), Vu = new In(), qu = new In(), wl = new _r(), zu = new _r();
class io extends Si {
  constructor(e = new ao(), n = new Am()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = n, this.updateMorphTargets();
  }
  copy(e, n) {
    return super.copy(e, n), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes, n = Object.keys(e);
    if (n.length > 0) {
      const i = e[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, y = i.length; s < y; s++) {
          const t = i[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = s;
        }
      }
    }
  }
  raycast(e, n) {
    const i = this.geometry, s = this.material, y = this.matrixWorld;
    if (s === void 0 || (i.boundingSphere === null && i.computeBoundingSphere(), yl.copy(i.boundingSphere), yl.applyMatrix4(y), e.ray.intersectsSphere(yl) === false) || (Dh.copy(y).invert(), Sa.copy(e.ray).applyMatrix4(Dh), i.boundingBox !== null && Sa.intersectsBox(i.boundingBox) === false)) return;
    let t;
    const o = i.index, u = i.attributes.position, c = i.morphAttributes.position, h = i.morphTargetsRelative, f = i.attributes.uv, r = i.attributes.uv2, m = i.groups, g = i.drawRange;
    if (o !== null) if (Array.isArray(s)) for (let a = 0, l = m.length; a < l; a++) {
      const d = m[a], b = s[d.materialIndex], S = Math.max(d.start, g.start), E = Math.min(o.count, Math.min(d.start + d.count, g.start + g.count));
      for (let R = S, k = E; R < k; R += 3) {
        const w = o.getX(R), F = o.getX(R + 1), I = o.getX(R + 2);
        t = Hu(this, b, e, Sa, u, c, h, f, r, w, F, I), t && (t.faceIndex = Math.floor(R / 3), t.face.materialIndex = d.materialIndex, n.push(t));
      }
    }
    else {
      const a = Math.max(0, g.start), l = Math.min(o.count, g.start + g.count);
      for (let d = a, b = l; d < b; d += 3) {
        const S = o.getX(d), E = o.getX(d + 1), R = o.getX(d + 2);
        t = Hu(this, s, e, Sa, u, c, h, f, r, S, E, R), t && (t.faceIndex = Math.floor(d / 3), n.push(t));
      }
    }
    else if (u !== void 0) if (Array.isArray(s)) for (let a = 0, l = m.length; a < l; a++) {
      const d = m[a], b = s[d.materialIndex], S = Math.max(d.start, g.start), E = Math.min(u.count, Math.min(d.start + d.count, g.start + g.count));
      for (let R = S, k = E; R < k; R += 3) {
        const w = R, F = R + 1, I = R + 2;
        t = Hu(this, b, e, Sa, u, c, h, f, r, w, F, I), t && (t.faceIndex = Math.floor(R / 3), t.face.materialIndex = d.materialIndex, n.push(t));
      }
    }
    else {
      const a = Math.max(0, g.start), l = Math.min(u.count, g.start + g.count);
      for (let d = a, b = l; d < b; d += 3) {
        const S = d, E = d + 1, R = d + 2;
        t = Hu(this, s, e, Sa, u, c, h, f, r, S, E, R), t && (t.faceIndex = Math.floor(d / 3), n.push(t));
      }
    }
  }
}
function Wg(v, e, n, i, s, y, t, o) {
  let u;
  if (e.side === 1 ? u = i.intersectTriangle(t, y, s, true, o) : u = i.intersectTriangle(s, y, t, e.side !== 2, o), u === null) return null;
  zu.copy(o), zu.applyMatrix4(v.matrixWorld);
  const c = n.ray.origin.distanceTo(zu);
  return c < n.near || c > n.far ? null : { distance: c, point: zu.clone(), object: v };
}
function Hu(v, e, n, i, s, y, t, o, u, c, h, f) {
  Lo.fromBufferAttribute(s, c), Bo.fromBufferAttribute(s, h), No.fromBufferAttribute(s, f);
  const r = v.morphTargetInfluences;
  if (y && r) {
    Du.set(0, 0, 0), Fu.set(0, 0, 0), Uu.set(0, 0, 0);
    for (let g = 0, a = y.length; g < a; g++) {
      const l = r[g], d = y[g];
      l !== 0 && (gl.fromBufferAttribute(d, c), vl.fromBufferAttribute(d, h), bl.fromBufferAttribute(d, f), t ? (Du.addScaledVector(gl, l), Fu.addScaledVector(vl, l), Uu.addScaledVector(bl, l)) : (Du.addScaledVector(gl.sub(Lo), l), Fu.addScaledVector(vl.sub(Bo), l), Uu.addScaledVector(bl.sub(No), l)));
    }
    Lo.add(Du), Bo.add(Fu), No.add(Uu);
  }
  v.isSkinnedMesh && (v.boneTransform(c, Lo), v.boneTransform(h, Bo), v.boneTransform(f, No));
  const m = Wg(v, e, n, i, Lo, Bo, No, wl);
  if (m) {
    o && (ju.fromBufferAttribute(o, c), Vu.fromBufferAttribute(o, h), qu.fromBufferAttribute(o, f), m.uv = xo.getUV(wl, Lo, Bo, No, ju, Vu, qu, new In())), u && (ju.fromBufferAttribute(u, c), Vu.fromBufferAttribute(u, h), qu.fromBufferAttribute(u, f), m.uv2 = xo.getUV(wl, Lo, Bo, No, ju, Vu, qu, new In()));
    const g = { a: c, b: h, c: f, normal: new _r(), materialIndex: 0 };
    xo.getNormal(Lo, Bo, No, g.normal), m.face = g;
  }
  return m;
}
class qs extends ao {
  constructor(e = 1, n = 1, i = 1, s = 1, y = 1, t = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: n, depth: i, widthSegments: s, heightSegments: y, depthSegments: t };
    const o = this;
    s = Math.floor(s), y = Math.floor(y), t = Math.floor(t);
    const u = [], c = [], h = [], f = [];
    let r = 0, m = 0;
    g("z", "y", "x", -1, -1, i, n, e, t, y, 0), g("z", "y", "x", 1, -1, i, n, -e, t, y, 1), g("x", "z", "y", 1, 1, e, i, n, s, t, 2), g("x", "z", "y", 1, -1, e, i, -n, s, t, 3), g("x", "y", "z", 1, -1, e, n, i, s, y, 4), g("x", "y", "z", -1, -1, e, n, -i, s, y, 5), this.setIndex(u), this.setAttribute("position", new gi(c, 3)), this.setAttribute("normal", new gi(h, 3)), this.setAttribute("uv", new gi(f, 2));
    function g(a, l, d, b, S, E, R, k, w, F, I) {
      const q = E / w, D = R / F, H = E / 2, _ = R / 2, T = k / 2, L = w + 1, j = F + 1;
      let z = 0, Y = 0;
      const te = new _r();
      for (let G = 0; G < j; G++) {
        const K = G * D - _;
        for (let J = 0; J < L; J++) {
          const B = J * q - H;
          te[a] = B * b, te[l] = K * S, te[d] = T, c.push(te.x, te.y, te.z), te[a] = 0, te[l] = 0, te[d] = k > 0 ? 1 : -1, h.push(te.x, te.y, te.z), f.push(J / w), f.push(1 - G / F), z += 1;
        }
      }
      for (let G = 0; G < F; G++) for (let K = 0; K < w; K++) {
        const J = r + K + L * G, B = r + K + L * (G + 1), Z = r + (K + 1) + L * (G + 1), ie = r + (K + 1) + L * G;
        u.push(J, B, ie), u.push(B, Z, ie), Y += 6;
      }
      o.addGroup(m, Y, I), m += Y, r += z;
    }
  }
  static fromJSON(e) {
    return new qs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Ca(v) {
  const e = {};
  for (const n in v) {
    e[n] = {};
    for (const i in v[n]) {
      const s = v[n][i];
      s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? e[n][i] = s.clone() : Array.isArray(s) ? e[n][i] = s.slice() : e[n][i] = s;
    }
  }
  return e;
}
function mi(v) {
  const e = {};
  for (let n = 0; n < v.length; n++) {
    const i = Ca(v[n]);
    for (const s in i) e[s] = i[s];
  }
  return e;
}
function Kg(v) {
  const e = [];
  for (let n = 0; n < v.length; n++) e.push(v[n].clone());
  return e;
}
const Xg = { clone: Ca, merge: mi };
var $g = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Yg = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class aa extends ca {
  constructor(e) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = $g, this.fragmentShader = Yg, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && (e.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e));
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ca(e.uniforms), this.uniformsGroups = Kg(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    n.glslVersion = this.glslVersion, n.uniforms = {};
    for (const s in this.uniforms) {
      const y = this.uniforms[s].value;
      y && y.isTexture ? n.uniforms[s] = { type: "t", value: y.toJSON(e).uuid } : y && y.isColor ? n.uniforms[s] = { type: "c", value: y.getHex() } : y && y.isVector2 ? n.uniforms[s] = { type: "v2", value: y.toArray() } : y && y.isVector3 ? n.uniforms[s] = { type: "v3", value: y.toArray() } : y && y.isVector4 ? n.uniforms[s] = { type: "v4", value: y.toArray() } : y && y.isMatrix3 ? n.uniforms[s] = { type: "m3", value: y.toArray() } : y && y.isMatrix4 ? n.uniforms[s] = { type: "m4", value: y.toArray() } : n.uniforms[s] = { value: y };
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader;
    const i = {};
    for (const s in this.extensions) this.extensions[s] === true && (i[s] = true);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class km extends Si {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new li(), this.projectionMatrix = new li(), this.projectionMatrixInverse = new li();
  }
  copy(e, n) {
    return super.copy(e, n), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const n = this.matrixWorld.elements;
    return e.set(-n[8], -n[9], -n[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ri extends km {
  constructor(e = 50, n = 1, i = 0.1, s = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = n, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const n = 0.5 * this.getFilmHeight() / e;
    this.fov = jl * 2 * Math.atan(n), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Jc * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return jl * 2 * Math.atan(Math.tan(Jc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, n, i, s, y, t) {
    this.aspect = e / n, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = y, this.view.height = t, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = e * Math.tan(Jc * 0.5 * this.fov) / this.zoom, i = 2 * n, s = this.aspect * i, y = -0.5 * s;
    const t = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = t.fullWidth, c = t.fullHeight;
      y += t.offsetX * s / u, n -= t.offsetY * i / c, s *= t.width / u, i *= t.height / c;
    }
    const o = this.filmOffset;
    o !== 0 && (y += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(y, y + s, n, n - i, e, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.fov = this.fov, n.object.zoom = this.zoom, n.object.near = this.near, n.object.far = this.far, n.object.focus = this.focus, n.object.aspect = this.aspect, this.view !== null && (n.object.view = Object.assign({}, this.view)), n.object.filmGauge = this.filmGauge, n.object.filmOffset = this.filmOffset, n;
  }
}
const _a = 90, Ea = 1;
class Qg extends Si {
  constructor(e, n, i) {
    if (super(), this.type = "CubeCamera", i.isWebGLCubeRenderTarget !== true) {
      console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
      return;
    }
    this.renderTarget = i;
    const s = new Ri(_a, Ea, e, n);
    s.layers = this.layers, s.up.set(0, -1, 0), s.lookAt(new _r(1, 0, 0)), this.add(s);
    const y = new Ri(_a, Ea, e, n);
    y.layers = this.layers, y.up.set(0, -1, 0), y.lookAt(new _r(-1, 0, 0)), this.add(y);
    const t = new Ri(_a, Ea, e, n);
    t.layers = this.layers, t.up.set(0, 0, 1), t.lookAt(new _r(0, 1, 0)), this.add(t);
    const o = new Ri(_a, Ea, e, n);
    o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new _r(0, -1, 0)), this.add(o);
    const u = new Ri(_a, Ea, e, n);
    u.layers = this.layers, u.up.set(0, -1, 0), u.lookAt(new _r(0, 0, 1)), this.add(u);
    const c = new Ri(_a, Ea, e, n);
    c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new _r(0, 0, -1)), this.add(c);
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget, [s, y, t, o, u, c] = this.children, h = e.getRenderTarget(), f = e.toneMapping, r = e.xr.enabled;
    e.toneMapping = 0, e.xr.enabled = false;
    const m = i.texture.generateMipmaps;
    i.texture.generateMipmaps = false, e.setRenderTarget(i, 0), e.render(n, s), e.setRenderTarget(i, 1), e.render(n, y), e.setRenderTarget(i, 2), e.render(n, t), e.setRenderTarget(i, 3), e.render(n, o), e.setRenderTarget(i, 4), e.render(n, u), i.texture.generateMipmaps = m, e.setRenderTarget(i, 5), e.render(n, c), e.setRenderTarget(h), e.toneMapping = f, e.xr.enabled = r, i.texture.needsPMREMUpdate = true;
  }
}
class Om extends Mi {
  constructor(e, n, i, s, y, t, o, u, c, h) {
    e = e !== void 0 ? e : [], n = n !== void 0 ? n : 301, super(e, n, i, s, y, t, o, u, c, h), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Zg extends oa {
  constructor(e, n = {}) {
    super(e, e, n), this.isWebGLCubeRenderTarget = true;
    const i = { width: e, height: e, depth: 1 }, s = [i, i, i, i, i, i];
    this.texture = new Om(s, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : false, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : 1006;
  }
  fromEquirectangularTexture(e, n) {
    this.texture.type = n.type, this.texture.encoding = n.encoding, this.texture.generateMipmaps = n.generateMipmaps, this.texture.minFilter = n.minFilter, this.texture.magFilter = n.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, s = new qs(5, 5, 5), y = new aa({ name: "CubemapFromEquirect", uniforms: Ca(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: 1, blending: 0 });
    y.uniforms.tEquirect.value = n;
    const t = new io(s, y), o = n.minFilter;
    return n.minFilter === 1008 && (n.minFilter = 1006), new Qg(1, 10, this).update(e, t), n.minFilter = o, t.geometry.dispose(), t.material.dispose(), this;
  }
  clear(e, n, i, s) {
    const y = e.getRenderTarget();
    for (let t = 0; t < 6; t++) e.setRenderTarget(this, t), e.clear(n, i, s);
    e.setRenderTarget(y);
  }
}
const Sl = new _r(), Jg = new _r(), ev = new Vi();
class Yo {
  constructor(e = new _r(1, 0, 0), n = 0) {
    this.isPlane = true, this.normal = e, this.constant = n;
  }
  set(e, n) {
    return this.normal.copy(e), this.constant = n, this;
  }
  setComponents(e, n, i, s) {
    return this.normal.set(e, n, i), this.constant = s, this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), this.constant = -n.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const s = Sl.subVectors(i, n).cross(Jg.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(s, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
  }
  intersectLine(e, n) {
    const i = e.delta(Sl), s = this.normal.dot(i);
    if (s === 0) return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const y = -(e.start.dot(this.normal) + this.constant) / s;
    return y < 0 || y > 1 ? null : n.copy(i).multiplyScalar(y).add(e.start);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return n < 0 && i > 0 || i < 0 && n > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || ev.getNormalMatrix(e), s = this.coplanarPoint(Sl).applyMatrix4(e), y = this.normal.applyMatrix3(i).normalize();
    return this.constant = -s.dot(y), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Aa = new Ds(), Gu = new _r();
class uf {
  constructor(e = new Yo(), n = new Yo(), i = new Yo(), s = new Yo(), y = new Yo(), t = new Yo()) {
    this.planes = [e, n, i, s, y, t];
  }
  set(e, n, i, s, y, t) {
    const o = this.planes;
    return o[0].copy(e), o[1].copy(n), o[2].copy(i), o[3].copy(s), o[4].copy(y), o[5].copy(t), this;
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const n = this.planes, i = e.elements, s = i[0], y = i[1], t = i[2], o = i[3], u = i[4], c = i[5], h = i[6], f = i[7], r = i[8], m = i[9], g = i[10], a = i[11], l = i[12], d = i[13], b = i[14], S = i[15];
    return n[0].setComponents(o - s, f - u, a - r, S - l).normalize(), n[1].setComponents(o + s, f + u, a + r, S + l).normalize(), n[2].setComponents(o + y, f + c, a + m, S + d).normalize(), n[3].setComponents(o - y, f - c, a - m, S - d).normalize(), n[4].setComponents(o - t, f - h, a - g, S - b).normalize(), n[5].setComponents(o + t, f + h, a + g, S + b).normalize(), this;
  }
  intersectsObject(e) {
    const n = e.geometry;
    return n.boundingSphere === null && n.computeBoundingSphere(), Aa.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(Aa);
  }
  intersectsSprite(e) {
    return Aa.center.set(0, 0, 0), Aa.radius = 0.7071067811865476, Aa.applyMatrix4(e.matrixWorld), this.intersectsSphere(Aa);
  }
  intersectsSphere(e) {
    const n = this.planes, i = e.center, s = -e.radius;
    for (let y = 0; y < 6; y++) if (n[y].distanceToPoint(i) < s) return false;
    return true;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const s = n[i];
      if (Gu.x = s.normal.x > 0 ? e.max.x : e.min.x, Gu.y = s.normal.y > 0 ? e.max.y : e.min.y, Gu.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(Gu) < 0) return false;
    }
    return true;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) if (n[i].distanceToPoint(e) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Pm() {
  let v = null, e = false, n = null, i = null;
  function s(y, t) {
    n(y, t), i = v.requestAnimationFrame(s);
  }
  return { start: function() {
    e !== true && n !== null && (i = v.requestAnimationFrame(s), e = true);
  }, stop: function() {
    v.cancelAnimationFrame(i), e = false;
  }, setAnimationLoop: function(y) {
    n = y;
  }, setContext: function(y) {
    v = y;
  } };
}
function tv(v, e) {
  const n = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function s(c, h) {
    const f = c.array, r = c.usage, m = v.createBuffer();
    v.bindBuffer(h, m), v.bufferData(h, f, r), c.onUploadCallback();
    let g;
    if (f instanceof Float32Array) g = 5126;
    else if (f instanceof Uint16Array) if (c.isFloat16BufferAttribute) if (n) g = 5131;
    else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
    else g = 5123;
    else if (f instanceof Int16Array) g = 5122;
    else if (f instanceof Uint32Array) g = 5125;
    else if (f instanceof Int32Array) g = 5124;
    else if (f instanceof Int8Array) g = 5120;
    else if (f instanceof Uint8Array) g = 5121;
    else if (f instanceof Uint8ClampedArray) g = 5121;
    else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
    return { buffer: m, type: g, bytesPerElement: f.BYTES_PER_ELEMENT, version: c.version };
  }
  function y(c, h, f) {
    const r = h.array, m = h.updateRange;
    v.bindBuffer(f, c), m.count === -1 ? v.bufferSubData(f, 0, r) : (n ? v.bufferSubData(f, m.offset * r.BYTES_PER_ELEMENT, r, m.offset, m.count) : v.bufferSubData(f, m.offset * r.BYTES_PER_ELEMENT, r.subarray(m.offset, m.offset + m.count)), m.count = -1);
  }
  function t(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = i.get(c);
    h && (v.deleteBuffer(h.buffer), i.delete(c));
  }
  function u(c, h) {
    if (c.isGLBufferAttribute) {
      const r = i.get(c);
      (!r || r.version < c.version) && i.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const f = i.get(c);
    f === void 0 ? i.set(c, s(c, h)) : f.version < c.version && (y(f.buffer, c, h), f.version = c.version);
  }
  return { get: t, remove: o, update: u };
}
class xc extends ao {
  constructor(e = 1, n = 1, i = 1, s = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: n, widthSegments: i, heightSegments: s };
    const y = e / 2, t = n / 2, o = Math.floor(i), u = Math.floor(s), c = o + 1, h = u + 1, f = e / o, r = n / u, m = [], g = [], a = [], l = [];
    for (let d = 0; d < h; d++) {
      const b = d * r - t;
      for (let S = 0; S < c; S++) {
        const E = S * f - y;
        g.push(E, -b, 0), a.push(0, 0, 1), l.push(S / o), l.push(1 - d / u);
      }
    }
    for (let d = 0; d < u; d++) for (let b = 0; b < o; b++) {
      const S = b + c * d, E = b + c * (d + 1), R = b + 1 + c * (d + 1), k = b + 1 + c * d;
      m.push(S, E, k), m.push(E, R, k);
    }
    this.setIndex(m), this.setAttribute("position", new gi(g, 3)), this.setAttribute("normal", new gi(a, 3)), this.setAttribute("uv", new gi(l, 2));
  }
  static fromJSON(e) {
    return new xc(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var rv = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, nv = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, iv = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, ov = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, av = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, sv = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, uv = "vec3 transformed = vec3( position );", cv = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, lv = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, fv = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, pv = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, hv = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, dv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, mv = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, yv = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, gv = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, vv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, bv = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, wv = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, Sv = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, _v = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, Ev = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, Av = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, xv = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, Tv = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, kv = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, Ov = "gl_FragColor = linearToOutputTexel( gl_FragColor );", Pv = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, Cv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Rv = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, Mv = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, Iv = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, Lv = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, Bv = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, Nv = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, Dv = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, Fv = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, Uv = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`, jv = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, Vv = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, qv = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`, zv = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Hv = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, Gv = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Wv = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`, Kv = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Xv = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`, $v = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, Yv = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Qv = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Zv = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Jv = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, e0 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, t0 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, r0 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, n0 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, i0 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, o0 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, a0 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, s0 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, u0 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, c0 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, l0 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, f0 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, p0 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, h0 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, d0 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, m0 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, y0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, g0 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, v0 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, b0 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, w0 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, S0 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, _0 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, E0 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, A0 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, x0 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, T0 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, k0 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, O0 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, P0 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, C0 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, R0 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, M0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, I0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, L0 = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`, B0 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, N0 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, D0 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, F0 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, U0 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, j0 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, V0 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, q0 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, z0 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, H0 = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`, G0 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, W0 = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, K0 = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, X0 = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, $0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, Y0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, Q0 = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, Z0 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const J0 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, eb = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	gl_FragColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );
	#endif
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, tb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, rb = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, nb = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ib = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, ob = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, ab = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, sb = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, ub = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, cb = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, lb = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, fb = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, pb = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, hb = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, db = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, mb = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, yb = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gb = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, vb = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, bb = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, wb = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Sb = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, _b = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Eb = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ab = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, xb = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Tb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, kb = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ob = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, Pb = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Cb = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, kn = { alphamap_fragment: rv, alphamap_pars_fragment: nv, alphatest_fragment: iv, alphatest_pars_fragment: ov, aomap_fragment: av, aomap_pars_fragment: sv, begin_vertex: uv, beginnormal_vertex: cv, bsdfs: lv, iridescence_fragment: fv, bumpmap_pars_fragment: pv, clipping_planes_fragment: hv, clipping_planes_pars_fragment: dv, clipping_planes_pars_vertex: mv, clipping_planes_vertex: yv, color_fragment: gv, color_pars_fragment: vv, color_pars_vertex: bv, color_vertex: wv, common: Sv, cube_uv_reflection_fragment: _v, defaultnormal_vertex: Ev, displacementmap_pars_vertex: Av, displacementmap_vertex: xv, emissivemap_fragment: Tv, emissivemap_pars_fragment: kv, encodings_fragment: Ov, encodings_pars_fragment: Pv, envmap_fragment: Cv, envmap_common_pars_fragment: Rv, envmap_pars_fragment: Mv, envmap_pars_vertex: Iv, envmap_physical_pars_fragment: Hv, envmap_vertex: Lv, fog_vertex: Bv, fog_pars_vertex: Nv, fog_fragment: Dv, fog_pars_fragment: Fv, gradientmap_pars_fragment: Uv, lightmap_fragment: jv, lightmap_pars_fragment: Vv, lights_lambert_vertex: qv, lights_pars_begin: zv, lights_toon_fragment: Gv, lights_toon_pars_fragment: Wv, lights_phong_fragment: Kv, lights_phong_pars_fragment: Xv, lights_physical_fragment: $v, lights_physical_pars_fragment: Yv, lights_fragment_begin: Qv, lights_fragment_maps: Zv, lights_fragment_end: Jv, logdepthbuf_fragment: e0, logdepthbuf_pars_fragment: t0, logdepthbuf_pars_vertex: r0, logdepthbuf_vertex: n0, map_fragment: i0, map_pars_fragment: o0, map_particle_fragment: a0, map_particle_pars_fragment: s0, metalnessmap_fragment: u0, metalnessmap_pars_fragment: c0, morphcolor_vertex: l0, morphnormal_vertex: f0, morphtarget_pars_vertex: p0, morphtarget_vertex: h0, normal_fragment_begin: d0, normal_fragment_maps: m0, normal_pars_fragment: y0, normal_pars_vertex: g0, normal_vertex: v0, normalmap_pars_fragment: b0, clearcoat_normal_fragment_begin: w0, clearcoat_normal_fragment_maps: S0, clearcoat_pars_fragment: _0, iridescence_pars_fragment: E0, output_fragment: A0, packing: x0, premultiplied_alpha_fragment: T0, project_vertex: k0, dithering_fragment: O0, dithering_pars_fragment: P0, roughnessmap_fragment: C0, roughnessmap_pars_fragment: R0, shadowmap_pars_fragment: M0, shadowmap_pars_vertex: I0, shadowmap_vertex: L0, shadowmask_pars_fragment: B0, skinbase_vertex: N0, skinning_pars_vertex: D0, skinning_vertex: F0, skinnormal_vertex: U0, specularmap_fragment: j0, specularmap_pars_fragment: V0, tonemapping_fragment: q0, tonemapping_pars_fragment: z0, transmission_fragment: H0, transmission_pars_fragment: G0, uv_pars_fragment: W0, uv_pars_vertex: K0, uv_vertex: X0, uv2_pars_fragment: $0, uv2_pars_vertex: Y0, uv2_vertex: Q0, worldpos_vertex: Z0, background_vert: J0, background_frag: eb, cube_vert: tb, cube_frag: rb, depth_vert: nb, depth_frag: ib, distanceRGBA_vert: ob, distanceRGBA_frag: ab, equirect_vert: sb, equirect_frag: ub, linedashed_vert: cb, linedashed_frag: lb, meshbasic_vert: fb, meshbasic_frag: pb, meshlambert_vert: hb, meshlambert_frag: db, meshmatcap_vert: mb, meshmatcap_frag: yb, meshnormal_vert: gb, meshnormal_frag: vb, meshphong_vert: bb, meshphong_frag: wb, meshphysical_vert: Sb, meshphysical_frag: _b, meshtoon_vert: Eb, meshtoon_frag: Ab, points_vert: xb, points_frag: Tb, shadow_vert: kb, shadow_frag: Ob, sprite_vert: Pb, sprite_frag: Cb }, an = { common: { diffuse: { value: new Mn(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Vi() }, uv2Transform: { value: new Vi() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new In(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Mn(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Mn(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Vi() } }, sprite: { diffuse: { value: new Mn(16777215) }, opacity: { value: 1 }, center: { value: new In(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Vi() } } }, ro = { basic: { uniforms: mi([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.fog]), vertexShader: kn.meshbasic_vert, fragmentShader: kn.meshbasic_frag }, lambert: { uniforms: mi([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.fog, an.lights, { emissive: { value: new Mn(0) } }]), vertexShader: kn.meshlambert_vert, fragmentShader: kn.meshlambert_frag }, phong: { uniforms: mi([an.common, an.specularmap, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.fog, an.lights, { emissive: { value: new Mn(0) }, specular: { value: new Mn(1118481) }, shininess: { value: 30 } }]), vertexShader: kn.meshphong_vert, fragmentShader: kn.meshphong_frag }, standard: { uniforms: mi([an.common, an.envmap, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.roughnessmap, an.metalnessmap, an.fog, an.lights, { emissive: { value: new Mn(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: kn.meshphysical_vert, fragmentShader: kn.meshphysical_frag }, toon: { uniforms: mi([an.common, an.aomap, an.lightmap, an.emissivemap, an.bumpmap, an.normalmap, an.displacementmap, an.gradientmap, an.fog, an.lights, { emissive: { value: new Mn(0) } }]), vertexShader: kn.meshtoon_vert, fragmentShader: kn.meshtoon_frag }, matcap: { uniforms: mi([an.common, an.bumpmap, an.normalmap, an.displacementmap, an.fog, { matcap: { value: null } }]), vertexShader: kn.meshmatcap_vert, fragmentShader: kn.meshmatcap_frag }, points: { uniforms: mi([an.points, an.fog]), vertexShader: kn.points_vert, fragmentShader: kn.points_frag }, dashed: { uniforms: mi([an.common, an.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: kn.linedashed_vert, fragmentShader: kn.linedashed_frag }, depth: { uniforms: mi([an.common, an.displacementmap]), vertexShader: kn.depth_vert, fragmentShader: kn.depth_frag }, normal: { uniforms: mi([an.common, an.bumpmap, an.normalmap, an.displacementmap, { opacity: { value: 1 } }]), vertexShader: kn.meshnormal_vert, fragmentShader: kn.meshnormal_frag }, sprite: { uniforms: mi([an.sprite, an.fog]), vertexShader: kn.sprite_vert, fragmentShader: kn.sprite_frag }, background: { uniforms: { uvTransform: { value: new Vi() }, t2D: { value: null } }, vertexShader: kn.background_vert, fragmentShader: kn.background_frag }, cube: { uniforms: mi([an.envmap, { opacity: { value: 1 } }]), vertexShader: kn.cube_vert, fragmentShader: kn.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: kn.equirect_vert, fragmentShader: kn.equirect_frag }, distanceRGBA: { uniforms: mi([an.common, an.displacementmap, { referencePosition: { value: new _r() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: kn.distanceRGBA_vert, fragmentShader: kn.distanceRGBA_frag }, shadow: { uniforms: mi([an.lights, an.fog, { color: { value: new Mn(0) }, opacity: { value: 1 } }]), vertexShader: kn.shadow_vert, fragmentShader: kn.shadow_frag } };
ro.physical = { uniforms: mi([ro.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new In(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Mn(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new In() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Mn(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Mn(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: kn.meshphysical_vert, fragmentShader: kn.meshphysical_frag };
function Rb(v, e, n, i, s, y) {
  const t = new Mn(0);
  let o = s === true ? 0 : 1, u, c, h = null, f = 0, r = null;
  function m(a, l) {
    let d = false, b = l.isScene === true ? l.background : null;
    b && b.isTexture && (b = e.get(b));
    const S = v.xr, E = S.getSession && S.getSession();
    E && E.environmentBlendMode === "additive" && (b = null), b === null ? g(t, o) : b && b.isColor && (g(b, 1), d = true), (v.autoClear || d) && v.clear(v.autoClearColor, v.autoClearDepth, v.autoClearStencil), b && (b.isCubeTexture || b.mapping === 306) ? (c === void 0 && (c = new io(new qs(1, 1, 1), new aa({ name: "BackgroundCubeMaterial", uniforms: Ca(ro.cube.uniforms), vertexShader: ro.cube.vertexShader, fragmentShader: ro.cube.fragmentShader, side: 1, depthTest: false, depthWrite: false, fog: false })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(R, k, w) {
      this.matrixWorld.copyPosition(w.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), i.update(c)), c.material.uniforms.envMap.value = b, c.material.uniforms.flipEnvMap.value = b.isCubeTexture && b.isRenderTargetTexture === false ? -1 : 1, (h !== b || f !== b.version || r !== v.toneMapping) && (c.material.needsUpdate = true, h = b, f = b.version, r = v.toneMapping), c.layers.enableAll(), a.unshift(c, c.geometry, c.material, 0, 0, null)) : b && b.isTexture && (u === void 0 && (u = new io(new xc(2, 2), new aa({ name: "BackgroundMaterial", uniforms: Ca(ro.background.uniforms), vertexShader: ro.background.vertexShader, fragmentShader: ro.background.fragmentShader, side: 0, depthTest: false, depthWrite: false, fog: false })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), i.update(u)), u.material.uniforms.t2D.value = b, b.matrixAutoUpdate === true && b.updateMatrix(), u.material.uniforms.uvTransform.value.copy(b.matrix), (h !== b || f !== b.version || r !== v.toneMapping) && (u.material.needsUpdate = true, h = b, f = b.version, r = v.toneMapping), u.layers.enableAll(), a.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function g(a, l) {
    n.buffers.color.setClear(a.r, a.g, a.b, l, y);
  }
  return { getClearColor: function() {
    return t;
  }, setClearColor: function(a, l = 1) {
    t.set(a), o = l, g(t, o);
  }, getClearAlpha: function() {
    return o;
  }, setClearAlpha: function(a) {
    o = a, g(t, o);
  }, render: m };
}
function Mb(v, e, n, i) {
  const s = v.getParameter(34921), y = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), t = i.isWebGL2 || y !== null, o = {}, u = l(null);
  let c = u, h = false;
  function f(T, L, j, z, Y) {
    let te = false;
    if (t) {
      const G = a(z, j, L);
      c !== G && (c = G, m(c.object)), te = d(T, z, j, Y), te && b(T, z, j, Y);
    } else {
      const G = L.wireframe === true;
      (c.geometry !== z.id || c.program !== j.id || c.wireframe !== G) && (c.geometry = z.id, c.program = j.id, c.wireframe = G, te = true);
    }
    Y !== null && n.update(Y, 34963), (te || h) && (h = false, F(T, L, j, z), Y !== null && v.bindBuffer(34963, n.get(Y).buffer));
  }
  function r() {
    return i.isWebGL2 ? v.createVertexArray() : y.createVertexArrayOES();
  }
  function m(T) {
    return i.isWebGL2 ? v.bindVertexArray(T) : y.bindVertexArrayOES(T);
  }
  function g(T) {
    return i.isWebGL2 ? v.deleteVertexArray(T) : y.deleteVertexArrayOES(T);
  }
  function a(T, L, j) {
    const z = j.wireframe === true;
    let Y = o[T.id];
    Y === void 0 && (Y = {}, o[T.id] = Y);
    let te = Y[L.id];
    te === void 0 && (te = {}, Y[L.id] = te);
    let G = te[z];
    return G === void 0 && (G = l(r()), te[z] = G), G;
  }
  function l(T) {
    const L = [], j = [], z = [];
    for (let Y = 0; Y < s; Y++) L[Y] = 0, j[Y] = 0, z[Y] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: L, enabledAttributes: j, attributeDivisors: z, object: T, attributes: {}, index: null };
  }
  function d(T, L, j, z) {
    const Y = c.attributes, te = L.attributes;
    let G = 0;
    const K = j.getAttributes();
    for (const J in K) if (K[J].location >= 0) {
      const B = Y[J];
      let Z = te[J];
      if (Z === void 0 && (J === "instanceMatrix" && T.instanceMatrix && (Z = T.instanceMatrix), J === "instanceColor" && T.instanceColor && (Z = T.instanceColor)), B === void 0 || B.attribute !== Z || Z && B.data !== Z.data) return true;
      G++;
    }
    return c.attributesNum !== G || c.index !== z;
  }
  function b(T, L, j, z) {
    const Y = {}, te = L.attributes;
    let G = 0;
    const K = j.getAttributes();
    for (const J in K) if (K[J].location >= 0) {
      let B = te[J];
      B === void 0 && (J === "instanceMatrix" && T.instanceMatrix && (B = T.instanceMatrix), J === "instanceColor" && T.instanceColor && (B = T.instanceColor));
      const Z = {};
      Z.attribute = B, B && B.data && (Z.data = B.data), Y[J] = Z, G++;
    }
    c.attributes = Y, c.attributesNum = G, c.index = z;
  }
  function S() {
    const T = c.newAttributes;
    for (let L = 0, j = T.length; L < j; L++) T[L] = 0;
  }
  function E(T) {
    R(T, 0);
  }
  function R(T, L) {
    const j = c.newAttributes, z = c.enabledAttributes, Y = c.attributeDivisors;
    j[T] = 1, z[T] === 0 && (v.enableVertexAttribArray(T), z[T] = 1), Y[T] !== L && ((i.isWebGL2 ? v : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](T, L), Y[T] = L);
  }
  function k() {
    const T = c.newAttributes, L = c.enabledAttributes;
    for (let j = 0, z = L.length; j < z; j++) L[j] !== T[j] && (v.disableVertexAttribArray(j), L[j] = 0);
  }
  function w(T, L, j, z, Y, te) {
    i.isWebGL2 === true && (j === 5124 || j === 5125) ? v.vertexAttribIPointer(T, L, j, Y, te) : v.vertexAttribPointer(T, L, j, z, Y, te);
  }
  function F(T, L, j, z) {
    if (i.isWebGL2 === false && (T.isInstancedMesh || z.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
    S();
    const Y = z.attributes, te = j.getAttributes(), G = L.defaultAttributeValues;
    for (const K in te) {
      const J = te[K];
      if (J.location >= 0) {
        let B = Y[K];
        if (B === void 0 && (K === "instanceMatrix" && T.instanceMatrix && (B = T.instanceMatrix), K === "instanceColor" && T.instanceColor && (B = T.instanceColor)), B !== void 0) {
          const Z = B.normalized, ie = B.itemSize, $ = n.get(B);
          if ($ === void 0) continue;
          const oe = $.buffer, ce = $.type, ye = $.bytesPerElement;
          if (B.isInterleavedBufferAttribute) {
            const ae = B.data, ue = ae.stride, ne = B.offset;
            if (ae.isInstancedInterleavedBuffer) {
              for (let ge = 0; ge < J.locationSize; ge++) R(J.location + ge, ae.meshPerAttribute);
              T.isInstancedMesh !== true && z._maxInstanceCount === void 0 && (z._maxInstanceCount = ae.meshPerAttribute * ae.count);
            } else for (let ge = 0; ge < J.locationSize; ge++) E(J.location + ge);
            v.bindBuffer(34962, oe);
            for (let ge = 0; ge < J.locationSize; ge++) w(J.location + ge, ie / J.locationSize, ce, Z, ue * ye, (ne + ie / J.locationSize * ge) * ye);
          } else {
            if (B.isInstancedBufferAttribute) {
              for (let ae = 0; ae < J.locationSize; ae++) R(J.location + ae, B.meshPerAttribute);
              T.isInstancedMesh !== true && z._maxInstanceCount === void 0 && (z._maxInstanceCount = B.meshPerAttribute * B.count);
            } else for (let ae = 0; ae < J.locationSize; ae++) E(J.location + ae);
            v.bindBuffer(34962, oe);
            for (let ae = 0; ae < J.locationSize; ae++) w(J.location + ae, ie / J.locationSize, ce, Z, ie * ye, ie / J.locationSize * ae * ye);
          }
        } else if (G !== void 0) {
          const Z = G[K];
          if (Z !== void 0) switch (Z.length) {
            case 2:
              v.vertexAttrib2fv(J.location, Z);
              break;
            case 3:
              v.vertexAttrib3fv(J.location, Z);
              break;
            case 4:
              v.vertexAttrib4fv(J.location, Z);
              break;
            default:
              v.vertexAttrib1fv(J.location, Z);
          }
        }
      }
    }
    k();
  }
  function I() {
    H();
    for (const T in o) {
      const L = o[T];
      for (const j in L) {
        const z = L[j];
        for (const Y in z) g(z[Y].object), delete z[Y];
        delete L[j];
      }
      delete o[T];
    }
  }
  function q(T) {
    if (o[T.id] === void 0) return;
    const L = o[T.id];
    for (const j in L) {
      const z = L[j];
      for (const Y in z) g(z[Y].object), delete z[Y];
      delete L[j];
    }
    delete o[T.id];
  }
  function D(T) {
    for (const L in o) {
      const j = o[L];
      if (j[T.id] === void 0) continue;
      const z = j[T.id];
      for (const Y in z) g(z[Y].object), delete z[Y];
      delete j[T.id];
    }
  }
  function H() {
    _(), h = true, c !== u && (c = u, m(c.object));
  }
  function _() {
    u.geometry = null, u.program = null, u.wireframe = false;
  }
  return { setup: f, reset: H, resetDefaultState: _, dispose: I, releaseStatesOfGeometry: q, releaseStatesOfProgram: D, initAttributes: S, enableAttribute: E, disableUnusedAttributes: k };
}
function Ib(v, e, n, i) {
  const s = i.isWebGL2;
  let y;
  function t(c) {
    y = c;
  }
  function o(c, h) {
    v.drawArrays(y, c, h), n.update(h, y, 1);
  }
  function u(c, h, f) {
    if (f === 0) return;
    let r, m;
    if (s) r = v, m = "drawArraysInstanced";
    else if (r = e.get("ANGLE_instanced_arrays"), m = "drawArraysInstancedANGLE", r === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    r[m](y, c, h, f), n.update(h, y, f);
  }
  this.setMode = t, this.render = o, this.renderInstances = u;
}
function Lb(v, e, n) {
  let i;
  function s() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === true) {
      const w = e.get("EXT_texture_filter_anisotropic");
      i = v.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function y(w) {
    if (w === "highp") {
      if (v.getShaderPrecisionFormat(35633, 36338).precision > 0 && v.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
      w = "mediump";
    }
    return w === "mediump" && v.getShaderPrecisionFormat(35633, 36337).precision > 0 && v.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
  }
  const t = typeof WebGL2RenderingContext < "u" && v instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && v instanceof WebGL2ComputeRenderingContext;
  let o = n.precision !== void 0 ? n.precision : "highp";
  const u = y(o);
  u !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", u, "instead."), o = u);
  const c = t || e.has("WEBGL_draw_buffers"), h = n.logarithmicDepthBuffer === true, f = v.getParameter(34930), r = v.getParameter(35660), m = v.getParameter(3379), g = v.getParameter(34076), a = v.getParameter(34921), l = v.getParameter(36347), d = v.getParameter(36348), b = v.getParameter(36349), S = r > 0, E = t || e.has("OES_texture_float"), R = S && E, k = t ? v.getParameter(36183) : 0;
  return { isWebGL2: t, drawBuffers: c, getMaxAnisotropy: s, getMaxPrecision: y, precision: o, logarithmicDepthBuffer: h, maxTextures: f, maxVertexTextures: r, maxTextureSize: m, maxCubemapSize: g, maxAttributes: a, maxVertexUniforms: l, maxVaryings: d, maxFragmentUniforms: b, vertexTextures: S, floatFragmentTextures: E, floatVertexTextures: R, maxSamples: k };
}
function Bb(v) {
  const e = this;
  let n = null, i = 0, s = false, y = false;
  const t = new Yo(), o = new Vi(), u = { value: null, needsUpdate: false };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, r, m) {
    const g = f.length !== 0 || r || i !== 0 || s;
    return s = r, n = h(f, m, 0), i = f.length, g;
  }, this.beginShadows = function() {
    y = true, h(null);
  }, this.endShadows = function() {
    y = false, c();
  }, this.setState = function(f, r, m) {
    const g = f.clippingPlanes, a = f.clipIntersection, l = f.clipShadows, d = v.get(f);
    if (!s || g === null || g.length === 0 || y && !l) y ? h(null) : c();
    else {
      const b = y ? 0 : i, S = b * 4;
      let E = d.clippingState || null;
      u.value = E, E = h(g, r, S, m);
      for (let R = 0; R !== S; ++R) E[R] = n[R];
      d.clippingState = E, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += b;
    }
  };
  function c() {
    u.value !== n && (u.value = n, u.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(f, r, m, g) {
    const a = f !== null ? f.length : 0;
    let l = null;
    if (a !== 0) {
      if (l = u.value, g !== true || l === null) {
        const d = m + a * 4, b = r.matrixWorldInverse;
        o.getNormalMatrix(b), (l === null || l.length < d) && (l = new Float32Array(d));
        for (let S = 0, E = m; S !== a; ++S, E += 4) t.copy(f[S]).applyMatrix4(b, o), t.normal.toArray(l, E), l[E + 3] = t.constant;
      }
      u.value = l, u.needsUpdate = true;
    }
    return e.numPlanes = a, e.numIntersection = 0, l;
  }
}
function Nb(v) {
  let e = /* @__PURE__ */ new WeakMap();
  function n(t, o) {
    return o === 303 ? t.mapping = 301 : o === 304 && (t.mapping = 302), t;
  }
  function i(t) {
    if (t && t.isTexture && t.isRenderTargetTexture === false) {
      const o = t.mapping;
      if (o === 303 || o === 304) if (e.has(t)) {
        const u = e.get(t).texture;
        return n(u, t.mapping);
      } else {
        const u = t.image;
        if (u && u.height > 0) {
          const c = new Zg(u.height / 2);
          return c.fromEquirectangularTexture(v, t), e.set(t, c), t.addEventListener("dispose", s), n(c.texture, t.mapping);
        } else return null;
      }
    }
    return t;
  }
  function s(t) {
    const o = t.target;
    o.removeEventListener("dispose", s);
    const u = e.get(o);
    u !== void 0 && (e.delete(o), u.dispose());
  }
  function y() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: y };
}
class Db extends km {
  constructor(e = -1, n = 1, i = 1, s = -1, y = 0.1, t = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = n, this.top = i, this.bottom = s, this.near = y, this.far = t, this.updateProjectionMatrix();
  }
  copy(e, n) {
    return super.copy(e, n), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, n, i, s, y, t) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = n, this.view.offsetX = i, this.view.offsetY = s, this.view.width = y, this.view.height = t, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), n = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, s = (this.top + this.bottom) / 2;
    let y = i - e, t = i + e, o = s + n, u = s - n;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      y += c * this.view.offsetX, t = y + c * this.view.width, o -= h * this.view.offsetY, u = o - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(y, t, o, u, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.zoom = this.zoom, n.object.left = this.left, n.object.right = this.right, n.object.top = this.top, n.object.bottom = this.bottom, n.object.near = this.near, n.object.far = this.far, this.view !== null && (n.object.view = Object.assign({}, this.view)), n;
  }
}
const Oa = 4, Fh = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Zo = 20, _l = new Db(), Uh = new Mn();
let El = null;
const Qo = (1 + Math.sqrt(5)) / 2, xa = 1 / Qo, jh = [new _r(1, 1, 1), new _r(-1, 1, 1), new _r(1, 1, -1), new _r(-1, 1, -1), new _r(0, Qo, xa), new _r(0, Qo, -xa), new _r(xa, 0, Qo), new _r(-xa, 0, Qo), new _r(Qo, xa, 0), new _r(-Qo, xa, 0)];
class Vh {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, i = 0.1, s = 100) {
    El = this._renderer.getRenderTarget(), this._setSize(256);
    const y = this._allocateTargets();
    return y.depthBuffer = true, this._sceneToCubeUV(e, i, s, y), n > 0 && this._blur(y, 0, 0, n), this._applyPMREM(y), this._cleanup(y), y;
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = Hh(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = zh(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(El), e.scissorTest = false, Wu(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === 301 || e.mapping === 302 ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), El = this._renderer.getRenderTarget();
    const i = n || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), n = 4 * this._cubeSize, i = { magFilter: 1006, minFilter: 1006, generateMipmaps: false, type: 1016, format: 1023, encoding: 3e3, depthBuffer: false }, s = qh(e, n, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = qh(e, n, i);
      const { _lodMax: y } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Fb(y)), this._blurMaterial = Ub(y, e, n);
    }
    return s;
  }
  _compileMaterial(e) {
    const n = new io(this._lodPlanes[0], e);
    this._renderer.compile(n, _l);
  }
  _sceneToCubeUV(e, n, i, s) {
    const y = new Ri(90, 1, n, i), t = [1, -1, 1, 1, 1, 1], o = [1, 1, 1, -1, -1, -1], u = this._renderer, c = u.autoClear, h = u.toneMapping;
    u.getClearColor(Uh), u.toneMapping = 0, u.autoClear = false;
    const f = new Am({ name: "PMREM.Background", side: 1, depthWrite: false, depthTest: false }), r = new io(new qs(), f);
    let m = false;
    const g = e.background;
    g ? g.isColor && (f.color.copy(g), e.background = null, m = true) : (f.color.copy(Uh), m = true);
    for (let a = 0; a < 6; a++) {
      const l = a % 3;
      l === 0 ? (y.up.set(0, t[a], 0), y.lookAt(o[a], 0, 0)) : l === 1 ? (y.up.set(0, 0, t[a]), y.lookAt(0, o[a], 0)) : (y.up.set(0, t[a], 0), y.lookAt(0, 0, o[a]));
      const d = this._cubeSize;
      Wu(s, l * d, a > 2 ? d : 0, d, d), u.setRenderTarget(s), m && u.render(r, y), u.render(e, y);
    }
    r.geometry.dispose(), r.material.dispose(), u.toneMapping = h, u.autoClear = c, e.background = g;
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer, s = e.mapping === 301 || e.mapping === 302;
    s ? (this._cubemapMaterial === null && (this._cubemapMaterial = Hh()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zh());
    const y = s ? this._cubemapMaterial : this._equirectMaterial, t = new io(this._lodPlanes[0], y), o = y.uniforms;
    o.envMap.value = e;
    const u = this._cubeSize;
    Wu(n, 0, 0, 3 * u, 2 * u), i.setRenderTarget(n), i.render(t, _l);
  }
  _applyPMREM(e) {
    const n = this._renderer, i = n.autoClear;
    n.autoClear = false;
    for (let s = 1; s < this._lodPlanes.length; s++) {
      const y = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), t = jh[(s - 1) % jh.length];
      this._blur(e, s - 1, s, y, t);
    }
    n.autoClear = i;
  }
  _blur(e, n, i, s, y) {
    const t = this._pingPongRenderTarget;
    this._halfBlur(e, t, n, i, s, "latitudinal", y), this._halfBlur(t, e, i, i, s, "longitudinal", y);
  }
  _halfBlur(e, n, i, s, y, t, o) {
    const u = this._renderer, c = this._blurMaterial;
    t !== "latitudinal" && t !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, f = new io(this._lodPlanes[s], c), r = c.uniforms, m = this._sizeLods[i] - 1, g = isFinite(y) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Zo - 1), a = y / g, l = isFinite(y) ? 1 + Math.floor(h * a) : Zo;
    l > Zo && console.warn(`sigmaRadians, ${y}, is too large and will clip, as it requested ${l} samples when the maximum is set to ${Zo}`);
    const d = [];
    let b = 0;
    for (let w = 0; w < Zo; ++w) {
      const F = w / a, I = Math.exp(-F * F / 2);
      d.push(I), w === 0 ? b += I : w < l && (b += 2 * I);
    }
    for (let w = 0; w < d.length; w++) d[w] = d[w] / b;
    r.envMap.value = e.texture, r.samples.value = l, r.weights.value = d, r.latitudinal.value = t === "latitudinal", o && (r.poleAxis.value = o);
    const { _lodMax: S } = this;
    r.dTheta.value = g, r.mipInt.value = S - i;
    const E = this._sizeLods[s], R = 3 * E * (s > S - Oa ? s - S + Oa : 0), k = 4 * (this._cubeSize - E);
    Wu(n, R, k, 3 * E, 2 * E), u.setRenderTarget(n), u.render(f, _l);
  }
}
function Fb(v) {
  const e = [], n = [], i = [];
  let s = v;
  const y = v - Oa + 1 + Fh.length;
  for (let t = 0; t < y; t++) {
    const o = Math.pow(2, s);
    n.push(o);
    let u = 1 / o;
    t > v - Oa ? u = Fh[t - v + Oa - 1] : t === 0 && (u = 0), i.push(u);
    const c = 1 / (o - 2), h = -c, f = 1 + c, r = [h, h, f, h, f, f, h, h, f, f, h, f], m = 6, g = 6, a = 3, l = 2, d = 1, b = new Float32Array(a * g * m), S = new Float32Array(l * g * m), E = new Float32Array(d * g * m);
    for (let k = 0; k < m; k++) {
      const w = k % 3 * 2 / 3 - 1, F = k > 2 ? 0 : -1, I = [w, F, 0, w + 2 / 3, F, 0, w + 2 / 3, F + 1, 0, w, F, 0, w + 2 / 3, F + 1, 0, w, F + 1, 0];
      b.set(I, a * g * k), S.set(r, l * g * k);
      const q = [k, k, k, k, k, k];
      E.set(q, d * g * k);
    }
    const R = new ao();
    R.setAttribute("position", new oo(b, a)), R.setAttribute("uv", new oo(S, l)), R.setAttribute("faceIndex", new oo(E, d)), e.push(R), s > Oa && s--;
  }
  return { lodPlanes: e, sizeLods: n, sigmas: i };
}
function qh(v, e, n) {
  const i = new oa(v, e, n);
  return i.texture.mapping = 306, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
}
function Wu(v, e, n, i, s) {
  v.viewport.set(e, n, i, s), v.scissor.set(e, n, i, s);
}
function Ub(v, e, n) {
  const i = new Float32Array(Zo), s = new _r(0, 1, 0);
  return new aa({ name: "SphericalGaussianBlur", defines: { n: Zo, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / n, CUBEUV_MAX_MIP: `${v}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: s } }, vertexShader: cf(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: 0, depthTest: false, depthWrite: false });
}
function zh() {
  return new aa({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: cf(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
}
function Hh() {
  return new aa({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: cf(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: 0, depthTest: false, depthWrite: false });
}
function cf() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function jb(v) {
  let e = /* @__PURE__ */ new WeakMap(), n = null;
  function i(o) {
    if (o && o.isTexture) {
      const u = o.mapping, c = u === 303 || u === 304, h = u === 301 || u === 302;
      if (c || h) if (o.isRenderTargetTexture && o.needsPMREMUpdate === true) {
        o.needsPMREMUpdate = false;
        let f = e.get(o);
        return n === null && (n = new Vh(v)), f = c ? n.fromEquirectangular(o, f) : n.fromCubemap(o, f), e.set(o, f), f.texture;
      } else {
        if (e.has(o)) return e.get(o).texture;
        {
          const f = o.image;
          if (c && f && f.height > 0 || h && f && s(f)) {
            n === null && (n = new Vh(v));
            const r = c ? n.fromEquirectangular(o) : n.fromCubemap(o);
            return e.set(o, r), o.addEventListener("dispose", y), r.texture;
          } else return null;
        }
      }
    }
    return o;
  }
  function s(o) {
    let u = 0;
    const c = 6;
    for (let h = 0; h < c; h++) o[h] !== void 0 && u++;
    return u === c;
  }
  function y(o) {
    const u = o.target;
    u.removeEventListener("dispose", y);
    const c = e.get(u);
    c !== void 0 && (e.delete(u), c.dispose());
  }
  function t() {
    e = /* @__PURE__ */ new WeakMap(), n !== null && (n.dispose(), n = null);
  }
  return { get: i, dispose: t };
}
function Vb(v) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0) return e[i];
    let s;
    switch (i) {
      case "WEBGL_depth_texture":
        s = v.getExtension("WEBGL_depth_texture") || v.getExtension("MOZ_WEBGL_depth_texture") || v.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        s = v.getExtension("EXT_texture_filter_anisotropic") || v.getExtension("MOZ_EXT_texture_filter_anisotropic") || v.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        s = v.getExtension("WEBGL_compressed_texture_s3tc") || v.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || v.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        s = v.getExtension("WEBGL_compressed_texture_pvrtc") || v.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        s = v.getExtension(i);
    }
    return e[i] = s, s;
  }
  return { has: function(i) {
    return n(i) !== null;
  }, init: function(i) {
    i.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture");
  }, get: function(i) {
    const s = n(i);
    return s === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), s;
  } };
}
function qb(v, e, n, i) {
  const s = {}, y = /* @__PURE__ */ new WeakMap();
  function t(f) {
    const r = f.target;
    r.index !== null && e.remove(r.index);
    for (const g in r.attributes) e.remove(r.attributes[g]);
    r.removeEventListener("dispose", t), delete s[r.id];
    const m = y.get(r);
    m && (e.remove(m), y.delete(r)), i.releaseStatesOfGeometry(r), r.isInstancedBufferGeometry === true && delete r._maxInstanceCount, n.memory.geometries--;
  }
  function o(f, r) {
    return s[r.id] === true || (r.addEventListener("dispose", t), s[r.id] = true, n.memory.geometries++), r;
  }
  function u(f) {
    const r = f.attributes;
    for (const g in r) e.update(r[g], 34962);
    const m = f.morphAttributes;
    for (const g in m) {
      const a = m[g];
      for (let l = 0, d = a.length; l < d; l++) e.update(a[l], 34962);
    }
  }
  function c(f) {
    const r = [], m = f.index, g = f.attributes.position;
    let a = 0;
    if (m !== null) {
      const b = m.array;
      a = m.version;
      for (let S = 0, E = b.length; S < E; S += 3) {
        const R = b[S + 0], k = b[S + 1], w = b[S + 2];
        r.push(R, k, k, w, w, R);
      }
    } else {
      const b = g.array;
      a = g.version;
      for (let S = 0, E = b.length / 3 - 1; S < E; S += 3) {
        const R = S + 0, k = S + 1, w = S + 2;
        r.push(R, k, k, w, w, R);
      }
    }
    const l = new (vm(r) ? Tm : xm)(r, 1);
    l.version = a;
    const d = y.get(f);
    d && e.remove(d), y.set(f, l);
  }
  function h(f) {
    const r = y.get(f);
    if (r) {
      const m = f.index;
      m !== null && r.version < m.version && c(f);
    } else c(f);
    return y.get(f);
  }
  return { get: o, update: u, getWireframeAttribute: h };
}
function zb(v, e, n, i) {
  const s = i.isWebGL2;
  let y;
  function t(r) {
    y = r;
  }
  let o, u;
  function c(r) {
    o = r.type, u = r.bytesPerElement;
  }
  function h(r, m) {
    v.drawElements(y, m, o, r * u), n.update(m, y, 1);
  }
  function f(r, m, g) {
    if (g === 0) return;
    let a, l;
    if (s) a = v, l = "drawElementsInstanced";
    else if (a = e.get("ANGLE_instanced_arrays"), l = "drawElementsInstancedANGLE", a === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    a[l](y, m, o, r * u, g), n.update(m, y, g);
  }
  this.setMode = t, this.setIndex = c, this.render = h, this.renderInstances = f;
}
function Hb(v) {
  const e = { geometries: 0, textures: 0 }, n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(y, t, o) {
    switch (n.calls++, t) {
      case 4:
        n.triangles += o * (y / 3);
        break;
      case 1:
        n.lines += o * (y / 2);
        break;
      case 3:
        n.lines += o * (y - 1);
        break;
      case 2:
        n.lines += o * y;
        break;
      case 0:
        n.points += o * y;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", t);
        break;
    }
  }
  function s() {
    n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0;
  }
  return { memory: e, render: n, programs: null, autoReset: true, reset: s, update: i };
}
function Gb(v, e) {
  return v[0] - e[0];
}
function Wb(v, e) {
  return Math.abs(e[1]) - Math.abs(v[1]);
}
function Al(v, e) {
  let n = 1;
  const i = e.isInterleavedBufferAttribute ? e.data.array : e.array;
  i instanceof Int8Array ? n = 127 : i instanceof Uint8Array ? n = 255 : i instanceof Uint16Array ? n = 65535 : i instanceof Int16Array ? n = 32767 : i instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", i), v.divideScalar(n);
}
function Kb(v, e, n) {
  const i = {}, s = new Float32Array(8), y = /* @__PURE__ */ new WeakMap(), t = new ci(), o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function u(c, h, f, r) {
    const m = c.morphTargetInfluences;
    if (e.isWebGL2 === true) {
      const g = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, a = g !== void 0 ? g.length : 0;
      let l = y.get(h);
      if (l === void 0 || l.count !== a) {
        let S = function() {
          T.dispose(), y.delete(h), h.removeEventListener("dispose", S);
        };
        l !== void 0 && l.texture.dispose();
        const E = h.morphAttributes.position !== void 0, R = h.morphAttributes.normal !== void 0, k = h.morphAttributes.color !== void 0, w = h.morphAttributes.position || [], F = h.morphAttributes.normal || [], I = h.morphAttributes.color || [];
        let q = 0;
        E === true && (q = 1), R === true && (q = 2), k === true && (q = 3);
        let D = h.attributes.position.count * q, H = 1;
        D > e.maxTextureSize && (H = Math.ceil(D / e.maxTextureSize), D = e.maxTextureSize);
        const _ = new Float32Array(D * H * 4 * a), T = new _m(_, D, H, a);
        T.type = 1015, T.needsUpdate = true;
        const L = q * 4;
        for (let j = 0; j < a; j++) {
          const z = w[j], Y = F[j], te = I[j], G = D * H * 4 * j;
          for (let K = 0; K < z.count; K++) {
            const J = K * L;
            E === true && (t.fromBufferAttribute(z, K), z.normalized === true && Al(t, z), _[G + J + 0] = t.x, _[G + J + 1] = t.y, _[G + J + 2] = t.z, _[G + J + 3] = 0), R === true && (t.fromBufferAttribute(Y, K), Y.normalized === true && Al(t, Y), _[G + J + 4] = t.x, _[G + J + 5] = t.y, _[G + J + 6] = t.z, _[G + J + 7] = 0), k === true && (t.fromBufferAttribute(te, K), te.normalized === true && Al(t, te), _[G + J + 8] = t.x, _[G + J + 9] = t.y, _[G + J + 10] = t.z, _[G + J + 11] = te.itemSize === 4 ? t.w : 1);
          }
        }
        l = { count: a, texture: T, size: new In(D, H) }, y.set(h, l), h.addEventListener("dispose", S);
      }
      let d = 0;
      for (let S = 0; S < m.length; S++) d += m[S];
      const b = h.morphTargetsRelative ? 1 : 1 - d;
      r.getUniforms().setValue(v, "morphTargetBaseInfluence", b), r.getUniforms().setValue(v, "morphTargetInfluences", m), r.getUniforms().setValue(v, "morphTargetsTexture", l.texture, n), r.getUniforms().setValue(v, "morphTargetsTextureSize", l.size);
    } else {
      const g = m === void 0 ? 0 : m.length;
      let a = i[h.id];
      if (a === void 0 || a.length !== g) {
        a = [];
        for (let E = 0; E < g; E++) a[E] = [E, 0];
        i[h.id] = a;
      }
      for (let E = 0; E < g; E++) {
        const R = a[E];
        R[0] = E, R[1] = m[E];
      }
      a.sort(Wb);
      for (let E = 0; E < 8; E++) E < g && a[E][1] ? (o[E][0] = a[E][0], o[E][1] = a[E][1]) : (o[E][0] = Number.MAX_SAFE_INTEGER, o[E][1] = 0);
      o.sort(Gb);
      const l = h.morphAttributes.position, d = h.morphAttributes.normal;
      let b = 0;
      for (let E = 0; E < 8; E++) {
        const R = o[E], k = R[0], w = R[1];
        k !== Number.MAX_SAFE_INTEGER && w ? (l && h.getAttribute("morphTarget" + E) !== l[k] && h.setAttribute("morphTarget" + E, l[k]), d && h.getAttribute("morphNormal" + E) !== d[k] && h.setAttribute("morphNormal" + E, d[k]), s[E] = w, b += w) : (l && h.hasAttribute("morphTarget" + E) === true && h.deleteAttribute("morphTarget" + E), d && h.hasAttribute("morphNormal" + E) === true && h.deleteAttribute("morphNormal" + E), s[E] = 0);
      }
      const S = h.morphTargetsRelative ? 1 : 1 - b;
      r.getUniforms().setValue(v, "morphTargetBaseInfluence", S), r.getUniforms().setValue(v, "morphTargetInfluences", s);
    }
  }
  return { update: u };
}
function Xb(v, e, n, i) {
  let s = /* @__PURE__ */ new WeakMap();
  function y(u) {
    const c = i.render.frame, h = u.geometry, f = e.get(u, h);
    return s.get(f) !== c && (e.update(f), s.set(f, c)), u.isInstancedMesh && (u.hasEventListener("dispose", o) === false && u.addEventListener("dispose", o), n.update(u.instanceMatrix, 34962), u.instanceColor !== null && n.update(u.instanceColor, 34962)), f;
  }
  function t() {
    s = /* @__PURE__ */ new WeakMap();
  }
  function o(u) {
    const c = u.target;
    c.removeEventListener("dispose", o), n.remove(c.instanceMatrix), c.instanceColor !== null && n.remove(c.instanceColor);
  }
  return { update: y, dispose: t };
}
const Cm = new Mi(), Rm = new _m(), Mm = new Bg(), Im = new Om(), Gh = [], Wh = [], Kh = new Float32Array(16), Xh = new Float32Array(9), $h = new Float32Array(4);
function Fa(v, e, n) {
  const i = v[0];
  if (i <= 0 || i > 0) return v;
  const s = e * n;
  let y = Gh[s];
  if (y === void 0 && (y = new Float32Array(s), Gh[s] = y), e !== 0) {
    i.toArray(y, 0);
    for (let t = 1, o = 0; t !== e; ++t) o += n, v[t].toArray(y, o);
  }
  return y;
}
function _i(v, e) {
  if (v.length !== e.length) return false;
  for (let n = 0, i = v.length; n < i; n++) if (v[n] !== e[n]) return false;
  return true;
}
function Ei(v, e) {
  for (let n = 0, i = e.length; n < i; n++) v[n] = e[n];
}
function Tc(v, e) {
  let n = Wh[e];
  n === void 0 && (n = new Int32Array(e), Wh[e] = n);
  for (let i = 0; i !== e; ++i) n[i] = v.allocateTextureUnit();
  return n;
}
function $b(v, e) {
  const n = this.cache;
  n[0] !== e && (v.uniform1f(this.addr, e), n[0] = e);
}
function Yb(v, e) {
  const n = this.cache;
  if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y) && (v.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
  else {
    if (_i(n, e)) return;
    v.uniform2fv(this.addr, e), Ei(n, e);
  }
}
function Qb(v, e) {
  const n = this.cache;
  if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) && (v.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
  else if (e.r !== void 0) (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) && (v.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
  else {
    if (_i(n, e)) return;
    v.uniform3fv(this.addr, e), Ei(n, e);
  }
}
function Zb(v, e) {
  const n = this.cache;
  if (e.x !== void 0) (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) && (v.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
  else {
    if (_i(n, e)) return;
    v.uniform4fv(this.addr, e), Ei(n, e);
  }
}
function Jb(v, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (_i(n, e)) return;
    v.uniformMatrix2fv(this.addr, false, e), Ei(n, e);
  } else {
    if (_i(n, i)) return;
    $h.set(i), v.uniformMatrix2fv(this.addr, false, $h), Ei(n, i);
  }
}
function ew(v, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (_i(n, e)) return;
    v.uniformMatrix3fv(this.addr, false, e), Ei(n, e);
  } else {
    if (_i(n, i)) return;
    Xh.set(i), v.uniformMatrix3fv(this.addr, false, Xh), Ei(n, i);
  }
}
function tw(v, e) {
  const n = this.cache, i = e.elements;
  if (i === void 0) {
    if (_i(n, e)) return;
    v.uniformMatrix4fv(this.addr, false, e), Ei(n, e);
  } else {
    if (_i(n, i)) return;
    Kh.set(i), v.uniformMatrix4fv(this.addr, false, Kh), Ei(n, i);
  }
}
function rw(v, e) {
  const n = this.cache;
  n[0] !== e && (v.uniform1i(this.addr, e), n[0] = e);
}
function nw(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform2iv(this.addr, e), Ei(n, e));
}
function iw(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform3iv(this.addr, e), Ei(n, e));
}
function ow(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform4iv(this.addr, e), Ei(n, e));
}
function aw(v, e) {
  const n = this.cache;
  n[0] !== e && (v.uniform1ui(this.addr, e), n[0] = e);
}
function sw(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform2uiv(this.addr, e), Ei(n, e));
}
function uw(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform3uiv(this.addr, e), Ei(n, e));
}
function cw(v, e) {
  const n = this.cache;
  _i(n, e) || (v.uniform4uiv(this.addr, e), Ei(n, e));
}
function lw(v, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (v.uniform1i(this.addr, s), i[0] = s), n.setTexture2D(e || Cm, s);
}
function fw(v, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (v.uniform1i(this.addr, s), i[0] = s), n.setTexture3D(e || Mm, s);
}
function pw(v, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (v.uniform1i(this.addr, s), i[0] = s), n.setTextureCube(e || Im, s);
}
function hw(v, e, n) {
  const i = this.cache, s = n.allocateTextureUnit();
  i[0] !== s && (v.uniform1i(this.addr, s), i[0] = s), n.setTexture2DArray(e || Rm, s);
}
function dw(v) {
  switch (v) {
    case 5126:
      return $b;
    case 35664:
      return Yb;
    case 35665:
      return Qb;
    case 35666:
      return Zb;
    case 35674:
      return Jb;
    case 35675:
      return ew;
    case 35676:
      return tw;
    case 5124:
    case 35670:
      return rw;
    case 35667:
    case 35671:
      return nw;
    case 35668:
    case 35672:
      return iw;
    case 35669:
    case 35673:
      return ow;
    case 5125:
      return aw;
    case 36294:
      return sw;
    case 36295:
      return uw;
    case 36296:
      return cw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return lw;
    case 35679:
    case 36299:
    case 36307:
      return fw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return pw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return hw;
  }
}
function mw(v, e) {
  v.uniform1fv(this.addr, e);
}
function yw(v, e) {
  const n = Fa(e, this.size, 2);
  v.uniform2fv(this.addr, n);
}
function gw(v, e) {
  const n = Fa(e, this.size, 3);
  v.uniform3fv(this.addr, n);
}
function vw(v, e) {
  const n = Fa(e, this.size, 4);
  v.uniform4fv(this.addr, n);
}
function bw(v, e) {
  const n = Fa(e, this.size, 4);
  v.uniformMatrix2fv(this.addr, false, n);
}
function ww(v, e) {
  const n = Fa(e, this.size, 9);
  v.uniformMatrix3fv(this.addr, false, n);
}
function Sw(v, e) {
  const n = Fa(e, this.size, 16);
  v.uniformMatrix4fv(this.addr, false, n);
}
function _w(v, e) {
  v.uniform1iv(this.addr, e);
}
function Ew(v, e) {
  v.uniform2iv(this.addr, e);
}
function Aw(v, e) {
  v.uniform3iv(this.addr, e);
}
function xw(v, e) {
  v.uniform4iv(this.addr, e);
}
function Tw(v, e) {
  v.uniform1uiv(this.addr, e);
}
function kw(v, e) {
  v.uniform2uiv(this.addr, e);
}
function Ow(v, e) {
  v.uniform3uiv(this.addr, e);
}
function Pw(v, e) {
  v.uniform4uiv(this.addr, e);
}
function Cw(v, e, n) {
  const i = e.length, s = Tc(n, i);
  v.uniform1iv(this.addr, s);
  for (let y = 0; y !== i; ++y) n.setTexture2D(e[y] || Cm, s[y]);
}
function Rw(v, e, n) {
  const i = e.length, s = Tc(n, i);
  v.uniform1iv(this.addr, s);
  for (let y = 0; y !== i; ++y) n.setTexture3D(e[y] || Mm, s[y]);
}
function Mw(v, e, n) {
  const i = e.length, s = Tc(n, i);
  v.uniform1iv(this.addr, s);
  for (let y = 0; y !== i; ++y) n.setTextureCube(e[y] || Im, s[y]);
}
function Iw(v, e, n) {
  const i = e.length, s = Tc(n, i);
  v.uniform1iv(this.addr, s);
  for (let y = 0; y !== i; ++y) n.setTexture2DArray(e[y] || Rm, s[y]);
}
function Lw(v) {
  switch (v) {
    case 5126:
      return mw;
    case 35664:
      return yw;
    case 35665:
      return gw;
    case 35666:
      return vw;
    case 35674:
      return bw;
    case 35675:
      return ww;
    case 35676:
      return Sw;
    case 5124:
    case 35670:
      return _w;
    case 35667:
    case 35671:
      return Ew;
    case 35668:
    case 35672:
      return Aw;
    case 35669:
    case 35673:
      return xw;
    case 5125:
      return Tw;
    case 36294:
      return kw;
    case 36295:
      return Ow;
    case 36296:
      return Pw;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Cw;
    case 35679:
    case 36299:
    case 36307:
      return Rw;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Mw;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Iw;
  }
}
class Bw {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.setValue = dw(n.type);
  }
}
class Nw {
  constructor(e, n, i) {
    this.id = e, this.addr = i, this.cache = [], this.size = n.size, this.setValue = Lw(n.type);
  }
}
class Dw {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, n, i) {
    const s = this.seq;
    for (let y = 0, t = s.length; y !== t; ++y) {
      const o = s[y];
      o.setValue(e, n[o.id], i);
    }
  }
}
const xl = /(\w+)(\])?(\[|\.)?/g;
function Yh(v, e) {
  v.seq.push(e), v.map[e.id] = e;
}
function Fw(v, e, n) {
  const i = v.name, s = i.length;
  for (xl.lastIndex = 0; ; ) {
    const y = xl.exec(i), t = xl.lastIndex;
    let o = y[1];
    const u = y[2] === "]", c = y[3];
    if (u && (o = o | 0), c === void 0 || c === "[" && t + 2 === s) {
      Yh(n, c === void 0 ? new Bw(o, v, e) : new Nw(o, v, e));
      break;
    } else {
      let h = n.map[o];
      h === void 0 && (h = new Dw(o), Yh(n, h)), n = h;
    }
  }
}
class fc {
  constructor(e, n) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(n, 35718);
    for (let s = 0; s < i; ++s) {
      const y = e.getActiveUniform(n, s), t = e.getUniformLocation(n, y.name);
      Fw(y, t, this);
    }
  }
  setValue(e, n, i, s) {
    const y = this.map[n];
    y !== void 0 && y.setValue(e, i, s);
  }
  setOptional(e, n, i) {
    const s = n[i];
    s !== void 0 && this.setValue(e, i, s);
  }
  static upload(e, n, i, s) {
    for (let y = 0, t = n.length; y !== t; ++y) {
      const o = n[y], u = i[o.id];
      u.needsUpdate !== false && o.setValue(e, u.value, s);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let s = 0, y = e.length; s !== y; ++s) {
      const t = e[s];
      t.id in n && i.push(t);
    }
    return i;
  }
}
function Qh(v, e, n) {
  const i = v.createShader(e);
  return v.shaderSource(i, n), v.compileShader(i), i;
}
let Uw = 0;
function jw(v, e) {
  const n = v.split(`
`), i = [], s = Math.max(e - 6, 0), y = Math.min(e + 6, n.length);
  for (let t = s; t < y; t++) {
    const o = t + 1;
    i.push(`${o === e ? ">" : " "} ${o}: ${n[t]}`);
  }
  return i.join(`
`);
}
function Vw(v) {
  switch (v) {
    case 3e3:
      return ["Linear", "( value )"];
    case 3001:
      return ["sRGB", "( value )"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported encoding:", v), ["Linear", "( value )"];
  }
}
function Zh(v, e, n) {
  const i = v.getShaderParameter(e, 35713), s = v.getShaderInfoLog(e).trim();
  if (i && s === "") return "";
  const y = /ERROR: 0:(\d+)/.exec(s);
  if (y) {
    const t = parseInt(y[1]);
    return n.toUpperCase() + `

` + s + `

` + jw(v.getShaderSource(e), t);
  } else return s;
}
function qw(v, e) {
  const n = Vw(e);
  return "vec4 " + v + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }";
}
function zw(v, e) {
  let n;
  switch (e) {
    case 1:
      n = "Linear";
      break;
    case 2:
      n = "Reinhard";
      break;
    case 3:
      n = "OptimizedCineon";
      break;
    case 4:
      n = "ACESFilmic";
      break;
    case 5:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear";
  }
  return "vec3 " + v + "( vec3 color ) { return " + n + "ToneMapping( color ); }";
}
function Hw(v) {
  return [v.extensionDerivatives || v.envMapCubeUVHeight || v.bumpMap || v.tangentSpaceNormalMap || v.clearcoatNormalMap || v.flatShading || v.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (v.extensionFragDepth || v.logarithmicDepthBuffer) && v.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", v.extensionDrawBuffers && v.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (v.extensionShaderTextureLOD || v.envMap || v.transmission) && v.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ls).join(`
`);
}
function Gw(v) {
  const e = [];
  for (const n in v) {
    const i = v[n];
    i !== false && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function Ww(v, e) {
  const n = {}, i = v.getProgramParameter(e, 35721);
  for (let s = 0; s < i; s++) {
    const y = v.getActiveAttrib(e, s), t = y.name;
    let o = 1;
    y.type === 35674 && (o = 2), y.type === 35675 && (o = 3), y.type === 35676 && (o = 4), n[t] = { type: y.type, location: v.getAttribLocation(e, t), locationSize: o };
  }
  return n;
}
function Ls(v) {
  return v !== "";
}
function Jh(v, e) {
  return v.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function ed(v, e) {
  return v.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Kw = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ql(v) {
  return v.replace(Kw, Xw);
}
function Xw(v, e) {
  const n = kn[e];
  if (n === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return ql(n);
}
const $w = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, Yw = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function td(v) {
  return v.replace(Yw, Lm).replace($w, Qw);
}
function Qw(v, e, n, i) {
  return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Lm(v, e, n, i);
}
function Lm(v, e, n, i) {
  let s = "";
  for (let y = parseInt(e); y < parseInt(n); y++) s += i.replace(/\[\s*i\s*\]/g, "[ " + y + " ]").replace(/UNROLLED_LOOP_INDEX/g, y);
  return s;
}
function rd(v) {
  let e = "precision " + v.precision + ` float;
precision ` + v.precision + " int;";
  return v.precision === "highp" ? e += `
#define HIGH_PRECISION` : v.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : v.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function Zw(v) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return v.shadowMapType === 1 ? e = "SHADOWMAP_TYPE_PCF" : v.shadowMapType === 2 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : v.shadowMapType === 3 && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Jw(v) {
  let e = "ENVMAP_TYPE_CUBE";
  if (v.envMap) switch (v.envMapMode) {
    case 301:
    case 302:
      e = "ENVMAP_TYPE_CUBE";
      break;
    case 306:
      e = "ENVMAP_TYPE_CUBE_UV";
      break;
  }
  return e;
}
function e1(v) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (v.envMap) switch (v.envMapMode) {
    case 302:
      e = "ENVMAP_MODE_REFRACTION";
      break;
  }
  return e;
}
function t1(v) {
  let e = "ENVMAP_BLENDING_NONE";
  if (v.envMap) switch (v.combine) {
    case 0:
      e = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case 1:
      e = "ENVMAP_BLENDING_MIX";
      break;
    case 2:
      e = "ENVMAP_BLENDING_ADD";
      break;
  }
  return e;
}
function r1(v) {
  const e = v.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)), texelHeight: i, maxMip: n };
}
function n1(v, e, n, i) {
  const s = v.getContext(), y = n.defines;
  let t = n.vertexShader, o = n.fragmentShader;
  const u = Zw(n), c = Jw(n), h = e1(n), f = t1(n), r = r1(n), m = n.isWebGL2 ? "" : Hw(n), g = Gw(y), a = s.createProgram();
  let l, d, b = n.glslVersion ? "#version " + n.glslVersion + `
` : "";
  n.isRawShaderMaterial ? (l = [g].filter(Ls).join(`
`), l.length > 0 && (l += `
`), d = [m, g].filter(Ls).join(`
`), d.length > 0 && (d += `
`)) : (l = [rd(n), "#define SHADER_NAME " + n.shaderName, g, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && n.flatShading === false ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Ls).join(`
`), d = [m, rd(n), "#define SHADER_NAME " + n.shaderName, g, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + f : "", r ? "#define CUBEUV_TEXEL_WIDTH " + r.texelWidth : "", r ? "#define CUBEUV_TEXEL_HEIGHT " + r.texelHeight : "", r ? "#define CUBEUV_MAX_MIP " + r.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + u : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== 0 ? "#define TONE_MAPPING" : "", n.toneMapping !== 0 ? kn.tonemapping_pars_fragment : "", n.toneMapping !== 0 ? zw("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", kn.encodings_pars_fragment, qw("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", `
`].filter(Ls).join(`
`)), t = ql(t), t = Jh(t, n), t = ed(t, n), o = ql(o), o = Jh(o, n), o = ed(o, n), t = td(t), o = td(o), n.isWebGL2 && n.isRawShaderMaterial !== true && (b = `#version 300 es
`, l = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + l, d = ["#define varying in", n.glslVersion === xh ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === xh ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + d);
  const S = b + l + t, E = b + d + o, R = Qh(s, 35633, S), k = Qh(s, 35632, E);
  if (s.attachShader(a, R), s.attachShader(a, k), n.index0AttributeName !== void 0 ? s.bindAttribLocation(a, 0, n.index0AttributeName) : n.morphTargets === true && s.bindAttribLocation(a, 0, "position"), s.linkProgram(a), v.debug.checkShaderErrors) {
    const I = s.getProgramInfoLog(a).trim(), q = s.getShaderInfoLog(R).trim(), D = s.getShaderInfoLog(k).trim();
    let H = true, _ = true;
    if (s.getProgramParameter(a, 35714) === false) {
      H = false;
      const T = Zh(s, R, "vertex"), L = Zh(s, k, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(a, 35715) + `

Program Info Log: ` + I + `
` + T + `
` + L);
    } else I !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", I) : (q === "" || D === "") && (_ = false);
    _ && (this.diagnostics = { runnable: H, programLog: I, vertexShader: { log: q, prefix: l }, fragmentShader: { log: D, prefix: d } });
  }
  s.deleteShader(R), s.deleteShader(k);
  let w;
  this.getUniforms = function() {
    return w === void 0 && (w = new fc(s, a)), w;
  };
  let F;
  return this.getAttributes = function() {
    return F === void 0 && (F = Ww(s, a)), F;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), s.deleteProgram(a), this.program = void 0;
  }, this.name = n.shaderName, this.id = Uw++, this.cacheKey = e, this.usedTimes = 1, this.program = a, this.vertexShader = R, this.fragmentShader = k, this;
}
let i1 = 0;
class o1 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const n = e.vertexShader, i = e.fragmentShader, s = this._getShaderStage(n), y = this._getShaderStage(i), t = this._getShaderCacheForMaterial(e);
    return t.has(s) === false && (t.add(s), s.usedTimes++), t.has(y) === false && (t.add(y), y.usedTimes++), this;
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    return n.has(e) === false && n.set(e, /* @__PURE__ */ new Set()), n.get(e);
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    if (n.has(e) === false) {
      const i = new a1(e);
      n.set(e, i);
    }
    return n.get(e);
  }
}
class a1 {
  constructor(e) {
    this.id = i1++, this.code = e, this.usedTimes = 0;
  }
}
function s1(v, e, n, i, s, y, t) {
  const o = new Em(), u = new o1(), c = [], h = s.isWebGL2, f = s.logarithmicDepthBuffer, r = s.vertexTextures;
  let m = s.precision;
  const g = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function a(F, I, q, D, H) {
    const _ = D.fog, T = H.geometry, L = F.isMeshStandardMaterial ? D.environment : null, j = (F.isMeshStandardMaterial ? n : e).get(F.envMap || L), z = j && j.mapping === 306 ? j.image.height : null, Y = g[F.type];
    F.precision !== null && (m = s.getMaxPrecision(F.precision), m !== F.precision && console.warn("THREE.WebGLProgram.getParameters:", F.precision, "not supported, using", m, "instead."));
    const te = T.morphAttributes.position || T.morphAttributes.normal || T.morphAttributes.color, G = te !== void 0 ? te.length : 0;
    let K = 0;
    T.morphAttributes.position !== void 0 && (K = 1), T.morphAttributes.normal !== void 0 && (K = 2), T.morphAttributes.color !== void 0 && (K = 3);
    let J, B, Z, ie;
    if (Y) {
      const ae = ro[Y];
      J = ae.vertexShader, B = ae.fragmentShader;
    } else J = F.vertexShader, B = F.fragmentShader, u.update(F), Z = u.getVertexShaderID(F), ie = u.getFragmentShaderID(F);
    const $ = v.getRenderTarget(), oe = F.alphaTest > 0, ce = F.clearcoat > 0, ye = F.iridescence > 0;
    return { isWebGL2: h, shaderID: Y, shaderName: F.type, vertexShader: J, fragmentShader: B, defines: F.defines, customVertexShaderID: Z, customFragmentShaderID: ie, isRawShaderMaterial: F.isRawShaderMaterial === true, glslVersion: F.glslVersion, precision: m, instancing: H.isInstancedMesh === true, instancingColor: H.isInstancedMesh === true && H.instanceColor !== null, supportsVertexTextures: r, outputEncoding: $ === null ? v.outputEncoding : $.isXRRenderTarget === true ? $.texture.encoding : 3e3, map: !!F.map, matcap: !!F.matcap, envMap: !!j, envMapMode: j && j.mapping, envMapCubeUVHeight: z, lightMap: !!F.lightMap, aoMap: !!F.aoMap, emissiveMap: !!F.emissiveMap, bumpMap: !!F.bumpMap, normalMap: !!F.normalMap, objectSpaceNormalMap: F.normalMapType === 1, tangentSpaceNormalMap: F.normalMapType === 0, decodeVideoTexture: !!F.map && F.map.isVideoTexture === true && F.map.encoding === 3001, clearcoat: ce, clearcoatMap: ce && !!F.clearcoatMap, clearcoatRoughnessMap: ce && !!F.clearcoatRoughnessMap, clearcoatNormalMap: ce && !!F.clearcoatNormalMap, iridescence: ye, iridescenceMap: ye && !!F.iridescenceMap, iridescenceThicknessMap: ye && !!F.iridescenceThicknessMap, displacementMap: !!F.displacementMap, roughnessMap: !!F.roughnessMap, metalnessMap: !!F.metalnessMap, specularMap: !!F.specularMap, specularIntensityMap: !!F.specularIntensityMap, specularColorMap: !!F.specularColorMap, opaque: F.transparent === false && F.blending === 1, alphaMap: !!F.alphaMap, alphaTest: oe, gradientMap: !!F.gradientMap, sheen: F.sheen > 0, sheenColorMap: !!F.sheenColorMap, sheenRoughnessMap: !!F.sheenRoughnessMap, transmission: F.transmission > 0, transmissionMap: !!F.transmissionMap, thicknessMap: !!F.thicknessMap, combine: F.combine, vertexTangents: !!F.normalMap && !!T.attributes.tangent, vertexColors: F.vertexColors, vertexAlphas: F.vertexColors === true && !!T.attributes.color && T.attributes.color.itemSize === 4, vertexUvs: !!F.map || !!F.bumpMap || !!F.normalMap || !!F.specularMap || !!F.alphaMap || !!F.emissiveMap || !!F.roughnessMap || !!F.metalnessMap || !!F.clearcoatMap || !!F.clearcoatRoughnessMap || !!F.clearcoatNormalMap || !!F.iridescenceMap || !!F.iridescenceThicknessMap || !!F.displacementMap || !!F.transmissionMap || !!F.thicknessMap || !!F.specularIntensityMap || !!F.specularColorMap || !!F.sheenColorMap || !!F.sheenRoughnessMap, uvsVertexOnly: !(F.map || F.bumpMap || F.normalMap || F.specularMap || F.alphaMap || F.emissiveMap || F.roughnessMap || F.metalnessMap || F.clearcoatNormalMap || F.iridescenceMap || F.iridescenceThicknessMap || F.transmission > 0 || F.transmissionMap || F.thicknessMap || F.specularIntensityMap || F.specularColorMap || F.sheen > 0 || F.sheenColorMap || F.sheenRoughnessMap) && !!F.displacementMap, fog: !!_, useFog: F.fog === true, fogExp2: _ && _.isFogExp2, flatShading: !!F.flatShading, sizeAttenuation: F.sizeAttenuation, logarithmicDepthBuffer: f, skinning: H.isSkinnedMesh === true, morphTargets: T.morphAttributes.position !== void 0, morphNormals: T.morphAttributes.normal !== void 0, morphColors: T.morphAttributes.color !== void 0, morphTargetsCount: G, morphTextureStride: K, numDirLights: I.directional.length, numPointLights: I.point.length, numSpotLights: I.spot.length, numRectAreaLights: I.rectArea.length, numHemiLights: I.hemi.length, numDirLightShadows: I.directionalShadowMap.length, numPointLightShadows: I.pointShadowMap.length, numSpotLightShadows: I.spotShadowMap.length, numClippingPlanes: t.numPlanes, numClipIntersection: t.numIntersection, dithering: F.dithering, shadowMapEnabled: v.shadowMap.enabled && q.length > 0, shadowMapType: v.shadowMap.type, toneMapping: F.toneMapped ? v.toneMapping : 0, physicallyCorrectLights: v.physicallyCorrectLights, premultipliedAlpha: F.premultipliedAlpha, doubleSided: F.side === 2, flipSided: F.side === 1, useDepthPacking: !!F.depthPacking, depthPacking: F.depthPacking || 0, index0AttributeName: F.index0AttributeName, extensionDerivatives: F.extensions && F.extensions.derivatives, extensionFragDepth: F.extensions && F.extensions.fragDepth, extensionDrawBuffers: F.extensions && F.extensions.drawBuffers, extensionShaderTextureLOD: F.extensions && F.extensions.shaderTextureLOD, rendererExtensionFragDepth: h || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"), customProgramCacheKey: F.customProgramCacheKey() };
  }
  function l(F) {
    const I = [];
    if (F.shaderID ? I.push(F.shaderID) : (I.push(F.customVertexShaderID), I.push(F.customFragmentShaderID)), F.defines !== void 0) for (const q in F.defines) I.push(q), I.push(F.defines[q]);
    return F.isRawShaderMaterial === false && (d(I, F), b(I, F), I.push(v.outputEncoding)), I.push(F.customProgramCacheKey), I.join();
  }
  function d(F, I) {
    F.push(I.precision), F.push(I.outputEncoding), F.push(I.envMapMode), F.push(I.envMapCubeUVHeight), F.push(I.combine), F.push(I.vertexUvs), F.push(I.fogExp2), F.push(I.sizeAttenuation), F.push(I.morphTargetsCount), F.push(I.morphAttributeCount), F.push(I.numDirLights), F.push(I.numPointLights), F.push(I.numSpotLights), F.push(I.numHemiLights), F.push(I.numRectAreaLights), F.push(I.numDirLightShadows), F.push(I.numPointLightShadows), F.push(I.numSpotLightShadows), F.push(I.shadowMapType), F.push(I.toneMapping), F.push(I.numClippingPlanes), F.push(I.numClipIntersection), F.push(I.depthPacking);
  }
  function b(F, I) {
    o.disableAll(), I.isWebGL2 && o.enable(0), I.supportsVertexTextures && o.enable(1), I.instancing && o.enable(2), I.instancingColor && o.enable(3), I.map && o.enable(4), I.matcap && o.enable(5), I.envMap && o.enable(6), I.lightMap && o.enable(7), I.aoMap && o.enable(8), I.emissiveMap && o.enable(9), I.bumpMap && o.enable(10), I.normalMap && o.enable(11), I.objectSpaceNormalMap && o.enable(12), I.tangentSpaceNormalMap && o.enable(13), I.clearcoat && o.enable(14), I.clearcoatMap && o.enable(15), I.clearcoatRoughnessMap && o.enable(16), I.clearcoatNormalMap && o.enable(17), I.iridescence && o.enable(18), I.iridescenceMap && o.enable(19), I.iridescenceThicknessMap && o.enable(20), I.displacementMap && o.enable(21), I.specularMap && o.enable(22), I.roughnessMap && o.enable(23), I.metalnessMap && o.enable(24), I.gradientMap && o.enable(25), I.alphaMap && o.enable(26), I.alphaTest && o.enable(27), I.vertexColors && o.enable(28), I.vertexAlphas && o.enable(29), I.vertexUvs && o.enable(30), I.vertexTangents && o.enable(31), I.uvsVertexOnly && o.enable(32), I.fog && o.enable(33), F.push(o.mask), o.disableAll(), I.useFog && o.enable(0), I.flatShading && o.enable(1), I.logarithmicDepthBuffer && o.enable(2), I.skinning && o.enable(3), I.morphTargets && o.enable(4), I.morphNormals && o.enable(5), I.morphColors && o.enable(6), I.premultipliedAlpha && o.enable(7), I.shadowMapEnabled && o.enable(8), I.physicallyCorrectLights && o.enable(9), I.doubleSided && o.enable(10), I.flipSided && o.enable(11), I.useDepthPacking && o.enable(12), I.dithering && o.enable(13), I.specularIntensityMap && o.enable(14), I.specularColorMap && o.enable(15), I.transmission && o.enable(16), I.transmissionMap && o.enable(17), I.thicknessMap && o.enable(18), I.sheen && o.enable(19), I.sheenColorMap && o.enable(20), I.sheenRoughnessMap && o.enable(21), I.decodeVideoTexture && o.enable(22), I.opaque && o.enable(23), F.push(o.mask);
  }
  function S(F) {
    const I = g[F.type];
    let q;
    if (I) {
      const D = ro[I];
      q = Xg.clone(D.uniforms);
    } else q = F.uniforms;
    return q;
  }
  function E(F, I) {
    let q;
    for (let D = 0, H = c.length; D < H; D++) {
      const _ = c[D];
      if (_.cacheKey === I) {
        q = _, ++q.usedTimes;
        break;
      }
    }
    return q === void 0 && (q = new n1(v, I, F, y), c.push(q)), q;
  }
  function R(F) {
    if (--F.usedTimes === 0) {
      const I = c.indexOf(F);
      c[I] = c[c.length - 1], c.pop(), F.destroy();
    }
  }
  function k(F) {
    u.remove(F);
  }
  function w() {
    u.dispose();
  }
  return { getParameters: a, getProgramCacheKey: l, getUniforms: S, acquireProgram: E, releaseProgram: R, releaseShaderCache: k, programs: c, dispose: w };
}
function u1() {
  let v = /* @__PURE__ */ new WeakMap();
  function e(y) {
    let t = v.get(y);
    return t === void 0 && (t = {}, v.set(y, t)), t;
  }
  function n(y) {
    v.delete(y);
  }
  function i(y, t, o) {
    v.get(y)[t] = o;
  }
  function s() {
    v = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, remove: n, update: i, dispose: s };
}
function c1(v, e) {
  return v.groupOrder !== e.groupOrder ? v.groupOrder - e.groupOrder : v.renderOrder !== e.renderOrder ? v.renderOrder - e.renderOrder : v.material.id !== e.material.id ? v.material.id - e.material.id : v.z !== e.z ? v.z - e.z : v.id - e.id;
}
function nd(v, e) {
  return v.groupOrder !== e.groupOrder ? v.groupOrder - e.groupOrder : v.renderOrder !== e.renderOrder ? v.renderOrder - e.renderOrder : v.z !== e.z ? e.z - v.z : v.id - e.id;
}
function id() {
  const v = [];
  let e = 0;
  const n = [], i = [], s = [];
  function y() {
    e = 0, n.length = 0, i.length = 0, s.length = 0;
  }
  function t(f, r, m, g, a, l) {
    let d = v[e];
    return d === void 0 ? (d = { id: f.id, object: f, geometry: r, material: m, groupOrder: g, renderOrder: f.renderOrder, z: a, group: l }, v[e] = d) : (d.id = f.id, d.object = f, d.geometry = r, d.material = m, d.groupOrder = g, d.renderOrder = f.renderOrder, d.z = a, d.group = l), e++, d;
  }
  function o(f, r, m, g, a, l) {
    const d = t(f, r, m, g, a, l);
    m.transmission > 0 ? i.push(d) : m.transparent === true ? s.push(d) : n.push(d);
  }
  function u(f, r, m, g, a, l) {
    const d = t(f, r, m, g, a, l);
    m.transmission > 0 ? i.unshift(d) : m.transparent === true ? s.unshift(d) : n.unshift(d);
  }
  function c(f, r) {
    n.length > 1 && n.sort(f || c1), i.length > 1 && i.sort(r || nd), s.length > 1 && s.sort(r || nd);
  }
  function h() {
    for (let f = e, r = v.length; f < r; f++) {
      const m = v[f];
      if (m.id === null) break;
      m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null;
    }
  }
  return { opaque: n, transmissive: i, transparent: s, init: y, push: o, unshift: u, finish: h, sort: c };
}
function l1() {
  let v = /* @__PURE__ */ new WeakMap();
  function e(i, s) {
    let y;
    return v.has(i) === false ? (y = new id(), v.set(i, [y])) : s >= v.get(i).length ? (y = new id(), v.get(i).push(y)) : y = v.get(i)[s], y;
  }
  function n() {
    v = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, dispose: n };
}
function f1() {
  const v = {};
  return { get: function(e) {
    if (v[e.id] !== void 0) return v[e.id];
    let n;
    switch (e.type) {
      case "DirectionalLight":
        n = { direction: new _r(), color: new Mn() };
        break;
      case "SpotLight":
        n = { position: new _r(), direction: new _r(), color: new Mn(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        n = { position: new _r(), color: new Mn(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        n = { direction: new _r(), skyColor: new Mn(), groundColor: new Mn() };
        break;
      case "RectAreaLight":
        n = { color: new Mn(), position: new _r(), halfWidth: new _r(), halfHeight: new _r() };
        break;
    }
    return v[e.id] = n, n;
  } };
}
function p1() {
  const v = {};
  return { get: function(e) {
    if (v[e.id] !== void 0) return v[e.id];
    let n;
    switch (e.type) {
      case "DirectionalLight":
        n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new In() };
        break;
      case "SpotLight":
        n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new In() };
        break;
      case "PointLight":
        n = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new In(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return v[e.id] = n, n;
  } };
}
let h1 = 0;
function d1(v, e) {
  return (e.castShadow ? 1 : 0) - (v.castShadow ? 1 : 0);
}
function m1(v, e) {
  const n = new f1(), i = p1(), s = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
  for (let h = 0; h < 9; h++) s.probe.push(new _r());
  const y = new _r(), t = new li(), o = new li();
  function u(h, f) {
    let r = 0, m = 0, g = 0;
    for (let I = 0; I < 9; I++) s.probe[I].set(0, 0, 0);
    let a = 0, l = 0, d = 0, b = 0, S = 0, E = 0, R = 0, k = 0;
    h.sort(d1);
    const w = f !== true ? Math.PI : 1;
    for (let I = 0, q = h.length; I < q; I++) {
      const D = h[I], H = D.color, _ = D.intensity, T = D.distance, L = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight) r += H.r * _ * w, m += H.g * _ * w, g += H.b * _ * w;
      else if (D.isLightProbe) for (let j = 0; j < 9; j++) s.probe[j].addScaledVector(D.sh.coefficients[j], _);
      else if (D.isDirectionalLight) {
        const j = n.get(D);
        if (j.color.copy(D.color).multiplyScalar(D.intensity * w), D.castShadow) {
          const z = D.shadow, Y = i.get(D);
          Y.shadowBias = z.bias, Y.shadowNormalBias = z.normalBias, Y.shadowRadius = z.radius, Y.shadowMapSize = z.mapSize, s.directionalShadow[a] = Y, s.directionalShadowMap[a] = L, s.directionalShadowMatrix[a] = D.shadow.matrix, E++;
        }
        s.directional[a] = j, a++;
      } else if (D.isSpotLight) {
        const j = n.get(D);
        if (j.position.setFromMatrixPosition(D.matrixWorld), j.color.copy(H).multiplyScalar(_ * w), j.distance = T, j.coneCos = Math.cos(D.angle), j.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)), j.decay = D.decay, D.castShadow) {
          const z = D.shadow, Y = i.get(D);
          Y.shadowBias = z.bias, Y.shadowNormalBias = z.normalBias, Y.shadowRadius = z.radius, Y.shadowMapSize = z.mapSize, s.spotShadow[d] = Y, s.spotShadowMap[d] = L, s.spotShadowMatrix[d] = D.shadow.matrix, k++;
        }
        s.spot[d] = j, d++;
      } else if (D.isRectAreaLight) {
        const j = n.get(D);
        j.color.copy(H).multiplyScalar(_), j.halfWidth.set(D.width * 0.5, 0, 0), j.halfHeight.set(0, D.height * 0.5, 0), s.rectArea[b] = j, b++;
      } else if (D.isPointLight) {
        const j = n.get(D);
        if (j.color.copy(D.color).multiplyScalar(D.intensity * w), j.distance = D.distance, j.decay = D.decay, D.castShadow) {
          const z = D.shadow, Y = i.get(D);
          Y.shadowBias = z.bias, Y.shadowNormalBias = z.normalBias, Y.shadowRadius = z.radius, Y.shadowMapSize = z.mapSize, Y.shadowCameraNear = z.camera.near, Y.shadowCameraFar = z.camera.far, s.pointShadow[l] = Y, s.pointShadowMap[l] = L, s.pointShadowMatrix[l] = D.shadow.matrix, R++;
        }
        s.point[l] = j, l++;
      } else if (D.isHemisphereLight) {
        const j = n.get(D);
        j.skyColor.copy(D.color).multiplyScalar(_ * w), j.groundColor.copy(D.groundColor).multiplyScalar(_ * w), s.hemi[S] = j, S++;
      }
    }
    b > 0 && (e.isWebGL2 || v.has("OES_texture_float_linear") === true ? (s.rectAreaLTC1 = an.LTC_FLOAT_1, s.rectAreaLTC2 = an.LTC_FLOAT_2) : v.has("OES_texture_half_float_linear") === true ? (s.rectAreaLTC1 = an.LTC_HALF_1, s.rectAreaLTC2 = an.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), s.ambient[0] = r, s.ambient[1] = m, s.ambient[2] = g;
    const F = s.hash;
    (F.directionalLength !== a || F.pointLength !== l || F.spotLength !== d || F.rectAreaLength !== b || F.hemiLength !== S || F.numDirectionalShadows !== E || F.numPointShadows !== R || F.numSpotShadows !== k) && (s.directional.length = a, s.spot.length = d, s.rectArea.length = b, s.point.length = l, s.hemi.length = S, s.directionalShadow.length = E, s.directionalShadowMap.length = E, s.pointShadow.length = R, s.pointShadowMap.length = R, s.spotShadow.length = k, s.spotShadowMap.length = k, s.directionalShadowMatrix.length = E, s.pointShadowMatrix.length = R, s.spotShadowMatrix.length = k, F.directionalLength = a, F.pointLength = l, F.spotLength = d, F.rectAreaLength = b, F.hemiLength = S, F.numDirectionalShadows = E, F.numPointShadows = R, F.numSpotShadows = k, s.version = h1++);
  }
  function c(h, f) {
    let r = 0, m = 0, g = 0, a = 0, l = 0;
    const d = f.matrixWorldInverse;
    for (let b = 0, S = h.length; b < S; b++) {
      const E = h[b];
      if (E.isDirectionalLight) {
        const R = s.directional[r];
        R.direction.setFromMatrixPosition(E.matrixWorld), y.setFromMatrixPosition(E.target.matrixWorld), R.direction.sub(y), R.direction.transformDirection(d), r++;
      } else if (E.isSpotLight) {
        const R = s.spot[g];
        R.position.setFromMatrixPosition(E.matrixWorld), R.position.applyMatrix4(d), R.direction.setFromMatrixPosition(E.matrixWorld), y.setFromMatrixPosition(E.target.matrixWorld), R.direction.sub(y), R.direction.transformDirection(d), g++;
      } else if (E.isRectAreaLight) {
        const R = s.rectArea[a];
        R.position.setFromMatrixPosition(E.matrixWorld), R.position.applyMatrix4(d), o.identity(), t.copy(E.matrixWorld), t.premultiply(d), o.extractRotation(t), R.halfWidth.set(E.width * 0.5, 0, 0), R.halfHeight.set(0, E.height * 0.5, 0), R.halfWidth.applyMatrix4(o), R.halfHeight.applyMatrix4(o), a++;
      } else if (E.isPointLight) {
        const R = s.point[m];
        R.position.setFromMatrixPosition(E.matrixWorld), R.position.applyMatrix4(d), m++;
      } else if (E.isHemisphereLight) {
        const R = s.hemi[l];
        R.direction.setFromMatrixPosition(E.matrixWorld), R.direction.transformDirection(d), l++;
      }
    }
  }
  return { setup: u, setupView: c, state: s };
}
function od(v, e) {
  const n = new m1(v, e), i = [], s = [];
  function y() {
    i.length = 0, s.length = 0;
  }
  function t(h) {
    i.push(h);
  }
  function o(h) {
    s.push(h);
  }
  function u(h) {
    n.setup(i, h);
  }
  function c(h) {
    n.setupView(i, h);
  }
  return { init: y, state: { lightsArray: i, shadowsArray: s, lights: n }, setupLights: u, setupLightsView: c, pushLight: t, pushShadow: o };
}
function y1(v, e) {
  let n = /* @__PURE__ */ new WeakMap();
  function i(y, t = 0) {
    let o;
    return n.has(y) === false ? (o = new od(v, e), n.set(y, [o])) : t >= n.get(y).length ? (o = new od(v, e), n.get(y).push(o)) : o = n.get(y)[t], o;
  }
  function s() {
    n = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: s };
}
class g1 extends ca {
  constructor(e) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class v1 extends ca {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.referencePosition = new _r(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const b1 = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, w1 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function S1(v, e, n) {
  let i = new uf();
  const s = new In(), y = new In(), t = new ci(), o = new g1({ depthPacking: 3201 }), u = new v1(), c = {}, h = n.maxTextureSize, f = { 0: 1, 1: 0, 2: 2 }, r = new aa({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new In() }, radius: { value: 4 } }, vertexShader: b1, fragmentShader: w1 }), m = r.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const g = new ao();
  g.setAttribute("position", new oo(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const a = new io(g, r), l = this;
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = 1, this.render = function(E, R, k) {
    if (l.enabled === false || l.autoUpdate === false && l.needsUpdate === false || E.length === 0) return;
    const w = v.getRenderTarget(), F = v.getActiveCubeFace(), I = v.getActiveMipmapLevel(), q = v.state;
    q.setBlending(0), q.buffers.color.setClear(1, 1, 1, 1), q.buffers.depth.setTest(true), q.setScissorTest(false);
    for (let D = 0, H = E.length; D < H; D++) {
      const _ = E[D], T = _.shadow;
      if (T === void 0) {
        console.warn("THREE.WebGLShadowMap:", _, "has no shadow.");
        continue;
      }
      if (T.autoUpdate === false && T.needsUpdate === false) continue;
      s.copy(T.mapSize);
      const L = T.getFrameExtents();
      if (s.multiply(L), y.copy(T.mapSize), (s.x > h || s.y > h) && (s.x > h && (y.x = Math.floor(h / L.x), s.x = y.x * L.x, T.mapSize.x = y.x), s.y > h && (y.y = Math.floor(h / L.y), s.y = y.y * L.y, T.mapSize.y = y.y)), T.map === null) {
        const z = this.type !== 3 ? { minFilter: 1003, magFilter: 1003 } : {};
        T.map = new oa(s.x, s.y, z), T.map.texture.name = _.name + ".shadowMap", T.camera.updateProjectionMatrix();
      }
      v.setRenderTarget(T.map), v.clear();
      const j = T.getViewportCount();
      for (let z = 0; z < j; z++) {
        const Y = T.getViewport(z);
        t.set(y.x * Y.x, y.y * Y.y, y.x * Y.z, y.y * Y.w), q.viewport(t), T.updateMatrices(_, z), i = T.getFrustum(), S(R, k, T.camera, _, this.type);
      }
      T.isPointLightShadow !== true && this.type === 3 && d(T, k), T.needsUpdate = false;
    }
    l.needsUpdate = false, v.setRenderTarget(w, F, I);
  };
  function d(E, R) {
    const k = e.update(a);
    r.defines.VSM_SAMPLES !== E.blurSamples && (r.defines.VSM_SAMPLES = E.blurSamples, m.defines.VSM_SAMPLES = E.blurSamples, r.needsUpdate = true, m.needsUpdate = true), E.mapPass === null && (E.mapPass = new oa(s.x, s.y)), r.uniforms.shadow_pass.value = E.map.texture, r.uniforms.resolution.value = E.mapSize, r.uniforms.radius.value = E.radius, v.setRenderTarget(E.mapPass), v.clear(), v.renderBufferDirect(R, null, k, r, a, null), m.uniforms.shadow_pass.value = E.mapPass.texture, m.uniforms.resolution.value = E.mapSize, m.uniforms.radius.value = E.radius, v.setRenderTarget(E.map), v.clear(), v.renderBufferDirect(R, null, k, m, a, null);
  }
  function b(E, R, k, w, F, I) {
    let q = null;
    const D = k.isPointLight === true ? E.customDistanceMaterial : E.customDepthMaterial;
    if (D !== void 0 ? q = D : q = k.isPointLight === true ? u : o, v.localClippingEnabled && R.clipShadows === true && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0) {
      const H = q.uuid, _ = R.uuid;
      let T = c[H];
      T === void 0 && (T = {}, c[H] = T);
      let L = T[_];
      L === void 0 && (L = q.clone(), T[_] = L), q = L;
    }
    return q.visible = R.visible, q.wireframe = R.wireframe, I === 3 ? q.side = R.shadowSide !== null ? R.shadowSide : R.side : q.side = R.shadowSide !== null ? R.shadowSide : f[R.side], q.alphaMap = R.alphaMap, q.alphaTest = R.alphaTest, q.clipShadows = R.clipShadows, q.clippingPlanes = R.clippingPlanes, q.clipIntersection = R.clipIntersection, q.displacementMap = R.displacementMap, q.displacementScale = R.displacementScale, q.displacementBias = R.displacementBias, q.wireframeLinewidth = R.wireframeLinewidth, q.linewidth = R.linewidth, k.isPointLight === true && q.isMeshDistanceMaterial === true && (q.referencePosition.setFromMatrixPosition(k.matrixWorld), q.nearDistance = w, q.farDistance = F), q;
  }
  function S(E, R, k, w, F) {
    if (E.visible === false) return;
    if (E.layers.test(R.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && F === 3) && (!E.frustumCulled || i.intersectsObject(E))) {
      E.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, E.matrixWorld);
      const q = e.update(E), D = E.material;
      if (Array.isArray(D)) {
        const H = q.groups;
        for (let _ = 0, T = H.length; _ < T; _++) {
          const L = H[_], j = D[L.materialIndex];
          if (j && j.visible) {
            const z = b(E, j, w, k.near, k.far, F);
            v.renderBufferDirect(k, null, q, z, E, L);
          }
        }
      } else if (D.visible) {
        const H = b(E, D, w, k.near, k.far, F);
        v.renderBufferDirect(k, null, q, H, E, null);
      }
    }
    const I = E.children;
    for (let q = 0, D = I.length; q < D; q++) S(I[q], R, k, w, F);
  }
}
function _1(v, e, n) {
  const i = n.isWebGL2;
  function s() {
    let Ne = false;
    const ut = new ci();
    let Ze = null;
    const Et = new ci(0, 0, 0, 0);
    return { setMask: function(rr) {
      Ze !== rr && !Ne && (v.colorMask(rr, rr, rr, rr), Ze = rr);
    }, setLocked: function(rr) {
      Ne = rr;
    }, setClear: function(rr, je, Ge, at, Ae) {
      Ae === true && (rr *= at, je *= at, Ge *= at), ut.set(rr, je, Ge, at), Et.equals(ut) === false && (v.clearColor(rr, je, Ge, at), Et.copy(ut));
    }, reset: function() {
      Ne = false, Ze = null, Et.set(-1, 0, 0, 0);
    } };
  }
  function y() {
    let Ne = false, ut = null, Ze = null, Et = null;
    return { setTest: function(rr) {
      rr ? oe(2929) : ce(2929);
    }, setMask: function(rr) {
      ut !== rr && !Ne && (v.depthMask(rr), ut = rr);
    }, setFunc: function(rr) {
      if (Ze !== rr) {
        if (rr) switch (rr) {
          case 0:
            v.depthFunc(512);
            break;
          case 1:
            v.depthFunc(519);
            break;
          case 2:
            v.depthFunc(513);
            break;
          case 3:
            v.depthFunc(515);
            break;
          case 4:
            v.depthFunc(514);
            break;
          case 5:
            v.depthFunc(518);
            break;
          case 6:
            v.depthFunc(516);
            break;
          case 7:
            v.depthFunc(517);
            break;
          default:
            v.depthFunc(515);
        }
        else v.depthFunc(515);
        Ze = rr;
      }
    }, setLocked: function(rr) {
      Ne = rr;
    }, setClear: function(rr) {
      Et !== rr && (v.clearDepth(rr), Et = rr);
    }, reset: function() {
      Ne = false, ut = null, Ze = null, Et = null;
    } };
  }
  function t() {
    let Ne = false, ut = null, Ze = null, Et = null, rr = null, je = null, Ge = null, at = null, Ae = null;
    return { setTest: function(qe) {
      Ne || (qe ? oe(2960) : ce(2960));
    }, setMask: function(qe) {
      ut !== qe && !Ne && (v.stencilMask(qe), ut = qe);
    }, setFunc: function(qe, Ft, Dt) {
      (Ze !== qe || Et !== Ft || rr !== Dt) && (v.stencilFunc(qe, Ft, Dt), Ze = qe, Et = Ft, rr = Dt);
    }, setOp: function(qe, Ft, Dt) {
      (je !== qe || Ge !== Ft || at !== Dt) && (v.stencilOp(qe, Ft, Dt), je = qe, Ge = Ft, at = Dt);
    }, setLocked: function(qe) {
      Ne = qe;
    }, setClear: function(qe) {
      Ae !== qe && (v.clearStencil(qe), Ae = qe);
    }, reset: function() {
      Ne = false, ut = null, Ze = null, Et = null, rr = null, je = null, Ge = null, at = null, Ae = null;
    } };
  }
  const o = new s(), u = new y(), c = new t(), h = /* @__PURE__ */ new WeakMap(), f = /* @__PURE__ */ new WeakMap();
  let r = {}, m = {}, g = /* @__PURE__ */ new WeakMap(), a = [], l = null, d = false, b = null, S = null, E = null, R = null, k = null, w = null, F = null, I = false, q = null, D = null, H = null, _ = null, T = null;
  const L = v.getParameter(35661);
  let j = false, z = 0;
  const Y = v.getParameter(7938);
  Y.indexOf("WebGL") !== -1 ? (z = parseFloat(/^WebGL (\d)/.exec(Y)[1]), j = z >= 1) : Y.indexOf("OpenGL ES") !== -1 && (z = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]), j = z >= 2);
  let te = null, G = {};
  const K = v.getParameter(3088), J = v.getParameter(2978), B = new ci().fromArray(K), Z = new ci().fromArray(J);
  function ie(Ne, ut, Ze) {
    const Et = new Uint8Array(4), rr = v.createTexture();
    v.bindTexture(Ne, rr), v.texParameteri(Ne, 10241, 9728), v.texParameteri(Ne, 10240, 9728);
    for (let je = 0; je < Ze; je++) v.texImage2D(ut + je, 0, 6408, 1, 1, 0, 6408, 5121, Et);
    return rr;
  }
  const $ = {};
  $[3553] = ie(3553, 3553, 1), $[34067] = ie(34067, 34069, 6), o.setClear(0, 0, 0, 1), u.setClear(1), c.setClear(0), oe(2929), u.setFunc(3), Oe(false), xe(1), oe(2884), Te(0);
  function oe(Ne) {
    r[Ne] !== true && (v.enable(Ne), r[Ne] = true);
  }
  function ce(Ne) {
    r[Ne] !== false && (v.disable(Ne), r[Ne] = false);
  }
  function ye(Ne, ut) {
    return m[Ne] !== ut ? (v.bindFramebuffer(Ne, ut), m[Ne] = ut, i && (Ne === 36009 && (m[36160] = ut), Ne === 36160 && (m[36009] = ut)), true) : false;
  }
  function ae(Ne, ut) {
    let Ze = a, Et = false;
    if (Ne) if (Ze = g.get(ut), Ze === void 0 && (Ze = [], g.set(ut, Ze)), Ne.isWebGLMultipleRenderTargets) {
      const rr = Ne.texture;
      if (Ze.length !== rr.length || Ze[0] !== 36064) {
        for (let je = 0, Ge = rr.length; je < Ge; je++) Ze[je] = 36064 + je;
        Ze.length = rr.length, Et = true;
      }
    } else Ze[0] !== 36064 && (Ze[0] = 36064, Et = true);
    else Ze[0] !== 1029 && (Ze[0] = 1029, Et = true);
    Et && (n.isWebGL2 ? v.drawBuffers(Ze) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ze));
  }
  function ue(Ne) {
    return l !== Ne ? (v.useProgram(Ne), l = Ne, true) : false;
  }
  const ne = { 100: 32774, 101: 32778, 102: 32779 };
  if (i) ne[103] = 32775, ne[104] = 32776;
  else {
    const Ne = e.get("EXT_blend_minmax");
    Ne !== null && (ne[103] = Ne.MIN_EXT, ne[104] = Ne.MAX_EXT);
  }
  const ge = { 200: 0, 201: 1, 202: 768, 204: 770, 210: 776, 208: 774, 206: 772, 203: 769, 205: 771, 209: 775, 207: 773 };
  function Te(Ne, ut, Ze, Et, rr, je, Ge, at) {
    if (Ne === 0) {
      d === true && (ce(3042), d = false);
      return;
    }
    if (d === false && (oe(3042), d = true), Ne !== 5) {
      if (Ne !== b || at !== I) {
        if ((S !== 100 || k !== 100) && (v.blendEquation(32774), S = 100, k = 100), at) switch (Ne) {
          case 1:
            v.blendFuncSeparate(1, 771, 1, 771);
            break;
          case 2:
            v.blendFunc(1, 1);
            break;
          case 3:
            v.blendFuncSeparate(0, 769, 0, 1);
            break;
          case 4:
            v.blendFuncSeparate(0, 768, 0, 770);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", Ne);
            break;
        }
        else switch (Ne) {
          case 1:
            v.blendFuncSeparate(770, 771, 1, 771);
            break;
          case 2:
            v.blendFunc(770, 1);
            break;
          case 3:
            v.blendFuncSeparate(0, 769, 0, 1);
            break;
          case 4:
            v.blendFunc(0, 768);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", Ne);
            break;
        }
        E = null, R = null, w = null, F = null, b = Ne, I = at;
      }
      return;
    }
    rr = rr || ut, je = je || Ze, Ge = Ge || Et, (ut !== S || rr !== k) && (v.blendEquationSeparate(ne[ut], ne[rr]), S = ut, k = rr), (Ze !== E || Et !== R || je !== w || Ge !== F) && (v.blendFuncSeparate(ge[Ze], ge[Et], ge[je], ge[Ge]), E = Ze, R = Et, w = je, F = Ge), b = Ne, I = null;
  }
  function pe(Ne, ut) {
    Ne.side === 2 ? ce(2884) : oe(2884);
    let Ze = Ne.side === 1;
    ut && (Ze = !Ze), Oe(Ze), Ne.blending === 1 && Ne.transparent === false ? Te(0) : Te(Ne.blending, Ne.blendEquation, Ne.blendSrc, Ne.blendDst, Ne.blendEquationAlpha, Ne.blendSrcAlpha, Ne.blendDstAlpha, Ne.premultipliedAlpha), u.setFunc(Ne.depthFunc), u.setTest(Ne.depthTest), u.setMask(Ne.depthWrite), o.setMask(Ne.colorWrite);
    const Et = Ne.stencilWrite;
    c.setTest(Et), Et && (c.setMask(Ne.stencilWriteMask), c.setFunc(Ne.stencilFunc, Ne.stencilRef, Ne.stencilFuncMask), c.setOp(Ne.stencilFail, Ne.stencilZFail, Ne.stencilZPass)), _e(Ne.polygonOffset, Ne.polygonOffsetFactor, Ne.polygonOffsetUnits), Ne.alphaToCoverage === true ? oe(32926) : ce(32926);
  }
  function Oe(Ne) {
    q !== Ne && (Ne ? v.frontFace(2304) : v.frontFace(2305), q = Ne);
  }
  function xe(Ne) {
    Ne !== 0 ? (oe(2884), Ne !== D && (Ne === 1 ? v.cullFace(1029) : Ne === 2 ? v.cullFace(1028) : v.cullFace(1032))) : ce(2884), D = Ne;
  }
  function Ve(Ne) {
    Ne !== H && (j && v.lineWidth(Ne), H = Ne);
  }
  function _e(Ne, ut, Ze) {
    Ne ? (oe(32823), (_ !== ut || T !== Ze) && (v.polygonOffset(ut, Ze), _ = ut, T = Ze)) : ce(32823);
  }
  function Be(Ne) {
    Ne ? oe(3089) : ce(3089);
  }
  function Qe(Ne) {
    Ne === void 0 && (Ne = 33984 + L - 1), te !== Ne && (v.activeTexture(Ne), te = Ne);
  }
  function ee(Ne, ut) {
    te === null && Qe();
    let Ze = G[te];
    Ze === void 0 && (Ze = { type: void 0, texture: void 0 }, G[te] = Ze), (Ze.type !== Ne || Ze.texture !== ut) && (v.bindTexture(Ne, ut || $[Ne]), Ze.type = Ne, Ze.texture = ut);
  }
  function P() {
    const Ne = G[te];
    Ne !== void 0 && Ne.type !== void 0 && (v.bindTexture(Ne.type, null), Ne.type = void 0, Ne.texture = void 0);
  }
  function x() {
    try {
      v.compressedTexImage2D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function O() {
    try {
      v.texSubImage2D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function V() {
    try {
      v.texSubImage3D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function N() {
    try {
      v.compressedTexSubImage2D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function C() {
    try {
      v.texStorage2D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function p() {
    try {
      v.texStorage3D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function A() {
    try {
      v.texImage2D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function U() {
    try {
      v.texImage3D.apply(v, arguments);
    } catch (Ne) {
      console.error("THREE.WebGLState:", Ne);
    }
  }
  function Q(Ne) {
    B.equals(Ne) === false && (v.scissor(Ne.x, Ne.y, Ne.z, Ne.w), B.copy(Ne));
  }
  function se(Ne) {
    Z.equals(Ne) === false && (v.viewport(Ne.x, Ne.y, Ne.z, Ne.w), Z.copy(Ne));
  }
  function X(Ne, ut) {
    let Ze = f.get(ut);
    Ze === void 0 && (Ze = /* @__PURE__ */ new WeakMap(), f.set(ut, Ze));
    let Et = Ze.get(Ne);
    Et === void 0 && (Et = v.getUniformBlockIndex(ut, Ne.name), Ze.set(Ne, Et));
  }
  function de(Ne, ut) {
    const Ze = f.get(ut).get(Ne);
    h.get(Ne) !== Ze && (v.uniformBlockBinding(ut, Ze, Ne.__bindingPointIndex), h.set(Ne, Ze));
  }
  function tt() {
    v.disable(3042), v.disable(2884), v.disable(2929), v.disable(32823), v.disable(3089), v.disable(2960), v.disable(32926), v.blendEquation(32774), v.blendFunc(1, 0), v.blendFuncSeparate(1, 0, 1, 0), v.colorMask(true, true, true, true), v.clearColor(0, 0, 0, 0), v.depthMask(true), v.depthFunc(513), v.clearDepth(1), v.stencilMask(4294967295), v.stencilFunc(519, 0, 4294967295), v.stencilOp(7680, 7680, 7680), v.clearStencil(0), v.cullFace(1029), v.frontFace(2305), v.polygonOffset(0, 0), v.activeTexture(33984), v.bindFramebuffer(36160, null), i === true && (v.bindFramebuffer(36009, null), v.bindFramebuffer(36008, null)), v.useProgram(null), v.lineWidth(1), v.scissor(0, 0, v.canvas.width, v.canvas.height), v.viewport(0, 0, v.canvas.width, v.canvas.height), r = {}, te = null, G = {}, m = {}, g = /* @__PURE__ */ new WeakMap(), a = [], l = null, d = false, b = null, S = null, E = null, R = null, k = null, w = null, F = null, I = false, q = null, D = null, H = null, _ = null, T = null, B.set(0, 0, v.canvas.width, v.canvas.height), Z.set(0, 0, v.canvas.width, v.canvas.height), o.reset(), u.reset(), c.reset();
  }
  return { buffers: { color: o, depth: u, stencil: c }, enable: oe, disable: ce, bindFramebuffer: ye, drawBuffers: ae, useProgram: ue, setBlending: Te, setMaterial: pe, setFlipSided: Oe, setCullFace: xe, setLineWidth: Ve, setPolygonOffset: _e, setScissorTest: Be, activeTexture: Qe, bindTexture: ee, unbindTexture: P, compressedTexImage2D: x, texImage2D: A, texImage3D: U, updateUBOMapping: X, uniformBlockBinding: de, texStorage2D: C, texStorage3D: p, texSubImage2D: O, texSubImage3D: V, compressedTexSubImage2D: N, scissor: Q, viewport: se, reset: tt };
}
function E1(v, e, n, i, s, y, t) {
  const o = s.isWebGL2, u = s.maxTextures, c = s.maxCubemapSize, h = s.maxTextureSize, f = s.maxSamples, r = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, m = /OculusBrowser/g.test(navigator.userAgent), g = /* @__PURE__ */ new WeakMap();
  let a;
  const l = /* @__PURE__ */ new WeakMap();
  let d = false;
  try {
    d = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function b(ee, P) {
    return d ? new OffscreenCanvas(ee, P) : bc("canvas");
  }
  function S(ee, P, x, O) {
    let V = 1;
    if ((ee.width > O || ee.height > O) && (V = O / Math.max(ee.width, ee.height)), V < 1 || P === true) if (typeof HTMLImageElement < "u" && ee instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ee instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ee instanceof ImageBitmap) {
      const N = P ? Vl : Math.floor, C = N(V * ee.width), p = N(V * ee.height);
      a === void 0 && (a = b(C, p));
      const A = x ? b(C, p) : a;
      return A.width = C, A.height = p, A.getContext("2d").drawImage(ee, 0, 0, C, p), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ee.width + "x" + ee.height + ") to (" + C + "x" + p + ")."), A;
    } else return "data" in ee && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ee.width + "x" + ee.height + ")."), ee;
    return ee;
  }
  function E(ee) {
    return Th(ee.width) && Th(ee.height);
  }
  function R(ee) {
    return o ? false : ee.wrapS !== 1001 || ee.wrapT !== 1001 || ee.minFilter !== 1003 && ee.minFilter !== 1006;
  }
  function k(ee, P) {
    return ee.generateMipmaps && P && ee.minFilter !== 1003 && ee.minFilter !== 1006;
  }
  function w(ee) {
    v.generateMipmap(ee);
  }
  function F(ee, P, x, O, V = false) {
    if (o === false) return P;
    if (ee !== null) {
      if (v[ee] !== void 0) return v[ee];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ee + "'");
    }
    let N = P;
    return P === 6403 && (x === 5126 && (N = 33326), x === 5131 && (N = 33325), x === 5121 && (N = 33321)), P === 33319 && (x === 5126 && (N = 33328), x === 5131 && (N = 33327), x === 5121 && (N = 33323)), P === 6408 && (x === 5126 && (N = 34836), x === 5131 && (N = 34842), x === 5121 && (N = O === 3001 && V === false ? 35907 : 32856), x === 32819 && (N = 32854), x === 32820 && (N = 32855)), (N === 33325 || N === 33326 || N === 33327 || N === 33328 || N === 34842 || N === 34836) && e.get("EXT_color_buffer_float"), N;
  }
  function I(ee, P, x) {
    return k(ee, x) === true || ee.isFramebufferTexture && ee.minFilter !== 1003 && ee.minFilter !== 1006 ? Math.log2(Math.max(P.width, P.height)) + 1 : ee.mipmaps !== void 0 && ee.mipmaps.length > 0 ? ee.mipmaps.length : ee.isCompressedTexture && Array.isArray(ee.image) ? P.mipmaps.length : 1;
  }
  function q(ee) {
    return ee === 1003 || ee === 1004 || ee === 1005 ? 9728 : 9729;
  }
  function D(ee) {
    const P = ee.target;
    P.removeEventListener("dispose", D), _(P), P.isVideoTexture && g.delete(P);
  }
  function H(ee) {
    const P = ee.target;
    P.removeEventListener("dispose", H), L(P);
  }
  function _(ee) {
    const P = i.get(ee);
    if (P.__webglInit === void 0) return;
    const x = ee.source, O = l.get(x);
    if (O) {
      const V = O[P.__cacheKey];
      V.usedTimes--, V.usedTimes === 0 && T(ee), Object.keys(O).length === 0 && l.delete(x);
    }
    i.remove(ee);
  }
  function T(ee) {
    const P = i.get(ee);
    v.deleteTexture(P.__webglTexture);
    const x = ee.source, O = l.get(x);
    delete O[P.__cacheKey], t.memory.textures--;
  }
  function L(ee) {
    const P = ee.texture, x = i.get(ee), O = i.get(P);
    if (O.__webglTexture !== void 0 && (v.deleteTexture(O.__webglTexture), t.memory.textures--), ee.depthTexture && ee.depthTexture.dispose(), ee.isWebGLCubeRenderTarget) for (let V = 0; V < 6; V++) v.deleteFramebuffer(x.__webglFramebuffer[V]), x.__webglDepthbuffer && v.deleteRenderbuffer(x.__webglDepthbuffer[V]);
    else {
      if (v.deleteFramebuffer(x.__webglFramebuffer), x.__webglDepthbuffer && v.deleteRenderbuffer(x.__webglDepthbuffer), x.__webglMultisampledFramebuffer && v.deleteFramebuffer(x.__webglMultisampledFramebuffer), x.__webglColorRenderbuffer) for (let V = 0; V < x.__webglColorRenderbuffer.length; V++) x.__webglColorRenderbuffer[V] && v.deleteRenderbuffer(x.__webglColorRenderbuffer[V]);
      x.__webglDepthRenderbuffer && v.deleteRenderbuffer(x.__webglDepthRenderbuffer);
    }
    if (ee.isWebGLMultipleRenderTargets) for (let V = 0, N = P.length; V < N; V++) {
      const C = i.get(P[V]);
      C.__webglTexture && (v.deleteTexture(C.__webglTexture), t.memory.textures--), i.remove(P[V]);
    }
    i.remove(P), i.remove(ee);
  }
  let j = 0;
  function z() {
    j = 0;
  }
  function Y() {
    const ee = j;
    return ee >= u && console.warn("THREE.WebGLTextures: Trying to use " + ee + " texture units while this GPU supports only " + u), j += 1, ee;
  }
  function te(ee) {
    const P = [];
    return P.push(ee.wrapS), P.push(ee.wrapT), P.push(ee.magFilter), P.push(ee.minFilter), P.push(ee.anisotropy), P.push(ee.internalFormat), P.push(ee.format), P.push(ee.type), P.push(ee.generateMipmaps), P.push(ee.premultiplyAlpha), P.push(ee.flipY), P.push(ee.unpackAlignment), P.push(ee.encoding), P.join();
  }
  function G(ee, P) {
    const x = i.get(ee);
    if (ee.isVideoTexture && Be(ee), ee.isRenderTargetTexture === false && ee.version > 0 && x.__version !== ee.version) {
      const O = ee.image;
      if (O === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (O.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        ce(x, ee, P);
        return;
      }
    }
    n.activeTexture(33984 + P), n.bindTexture(3553, x.__webglTexture);
  }
  function K(ee, P) {
    const x = i.get(ee);
    if (ee.version > 0 && x.__version !== ee.version) {
      ce(x, ee, P);
      return;
    }
    n.activeTexture(33984 + P), n.bindTexture(35866, x.__webglTexture);
  }
  function J(ee, P) {
    const x = i.get(ee);
    if (ee.version > 0 && x.__version !== ee.version) {
      ce(x, ee, P);
      return;
    }
    n.activeTexture(33984 + P), n.bindTexture(32879, x.__webglTexture);
  }
  function B(ee, P) {
    const x = i.get(ee);
    if (ee.version > 0 && x.__version !== ee.version) {
      ye(x, ee, P);
      return;
    }
    n.activeTexture(33984 + P), n.bindTexture(34067, x.__webglTexture);
  }
  const Z = { 1e3: 10497, 1001: 33071, 1002: 33648 }, ie = { 1003: 9728, 1004: 9984, 1005: 9986, 1006: 9729, 1007: 9985, 1008: 9987 };
  function $(ee, P, x) {
    if (x ? (v.texParameteri(ee, 10242, Z[P.wrapS]), v.texParameteri(ee, 10243, Z[P.wrapT]), (ee === 32879 || ee === 35866) && v.texParameteri(ee, 32882, Z[P.wrapR]), v.texParameteri(ee, 10240, ie[P.magFilter]), v.texParameteri(ee, 10241, ie[P.minFilter])) : (v.texParameteri(ee, 10242, 33071), v.texParameteri(ee, 10243, 33071), (ee === 32879 || ee === 35866) && v.texParameteri(ee, 32882, 33071), (P.wrapS !== 1001 || P.wrapT !== 1001) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), v.texParameteri(ee, 10240, q(P.magFilter)), v.texParameteri(ee, 10241, q(P.minFilter)), P.minFilter !== 1003 && P.minFilter !== 1006 && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), e.has("EXT_texture_filter_anisotropic") === true) {
      const O = e.get("EXT_texture_filter_anisotropic");
      if (P.type === 1015 && e.has("OES_texture_float_linear") === false || o === false && P.type === 1016 && e.has("OES_texture_half_float_linear") === false) return;
      (P.anisotropy > 1 || i.get(P).__currentAnisotropy) && (v.texParameterf(ee, O.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(P.anisotropy, s.getMaxAnisotropy())), i.get(P).__currentAnisotropy = P.anisotropy);
    }
  }
  function oe(ee, P) {
    let x = false;
    ee.__webglInit === void 0 && (ee.__webglInit = true, P.addEventListener("dispose", D));
    const O = P.source;
    let V = l.get(O);
    V === void 0 && (V = {}, l.set(O, V));
    const N = te(P);
    if (N !== ee.__cacheKey) {
      V[N] === void 0 && (V[N] = { texture: v.createTexture(), usedTimes: 0 }, t.memory.textures++, x = true), V[N].usedTimes++;
      const C = V[ee.__cacheKey];
      C !== void 0 && (V[ee.__cacheKey].usedTimes--, C.usedTimes === 0 && T(P)), ee.__cacheKey = N, ee.__webglTexture = V[N].texture;
    }
    return x;
  }
  function ce(ee, P, x) {
    let O = 3553;
    P.isDataArrayTexture && (O = 35866), P.isData3DTexture && (O = 32879);
    const V = oe(ee, P), N = P.source;
    if (n.activeTexture(33984 + x), n.bindTexture(O, ee.__webglTexture), N.version !== N.__currentVersion || V === true) {
      v.pixelStorei(37440, P.flipY), v.pixelStorei(37441, P.premultiplyAlpha), v.pixelStorei(3317, P.unpackAlignment), v.pixelStorei(37443, 0);
      const C = R(P) && E(P.image) === false;
      let p = S(P.image, C, false, h);
      p = Qe(P, p);
      const A = E(p) || o, U = y.convert(P.format, P.encoding);
      let Q = y.convert(P.type), se = F(P.internalFormat, U, Q, P.encoding, P.isVideoTexture);
      $(O, P, A);
      let X;
      const de = P.mipmaps, tt = o && P.isVideoTexture !== true, Ne = N.__currentVersion === void 0 || V === true, ut = I(P, p, A);
      if (P.isDepthTexture) se = 6402, o ? P.type === 1015 ? se = 36012 : P.type === 1014 ? se = 33190 : P.type === 1020 ? se = 35056 : se = 33189 : P.type === 1015 && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), P.format === 1026 && se === 6402 && P.type !== 1012 && P.type !== 1014 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), P.type = 1014, Q = y.convert(P.type)), P.format === 1027 && se === 6402 && (se = 34041, P.type !== 1020 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), P.type = 1020, Q = y.convert(P.type))), Ne && (tt ? n.texStorage2D(3553, 1, se, p.width, p.height) : n.texImage2D(3553, 0, se, p.width, p.height, 0, U, Q, null));
      else if (P.isDataTexture) if (de.length > 0 && A) {
        tt && Ne && n.texStorage2D(3553, ut, se, de[0].width, de[0].height);
        for (let Ze = 0, Et = de.length; Ze < Et; Ze++) X = de[Ze], tt ? n.texSubImage2D(3553, Ze, 0, 0, X.width, X.height, U, Q, X.data) : n.texImage2D(3553, Ze, se, X.width, X.height, 0, U, Q, X.data);
        P.generateMipmaps = false;
      } else tt ? (Ne && n.texStorage2D(3553, ut, se, p.width, p.height), n.texSubImage2D(3553, 0, 0, 0, p.width, p.height, U, Q, p.data)) : n.texImage2D(3553, 0, se, p.width, p.height, 0, U, Q, p.data);
      else if (P.isCompressedTexture) {
        tt && Ne && n.texStorage2D(3553, ut, se, de[0].width, de[0].height);
        for (let Ze = 0, Et = de.length; Ze < Et; Ze++) X = de[Ze], P.format !== 1023 ? U !== null ? tt ? n.compressedTexSubImage2D(3553, Ze, 0, 0, X.width, X.height, U, X.data) : n.compressedTexImage2D(3553, Ze, se, X.width, X.height, 0, X.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : tt ? n.texSubImage2D(3553, Ze, 0, 0, X.width, X.height, U, Q, X.data) : n.texImage2D(3553, Ze, se, X.width, X.height, 0, U, Q, X.data);
      } else if (P.isDataArrayTexture) tt ? (Ne && n.texStorage3D(35866, ut, se, p.width, p.height, p.depth), n.texSubImage3D(35866, 0, 0, 0, 0, p.width, p.height, p.depth, U, Q, p.data)) : n.texImage3D(35866, 0, se, p.width, p.height, p.depth, 0, U, Q, p.data);
      else if (P.isData3DTexture) tt ? (Ne && n.texStorage3D(32879, ut, se, p.width, p.height, p.depth), n.texSubImage3D(32879, 0, 0, 0, 0, p.width, p.height, p.depth, U, Q, p.data)) : n.texImage3D(32879, 0, se, p.width, p.height, p.depth, 0, U, Q, p.data);
      else if (P.isFramebufferTexture) {
        if (Ne) if (tt) n.texStorage2D(3553, ut, se, p.width, p.height);
        else {
          let Ze = p.width, Et = p.height;
          for (let rr = 0; rr < ut; rr++) n.texImage2D(3553, rr, se, Ze, Et, 0, U, Q, null), Ze >>= 1, Et >>= 1;
        }
      } else if (de.length > 0 && A) {
        tt && Ne && n.texStorage2D(3553, ut, se, de[0].width, de[0].height);
        for (let Ze = 0, Et = de.length; Ze < Et; Ze++) X = de[Ze], tt ? n.texSubImage2D(3553, Ze, 0, 0, U, Q, X) : n.texImage2D(3553, Ze, se, U, Q, X);
        P.generateMipmaps = false;
      } else tt ? (Ne && n.texStorage2D(3553, ut, se, p.width, p.height), n.texSubImage2D(3553, 0, 0, 0, U, Q, p)) : n.texImage2D(3553, 0, se, U, Q, p);
      k(P, A) && w(O), N.__currentVersion = N.version, P.onUpdate && P.onUpdate(P);
    }
    ee.__version = P.version;
  }
  function ye(ee, P, x) {
    if (P.image.length !== 6) return;
    const O = oe(ee, P), V = P.source;
    if (n.activeTexture(33984 + x), n.bindTexture(34067, ee.__webglTexture), V.version !== V.__currentVersion || O === true) {
      v.pixelStorei(37440, P.flipY), v.pixelStorei(37441, P.premultiplyAlpha), v.pixelStorei(3317, P.unpackAlignment), v.pixelStorei(37443, 0);
      const N = P.isCompressedTexture || P.image[0].isCompressedTexture, C = P.image[0] && P.image[0].isDataTexture, p = [];
      for (let Ze = 0; Ze < 6; Ze++) !N && !C ? p[Ze] = S(P.image[Ze], false, true, c) : p[Ze] = C ? P.image[Ze].image : P.image[Ze], p[Ze] = Qe(P, p[Ze]);
      const A = p[0], U = E(A) || o, Q = y.convert(P.format, P.encoding), se = y.convert(P.type), X = F(P.internalFormat, Q, se, P.encoding), de = o && P.isVideoTexture !== true, tt = V.__currentVersion === void 0 || O === true;
      let Ne = I(P, A, U);
      $(34067, P, U);
      let ut;
      if (N) {
        de && tt && n.texStorage2D(34067, Ne, X, A.width, A.height);
        for (let Ze = 0; Ze < 6; Ze++) {
          ut = p[Ze].mipmaps;
          for (let Et = 0; Et < ut.length; Et++) {
            const rr = ut[Et];
            P.format !== 1023 ? Q !== null ? de ? n.compressedTexSubImage2D(34069 + Ze, Et, 0, 0, rr.width, rr.height, Q, rr.data) : n.compressedTexImage2D(34069 + Ze, Et, X, rr.width, rr.height, 0, rr.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : de ? n.texSubImage2D(34069 + Ze, Et, 0, 0, rr.width, rr.height, Q, se, rr.data) : n.texImage2D(34069 + Ze, Et, X, rr.width, rr.height, 0, Q, se, rr.data);
          }
        }
      } else {
        ut = P.mipmaps, de && tt && (ut.length > 0 && Ne++, n.texStorage2D(34067, Ne, X, p[0].width, p[0].height));
        for (let Ze = 0; Ze < 6; Ze++) if (C) {
          de ? n.texSubImage2D(34069 + Ze, 0, 0, 0, p[Ze].width, p[Ze].height, Q, se, p[Ze].data) : n.texImage2D(34069 + Ze, 0, X, p[Ze].width, p[Ze].height, 0, Q, se, p[Ze].data);
          for (let Et = 0; Et < ut.length; Et++) {
            const rr = ut[Et].image[Ze].image;
            de ? n.texSubImage2D(34069 + Ze, Et + 1, 0, 0, rr.width, rr.height, Q, se, rr.data) : n.texImage2D(34069 + Ze, Et + 1, X, rr.width, rr.height, 0, Q, se, rr.data);
          }
        } else {
          de ? n.texSubImage2D(34069 + Ze, 0, 0, 0, Q, se, p[Ze]) : n.texImage2D(34069 + Ze, 0, X, Q, se, p[Ze]);
          for (let Et = 0; Et < ut.length; Et++) {
            const rr = ut[Et];
            de ? n.texSubImage2D(34069 + Ze, Et + 1, 0, 0, Q, se, rr.image[Ze]) : n.texImage2D(34069 + Ze, Et + 1, X, Q, se, rr.image[Ze]);
          }
        }
      }
      k(P, U) && w(34067), V.__currentVersion = V.version, P.onUpdate && P.onUpdate(P);
    }
    ee.__version = P.version;
  }
  function ae(ee, P, x, O, V) {
    const N = y.convert(x.format, x.encoding), C = y.convert(x.type), p = F(x.internalFormat, N, C, x.encoding);
    i.get(P).__hasExternalTextures || (V === 32879 || V === 35866 ? n.texImage3D(V, 0, p, P.width, P.height, P.depth, 0, N, C, null) : n.texImage2D(V, 0, p, P.width, P.height, 0, N, C, null)), n.bindFramebuffer(36160, ee), _e(P) ? r.framebufferTexture2DMultisampleEXT(36160, O, V, i.get(x).__webglTexture, 0, Ve(P)) : v.framebufferTexture2D(36160, O, V, i.get(x).__webglTexture, 0), n.bindFramebuffer(36160, null);
  }
  function ue(ee, P, x) {
    if (v.bindRenderbuffer(36161, ee), P.depthBuffer && !P.stencilBuffer) {
      let O = 33189;
      if (x || _e(P)) {
        const V = P.depthTexture;
        V && V.isDepthTexture && (V.type === 1015 ? O = 36012 : V.type === 1014 && (O = 33190));
        const N = Ve(P);
        _e(P) ? r.renderbufferStorageMultisampleEXT(36161, N, O, P.width, P.height) : v.renderbufferStorageMultisample(36161, N, O, P.width, P.height);
      } else v.renderbufferStorage(36161, O, P.width, P.height);
      v.framebufferRenderbuffer(36160, 36096, 36161, ee);
    } else if (P.depthBuffer && P.stencilBuffer) {
      const O = Ve(P);
      x && _e(P) === false ? v.renderbufferStorageMultisample(36161, O, 35056, P.width, P.height) : _e(P) ? r.renderbufferStorageMultisampleEXT(36161, O, 35056, P.width, P.height) : v.renderbufferStorage(36161, 34041, P.width, P.height), v.framebufferRenderbuffer(36160, 33306, 36161, ee);
    } else {
      const O = P.isWebGLMultipleRenderTargets === true ? P.texture : [P.texture];
      for (let V = 0; V < O.length; V++) {
        const N = O[V], C = y.convert(N.format, N.encoding), p = y.convert(N.type), A = F(N.internalFormat, C, p, N.encoding), U = Ve(P);
        x && _e(P) === false ? v.renderbufferStorageMultisample(36161, U, A, P.width, P.height) : _e(P) ? r.renderbufferStorageMultisampleEXT(36161, U, A, P.width, P.height) : v.renderbufferStorage(36161, A, P.width, P.height);
      }
    }
    v.bindRenderbuffer(36161, null);
  }
  function ne(ee, P) {
    if (P && P.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (n.bindFramebuffer(36160, ee), !(P.depthTexture && P.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(P.depthTexture).__webglTexture || P.depthTexture.image.width !== P.width || P.depthTexture.image.height !== P.height) && (P.depthTexture.image.width = P.width, P.depthTexture.image.height = P.height, P.depthTexture.needsUpdate = true), G(P.depthTexture, 0);
    const x = i.get(P.depthTexture).__webglTexture, O = Ve(P);
    if (P.depthTexture.format === 1026) _e(P) ? r.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, x, 0, O) : v.framebufferTexture2D(36160, 36096, 3553, x, 0);
    else if (P.depthTexture.format === 1027) _e(P) ? r.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, x, 0, O) : v.framebufferTexture2D(36160, 33306, 3553, x, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function ge(ee) {
    const P = i.get(ee), x = ee.isWebGLCubeRenderTarget === true;
    if (ee.depthTexture && !P.__autoAllocateDepthBuffer) {
      if (x) throw new Error("target.depthTexture not supported in Cube render targets");
      ne(P.__webglFramebuffer, ee);
    } else if (x) {
      P.__webglDepthbuffer = [];
      for (let O = 0; O < 6; O++) n.bindFramebuffer(36160, P.__webglFramebuffer[O]), P.__webglDepthbuffer[O] = v.createRenderbuffer(), ue(P.__webglDepthbuffer[O], ee, false);
    } else n.bindFramebuffer(36160, P.__webglFramebuffer), P.__webglDepthbuffer = v.createRenderbuffer(), ue(P.__webglDepthbuffer, ee, false);
    n.bindFramebuffer(36160, null);
  }
  function Te(ee, P, x) {
    const O = i.get(ee);
    P !== void 0 && ae(O.__webglFramebuffer, ee, ee.texture, 36064, 3553), x !== void 0 && ge(ee);
  }
  function pe(ee) {
    const P = ee.texture, x = i.get(ee), O = i.get(P);
    ee.addEventListener("dispose", H), ee.isWebGLMultipleRenderTargets !== true && (O.__webglTexture === void 0 && (O.__webglTexture = v.createTexture()), O.__version = P.version, t.memory.textures++);
    const V = ee.isWebGLCubeRenderTarget === true, N = ee.isWebGLMultipleRenderTargets === true, C = E(ee) || o;
    if (V) {
      x.__webglFramebuffer = [];
      for (let p = 0; p < 6; p++) x.__webglFramebuffer[p] = v.createFramebuffer();
    } else {
      if (x.__webglFramebuffer = v.createFramebuffer(), N) if (s.drawBuffers) {
        const p = ee.texture;
        for (let A = 0, U = p.length; A < U; A++) {
          const Q = i.get(p[A]);
          Q.__webglTexture === void 0 && (Q.__webglTexture = v.createTexture(), t.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (o && ee.samples > 0 && _e(ee) === false) {
        const p = N ? P : [P];
        x.__webglMultisampledFramebuffer = v.createFramebuffer(), x.__webglColorRenderbuffer = [], n.bindFramebuffer(36160, x.__webglMultisampledFramebuffer);
        for (let A = 0; A < p.length; A++) {
          const U = p[A];
          x.__webglColorRenderbuffer[A] = v.createRenderbuffer(), v.bindRenderbuffer(36161, x.__webglColorRenderbuffer[A]);
          const Q = y.convert(U.format, U.encoding), se = y.convert(U.type), X = F(U.internalFormat, Q, se, U.encoding), de = Ve(ee);
          v.renderbufferStorageMultisample(36161, de, X, ee.width, ee.height), v.framebufferRenderbuffer(36160, 36064 + A, 36161, x.__webglColorRenderbuffer[A]);
        }
        v.bindRenderbuffer(36161, null), ee.depthBuffer && (x.__webglDepthRenderbuffer = v.createRenderbuffer(), ue(x.__webglDepthRenderbuffer, ee, true)), n.bindFramebuffer(36160, null);
      }
    }
    if (V) {
      n.bindTexture(34067, O.__webglTexture), $(34067, P, C);
      for (let p = 0; p < 6; p++) ae(x.__webglFramebuffer[p], ee, P, 36064, 34069 + p);
      k(P, C) && w(34067), n.unbindTexture();
    } else if (N) {
      const p = ee.texture;
      for (let A = 0, U = p.length; A < U; A++) {
        const Q = p[A], se = i.get(Q);
        n.bindTexture(3553, se.__webglTexture), $(3553, Q, C), ae(x.__webglFramebuffer, ee, Q, 36064 + A, 3553), k(Q, C) && w(3553);
      }
      n.unbindTexture();
    } else {
      let p = 3553;
      (ee.isWebGL3DRenderTarget || ee.isWebGLArrayRenderTarget) && (o ? p = ee.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(p, O.__webglTexture), $(p, P, C), ae(x.__webglFramebuffer, ee, P, 36064, p), k(P, C) && w(p), n.unbindTexture();
    }
    ee.depthBuffer && ge(ee);
  }
  function Oe(ee) {
    const P = E(ee) || o, x = ee.isWebGLMultipleRenderTargets === true ? ee.texture : [ee.texture];
    for (let O = 0, V = x.length; O < V; O++) {
      const N = x[O];
      if (k(N, P)) {
        const C = ee.isWebGLCubeRenderTarget ? 34067 : 3553, p = i.get(N).__webglTexture;
        n.bindTexture(C, p), w(C), n.unbindTexture();
      }
    }
  }
  function xe(ee) {
    if (o && ee.samples > 0 && _e(ee) === false) {
      const P = ee.isWebGLMultipleRenderTargets ? ee.texture : [ee.texture], x = ee.width, O = ee.height;
      let V = 16384;
      const N = [], C = ee.stencilBuffer ? 33306 : 36096, p = i.get(ee), A = ee.isWebGLMultipleRenderTargets === true;
      if (A) for (let U = 0; U < P.length; U++) n.bindFramebuffer(36160, p.__webglMultisampledFramebuffer), v.framebufferRenderbuffer(36160, 36064 + U, 36161, null), n.bindFramebuffer(36160, p.__webglFramebuffer), v.framebufferTexture2D(36009, 36064 + U, 3553, null, 0);
      n.bindFramebuffer(36008, p.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, p.__webglFramebuffer);
      for (let U = 0; U < P.length; U++) {
        N.push(36064 + U), ee.depthBuffer && N.push(C);
        const Q = p.__ignoreDepthValues !== void 0 ? p.__ignoreDepthValues : false;
        if (Q === false && (ee.depthBuffer && (V |= 256), ee.stencilBuffer && (V |= 1024)), A && v.framebufferRenderbuffer(36008, 36064, 36161, p.__webglColorRenderbuffer[U]), Q === true && (v.invalidateFramebuffer(36008, [C]), v.invalidateFramebuffer(36009, [C])), A) {
          const se = i.get(P[U]).__webglTexture;
          v.framebufferTexture2D(36009, 36064, 3553, se, 0);
        }
        v.blitFramebuffer(0, 0, x, O, 0, 0, x, O, V, 9728), m && v.invalidateFramebuffer(36008, N);
      }
      if (n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, null), A) for (let U = 0; U < P.length; U++) {
        n.bindFramebuffer(36160, p.__webglMultisampledFramebuffer), v.framebufferRenderbuffer(36160, 36064 + U, 36161, p.__webglColorRenderbuffer[U]);
        const Q = i.get(P[U]).__webglTexture;
        n.bindFramebuffer(36160, p.__webglFramebuffer), v.framebufferTexture2D(36009, 36064 + U, 3553, Q, 0);
      }
      n.bindFramebuffer(36009, p.__webglMultisampledFramebuffer);
    }
  }
  function Ve(ee) {
    return Math.min(f, ee.samples);
  }
  function _e(ee) {
    const P = i.get(ee);
    return o && ee.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && P.__useRenderToTexture !== false;
  }
  function Be(ee) {
    const P = t.render.frame;
    g.get(ee) !== P && (g.set(ee, P), ee.update());
  }
  function Qe(ee, P) {
    const x = ee.encoding, O = ee.format, V = ee.type;
    return ee.isCompressedTexture === true || ee.isVideoTexture === true || ee.format === 1035 || x !== 3e3 && (x === 3001 ? o === false ? e.has("EXT_sRGB") === true && O === 1023 ? (ee.format = 1035, ee.minFilter = 1006, ee.generateMipmaps = false) : P = wm.sRGBToLinear(P) : (O !== 1023 || V !== 1009) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", x)), P;
  }
  this.allocateTextureUnit = Y, this.resetTextureUnits = z, this.setTexture2D = G, this.setTexture2DArray = K, this.setTexture3D = J, this.setTextureCube = B, this.rebindTextures = Te, this.setupRenderTarget = pe, this.updateRenderTargetMipmap = Oe, this.updateMultisampleRenderTarget = xe, this.setupDepthRenderbuffer = ge, this.setupFrameBufferTexture = ae, this.useMultisampledRTT = _e;
}
function A1(v, e, n) {
  const i = n.isWebGL2;
  function s(y, t = null) {
    let o;
    if (y === 1009) return 5121;
    if (y === 1017) return 32819;
    if (y === 1018) return 32820;
    if (y === 1010) return 5120;
    if (y === 1011) return 5122;
    if (y === 1012) return 5123;
    if (y === 1013) return 5124;
    if (y === 1014) return 5125;
    if (y === 1015) return 5126;
    if (y === 1016) return i ? 5131 : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
    if (y === 1021) return 6406;
    if (y === 1023) return 6408;
    if (y === 1024) return 6409;
    if (y === 1025) return 6410;
    if (y === 1026) return 6402;
    if (y === 1027) return 34041;
    if (y === 1028) return 6403;
    if (y === 1022) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
    if (y === 1035) return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (y === 1029) return 36244;
    if (y === 1030) return 33319;
    if (y === 1031) return 33320;
    if (y === 1033) return 36249;
    if (y === 33776 || y === 33777 || y === 33778 || y === 33779) if (t === 3001) if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
      if (y === 33776) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (y === 33777) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (y === 33778) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (y === 33779) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else return null;
    else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
      if (y === 33776) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (y === 33777) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (y === 33778) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (y === 33779) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else return null;
    if (y === 35840 || y === 35841 || y === 35842 || y === 35843) if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
      if (y === 35840) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (y === 35841) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (y === 35842) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (y === 35843) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else return null;
    if (y === 36196) return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (y === 37492 || y === 37496) if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
      if (y === 37492) return t === 3001 ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
      if (y === 37496) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
    } else return null;
    if (y === 37808 || y === 37809 || y === 37810 || y === 37811 || y === 37812 || y === 37813 || y === 37814 || y === 37815 || y === 37816 || y === 37817 || y === 37818 || y === 37819 || y === 37820 || y === 37821) if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
      if (y === 37808) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (y === 37809) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (y === 37810) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (y === 37811) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (y === 37812) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (y === 37813) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (y === 37814) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (y === 37815) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (y === 37816) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (y === 37817) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (y === 37818) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (y === 37819) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (y === 37820) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (y === 37821) return t === 3001 ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else return null;
    if (y === 36492) if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
      if (y === 36492) return t === 3001 ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
    } else return null;
    return y === 1020 ? i ? 34042 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : v[y] !== void 0 ? v[y] : null;
  }
  return { convert: s };
}
class x1 extends Ri {
  constructor(e = []) {
    super(), this.isArrayCamera = true, this.cameras = e;
  }
}
class Ku extends Si {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
}
const T1 = { type: "move" };
class Tl {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ku(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ku(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new _r(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new _r()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ku(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new _r(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new _r()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(e, n, i) {
    let s = null, y = null, t = null;
    const o = this._targetRay, u = this._grip, c = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        t = true;
        for (const a of e.hand.values()) {
          const l = n.getJointPose(a, i);
          if (c.joints[a.jointName] === void 0) {
            const b = new Ku();
            b.matrixAutoUpdate = false, b.visible = false, c.joints[a.jointName] = b, c.add(b);
          }
          const d = c.joints[a.jointName];
          l !== null && (d.matrix.fromArray(l.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.jointRadius = l.radius), d.visible = l !== null;
        }
        const h = c.joints["index-finger-tip"], f = c.joints["thumb-tip"], r = h.position.distanceTo(f.position), m = 0.02, g = 5e-3;
        c.inputState.pinching && r > m + g ? (c.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !c.inputState.pinching && r <= m - g && (c.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else u !== null && e.gripSpace && (y = n.getPose(e.gripSpace, i), y !== null && (u.matrix.fromArray(y.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), y.linearVelocity ? (u.hasLinearVelocity = true, u.linearVelocity.copy(y.linearVelocity)) : u.hasLinearVelocity = false, y.angularVelocity ? (u.hasAngularVelocity = true, u.angularVelocity.copy(y.angularVelocity)) : u.hasAngularVelocity = false));
      o !== null && (s = n.getPose(e.targetRaySpace, i), s === null && y !== null && (s = y), s !== null && (o.matrix.fromArray(s.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), s.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(s.linearVelocity)) : o.hasLinearVelocity = false, s.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(s.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(T1)));
    }
    return o !== null && (o.visible = s !== null), u !== null && (u.visible = y !== null), c !== null && (c.visible = t !== null), this;
  }
}
class k1 extends Mi {
  constructor(e, n, i, s, y, t, o, u, c, h) {
    if (h = h !== void 0 ? h : 1026, h !== 1026 && h !== 1027) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === 1026 && (i = 1014), i === void 0 && h === 1027 && (i = 1020), super(null, s, y, t, o, u, h, i, c), this.isDepthTexture = true, this.image = { width: e, height: n }, this.magFilter = o !== void 0 ? o : 1003, this.minFilter = u !== void 0 ? u : 1003, this.flipY = false, this.generateMipmaps = false;
  }
}
class O1 extends Da {
  constructor(e, n) {
    super();
    const i = this;
    let s = null, y = 1, t = null, o = "local-floor", u = null, c = null, h = null, f = null, r = null, m = null;
    const g = n.getContextAttributes();
    let a = null, l = null;
    const d = [], b = [], S = new Ri();
    S.layers.enable(1), S.viewport = new ci();
    const E = new Ri();
    E.layers.enable(2), E.viewport = new ci();
    const R = [S, E], k = new x1();
    k.layers.enable(1), k.layers.enable(2);
    let w = null, F = null;
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(te) {
      let G = d[te];
      return G === void 0 && (G = new Tl(), d[te] = G), G.getTargetRaySpace();
    }, this.getControllerGrip = function(te) {
      let G = d[te];
      return G === void 0 && (G = new Tl(), d[te] = G), G.getGripSpace();
    }, this.getHand = function(te) {
      let G = d[te];
      return G === void 0 && (G = new Tl(), d[te] = G), G.getHandSpace();
    };
    function I(te) {
      const G = b.indexOf(te.inputSource);
      if (G === -1) return;
      const K = d[G];
      K !== void 0 && K.dispatchEvent({ type: te.type, data: te.inputSource });
    }
    function q() {
      s.removeEventListener("select", I), s.removeEventListener("selectstart", I), s.removeEventListener("selectend", I), s.removeEventListener("squeeze", I), s.removeEventListener("squeezestart", I), s.removeEventListener("squeezeend", I), s.removeEventListener("end", q), s.removeEventListener("inputsourceschange", D);
      for (let te = 0; te < d.length; te++) {
        const G = b[te];
        G !== null && (b[te] = null, d[te].disconnect(G));
      }
      w = null, F = null, e.setRenderTarget(a), r = null, f = null, h = null, s = null, l = null, Y.stop(), i.isPresenting = false, i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(te) {
      y = te, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(te) {
      o = te, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || t;
    }, this.setReferenceSpace = function(te) {
      u = te;
    }, this.getBaseLayer = function() {
      return f !== null ? f : r;
    }, this.getBinding = function() {
      return h;
    }, this.getFrame = function() {
      return m;
    }, this.getSession = function() {
      return s;
    }, this.setSession = async function(te) {
      if (s = te, s !== null) {
        if (a = e.getRenderTarget(), s.addEventListener("select", I), s.addEventListener("selectstart", I), s.addEventListener("selectend", I), s.addEventListener("squeeze", I), s.addEventListener("squeezestart", I), s.addEventListener("squeezeend", I), s.addEventListener("end", q), s.addEventListener("inputsourceschange", D), g.xrCompatible !== true && await n.makeXRCompatible(), s.renderState.layers === void 0 || e.capabilities.isWebGL2 === false) {
          const G = { antialias: s.renderState.layers === void 0 ? g.antialias : true, alpha: g.alpha, depth: g.depth, stencil: g.stencil, framebufferScaleFactor: y };
          r = new XRWebGLLayer(s, n, G), s.updateRenderState({ baseLayer: r }), l = new oa(r.framebufferWidth, r.framebufferHeight, { format: 1023, type: 1009, encoding: e.outputEncoding });
        } else {
          let G = null, K = null, J = null;
          g.depth && (J = g.stencil ? 35056 : 33190, G = g.stencil ? 1027 : 1026, K = g.stencil ? 1020 : 1014);
          const B = { colorFormat: 32856, depthFormat: J, scaleFactor: y };
          h = new XRWebGLBinding(s, n), f = h.createProjectionLayer(B), s.updateRenderState({ layers: [f] }), l = new oa(f.textureWidth, f.textureHeight, { format: 1023, type: 1009, depthTexture: new k1(f.textureWidth, f.textureHeight, K, void 0, void 0, void 0, void 0, void 0, void 0, G), stencilBuffer: g.stencil, encoding: e.outputEncoding, samples: g.antialias ? 4 : 0 });
          const Z = e.properties.get(l);
          Z.__ignoreDepthValues = f.ignoreDepthValues;
        }
        l.isXRRenderTarget = true, this.setFoveation(1), u = null, t = await s.requestReferenceSpace(o), Y.setContext(s), Y.start(), i.isPresenting = true, i.dispatchEvent({ type: "sessionstart" });
      }
    };
    function D(te) {
      for (let G = 0; G < te.removed.length; G++) {
        const K = te.removed[G], J = b.indexOf(K);
        J >= 0 && (b[J] = null, d[J].dispatchEvent({ type: "disconnected", data: K }));
      }
      for (let G = 0; G < te.added.length; G++) {
        const K = te.added[G];
        let J = b.indexOf(K);
        if (J === -1) {
          for (let Z = 0; Z < d.length; Z++) if (Z >= b.length) {
            b.push(K), J = Z;
            break;
          } else if (b[Z] === null) {
            b[Z] = K, J = Z;
            break;
          }
          if (J === -1) break;
        }
        const B = d[J];
        B && B.dispatchEvent({ type: "connected", data: K });
      }
    }
    const H = new _r(), _ = new _r();
    function T(te, G, K) {
      H.setFromMatrixPosition(G.matrixWorld), _.setFromMatrixPosition(K.matrixWorld);
      const J = H.distanceTo(_), B = G.projectionMatrix.elements, Z = K.projectionMatrix.elements, ie = B[14] / (B[10] - 1), $ = B[14] / (B[10] + 1), oe = (B[9] + 1) / B[5], ce = (B[9] - 1) / B[5], ye = (B[8] - 1) / B[0], ae = (Z[8] + 1) / Z[0], ue = ie * ye, ne = ie * ae, ge = J / (-ye + ae), Te = ge * -ye;
      G.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX(Te), te.translateZ(ge), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert();
      const pe = ie + ge, Oe = $ + ge, xe = ue - Te, Ve = ne + (J - Te), _e = oe * $ / Oe * pe, Be = ce * $ / Oe * pe;
      te.projectionMatrix.makePerspective(xe, Ve, _e, Be, pe, Oe);
    }
    function L(te, G) {
      G === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(G.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function(te) {
      if (s === null) return;
      k.near = E.near = S.near = te.near, k.far = E.far = S.far = te.far, (w !== k.near || F !== k.far) && (s.updateRenderState({ depthNear: k.near, depthFar: k.far }), w = k.near, F = k.far);
      const G = te.parent, K = k.cameras;
      L(k, G);
      for (let B = 0; B < K.length; B++) L(K[B], G);
      k.matrixWorld.decompose(k.position, k.quaternion, k.scale), te.position.copy(k.position), te.quaternion.copy(k.quaternion), te.scale.copy(k.scale), te.matrix.copy(k.matrix), te.matrixWorld.copy(k.matrixWorld);
      const J = te.children;
      for (let B = 0, Z = J.length; B < Z; B++) J[B].updateMatrixWorld(true);
      K.length === 2 ? T(k, S, E) : k.projectionMatrix.copy(S.projectionMatrix);
    }, this.getCamera = function() {
      return k;
    }, this.getFoveation = function() {
      if (f !== null) return f.fixedFoveation;
      if (r !== null) return r.fixedFoveation;
    }, this.setFoveation = function(te) {
      f !== null && (f.fixedFoveation = te), r !== null && r.fixedFoveation !== void 0 && (r.fixedFoveation = te);
    };
    let j = null;
    function z(te, G) {
      if (c = G.getViewerPose(u || t), m = G, c !== null) {
        const K = c.views;
        r !== null && (e.setRenderTargetFramebuffer(l, r.framebuffer), e.setRenderTarget(l));
        let J = false;
        K.length !== k.cameras.length && (k.cameras.length = 0, J = true);
        for (let B = 0; B < K.length; B++) {
          const Z = K[B];
          let ie = null;
          if (r !== null) ie = r.getViewport(Z);
          else {
            const oe = h.getViewSubImage(f, Z);
            ie = oe.viewport, B === 0 && (e.setRenderTargetTextures(l, oe.colorTexture, f.ignoreDepthValues ? void 0 : oe.depthStencilTexture), e.setRenderTarget(l));
          }
          let $ = R[B];
          $ === void 0 && ($ = new Ri(), $.layers.enable(B), $.viewport = new ci(), R[B] = $), $.matrix.fromArray(Z.transform.matrix), $.projectionMatrix.fromArray(Z.projectionMatrix), $.viewport.set(ie.x, ie.y, ie.width, ie.height), B === 0 && k.matrix.copy($.matrix), J === true && k.cameras.push($);
        }
      }
      for (let K = 0; K < d.length; K++) {
        const J = b[K], B = d[K];
        J !== null && B !== void 0 && B.update(J, G, u || t);
      }
      j && j(te, G), m = null;
    }
    const Y = new Pm();
    Y.setAnimationLoop(z), this.setAnimationLoop = function(te) {
      j = te;
    }, this.dispose = function() {
    };
  }
}
function P1(v, e) {
  function n(a, l) {
    a.fogColor.value.copy(l.color), l.isFog ? (a.fogNear.value = l.near, a.fogFar.value = l.far) : l.isFogExp2 && (a.fogDensity.value = l.density);
  }
  function i(a, l, d, b, S) {
    l.isMeshBasicMaterial || l.isMeshLambertMaterial ? s(a, l) : l.isMeshToonMaterial ? (s(a, l), h(a, l)) : l.isMeshPhongMaterial ? (s(a, l), c(a, l)) : l.isMeshStandardMaterial ? (s(a, l), f(a, l), l.isMeshPhysicalMaterial && r(a, l, S)) : l.isMeshMatcapMaterial ? (s(a, l), m(a, l)) : l.isMeshDepthMaterial ? s(a, l) : l.isMeshDistanceMaterial ? (s(a, l), g(a, l)) : l.isMeshNormalMaterial ? s(a, l) : l.isLineBasicMaterial ? (y(a, l), l.isLineDashedMaterial && t(a, l)) : l.isPointsMaterial ? o(a, l, d, b) : l.isSpriteMaterial ? u(a, l) : l.isShadowMaterial ? (a.color.value.copy(l.color), a.opacity.value = l.opacity) : l.isShaderMaterial && (l.uniformsNeedUpdate = false);
  }
  function s(a, l) {
    a.opacity.value = l.opacity, l.color && a.diffuse.value.copy(l.color), l.emissive && a.emissive.value.copy(l.emissive).multiplyScalar(l.emissiveIntensity), l.map && (a.map.value = l.map), l.alphaMap && (a.alphaMap.value = l.alphaMap), l.bumpMap && (a.bumpMap.value = l.bumpMap, a.bumpScale.value = l.bumpScale, l.side === 1 && (a.bumpScale.value *= -1)), l.displacementMap && (a.displacementMap.value = l.displacementMap, a.displacementScale.value = l.displacementScale, a.displacementBias.value = l.displacementBias), l.emissiveMap && (a.emissiveMap.value = l.emissiveMap), l.normalMap && (a.normalMap.value = l.normalMap, a.normalScale.value.copy(l.normalScale), l.side === 1 && a.normalScale.value.negate()), l.specularMap && (a.specularMap.value = l.specularMap), l.alphaTest > 0 && (a.alphaTest.value = l.alphaTest);
    const d = e.get(l).envMap;
    if (d && (a.envMap.value = d, a.flipEnvMap.value = d.isCubeTexture && d.isRenderTargetTexture === false ? -1 : 1, a.reflectivity.value = l.reflectivity, a.ior.value = l.ior, a.refractionRatio.value = l.refractionRatio), l.lightMap) {
      a.lightMap.value = l.lightMap;
      const E = v.physicallyCorrectLights !== true ? Math.PI : 1;
      a.lightMapIntensity.value = l.lightMapIntensity * E;
    }
    l.aoMap && (a.aoMap.value = l.aoMap, a.aoMapIntensity.value = l.aoMapIntensity);
    let b;
    l.map ? b = l.map : l.specularMap ? b = l.specularMap : l.displacementMap ? b = l.displacementMap : l.normalMap ? b = l.normalMap : l.bumpMap ? b = l.bumpMap : l.roughnessMap ? b = l.roughnessMap : l.metalnessMap ? b = l.metalnessMap : l.alphaMap ? b = l.alphaMap : l.emissiveMap ? b = l.emissiveMap : l.clearcoatMap ? b = l.clearcoatMap : l.clearcoatNormalMap ? b = l.clearcoatNormalMap : l.clearcoatRoughnessMap ? b = l.clearcoatRoughnessMap : l.iridescenceMap ? b = l.iridescenceMap : l.iridescenceThicknessMap ? b = l.iridescenceThicknessMap : l.specularIntensityMap ? b = l.specularIntensityMap : l.specularColorMap ? b = l.specularColorMap : l.transmissionMap ? b = l.transmissionMap : l.thicknessMap ? b = l.thicknessMap : l.sheenColorMap ? b = l.sheenColorMap : l.sheenRoughnessMap && (b = l.sheenRoughnessMap), b !== void 0 && (b.isWebGLRenderTarget && (b = b.texture), b.matrixAutoUpdate === true && b.updateMatrix(), a.uvTransform.value.copy(b.matrix));
    let S;
    l.aoMap ? S = l.aoMap : l.lightMap && (S = l.lightMap), S !== void 0 && (S.isWebGLRenderTarget && (S = S.texture), S.matrixAutoUpdate === true && S.updateMatrix(), a.uv2Transform.value.copy(S.matrix));
  }
  function y(a, l) {
    a.diffuse.value.copy(l.color), a.opacity.value = l.opacity;
  }
  function t(a, l) {
    a.dashSize.value = l.dashSize, a.totalSize.value = l.dashSize + l.gapSize, a.scale.value = l.scale;
  }
  function o(a, l, d, b) {
    a.diffuse.value.copy(l.color), a.opacity.value = l.opacity, a.size.value = l.size * d, a.scale.value = b * 0.5, l.map && (a.map.value = l.map), l.alphaMap && (a.alphaMap.value = l.alphaMap), l.alphaTest > 0 && (a.alphaTest.value = l.alphaTest);
    let S;
    l.map ? S = l.map : l.alphaMap && (S = l.alphaMap), S !== void 0 && (S.matrixAutoUpdate === true && S.updateMatrix(), a.uvTransform.value.copy(S.matrix));
  }
  function u(a, l) {
    a.diffuse.value.copy(l.color), a.opacity.value = l.opacity, a.rotation.value = l.rotation, l.map && (a.map.value = l.map), l.alphaMap && (a.alphaMap.value = l.alphaMap), l.alphaTest > 0 && (a.alphaTest.value = l.alphaTest);
    let d;
    l.map ? d = l.map : l.alphaMap && (d = l.alphaMap), d !== void 0 && (d.matrixAutoUpdate === true && d.updateMatrix(), a.uvTransform.value.copy(d.matrix));
  }
  function c(a, l) {
    a.specular.value.copy(l.specular), a.shininess.value = Math.max(l.shininess, 1e-4);
  }
  function h(a, l) {
    l.gradientMap && (a.gradientMap.value = l.gradientMap);
  }
  function f(a, l) {
    a.roughness.value = l.roughness, a.metalness.value = l.metalness, l.roughnessMap && (a.roughnessMap.value = l.roughnessMap), l.metalnessMap && (a.metalnessMap.value = l.metalnessMap), e.get(l).envMap && (a.envMapIntensity.value = l.envMapIntensity);
  }
  function r(a, l, d) {
    a.ior.value = l.ior, l.sheen > 0 && (a.sheenColor.value.copy(l.sheenColor).multiplyScalar(l.sheen), a.sheenRoughness.value = l.sheenRoughness, l.sheenColorMap && (a.sheenColorMap.value = l.sheenColorMap), l.sheenRoughnessMap && (a.sheenRoughnessMap.value = l.sheenRoughnessMap)), l.clearcoat > 0 && (a.clearcoat.value = l.clearcoat, a.clearcoatRoughness.value = l.clearcoatRoughness, l.clearcoatMap && (a.clearcoatMap.value = l.clearcoatMap), l.clearcoatRoughnessMap && (a.clearcoatRoughnessMap.value = l.clearcoatRoughnessMap), l.clearcoatNormalMap && (a.clearcoatNormalScale.value.copy(l.clearcoatNormalScale), a.clearcoatNormalMap.value = l.clearcoatNormalMap, l.side === 1 && a.clearcoatNormalScale.value.negate())), l.iridescence > 0 && (a.iridescence.value = l.iridescence, a.iridescenceIOR.value = l.iridescenceIOR, a.iridescenceThicknessMinimum.value = l.iridescenceThicknessRange[0], a.iridescenceThicknessMaximum.value = l.iridescenceThicknessRange[1], l.iridescenceMap && (a.iridescenceMap.value = l.iridescenceMap), l.iridescenceThicknessMap && (a.iridescenceThicknessMap.value = l.iridescenceThicknessMap)), l.transmission > 0 && (a.transmission.value = l.transmission, a.transmissionSamplerMap.value = d.texture, a.transmissionSamplerSize.value.set(d.width, d.height), l.transmissionMap && (a.transmissionMap.value = l.transmissionMap), a.thickness.value = l.thickness, l.thicknessMap && (a.thicknessMap.value = l.thicknessMap), a.attenuationDistance.value = l.attenuationDistance, a.attenuationColor.value.copy(l.attenuationColor)), a.specularIntensity.value = l.specularIntensity, a.specularColor.value.copy(l.specularColor), l.specularIntensityMap && (a.specularIntensityMap.value = l.specularIntensityMap), l.specularColorMap && (a.specularColorMap.value = l.specularColorMap);
  }
  function m(a, l) {
    l.matcap && (a.matcap.value = l.matcap);
  }
  function g(a, l) {
    a.referencePosition.value.copy(l.referencePosition), a.nearDistance.value = l.nearDistance, a.farDistance.value = l.farDistance;
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function C1(v, e, n, i) {
  let s = {}, y = {}, t = [];
  const o = n.isWebGL2 ? v.getParameter(35375) : 0;
  function u(b, S) {
    const E = S.program;
    i.uniformBlockBinding(b, E);
  }
  function c(b, S) {
    let E = s[b.id];
    E === void 0 && (g(b), E = h(b), s[b.id] = E, b.addEventListener("dispose", l));
    const R = S.program;
    i.updateUBOMapping(b, R);
    const k = e.render.frame;
    y[b.id] !== k && (r(b), y[b.id] = k);
  }
  function h(b) {
    const S = f();
    b.__bindingPointIndex = S;
    const E = v.createBuffer(), R = b.__size, k = b.usage;
    return v.bindBuffer(35345, E), v.bufferData(35345, R, k), v.bindBuffer(35345, null), v.bindBufferBase(35345, S, E), E;
  }
  function f() {
    for (let b = 0; b < o; b++) if (t.indexOf(b) === -1) return t.push(b), b;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function r(b) {
    const S = s[b.id], E = b.uniforms, R = b.__cache;
    v.bindBuffer(35345, S);
    for (let k = 0, w = E.length; k < w; k++) {
      const F = E[k];
      if (m(F, k, R) === true) {
        const I = F.value, q = F.__offset;
        typeof I == "number" ? (F.__data[0] = I, v.bufferSubData(35345, q, F.__data)) : (F.value.isMatrix3 ? (F.__data[0] = F.value.elements[0], F.__data[1] = F.value.elements[1], F.__data[2] = F.value.elements[2], F.__data[3] = F.value.elements[0], F.__data[4] = F.value.elements[3], F.__data[5] = F.value.elements[4], F.__data[6] = F.value.elements[5], F.__data[7] = F.value.elements[0], F.__data[8] = F.value.elements[6], F.__data[9] = F.value.elements[7], F.__data[10] = F.value.elements[8], F.__data[11] = F.value.elements[0]) : I.toArray(F.__data), v.bufferSubData(35345, q, F.__data));
      }
    }
    v.bindBuffer(35345, null);
  }
  function m(b, S, E) {
    const R = b.value;
    if (E[S] === void 0) return typeof R == "number" ? E[S] = R : E[S] = R.clone(), true;
    if (typeof R == "number") {
      if (E[S] !== R) return E[S] = R, true;
    } else {
      const k = E[S];
      if (k.equals(R) === false) return k.copy(R), true;
    }
    return false;
  }
  function g(b) {
    const S = b.uniforms;
    let E = 0;
    const R = 16;
    let k = 0;
    for (let w = 0, F = S.length; w < F; w++) {
      const I = S[w], q = a(I);
      if (I.__data = new Float32Array(q.storage / Float32Array.BYTES_PER_ELEMENT), I.__offset = E, w > 0) {
        k = E % R;
        const D = R - k;
        k !== 0 && D - q.boundary < 0 && (E += R - k, I.__offset = E);
      }
      E += q.storage;
    }
    return k = E % R, k > 0 && (E += R - k), b.__size = E, b.__cache = {}, this;
  }
  function a(b) {
    const S = b.value, E = { boundary: 0, storage: 0 };
    return typeof S == "number" ? (E.boundary = 4, E.storage = 4) : S.isVector2 ? (E.boundary = 8, E.storage = 8) : S.isVector3 || S.isColor ? (E.boundary = 16, E.storage = 12) : S.isVector4 ? (E.boundary = 16, E.storage = 16) : S.isMatrix3 ? (E.boundary = 48, E.storage = 48) : S.isMatrix4 ? (E.boundary = 64, E.storage = 64) : S.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", S), E;
  }
  function l(b) {
    const S = b.target;
    S.removeEventListener("dispose", l);
    const E = t.indexOf(S.__bindingPointIndex);
    t.splice(E, 1), v.deleteBuffer(s[S.id]), delete s[S.id], delete y[S.id];
  }
  function d() {
    for (const b in s) v.deleteBuffer(s[b]);
    t = [], s = {}, y = {};
  }
  return { bind: u, update: c, dispose: d };
}
function R1() {
  const v = bc("canvas");
  return v.style.display = "block", v;
}
function Bm(v = {}) {
  this.isWebGLRenderer = true;
  const e = v.canvas !== void 0 ? v.canvas : R1(), n = v.context !== void 0 ? v.context : null, i = v.depth !== void 0 ? v.depth : true, s = v.stencil !== void 0 ? v.stencil : true, y = v.antialias !== void 0 ? v.antialias : false, t = v.premultipliedAlpha !== void 0 ? v.premultipliedAlpha : true, o = v.preserveDrawingBuffer !== void 0 ? v.preserveDrawingBuffer : false, u = v.powerPreference !== void 0 ? v.powerPreference : "default", c = v.failIfMajorPerformanceCaveat !== void 0 ? v.failIfMajorPerformanceCaveat : false;
  let h;
  n !== null ? h = n.getContextAttributes().alpha : h = v.alpha !== void 0 ? v.alpha : false;
  let f = null, r = null;
  const m = [], g = [];
  this.domElement = e, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.outputEncoding = 3e3, this.physicallyCorrectLights = false, this.toneMapping = 0, this.toneMappingExposure = 1, Object.defineProperties(this, { gammaFactor: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
  } } });
  const a = this;
  let l = false, d = 0, b = 0, S = null, E = -1, R = null;
  const k = new ci(), w = new ci();
  let F = null, I = e.width, q = e.height, D = 1, H = null, _ = null;
  const T = new ci(0, 0, I, q), L = new ci(0, 0, I, q);
  let j = false;
  const z = new uf();
  let Y = false, te = false, G = null;
  const K = new li(), J = new In(), B = new _r(), Z = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function ie() {
    return S === null ? D : 1;
  }
  let $ = n;
  function oe(le, re) {
    for (let Le = 0; Le < le.length; Le++) {
      const nt = le[Le], ft = e.getContext(nt, re);
      if (ft !== null) return ft;
    }
    return null;
  }
  try {
    const le = { alpha: true, depth: i, stencil: s, antialias: y, premultipliedAlpha: t, preserveDrawingBuffer: o, powerPreference: u, failIfMajorPerformanceCaveat: c };
    if ("setAttribute" in e && e.setAttribute("data-engine", `three.js r${sf}`), e.addEventListener("webglcontextlost", X, false), e.addEventListener("webglcontextrestored", de, false), e.addEventListener("webglcontextcreationerror", tt, false), $ === null) {
      const re = ["webgl2", "webgl", "experimental-webgl"];
      if (a.isWebGL1Renderer === true && re.shift(), $ = oe(re, le), $ === null) throw oe(re) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
    }
    $.getShaderPrecisionFormat === void 0 && ($.getShaderPrecisionFormat = function() {
      return { rangeMin: 1, rangeMax: 1, precision: 1 };
    });
  } catch (le) {
    throw console.error("THREE.WebGLRenderer: " + le.message), le;
  }
  let ce, ye, ae, ue, ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P, x, O, V, N, C, p, A, U;
  function Q() {
    ce = new Vb($), ye = new Lb($, ce, v), ce.init(ye), p = new A1($, ce, ye), ae = new _1($, ce, ye), ue = new Hb(), ne = new u1(), ge = new E1($, ce, ae, ne, ye, p, ue), Te = new Nb(a), pe = new jb(a), Oe = new tv($, ye), A = new Mb($, ce, Oe, ye), xe = new qb($, Oe, ue, A), Ve = new Xb($, xe, Oe, ue), V = new Kb($, ye, ge), P = new Bb(ne), _e = new s1(a, Te, pe, ce, ye, A, P), Be = new P1(a, ne), Qe = new l1(), ee = new y1(ce, ye), O = new Rb(a, Te, ae, Ve, h, t), x = new S1(a, Ve, ye), U = new C1($, ue, ye, ae), N = new Ib($, ce, ue, ye), C = new zb($, ce, ue, ye), ue.programs = _e.programs, a.capabilities = ye, a.extensions = ce, a.properties = ne, a.renderLists = Qe, a.shadowMap = x, a.state = ae, a.info = ue;
  }
  Q();
  const se = new O1(a, $);
  this.xr = se, this.getContext = function() {
    return $;
  }, this.getContextAttributes = function() {
    return $.getContextAttributes();
  }, this.forceContextLoss = function() {
    const le = ce.get("WEBGL_lose_context");
    le && le.loseContext();
  }, this.forceContextRestore = function() {
    const le = ce.get("WEBGL_lose_context");
    le && le.restoreContext();
  }, this.getPixelRatio = function() {
    return D;
  }, this.setPixelRatio = function(le) {
    le !== void 0 && (D = le, this.setSize(I, q, false));
  }, this.getSize = function(le) {
    return le.set(I, q);
  }, this.setSize = function(le, re, Le) {
    if (se.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    I = le, q = re, e.width = Math.floor(le * D), e.height = Math.floor(re * D), Le !== false && (e.style.width = le + "px", e.style.height = re + "px"), this.setViewport(0, 0, le, re);
  }, this.getDrawingBufferSize = function(le) {
    return le.set(I * D, q * D).floor();
  }, this.setDrawingBufferSize = function(le, re, Le) {
    I = le, q = re, D = Le, e.width = Math.floor(le * Le), e.height = Math.floor(re * Le), this.setViewport(0, 0, le, re);
  }, this.getCurrentViewport = function(le) {
    return le.copy(k);
  }, this.getViewport = function(le) {
    return le.copy(T);
  }, this.setViewport = function(le, re, Le, nt) {
    le.isVector4 ? T.set(le.x, le.y, le.z, le.w) : T.set(le, re, Le, nt), ae.viewport(k.copy(T).multiplyScalar(D).floor());
  }, this.getScissor = function(le) {
    return le.copy(L);
  }, this.setScissor = function(le, re, Le, nt) {
    le.isVector4 ? L.set(le.x, le.y, le.z, le.w) : L.set(le, re, Le, nt), ae.scissor(w.copy(L).multiplyScalar(D).floor());
  }, this.getScissorTest = function() {
    return j;
  }, this.setScissorTest = function(le) {
    ae.setScissorTest(j = le);
  }, this.setOpaqueSort = function(le) {
    H = le;
  }, this.setTransparentSort = function(le) {
    _ = le;
  }, this.getClearColor = function(le) {
    return le.copy(O.getClearColor());
  }, this.setClearColor = function() {
    O.setClearColor.apply(O, arguments);
  }, this.getClearAlpha = function() {
    return O.getClearAlpha();
  }, this.setClearAlpha = function() {
    O.setClearAlpha.apply(O, arguments);
  }, this.clear = function(le = true, re = true, Le = true) {
    let nt = 0;
    le && (nt |= 16384), re && (nt |= 256), Le && (nt |= 1024), $.clear(nt);
  }, this.clearColor = function() {
    this.clear(true, false, false);
  }, this.clearDepth = function() {
    this.clear(false, true, false);
  }, this.clearStencil = function() {
    this.clear(false, false, true);
  }, this.dispose = function() {
    e.removeEventListener("webglcontextlost", X, false), e.removeEventListener("webglcontextrestored", de, false), e.removeEventListener("webglcontextcreationerror", tt, false), Qe.dispose(), ee.dispose(), ne.dispose(), Te.dispose(), pe.dispose(), Ve.dispose(), A.dispose(), U.dispose(), _e.dispose(), se.dispose(), se.removeEventListener("sessionstart", je), se.removeEventListener("sessionend", Ge), G && (G.dispose(), G = null), at.stop();
  };
  function X(le) {
    le.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), l = true;
  }
  function de() {
    console.log("THREE.WebGLRenderer: Context Restored."), l = false;
    const le = ue.autoReset, re = x.enabled, Le = x.autoUpdate, nt = x.needsUpdate, ft = x.type;
    Q(), ue.autoReset = le, x.enabled = re, x.autoUpdate = Le, x.needsUpdate = nt, x.type = ft;
  }
  function tt(le) {
    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", le.statusMessage);
  }
  function Ne(le) {
    const re = le.target;
    re.removeEventListener("dispose", Ne), ut(re);
  }
  function ut(le) {
    Ze(le), ne.remove(le);
  }
  function Ze(le) {
    const re = ne.get(le).programs;
    re !== void 0 && (re.forEach(function(Le) {
      _e.releaseProgram(Le);
    }), le.isShaderMaterial && _e.releaseShaderCache(le));
  }
  this.renderBufferDirect = function(le, re, Le, nt, ft, zt) {
    re === null && (re = Z);
    const st = ft.isMesh && ft.matrixWorld.determinant() < 0, ct = Ur(le, re, Le, nt, ft);
    ae.setMaterial(nt, st);
    let yt = Le.index;
    const Zt = Le.attributes.position;
    if (yt === null) {
      if (Zt === void 0 || Zt.count === 0) return;
    } else if (yt.count === 0) return;
    let Ct = 1;
    nt.wireframe === true && (yt = xe.getWireframeAttribute(Le), Ct = 2), A.setup(ft, nt, ct, Le, yt);
    let Lt, Wt = N;
    yt !== null && (Lt = Oe.get(yt), Wt = C, Wt.setIndex(Lt));
    const vr = yt !== null ? yt.count : Zt.count, ar = Le.drawRange.start * Ct, sr = Le.drawRange.count * Ct, gr = zt !== null ? zt.start * Ct : 0, Tr = zt !== null ? zt.count * Ct : 1 / 0, Mr = Math.max(ar, gr), Nr = Math.min(vr, ar + sr, gr + Tr) - 1, Lr = Math.max(0, Nr - Mr + 1);
    if (Lr !== 0) {
      if (ft.isMesh) nt.wireframe === true ? (ae.setLineWidth(nt.wireframeLinewidth * ie()), Wt.setMode(1)) : Wt.setMode(4);
      else if (ft.isLine) {
        let jr = nt.linewidth;
        jr === void 0 && (jr = 1), ae.setLineWidth(jr * ie()), ft.isLineSegments ? Wt.setMode(1) : ft.isLineLoop ? Wt.setMode(2) : Wt.setMode(3);
      } else ft.isPoints ? Wt.setMode(0) : ft.isSprite && Wt.setMode(4);
      if (ft.isInstancedMesh) Wt.renderInstances(Mr, Lr, ft.count);
      else if (Le.isInstancedBufferGeometry) {
        const jr = Math.min(Le.instanceCount, Le._maxInstanceCount);
        Wt.renderInstances(Mr, Lr, jr);
      } else Wt.render(Mr, Lr);
    }
  }, this.compile = function(le, re) {
    r = ee.get(le), r.init(), g.push(r), le.traverseVisible(function(Le) {
      Le.isLight && Le.layers.test(re.layers) && (r.pushLight(Le), Le.castShadow && r.pushShadow(Le));
    }), r.setupLights(a.physicallyCorrectLights), le.traverse(function(Le) {
      const nt = Le.material;
      if (nt) if (Array.isArray(nt)) for (let ft = 0; ft < nt.length; ft++) {
        const zt = nt[ft];
        Nt(zt, le, Le);
      }
      else Nt(nt, le, Le);
    }), g.pop(), r = null;
  };
  let Et = null;
  function rr(le) {
    Et && Et(le);
  }
  function je() {
    at.stop();
  }
  function Ge() {
    at.start();
  }
  const at = new Pm();
  at.setAnimationLoop(rr), typeof self < "u" && at.setContext(self), this.setAnimationLoop = function(le) {
    Et = le, se.setAnimationLoop(le), le === null ? at.stop() : at.start();
  }, se.addEventListener("sessionstart", je), se.addEventListener("sessionend", Ge), this.render = function(le, re) {
    if (re !== void 0 && re.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (l === true) return;
    le.autoUpdate === true && le.updateMatrixWorld(), re.parent === null && re.updateMatrixWorld(), se.enabled === true && se.isPresenting === true && (se.cameraAutoUpdate === true && se.updateCamera(re), re = se.getCamera()), le.isScene === true && le.onBeforeRender(a, le, re, S), r = ee.get(le, g.length), r.init(), g.push(r), K.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse), z.setFromProjectionMatrix(K), te = this.localClippingEnabled, Y = P.init(this.clippingPlanes, te, re), f = Qe.get(le, m.length), f.init(), m.push(f), Ae(le, re, 0, a.sortObjects), f.finish(), a.sortObjects === true && f.sort(H, _), Y === true && P.beginShadows();
    const Le = r.state.shadowsArray;
    if (x.render(Le, le, re), Y === true && P.endShadows(), this.info.autoReset === true && this.info.reset(), O.render(f, le), r.setupLights(a.physicallyCorrectLights), re.isArrayCamera) {
      const nt = re.cameras;
      for (let ft = 0, zt = nt.length; ft < zt; ft++) {
        const st = nt[ft];
        qe(f, le, st, st.viewport);
      }
    } else qe(f, le, re);
    S !== null && (ge.updateMultisampleRenderTarget(S), ge.updateRenderTargetMipmap(S)), le.isScene === true && le.onAfterRender(a, le, re), A.resetDefaultState(), E = -1, R = null, g.pop(), g.length > 0 ? r = g[g.length - 1] : r = null, m.pop(), m.length > 0 ? f = m[m.length - 1] : f = null;
  };
  function Ae(le, re, Le, nt) {
    if (le.visible === false) return;
    if (le.layers.test(re.layers)) {
      if (le.isGroup) Le = le.renderOrder;
      else if (le.isLOD) le.autoUpdate === true && le.update(re);
      else if (le.isLight) r.pushLight(le), le.castShadow && r.pushShadow(le);
      else if (le.isSprite) {
        if (!le.frustumCulled || z.intersectsSprite(le)) {
          nt && B.setFromMatrixPosition(le.matrixWorld).applyMatrix4(K);
          const zt = Ve.update(le), st = le.material;
          st.visible && f.push(le, zt, st, Le, B.z, null);
        }
      } else if ((le.isMesh || le.isLine || le.isPoints) && (le.isSkinnedMesh && le.skeleton.frame !== ue.render.frame && (le.skeleton.update(), le.skeleton.frame = ue.render.frame), !le.frustumCulled || z.intersectsObject(le))) {
        nt && B.setFromMatrixPosition(le.matrixWorld).applyMatrix4(K);
        const zt = Ve.update(le), st = le.material;
        if (Array.isArray(st)) {
          const ct = zt.groups;
          for (let yt = 0, Zt = ct.length; yt < Zt; yt++) {
            const Ct = ct[yt], Lt = st[Ct.materialIndex];
            Lt && Lt.visible && f.push(le, zt, Lt, Le, B.z, Ct);
          }
        } else st.visible && f.push(le, zt, st, Le, B.z, null);
      }
    }
    const ft = le.children;
    for (let zt = 0, st = ft.length; zt < st; zt++) Ae(ft[zt], re, Le, nt);
  }
  function qe(le, re, Le, nt) {
    const ft = le.opaque, zt = le.transmissive, st = le.transparent;
    r.setupLightsView(Le), zt.length > 0 && Ft(ft, re, Le), nt && ae.viewport(k.copy(nt)), ft.length > 0 && Dt(ft, re, Le), zt.length > 0 && Dt(zt, re, Le), st.length > 0 && Dt(st, re, Le), ae.buffers.depth.setTest(true), ae.buffers.depth.setMask(true), ae.buffers.color.setMask(true), ae.setPolygonOffset(false);
  }
  function Ft(le, re, Le) {
    const nt = ye.isWebGL2;
    G === null && (G = new oa(1, 1, { generateMipmaps: true, type: ce.has("EXT_color_buffer_half_float") ? 1016 : 1009, minFilter: 1008, samples: nt && y === true ? 4 : 0 })), a.getDrawingBufferSize(J), nt ? G.setSize(J.x, J.y) : G.setSize(Vl(J.x), Vl(J.y));
    const ft = a.getRenderTarget();
    a.setRenderTarget(G), a.clear();
    const zt = a.toneMapping;
    a.toneMapping = 0, Dt(le, re, Le), a.toneMapping = zt, ge.updateMultisampleRenderTarget(G), ge.updateRenderTargetMipmap(G), a.setRenderTarget(ft);
  }
  function Dt(le, re, Le) {
    const nt = re.isScene === true ? re.overrideMaterial : null;
    for (let ft = 0, zt = le.length; ft < zt; ft++) {
      const st = le[ft], ct = st.object, yt = st.geometry, Zt = nt === null ? st.material : nt, Ct = st.group;
      ct.layers.test(Le.layers) && wr(ct, re, Le, yt, Zt, Ct);
    }
  }
  function wr(le, re, Le, nt, ft, zt) {
    le.onBeforeRender(a, re, Le, nt, ft, zt), le.modelViewMatrix.multiplyMatrices(Le.matrixWorldInverse, le.matrixWorld), le.normalMatrix.getNormalMatrix(le.modelViewMatrix), ft.onBeforeRender(a, re, Le, nt, le, zt), ft.transparent === true && ft.side === 2 ? (ft.side = 1, ft.needsUpdate = true, a.renderBufferDirect(Le, re, nt, ft, le, zt), ft.side = 0, ft.needsUpdate = true, a.renderBufferDirect(Le, re, nt, ft, le, zt), ft.side = 2) : a.renderBufferDirect(Le, re, nt, ft, le, zt), le.onAfterRender(a, re, Le, nt, ft, zt);
  }
  function Nt(le, re, Le) {
    re.isScene !== true && (re = Z);
    const nt = ne.get(le), ft = r.state.lights, zt = r.state.shadowsArray, st = ft.state.version, ct = _e.getParameters(le, ft.state, zt, re, Le), yt = _e.getProgramCacheKey(ct);
    let Zt = nt.programs;
    nt.environment = le.isMeshStandardMaterial ? re.environment : null, nt.fog = re.fog, nt.envMap = (le.isMeshStandardMaterial ? pe : Te).get(le.envMap || nt.environment), Zt === void 0 && (le.addEventListener("dispose", Ne), Zt = /* @__PURE__ */ new Map(), nt.programs = Zt);
    let Ct = Zt.get(yt);
    if (Ct !== void 0) {
      if (nt.currentProgram === Ct && nt.lightsStateVersion === st) return yr(le, ct), Ct;
    } else ct.uniforms = _e.getUniforms(le), le.onBuild(Le, ct, a), le.onBeforeCompile(ct, a), Ct = _e.acquireProgram(ct, yt), Zt.set(yt, Ct), nt.uniforms = ct.uniforms;
    const Lt = nt.uniforms;
    (!le.isShaderMaterial && !le.isRawShaderMaterial || le.clipping === true) && (Lt.clippingPlanes = P.uniform), yr(le, ct), nt.needsLights = $e(le), nt.lightsStateVersion = st, nt.needsLights && (Lt.ambientLightColor.value = ft.state.ambient, Lt.lightProbe.value = ft.state.probe, Lt.directionalLights.value = ft.state.directional, Lt.directionalLightShadows.value = ft.state.directionalShadow, Lt.spotLights.value = ft.state.spot, Lt.spotLightShadows.value = ft.state.spotShadow, Lt.rectAreaLights.value = ft.state.rectArea, Lt.ltc_1.value = ft.state.rectAreaLTC1, Lt.ltc_2.value = ft.state.rectAreaLTC2, Lt.pointLights.value = ft.state.point, Lt.pointLightShadows.value = ft.state.pointShadow, Lt.hemisphereLights.value = ft.state.hemi, Lt.directionalShadowMap.value = ft.state.directionalShadowMap, Lt.directionalShadowMatrix.value = ft.state.directionalShadowMatrix, Lt.spotShadowMap.value = ft.state.spotShadowMap, Lt.spotShadowMatrix.value = ft.state.spotShadowMatrix, Lt.pointShadowMap.value = ft.state.pointShadowMap, Lt.pointShadowMatrix.value = ft.state.pointShadowMatrix);
    const Wt = Ct.getUniforms(), vr = fc.seqWithValue(Wt.seq, Lt);
    return nt.currentProgram = Ct, nt.uniformsList = vr, Ct;
  }
  function yr(le, re) {
    const Le = ne.get(le);
    Le.outputEncoding = re.outputEncoding, Le.instancing = re.instancing, Le.skinning = re.skinning, Le.morphTargets = re.morphTargets, Le.morphNormals = re.morphNormals, Le.morphColors = re.morphColors, Le.morphTargetsCount = re.morphTargetsCount, Le.numClippingPlanes = re.numClippingPlanes, Le.numIntersection = re.numClipIntersection, Le.vertexAlphas = re.vertexAlphas, Le.vertexTangents = re.vertexTangents, Le.toneMapping = re.toneMapping;
  }
  function Ur(le, re, Le, nt, ft) {
    re.isScene !== true && (re = Z), ge.resetTextureUnits();
    const zt = re.fog, st = nt.isMeshStandardMaterial ? re.environment : null, ct = S === null ? a.outputEncoding : S.isXRRenderTarget === true ? S.texture.encoding : 3e3, yt = (nt.isMeshStandardMaterial ? pe : Te).get(nt.envMap || st), Zt = nt.vertexColors === true && !!Le.attributes.color && Le.attributes.color.itemSize === 4, Ct = !!nt.normalMap && !!Le.attributes.tangent, Lt = !!Le.morphAttributes.position, Wt = !!Le.morphAttributes.normal, vr = !!Le.morphAttributes.color, ar = nt.toneMapped ? a.toneMapping : 0, sr = Le.morphAttributes.position || Le.morphAttributes.normal || Le.morphAttributes.color, gr = sr !== void 0 ? sr.length : 0, Tr = ne.get(nt), Mr = r.state.lights;
    if (Y === true && (te === true || le !== R)) {
      const we = le === R && nt.id === E;
      P.setState(nt, le, we);
    }
    let Nr = false;
    nt.version === Tr.__version ? (Tr.needsLights && Tr.lightsStateVersion !== Mr.state.version || Tr.outputEncoding !== ct || ft.isInstancedMesh && Tr.instancing === false || !ft.isInstancedMesh && Tr.instancing === true || ft.isSkinnedMesh && Tr.skinning === false || !ft.isSkinnedMesh && Tr.skinning === true || Tr.envMap !== yt || nt.fog === true && Tr.fog !== zt || Tr.numClippingPlanes !== void 0 && (Tr.numClippingPlanes !== P.numPlanes || Tr.numIntersection !== P.numIntersection) || Tr.vertexAlphas !== Zt || Tr.vertexTangents !== Ct || Tr.morphTargets !== Lt || Tr.morphNormals !== Wt || Tr.morphColors !== vr || Tr.toneMapping !== ar || ye.isWebGL2 === true && Tr.morphTargetsCount !== gr) && (Nr = true) : (Nr = true, Tr.__version = nt.version);
    let Lr = Tr.currentProgram;
    Nr === true && (Lr = Nt(nt, re, ft));
    let jr = false, Hr = false, kr = false;
    const Xt = Lr.getUniforms(), Qt = Tr.uniforms;
    if (ae.useProgram(Lr.program) && (jr = true, Hr = true, kr = true), nt.id !== E && (E = nt.id, Hr = true), jr || R !== le) {
      if (Xt.setValue($, "projectionMatrix", le.projectionMatrix), ye.logarithmicDepthBuffer && Xt.setValue($, "logDepthBufFC", 2 / (Math.log(le.far + 1) / Math.LN2)), R !== le && (R = le, Hr = true, kr = true), nt.isShaderMaterial || nt.isMeshPhongMaterial || nt.isMeshToonMaterial || nt.isMeshStandardMaterial || nt.envMap) {
        const we = Xt.map.cameraPosition;
        we !== void 0 && we.setValue($, B.setFromMatrixPosition(le.matrixWorld));
      }
      (nt.isMeshPhongMaterial || nt.isMeshToonMaterial || nt.isMeshLambertMaterial || nt.isMeshBasicMaterial || nt.isMeshStandardMaterial || nt.isShaderMaterial) && Xt.setValue($, "isOrthographic", le.isOrthographicCamera === true), (nt.isMeshPhongMaterial || nt.isMeshToonMaterial || nt.isMeshLambertMaterial || nt.isMeshBasicMaterial || nt.isMeshStandardMaterial || nt.isShaderMaterial || nt.isShadowMaterial || ft.isSkinnedMesh) && Xt.setValue($, "viewMatrix", le.matrixWorldInverse);
    }
    if (ft.isSkinnedMesh) {
      Xt.setOptional($, ft, "bindMatrix"), Xt.setOptional($, ft, "bindMatrixInverse");
      const we = ft.skeleton;
      we && (ye.floatVertexTextures ? (we.boneTexture === null && we.computeBoneTexture(), Xt.setValue($, "boneTexture", we.boneTexture, ge), Xt.setValue($, "boneTextureSize", we.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
    }
    const br = Le.morphAttributes;
    if ((br.position !== void 0 || br.normal !== void 0 || br.color !== void 0 && ye.isWebGL2 === true) && V.update(ft, Le, nt, Lr), (Hr || Tr.receiveShadow !== ft.receiveShadow) && (Tr.receiveShadow = ft.receiveShadow, Xt.setValue($, "receiveShadow", ft.receiveShadow)), Hr && (Xt.setValue($, "toneMappingExposure", a.toneMappingExposure), Tr.needsLights && Pe(Qt, kr), zt && nt.fog === true && Be.refreshFogUniforms(Qt, zt), Be.refreshMaterialUniforms(Qt, nt, D, q, G), fc.upload($, Tr.uniformsList, Qt, ge)), nt.isShaderMaterial && nt.uniformsNeedUpdate === true && (fc.upload($, Tr.uniformsList, Qt, ge), nt.uniformsNeedUpdate = false), nt.isSpriteMaterial && Xt.setValue($, "center", ft.center), Xt.setValue($, "modelViewMatrix", ft.modelViewMatrix), Xt.setValue($, "normalMatrix", ft.normalMatrix), Xt.setValue($, "modelMatrix", ft.matrixWorld), nt.isShaderMaterial || nt.isRawShaderMaterial) {
      const we = nt.uniformsGroups;
      for (let me = 0, ze = we.length; me < ze; me++) if (ye.isWebGL2) {
        const rt = we[me];
        U.update(rt, Lr), U.bind(rt, Lr);
      } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
    }
    return Lr;
  }
  function Pe(le, re) {
    le.ambientLightColor.needsUpdate = re, le.lightProbe.needsUpdate = re, le.directionalLights.needsUpdate = re, le.directionalLightShadows.needsUpdate = re, le.pointLights.needsUpdate = re, le.pointLightShadows.needsUpdate = re, le.spotLights.needsUpdate = re, le.spotLightShadows.needsUpdate = re, le.rectAreaLights.needsUpdate = re, le.hemisphereLights.needsUpdate = re;
  }
  function $e(le) {
    return le.isMeshLambertMaterial || le.isMeshToonMaterial || le.isMeshPhongMaterial || le.isMeshStandardMaterial || le.isShadowMaterial || le.isShaderMaterial && le.lights === true;
  }
  this.getActiveCubeFace = function() {
    return d;
  }, this.getActiveMipmapLevel = function() {
    return b;
  }, this.getRenderTarget = function() {
    return S;
  }, this.setRenderTargetTextures = function(le, re, Le) {
    ne.get(le.texture).__webglTexture = re, ne.get(le.depthTexture).__webglTexture = Le;
    const nt = ne.get(le);
    nt.__hasExternalTextures = true, nt.__hasExternalTextures && (nt.__autoAllocateDepthBuffer = Le === void 0, nt.__autoAllocateDepthBuffer || ce.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), nt.__useRenderToTexture = false));
  }, this.setRenderTargetFramebuffer = function(le, re) {
    const Le = ne.get(le);
    Le.__webglFramebuffer = re, Le.__useDefaultFramebuffer = re === void 0;
  }, this.setRenderTarget = function(le, re = 0, Le = 0) {
    S = le, d = re, b = Le;
    let nt = true;
    if (le) {
      const ct = ne.get(le);
      ct.__useDefaultFramebuffer !== void 0 ? (ae.bindFramebuffer(36160, null), nt = false) : ct.__webglFramebuffer === void 0 ? ge.setupRenderTarget(le) : ct.__hasExternalTextures && ge.rebindTextures(le, ne.get(le.texture).__webglTexture, ne.get(le.depthTexture).__webglTexture);
    }
    let ft = null, zt = false, st = false;
    if (le) {
      const ct = le.texture;
      (ct.isData3DTexture || ct.isDataArrayTexture) && (st = true);
      const yt = ne.get(le).__webglFramebuffer;
      le.isWebGLCubeRenderTarget ? (ft = yt[re], zt = true) : ye.isWebGL2 && le.samples > 0 && ge.useMultisampledRTT(le) === false ? ft = ne.get(le).__webglMultisampledFramebuffer : ft = yt, k.copy(le.viewport), w.copy(le.scissor), F = le.scissorTest;
    } else k.copy(T).multiplyScalar(D).floor(), w.copy(L).multiplyScalar(D).floor(), F = j;
    if (ae.bindFramebuffer(36160, ft) && ye.drawBuffers && nt && ae.drawBuffers(le, ft), ae.viewport(k), ae.scissor(w), ae.setScissorTest(F), zt) {
      const ct = ne.get(le.texture);
      $.framebufferTexture2D(36160, 36064, 34069 + re, ct.__webglTexture, Le);
    } else if (st) {
      const ct = ne.get(le.texture), yt = re || 0;
      $.framebufferTextureLayer(36160, 36064, ct.__webglTexture, Le || 0, yt);
    }
    E = -1;
  }, this.readRenderTargetPixels = function(le, re, Le, nt, ft, zt, st) {
    if (!(le && le.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let ct = ne.get(le).__webglFramebuffer;
    if (le.isWebGLCubeRenderTarget && st !== void 0 && (ct = ct[st]), ct) {
      ae.bindFramebuffer(36160, ct);
      try {
        const yt = le.texture, Zt = yt.format, Ct = yt.type;
        if (Zt !== 1023 && p.convert(Zt) !== $.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const Lt = Ct === 1016 && (ce.has("EXT_color_buffer_half_float") || ye.isWebGL2 && ce.has("EXT_color_buffer_float"));
        if (Ct !== 1009 && p.convert(Ct) !== $.getParameter(35738) && !(Ct === 1015 && (ye.isWebGL2 || ce.has("OES_texture_float") || ce.has("WEBGL_color_buffer_float"))) && !Lt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        re >= 0 && re <= le.width - nt && Le >= 0 && Le <= le.height - ft && $.readPixels(re, Le, nt, ft, p.convert(Zt), p.convert(Ct), zt);
      } finally {
        const yt = S !== null ? ne.get(S).__webglFramebuffer : null;
        ae.bindFramebuffer(36160, yt);
      }
    }
  }, this.copyFramebufferToTexture = function(le, re, Le = 0) {
    const nt = Math.pow(2, -Le), ft = Math.floor(re.image.width * nt), zt = Math.floor(re.image.height * nt);
    ge.setTexture2D(re, 0), $.copyTexSubImage2D(3553, Le, 0, 0, le.x, le.y, ft, zt), ae.unbindTexture();
  }, this.copyTextureToTexture = function(le, re, Le, nt = 0) {
    const ft = re.image.width, zt = re.image.height, st = p.convert(Le.format), ct = p.convert(Le.type);
    ge.setTexture2D(Le, 0), $.pixelStorei(37440, Le.flipY), $.pixelStorei(37441, Le.premultiplyAlpha), $.pixelStorei(3317, Le.unpackAlignment), re.isDataTexture ? $.texSubImage2D(3553, nt, le.x, le.y, ft, zt, st, ct, re.image.data) : re.isCompressedTexture ? $.compressedTexSubImage2D(3553, nt, le.x, le.y, re.mipmaps[0].width, re.mipmaps[0].height, st, re.mipmaps[0].data) : $.texSubImage2D(3553, nt, le.x, le.y, st, ct, re.image), nt === 0 && Le.generateMipmaps && $.generateMipmap(3553), ae.unbindTexture();
  }, this.copyTextureToTexture3D = function(le, re, Le, nt, ft = 0) {
    if (a.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const zt = le.max.x - le.min.x + 1, st = le.max.y - le.min.y + 1, ct = le.max.z - le.min.z + 1, yt = p.convert(nt.format), Zt = p.convert(nt.type);
    let Ct;
    if (nt.isData3DTexture) ge.setTexture3D(nt, 0), Ct = 32879;
    else if (nt.isDataArrayTexture) ge.setTexture2DArray(nt, 0), Ct = 35866;
    else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    $.pixelStorei(37440, nt.flipY), $.pixelStorei(37441, nt.premultiplyAlpha), $.pixelStorei(3317, nt.unpackAlignment);
    const Lt = $.getParameter(3314), Wt = $.getParameter(32878), vr = $.getParameter(3316), ar = $.getParameter(3315), sr = $.getParameter(32877), gr = Le.isCompressedTexture ? Le.mipmaps[0] : Le.image;
    $.pixelStorei(3314, gr.width), $.pixelStorei(32878, gr.height), $.pixelStorei(3316, le.min.x), $.pixelStorei(3315, le.min.y), $.pixelStorei(32877, le.min.z), Le.isDataTexture || Le.isData3DTexture ? $.texSubImage3D(Ct, ft, re.x, re.y, re.z, zt, st, ct, yt, Zt, gr.data) : Le.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), $.compressedTexSubImage3D(Ct, ft, re.x, re.y, re.z, zt, st, ct, yt, gr.data)) : $.texSubImage3D(Ct, ft, re.x, re.y, re.z, zt, st, ct, yt, Zt, gr), $.pixelStorei(3314, Lt), $.pixelStorei(32878, Wt), $.pixelStorei(3316, vr), $.pixelStorei(3315, ar), $.pixelStorei(32877, sr), ft === 0 && nt.generateMipmaps && $.generateMipmap(Ct), ae.unbindTexture();
  }, this.initTexture = function(le) {
    le.isCubeTexture ? ge.setTextureCube(le, 0) : le.isData3DTexture ? ge.setTexture3D(le, 0) : le.isDataArrayTexture ? ge.setTexture2DArray(le, 0) : ge.setTexture2D(le, 0), ae.unbindTexture();
  }, this.resetState = function() {
    d = 0, b = 0, S = null, ae.reset(), A.reset();
  }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
}
class M1 extends Bm {
}
M1.prototype.isWebGL1Renderer = true;
class I1 extends Si {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, n) {
    return super.copy(e, n), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return this.fog !== null && (n.object.fog = this.fog.toJSON()), n;
  }
}
class ad extends Mi {
  constructor(e, n, i, s, y, t, o, u, c) {
    super(e, n, i, s, y, t, o, u, c), this.isCanvasTexture = true, this.needsUpdate = true;
  }
}
class lf extends ao {
  constructor(e = 1, n = 1, i = 1, s = 8, y = 1, t = false, o = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: n, height: i, radialSegments: s, heightSegments: y, openEnded: t, thetaStart: o, thetaLength: u };
    const c = this;
    s = Math.floor(s), y = Math.floor(y);
    const h = [], f = [], r = [], m = [];
    let g = 0;
    const a = [], l = i / 2;
    let d = 0;
    b(), t === false && (e > 0 && S(true), n > 0 && S(false)), this.setIndex(h), this.setAttribute("position", new gi(f, 3)), this.setAttribute("normal", new gi(r, 3)), this.setAttribute("uv", new gi(m, 2));
    function b() {
      const E = new _r(), R = new _r();
      let k = 0;
      const w = (n - e) / i;
      for (let F = 0; F <= y; F++) {
        const I = [], q = F / y, D = q * (n - e) + e;
        for (let H = 0; H <= s; H++) {
          const _ = H / s, T = _ * u + o, L = Math.sin(T), j = Math.cos(T);
          R.x = D * L, R.y = -q * i + l, R.z = D * j, f.push(R.x, R.y, R.z), E.set(L, w, j).normalize(), r.push(E.x, E.y, E.z), m.push(_, 1 - q), I.push(g++);
        }
        a.push(I);
      }
      for (let F = 0; F < s; F++) for (let I = 0; I < y; I++) {
        const q = a[I][F], D = a[I + 1][F], H = a[I + 1][F + 1], _ = a[I][F + 1];
        h.push(q, D, _), h.push(D, H, _), k += 6;
      }
      c.addGroup(d, k, 0), d += k;
    }
    function S(E) {
      const R = g, k = new In(), w = new _r();
      let F = 0;
      const I = E === true ? e : n, q = E === true ? 1 : -1;
      for (let H = 1; H <= s; H++) f.push(0, l * q, 0), r.push(0, q, 0), m.push(0.5, 0.5), g++;
      const D = g;
      for (let H = 0; H <= s; H++) {
        const _ = H / s * u + o, T = Math.cos(_), L = Math.sin(_);
        w.x = I * L, w.y = l * q, w.z = I * T, f.push(w.x, w.y, w.z), r.push(0, q, 0), k.x = T * 0.5 + 0.5, k.y = L * 0.5 * q + 0.5, m.push(k.x, k.y), g++;
      }
      for (let H = 0; H < s; H++) {
        const _ = R + H, T = D + H;
        E === true ? h.push(T, T + 1, _) : h.push(T + 1, T, _), F += 3;
      }
      c.addGroup(d, F, E === true ? 1 : 2), d += F;
    }
  }
  static fromJSON(e) {
    return new lf(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class L1 extends ca {
  constructor(e) {
    super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Mn(0), this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class B1 extends ca {
  constructor(e) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Mn(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new In(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class N1 extends ca {
  constructor(e) {
    super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Mn(16777215), this.specular = new Mn(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Mn(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new In(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Nm extends Si {
  constructor(e, n = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Mn(e), this.intensity = n;
  }
  dispose() {
  }
  copy(e, n) {
    return super.copy(e, n), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return n.object.color = this.color.getHex(), n.object.intensity = this.intensity, this.groundColor !== void 0 && (n.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (n.object.distance = this.distance), this.angle !== void 0 && (n.object.angle = this.angle), this.decay !== void 0 && (n.object.decay = this.decay), this.penumbra !== void 0 && (n.object.penumbra = this.penumbra), this.shadow !== void 0 && (n.object.shadow = this.shadow.toJSON()), n;
  }
}
class D1 extends Nm {
  constructor(e, n, i) {
    super(e, i), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.groundColor = new Mn(n);
  }
  copy(e, n) {
    return super.copy(e, n), this.groundColor.copy(e.groundColor), this;
  }
}
const sd = new li(), ud = new _r(), cd = new _r();
class F1 {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new In(512, 512), this.map = null, this.mapPass = null, this.matrix = new li(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new uf(), this._frameExtents = new In(1, 1), this._viewportCount = 1, this._viewports = [new ci(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const n = this.camera, i = this.matrix;
    ud.setFromMatrixPosition(e.matrixWorld), n.position.copy(ud), cd.setFromMatrixPosition(e.target.matrixWorld), n.lookAt(cd), n.updateMatrixWorld(), sd.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sd), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(n.projectionMatrix), i.multiply(n.matrixWorldInverse);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
  }
}
class U1 extends F1 {
  constructor() {
    super(new Ri(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(e) {
    const n = this.camera, i = jl * 2 * e.angle * this.focus, s = this.mapSize.width / this.mapSize.height, y = e.distance || n.far;
    (i !== n.fov || s !== n.aspect || y !== n.far) && (n.fov = i, n.aspect = s, n.far = y, n.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class j1 extends Nm {
  constructor(e, n, i = 0, s = Math.PI / 3, y = 0, t = 1) {
    super(e, n), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Si.DefaultUp), this.updateMatrix(), this.target = new Si(), this.distance = i, this.angle = s, this.penumbra = y, this.decay = t, this.shadow = new U1();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, n) {
    return super.copy(e, n), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: sf } }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = sf);
class Xi {
  constructor(e) {
    e === void 0 && (e = [0, 0, 0, 0, 0, 0, 0, 0, 0]), this.elements = e;
  }
  identity() {
    const e = this.elements;
    e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 1, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 1;
  }
  setZero() {
    const e = this.elements;
    e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = 0, e[6] = 0, e[7] = 0, e[8] = 0;
  }
  setTrace(e) {
    const n = this.elements;
    n[0] = e.x, n[4] = e.y, n[8] = e.z;
  }
  getTrace(e) {
    e === void 0 && (e = new lt());
    const n = this.elements;
    return e.x = n[0], e.y = n[4], e.z = n[8], e;
  }
  vmult(e, n) {
    n === void 0 && (n = new lt());
    const i = this.elements, s = e.x, y = e.y, t = e.z;
    return n.x = i[0] * s + i[1] * y + i[2] * t, n.y = i[3] * s + i[4] * y + i[5] * t, n.z = i[6] * s + i[7] * y + i[8] * t, n;
  }
  smult(e) {
    for (let n = 0; n < this.elements.length; n++) this.elements[n] *= e;
  }
  mmult(e, n) {
    n === void 0 && (n = new Xi());
    const i = this.elements, s = e.elements, y = n.elements, t = i[0], o = i[1], u = i[2], c = i[3], h = i[4], f = i[5], r = i[6], m = i[7], g = i[8], a = s[0], l = s[1], d = s[2], b = s[3], S = s[4], E = s[5], R = s[6], k = s[7], w = s[8];
    return y[0] = t * a + o * b + u * R, y[1] = t * l + o * S + u * k, y[2] = t * d + o * E + u * w, y[3] = c * a + h * b + f * R, y[4] = c * l + h * S + f * k, y[5] = c * d + h * E + f * w, y[6] = r * a + m * b + g * R, y[7] = r * l + m * S + g * k, y[8] = r * d + m * E + g * w, n;
  }
  scale(e, n) {
    n === void 0 && (n = new Xi());
    const i = this.elements, s = n.elements;
    for (let y = 0; y !== 3; y++) s[3 * y + 0] = e.x * i[3 * y + 0], s[3 * y + 1] = e.y * i[3 * y + 1], s[3 * y + 2] = e.z * i[3 * y + 2];
    return n;
  }
  solve(e, n) {
    n === void 0 && (n = new lt());
    const i = 3, s = 4, y = [];
    let t, o;
    for (t = 0; t < i * s; t++) y.push(0);
    for (t = 0; t < 3; t++) for (o = 0; o < 3; o++) y[t + s * o] = this.elements[t + 3 * o];
    y[3 + 4 * 0] = e.x, y[3 + 4 * 1] = e.y, y[3 + 4 * 2] = e.z;
    let u = 3;
    const c = u;
    let h;
    const f = 4;
    let r;
    do {
      if (t = c - u, y[t + s * t] === 0) {
        for (o = t + 1; o < c; o++) if (y[t + s * o] !== 0) {
          h = f;
          do
            r = f - h, y[r + s * t] += y[r + s * o];
          while (--h);
          break;
        }
      }
      if (y[t + s * t] !== 0) for (o = t + 1; o < c; o++) {
        const m = y[t + s * o] / y[t + s * t];
        h = f;
        do
          r = f - h, y[r + s * o] = r <= t ? 0 : y[r + s * o] - y[r + s * t] * m;
        while (--h);
      }
    } while (--u);
    if (n.z = y[2 * s + 3] / y[2 * s + 2], n.y = (y[1 * s + 3] - y[1 * s + 2] * n.z) / y[1 * s + 1], n.x = (y[0 * s + 3] - y[0 * s + 2] * n.z - y[0 * s + 1] * n.y) / y[0 * s + 0], isNaN(n.x) || isNaN(n.y) || isNaN(n.z) || n.x === 1 / 0 || n.y === 1 / 0 || n.z === 1 / 0) throw `Could not solve equation! Got x=[${n.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;
    return n;
  }
  e(e, n, i) {
    if (i === void 0) return this.elements[n + 3 * e];
    this.elements[n + 3 * e] = i;
  }
  copy(e) {
    for (let n = 0; n < e.elements.length; n++) this.elements[n] = e.elements[n];
    return this;
  }
  toString() {
    let e = "";
    const n = ",";
    for (let i = 0; i < 9; i++) e += this.elements[i] + n;
    return e;
  }
  reverse(e) {
    e === void 0 && (e = new Xi());
    const n = 3, i = 6, s = V1;
    let y, t;
    for (y = 0; y < 3; y++) for (t = 0; t < 3; t++) s[y + i * t] = this.elements[y + 3 * t];
    s[3 + 6 * 0] = 1, s[3 + 6 * 1] = 0, s[3 + 6 * 2] = 0, s[4 + 6 * 0] = 0, s[4 + 6 * 1] = 1, s[4 + 6 * 2] = 0, s[5 + 6 * 0] = 0, s[5 + 6 * 1] = 0, s[5 + 6 * 2] = 1;
    let o = 3;
    const u = o;
    let c;
    const h = i;
    let f;
    do {
      if (y = u - o, s[y + i * y] === 0) {
        for (t = y + 1; t < u; t++) if (s[y + i * t] !== 0) {
          c = h;
          do
            f = h - c, s[f + i * y] += s[f + i * t];
          while (--c);
          break;
        }
      }
      if (s[y + i * y] !== 0) for (t = y + 1; t < u; t++) {
        const r = s[y + i * t] / s[y + i * y];
        c = h;
        do
          f = h - c, s[f + i * t] = f <= y ? 0 : s[f + i * t] - s[f + i * y] * r;
        while (--c);
      }
    } while (--o);
    y = 2;
    do {
      t = y - 1;
      do {
        const r = s[y + i * t] / s[y + i * y];
        c = i;
        do
          f = i - c, s[f + i * t] = s[f + i * t] - s[f + i * y] * r;
        while (--c);
      } while (t--);
    } while (--y);
    y = 2;
    do {
      const r = 1 / s[y + i * y];
      c = i;
      do
        f = i - c, s[f + i * y] = s[f + i * y] * r;
      while (--c);
    } while (y--);
    y = 2;
    do {
      t = 2;
      do {
        if (f = s[n + t + i * y], isNaN(f) || f === 1 / 0) throw `Could not reverse! A=[${this.toString()}]`;
        e.e(y, t, f);
      } while (t--);
    } while (y--);
    return e;
  }
  setRotationFromQuaternion(e) {
    const n = e.x, i = e.y, s = e.z, y = e.w, t = n + n, o = i + i, u = s + s, c = n * t, h = n * o, f = n * u, r = i * o, m = i * u, g = s * u, a = y * t, l = y * o, d = y * u, b = this.elements;
    return b[3 * 0 + 0] = 1 - (r + g), b[3 * 0 + 1] = h - d, b[3 * 0 + 2] = f + l, b[3 * 1 + 0] = h + d, b[3 * 1 + 1] = 1 - (c + g), b[3 * 1 + 2] = m - a, b[3 * 2 + 0] = f - l, b[3 * 2 + 1] = m + a, b[3 * 2 + 2] = 1 - (c + r), this;
  }
  transpose(e) {
    e === void 0 && (e = new Xi());
    const n = this.elements, i = e.elements;
    let s;
    return i[0] = n[0], i[4] = n[4], i[8] = n[8], s = n[1], i[1] = n[3], i[3] = s, s = n[2], i[2] = n[6], i[6] = s, s = n[5], i[5] = n[7], i[7] = s, e;
  }
}
const V1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
class lt {
  constructor(e, n, i) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), i === void 0 && (i = 0), this.x = e, this.y = n, this.z = i;
  }
  cross(e, n) {
    n === void 0 && (n = new lt());
    const i = e.x, s = e.y, y = e.z, t = this.x, o = this.y, u = this.z;
    return n.x = o * y - u * s, n.y = u * i - t * y, n.z = t * s - o * i, n;
  }
  set(e, n, i) {
    return this.x = e, this.y = n, this.z = i, this;
  }
  setZero() {
    this.x = this.y = this.z = 0;
  }
  vadd(e, n) {
    if (n) n.x = e.x + this.x, n.y = e.y + this.y, n.z = e.z + this.z;
    else return new lt(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  vsub(e, n) {
    if (n) n.x = this.x - e.x, n.y = this.y - e.y, n.z = this.z - e.z;
    else return new lt(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  crossmat() {
    return new Xi([0, -this.z, this.y, this.z, 0, -this.x, -this.y, this.x, 0]);
  }
  normalize() {
    const e = this.x, n = this.y, i = this.z, s = Math.sqrt(e * e + n * n + i * i);
    if (s > 0) {
      const y = 1 / s;
      this.x *= y, this.y *= y, this.z *= y;
    } else this.x = 0, this.y = 0, this.z = 0;
    return s;
  }
  unit(e) {
    e === void 0 && (e = new lt());
    const n = this.x, i = this.y, s = this.z;
    let y = Math.sqrt(n * n + i * i + s * s);
    return y > 0 ? (y = 1 / y, e.x = n * y, e.y = i * y, e.z = s * y) : (e.x = 1, e.y = 0, e.z = 0), e;
  }
  length() {
    const e = this.x, n = this.y, i = this.z;
    return Math.sqrt(e * e + n * n + i * i);
  }
  lengthSquared() {
    return this.dot(this);
  }
  distanceTo(e) {
    const n = this.x, i = this.y, s = this.z, y = e.x, t = e.y, o = e.z;
    return Math.sqrt((y - n) * (y - n) + (t - i) * (t - i) + (o - s) * (o - s));
  }
  distanceSquared(e) {
    const n = this.x, i = this.y, s = this.z, y = e.x, t = e.y, o = e.z;
    return (y - n) * (y - n) + (t - i) * (t - i) + (o - s) * (o - s);
  }
  scale(e, n) {
    n === void 0 && (n = new lt());
    const i = this.x, s = this.y, y = this.z;
    return n.x = e * i, n.y = e * s, n.z = e * y, n;
  }
  vmul(e, n) {
    return n === void 0 && (n = new lt()), n.x = e.x * this.x, n.y = e.y * this.y, n.z = e.z * this.z, n;
  }
  addScaledVector(e, n, i) {
    return i === void 0 && (i = new lt()), i.x = this.x + e * n.x, i.y = this.y + e * n.y, i.z = this.z + e * n.z, i;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  isZero() {
    return this.x === 0 && this.y === 0 && this.z === 0;
  }
  negate(e) {
    return e === void 0 && (e = new lt()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e;
  }
  tangents(e, n) {
    const i = this.length();
    if (i > 0) {
      const s = q1, y = 1 / i;
      s.set(this.x * y, this.y * y, this.z * y);
      const t = z1;
      Math.abs(s.x) < 0.9 ? (t.set(1, 0, 0), s.cross(t, e)) : (t.set(0, 1, 0), s.cross(t, e)), s.cross(e, n);
    } else e.set(1, 0, 0), n.set(0, 1, 0);
  }
  toString() {
    return `${this.x},${this.y},${this.z}`;
  }
  toArray() {
    return [this.x, this.y, this.z];
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  lerp(e, n, i) {
    const s = this.x, y = this.y, t = this.z;
    i.x = s + (e.x - s) * n, i.y = y + (e.y - y) * n, i.z = t + (e.z - t) * n;
  }
  almostEquals(e, n) {
    return n === void 0 && (n = 1e-6), !(Math.abs(this.x - e.x) > n || Math.abs(this.y - e.y) > n || Math.abs(this.z - e.z) > n);
  }
  almostZero(e) {
    return e === void 0 && (e = 1e-6), !(Math.abs(this.x) > e || Math.abs(this.y) > e || Math.abs(this.z) > e);
  }
  isAntiparallelTo(e, n) {
    return this.negate(ld), ld.almostEquals(e, n);
  }
  clone() {
    return new lt(this.x, this.y, this.z);
  }
}
lt.ZERO = new lt(0, 0, 0);
lt.UNIT_X = new lt(1, 0, 0);
lt.UNIT_Y = new lt(0, 1, 0);
lt.UNIT_Z = new lt(0, 0, 1);
const q1 = new lt(), z1 = new lt(), ld = new lt();
class Li {
  constructor(e) {
    e === void 0 && (e = {}), this.lowerBound = new lt(), this.upperBound = new lt(), e.lowerBound && this.lowerBound.copy(e.lowerBound), e.upperBound && this.upperBound.copy(e.upperBound);
  }
  setFromPoints(e, n, i, s) {
    const y = this.lowerBound, t = this.upperBound, o = i;
    y.copy(e[0]), o && o.vmult(y, y), t.copy(y);
    for (let u = 1; u < e.length; u++) {
      let c = e[u];
      o && (o.vmult(c, fd), c = fd), c.x > t.x && (t.x = c.x), c.x < y.x && (y.x = c.x), c.y > t.y && (t.y = c.y), c.y < y.y && (y.y = c.y), c.z > t.z && (t.z = c.z), c.z < y.z && (y.z = c.z);
    }
    return n && (n.vadd(y, y), n.vadd(t, t)), s && (y.x -= s, y.y -= s, y.z -= s, t.x += s, t.y += s, t.z += s), this;
  }
  copy(e) {
    return this.lowerBound.copy(e.lowerBound), this.upperBound.copy(e.upperBound), this;
  }
  clone() {
    return new Li().copy(this);
  }
  extend(e) {
    this.lowerBound.x = Math.min(this.lowerBound.x, e.lowerBound.x), this.upperBound.x = Math.max(this.upperBound.x, e.upperBound.x), this.lowerBound.y = Math.min(this.lowerBound.y, e.lowerBound.y), this.upperBound.y = Math.max(this.upperBound.y, e.upperBound.y), this.lowerBound.z = Math.min(this.lowerBound.z, e.lowerBound.z), this.upperBound.z = Math.max(this.upperBound.z, e.upperBound.z);
  }
  overlaps(e) {
    const n = this.lowerBound, i = this.upperBound, s = e.lowerBound, y = e.upperBound, t = s.x <= i.x && i.x <= y.x || n.x <= y.x && y.x <= i.x, o = s.y <= i.y && i.y <= y.y || n.y <= y.y && y.y <= i.y, u = s.z <= i.z && i.z <= y.z || n.z <= y.z && y.z <= i.z;
    return t && o && u;
  }
  volume() {
    const e = this.lowerBound, n = this.upperBound;
    return (n.x - e.x) * (n.y - e.y) * (n.z - e.z);
  }
  contains(e) {
    const n = this.lowerBound, i = this.upperBound, s = e.lowerBound, y = e.upperBound;
    return n.x <= s.x && i.x >= y.x && n.y <= s.y && i.y >= y.y && n.z <= s.z && i.z >= y.z;
  }
  getCorners(e, n, i, s, y, t, o, u) {
    const c = this.lowerBound, h = this.upperBound;
    e.copy(c), n.set(h.x, c.y, c.z), i.set(h.x, h.y, c.z), s.set(c.x, h.y, h.z), y.set(h.x, c.y, h.z), t.set(c.x, h.y, c.z), o.set(c.x, c.y, h.z), u.copy(h);
  }
  toLocalFrame(e, n) {
    const i = pd, s = i[0], y = i[1], t = i[2], o = i[3], u = i[4], c = i[5], h = i[6], f = i[7];
    this.getCorners(s, y, t, o, u, c, h, f);
    for (let r = 0; r !== 8; r++) {
      const m = i[r];
      e.pointToLocal(m, m);
    }
    return n.setFromPoints(i);
  }
  toWorldFrame(e, n) {
    const i = pd, s = i[0], y = i[1], t = i[2], o = i[3], u = i[4], c = i[5], h = i[6], f = i[7];
    this.getCorners(s, y, t, o, u, c, h, f);
    for (let r = 0; r !== 8; r++) {
      const m = i[r];
      e.pointToWorld(m, m);
    }
    return n.setFromPoints(i);
  }
  overlapsRay(e) {
    const { direction: n, from: i } = e, s = 1 / n.x, y = 1 / n.y, t = 1 / n.z, o = (this.lowerBound.x - i.x) * s, u = (this.upperBound.x - i.x) * s, c = (this.lowerBound.y - i.y) * y, h = (this.upperBound.y - i.y) * y, f = (this.lowerBound.z - i.z) * t, r = (this.upperBound.z - i.z) * t, m = Math.max(Math.max(Math.min(o, u), Math.min(c, h)), Math.min(f, r)), g = Math.min(Math.min(Math.max(o, u), Math.max(c, h)), Math.max(f, r));
    return !(g < 0 || m > g);
  }
}
const fd = new lt(), pd = [new lt(), new lt(), new lt(), new lt(), new lt(), new lt(), new lt(), new lt()];
class hd {
  constructor() {
    this.matrix = [];
  }
  get(e, n) {
    let { index: i } = e, { index: s } = n;
    if (s > i) {
      const y = s;
      s = i, i = y;
    }
    return this.matrix[(i * (i + 1) >> 1) + s - 1];
  }
  set(e, n, i) {
    let { index: s } = e, { index: y } = n;
    if (y > s) {
      const t = y;
      y = s, s = t;
    }
    this.matrix[(s * (s + 1) >> 1) + y - 1] = i ? 1 : 0;
  }
  reset() {
    for (let e = 0, n = this.matrix.length; e !== n; e++) this.matrix[e] = 0;
  }
  setNumObjects(e) {
    this.matrix.length = e * (e - 1) >> 1;
  }
}
class Dm {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    return i[e] === void 0 && (i[e] = []), i[e].includes(n) || i[e].push(n), this;
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return false;
    const i = this._listeners;
    return !!(i[e] !== void 0 && i[e].includes(n));
  }
  hasAnyEventListener(e) {
    return this._listeners === void 0 ? false : this._listeners[e] !== void 0;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return this;
    const i = this._listeners;
    if (i[e] === void 0) return this;
    const s = i[e].indexOf(n);
    return s !== -1 && i[e].splice(s, 1), this;
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return this;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      for (let i = 0, s = n.length; i < s; i++) n[i].call(this, e);
    }
    return this;
  }
}
class ti {
  constructor(e, n, i, s) {
    e === void 0 && (e = 0), n === void 0 && (n = 0), i === void 0 && (i = 0), s === void 0 && (s = 1), this.x = e, this.y = n, this.z = i, this.w = s;
  }
  set(e, n, i, s) {
    return this.x = e, this.y = n, this.z = i, this.w = s, this;
  }
  toString() {
    return `${this.x},${this.y},${this.z},${this.w}`;
  }
  toArray() {
    return [this.x, this.y, this.z, this.w];
  }
  setFromAxisAngle(e, n) {
    const i = Math.sin(n * 0.5);
    return this.x = e.x * i, this.y = e.y * i, this.z = e.z * i, this.w = Math.cos(n * 0.5), this;
  }
  toAxisAngle(e) {
    e === void 0 && (e = new lt()), this.normalize();
    const n = 2 * Math.acos(this.w), i = Math.sqrt(1 - this.w * this.w);
    return i < 1e-3 ? (e.x = this.x, e.y = this.y, e.z = this.z) : (e.x = this.x / i, e.y = this.y / i, e.z = this.z / i), [e, n];
  }
  setFromVectors(e, n) {
    if (e.isAntiparallelTo(n)) {
      const i = H1, s = G1;
      e.tangents(i, s), this.setFromAxisAngle(i, Math.PI);
    } else {
      const i = e.cross(n);
      this.x = i.x, this.y = i.y, this.z = i.z, this.w = Math.sqrt(e.length() ** 2 * n.length() ** 2) + e.dot(n), this.normalize();
    }
    return this;
  }
  mult(e, n) {
    n === void 0 && (n = new ti());
    const i = this.x, s = this.y, y = this.z, t = this.w, o = e.x, u = e.y, c = e.z, h = e.w;
    return n.x = i * h + t * o + s * c - y * u, n.y = s * h + t * u + y * o - i * c, n.z = y * h + t * c + i * u - s * o, n.w = t * h - i * o - s * u - y * c, n;
  }
  inverse(e) {
    e === void 0 && (e = new ti());
    const n = this.x, i = this.y, s = this.z, y = this.w;
    this.conjugate(e);
    const t = 1 / (n * n + i * i + s * s + y * y);
    return e.x *= t, e.y *= t, e.z *= t, e.w *= t, e;
  }
  conjugate(e) {
    return e === void 0 && (e = new ti()), e.x = -this.x, e.y = -this.y, e.z = -this.z, e.w = this.w, e;
  }
  normalize() {
    let e = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (e = 1 / e, this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  normalizeFast() {
    const e = (3 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2;
    return e === 0 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 0) : (this.x *= e, this.y *= e, this.z *= e, this.w *= e), this;
  }
  vmult(e, n) {
    n === void 0 && (n = new lt());
    const i = e.x, s = e.y, y = e.z, t = this.x, o = this.y, u = this.z, c = this.w, h = c * i + o * y - u * s, f = c * s + u * i - t * y, r = c * y + t * s - o * i, m = -t * i - o * s - u * y;
    return n.x = h * c + m * -t + f * -u - r * -o, n.y = f * c + m * -o + r * -t - h * -u, n.z = r * c + m * -u + h * -o - f * -t, n;
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  toEuler(e, n) {
    n === void 0 && (n = "YZX");
    let i, s, y;
    const t = this.x, o = this.y, u = this.z, c = this.w;
    switch (n) {
      case "YZX":
        const h = t * o + u * c;
        if (h > 0.499 && (i = 2 * Math.atan2(t, c), s = Math.PI / 2, y = 0), h < -0.499 && (i = -2 * Math.atan2(t, c), s = -Math.PI / 2, y = 0), i === void 0) {
          const f = t * t, r = o * o, m = u * u;
          i = Math.atan2(2 * o * c - 2 * t * u, 1 - 2 * r - 2 * m), s = Math.asin(2 * h), y = Math.atan2(2 * t * c - 2 * o * u, 1 - 2 * f - 2 * m);
        }
        break;
      default:
        throw new Error(`Euler order ${n} not supported yet.`);
    }
    e.y = i, e.z = s, e.x = y;
  }
  setFromEuler(e, n, i, s) {
    s === void 0 && (s = "XYZ");
    const y = Math.cos(e / 2), t = Math.cos(n / 2), o = Math.cos(i / 2), u = Math.sin(e / 2), c = Math.sin(n / 2), h = Math.sin(i / 2);
    return s === "XYZ" ? (this.x = u * t * o + y * c * h, this.y = y * c * o - u * t * h, this.z = y * t * h + u * c * o, this.w = y * t * o - u * c * h) : s === "YXZ" ? (this.x = u * t * o + y * c * h, this.y = y * c * o - u * t * h, this.z = y * t * h - u * c * o, this.w = y * t * o + u * c * h) : s === "ZXY" ? (this.x = u * t * o - y * c * h, this.y = y * c * o + u * t * h, this.z = y * t * h + u * c * o, this.w = y * t * o - u * c * h) : s === "ZYX" ? (this.x = u * t * o - y * c * h, this.y = y * c * o + u * t * h, this.z = y * t * h - u * c * o, this.w = y * t * o + u * c * h) : s === "YZX" ? (this.x = u * t * o + y * c * h, this.y = y * c * o + u * t * h, this.z = y * t * h - u * c * o, this.w = y * t * o - u * c * h) : s === "XZY" && (this.x = u * t * o - y * c * h, this.y = y * c * o - u * t * h, this.z = y * t * h + u * c * o, this.w = y * t * o + u * c * h), this;
  }
  clone() {
    return new ti(this.x, this.y, this.z, this.w);
  }
  slerp(e, n, i) {
    i === void 0 && (i = new ti());
    const s = this.x, y = this.y, t = this.z, o = this.w;
    let u = e.x, c = e.y, h = e.z, f = e.w, r, m, g, a, l;
    return m = s * u + y * c + t * h + o * f, m < 0 && (m = -m, u = -u, c = -c, h = -h, f = -f), 1 - m > 1e-6 ? (r = Math.acos(m), g = Math.sin(r), a = Math.sin((1 - n) * r) / g, l = Math.sin(n * r) / g) : (a = 1 - n, l = n), i.x = a * s + l * u, i.y = a * y + l * c, i.z = a * t + l * h, i.w = a * o + l * f, i;
  }
  integrate(e, n, i, s) {
    s === void 0 && (s = new ti());
    const y = e.x * i.x, t = e.y * i.y, o = e.z * i.z, u = this.x, c = this.y, h = this.z, f = this.w, r = n * 0.5;
    return s.x += r * (y * f + t * h - o * c), s.y += r * (t * f + o * u - y * h), s.z += r * (o * f + y * c - t * u), s.w += r * (-y * u - t * c - o * h), s;
  }
}
const H1 = new lt(), G1 = new lt(), W1 = { SPHERE: 1, PLANE: 2, BOX: 4, COMPOUND: 8, CONVEXPOLYHEDRON: 16, HEIGHTFIELD: 32, PARTICLE: 64, CYLINDER: 128, TRIMESH: 256 };
class hn {
  constructor(e) {
    e === void 0 && (e = {}), this.id = hn.idCounter++, this.type = e.type || 0, this.boundingSphereRadius = 0, this.collisionResponse = e.collisionResponse ? e.collisionResponse : true, this.collisionFilterGroup = e.collisionFilterGroup !== void 0 ? e.collisionFilterGroup : 1, this.collisionFilterMask = e.collisionFilterMask !== void 0 ? e.collisionFilterMask : -1, this.material = e.material ? e.material : null, this.body = null;
  }
  updateBoundingSphereRadius() {
    throw `computeBoundingSphereRadius() not implemented for shape type ${this.type}`;
  }
  volume() {
    throw `volume() not implemented for shape type ${this.type}`;
  }
  calculateLocalInertia(e, n) {
    throw `calculateLocalInertia() not implemented for shape type ${this.type}`;
  }
  calculateWorldAABB(e, n, i, s) {
    throw `calculateWorldAABB() not implemented for shape type ${this.type}`;
  }
}
hn.idCounter = 0;
hn.types = W1;
class Fn {
  constructor(e) {
    e === void 0 && (e = {}), this.position = new lt(), this.quaternion = new ti(), e.position && this.position.copy(e.position), e.quaternion && this.quaternion.copy(e.quaternion);
  }
  pointToLocal(e, n) {
    return Fn.pointToLocalFrame(this.position, this.quaternion, e, n);
  }
  pointToWorld(e, n) {
    return Fn.pointToWorldFrame(this.position, this.quaternion, e, n);
  }
  vectorToWorldFrame(e, n) {
    return n === void 0 && (n = new lt()), this.quaternion.vmult(e, n), n;
  }
  static pointToLocalFrame(e, n, i, s) {
    return s === void 0 && (s = new lt()), i.vsub(e, s), n.conjugate(dd), dd.vmult(s, s), s;
  }
  static pointToWorldFrame(e, n, i, s) {
    return s === void 0 && (s = new lt()), n.vmult(i, s), s.vadd(e, s), s;
  }
  static vectorToWorldFrame(e, n, i) {
    return i === void 0 && (i = new lt()), e.vmult(n, i), i;
  }
  static vectorToLocalFrame(e, n, i, s) {
    return s === void 0 && (s = new lt()), n.w *= -1, n.vmult(i, s), n.w *= -1, s;
  }
}
const dd = new ti();
class ra extends hn {
  constructor(e) {
    e === void 0 && (e = {});
    const { vertices: n = [], faces: i = [], normals: s = [], axes: y, boundingSphereRadius: t } = e;
    super({ type: hn.types.CONVEXPOLYHEDRON }), this.vertices = n, this.faces = i, this.faceNormals = s, this.faceNormals.length === 0 && this.computeNormals(), t ? this.boundingSphereRadius = t : this.updateBoundingSphereRadius(), this.worldVertices = [], this.worldVerticesNeedsUpdate = true, this.worldFaceNormals = [], this.worldFaceNormalsNeedsUpdate = true, this.uniqueAxes = y ? y.slice() : null, this.uniqueEdges = [], this.computeEdges();
  }
  computeEdges() {
    const e = this.faces, n = this.vertices, i = this.uniqueEdges;
    i.length = 0;
    const s = new lt();
    for (let y = 0; y !== e.length; y++) {
      const t = e[y], o = t.length;
      for (let u = 0; u !== o; u++) {
        const c = (u + 1) % o;
        n[t[u]].vsub(n[t[c]], s), s.normalize();
        let h = false;
        for (let f = 0; f !== i.length; f++) if (i[f].almostEquals(s) || i[f].almostEquals(s)) {
          h = true;
          break;
        }
        h || i.push(s.clone());
      }
    }
  }
  computeNormals() {
    this.faceNormals.length = this.faces.length;
    for (let e = 0; e < this.faces.length; e++) {
      for (let s = 0; s < this.faces[e].length; s++) if (!this.vertices[this.faces[e][s]]) throw new Error(`Vertex ${this.faces[e][s]} not found!`);
      const n = this.faceNormals[e] || new lt();
      this.getFaceNormal(e, n), n.negate(n), this.faceNormals[e] = n;
      const i = this.vertices[this.faces[e][0]];
      if (n.dot(i) < 0) {
        console.error(`.faceNormals[${e}] = Vec3(${n.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);
        for (let s = 0; s < this.faces[e].length; s++) console.warn(`.vertices[${this.faces[e][s]}] = Vec3(${this.vertices[this.faces[e][s]].toString()})`);
      }
    }
  }
  getFaceNormal(e, n) {
    const i = this.faces[e], s = this.vertices[i[0]], y = this.vertices[i[1]], t = this.vertices[i[2]];
    ra.computeNormal(s, y, t, n);
  }
  static computeNormal(e, n, i, s) {
    const y = new lt(), t = new lt();
    n.vsub(e, t), i.vsub(n, y), y.cross(t, s), s.isZero() || s.normalize();
  }
  clipAgainstHull(e, n, i, s, y, t, o, u, c) {
    const h = new lt();
    let f = -1, r = -Number.MAX_VALUE;
    for (let g = 0; g < i.faces.length; g++) {
      h.copy(i.faceNormals[g]), y.vmult(h, h);
      const a = h.dot(t);
      a > r && (r = a, f = g);
    }
    const m = [];
    for (let g = 0; g < i.faces[f].length; g++) {
      const a = i.vertices[i.faces[f][g]], l = new lt();
      l.copy(a), y.vmult(l, l), s.vadd(l, l), m.push(l);
    }
    f >= 0 && this.clipFaceAgainstHull(t, e, n, m, o, u, c);
  }
  findSeparatingAxis(e, n, i, s, y, t, o, u) {
    const c = new lt(), h = new lt(), f = new lt(), r = new lt(), m = new lt(), g = new lt();
    let a = Number.MAX_VALUE;
    const l = this;
    if (l.uniqueAxes) for (let d = 0; d !== l.uniqueAxes.length; d++) {
      i.vmult(l.uniqueAxes[d], c);
      const b = l.testSepAxis(c, e, n, i, s, y);
      if (b === false) return false;
      b < a && (a = b, t.copy(c));
    }
    else {
      const d = o ? o.length : l.faces.length;
      for (let b = 0; b < d; b++) {
        const S = o ? o[b] : b;
        c.copy(l.faceNormals[S]), i.vmult(c, c);
        const E = l.testSepAxis(c, e, n, i, s, y);
        if (E === false) return false;
        E < a && (a = E, t.copy(c));
      }
    }
    if (e.uniqueAxes) for (let d = 0; d !== e.uniqueAxes.length; d++) {
      y.vmult(e.uniqueAxes[d], h);
      const b = l.testSepAxis(h, e, n, i, s, y);
      if (b === false) return false;
      b < a && (a = b, t.copy(h));
    }
    else {
      const d = u ? u.length : e.faces.length;
      for (let b = 0; b < d; b++) {
        const S = u ? u[b] : b;
        h.copy(e.faceNormals[S]), y.vmult(h, h);
        const E = l.testSepAxis(h, e, n, i, s, y);
        if (E === false) return false;
        E < a && (a = E, t.copy(h));
      }
    }
    for (let d = 0; d !== l.uniqueEdges.length; d++) {
      i.vmult(l.uniqueEdges[d], r);
      for (let b = 0; b !== e.uniqueEdges.length; b++) if (y.vmult(e.uniqueEdges[b], m), r.cross(m, g), !g.almostZero()) {
        g.normalize();
        const S = l.testSepAxis(g, e, n, i, s, y);
        if (S === false) return false;
        S < a && (a = S, t.copy(g));
      }
    }
    return s.vsub(n, f), f.dot(t) > 0 && t.negate(t), true;
  }
  testSepAxis(e, n, i, s, y, t) {
    const o = this;
    ra.project(o, e, i, s, kl), ra.project(n, e, y, t, Ol);
    const u = kl[0], c = kl[1], h = Ol[0], f = Ol[1];
    if (u < f || h < c) return false;
    const r = u - f, m = h - c;
    return r < m ? r : m;
  }
  calculateLocalInertia(e, n) {
    const i = new lt(), s = new lt();
    this.computeLocalAABB(s, i);
    const y = i.x - s.x, t = i.y - s.y, o = i.z - s.z;
    n.x = 1 / 12 * e * (2 * t * 2 * t + 2 * o * 2 * o), n.y = 1 / 12 * e * (2 * y * 2 * y + 2 * o * 2 * o), n.z = 1 / 12 * e * (2 * t * 2 * t + 2 * y * 2 * y);
  }
  getPlaneConstantOfFace(e) {
    const n = this.faces[e], i = this.faceNormals[e], s = this.vertices[n[0]];
    return -i.dot(s);
  }
  clipFaceAgainstHull(e, n, i, s, y, t, o) {
    const u = new lt(), c = new lt(), h = new lt(), f = new lt(), r = new lt(), m = new lt(), g = new lt(), a = new lt(), l = this, d = [], b = s, S = d;
    let E = -1, R = Number.MAX_VALUE;
    for (let q = 0; q < l.faces.length; q++) {
      u.copy(l.faceNormals[q]), i.vmult(u, u);
      const D = u.dot(e);
      D < R && (R = D, E = q);
    }
    if (E < 0) return;
    const k = l.faces[E];
    k.connectedFaces = [];
    for (let q = 0; q < l.faces.length; q++) for (let D = 0; D < l.faces[q].length; D++) k.indexOf(l.faces[q][D]) !== -1 && q !== E && k.connectedFaces.indexOf(q) === -1 && k.connectedFaces.push(q);
    const w = k.length;
    for (let q = 0; q < w; q++) {
      const D = l.vertices[k[q]], H = l.vertices[k[(q + 1) % w]];
      D.vsub(H, c), h.copy(c), i.vmult(h, h), n.vadd(h, h), f.copy(this.faceNormals[E]), i.vmult(f, f), n.vadd(f, f), h.cross(f, r), r.negate(r), m.copy(D), i.vmult(m, m), n.vadd(m, m);
      const _ = k.connectedFaces[q];
      g.copy(this.faceNormals[_]);
      const T = this.getPlaneConstantOfFace(_);
      a.copy(g), i.vmult(a, a);
      const L = T - a.dot(n);
      for (this.clipFaceAgainstPlane(b, S, a, L); b.length; ) b.shift();
      for (; S.length; ) b.push(S.shift());
    }
    g.copy(this.faceNormals[E]);
    const F = this.getPlaneConstantOfFace(E);
    a.copy(g), i.vmult(a, a);
    const I = F - a.dot(n);
    for (let q = 0; q < b.length; q++) {
      let D = a.dot(b[q]) + I;
      if (D <= y && (D = y), D <= t) {
        const H = b[q];
        if (D <= 1e-6) {
          const _ = { point: H, normal: a, depth: D };
          o.push(_);
        }
      }
    }
  }
  clipFaceAgainstPlane(e, n, i, s) {
    let y, t;
    const o = e.length;
    if (o < 2) return n;
    let u = e[e.length - 1], c = e[0];
    y = i.dot(u) + s;
    for (let h = 0; h < o; h++) {
      if (c = e[h], t = i.dot(c) + s, y < 0) if (t < 0) {
        const f = new lt();
        f.copy(c), n.push(f);
      } else {
        const f = new lt();
        u.lerp(c, y / (y - t), f), n.push(f);
      }
      else if (t < 0) {
        const f = new lt();
        u.lerp(c, y / (y - t), f), n.push(f), n.push(c);
      }
      u = c, y = t;
    }
    return n;
  }
  computeWorldVertices(e, n) {
    for (; this.worldVertices.length < this.vertices.length; ) this.worldVertices.push(new lt());
    const i = this.vertices, s = this.worldVertices;
    for (let y = 0; y !== this.vertices.length; y++) n.vmult(i[y], s[y]), e.vadd(s[y], s[y]);
    this.worldVerticesNeedsUpdate = false;
  }
  computeLocalAABB(e, n) {
    const i = this.vertices;
    e.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    for (let s = 0; s < this.vertices.length; s++) {
      const y = i[s];
      y.x < e.x ? e.x = y.x : y.x > n.x && (n.x = y.x), y.y < e.y ? e.y = y.y : y.y > n.y && (n.y = y.y), y.z < e.z ? e.z = y.z : y.z > n.z && (n.z = y.z);
    }
  }
  computeWorldFaceNormals(e) {
    const n = this.faceNormals.length;
    for (; this.worldFaceNormals.length < n; ) this.worldFaceNormals.push(new lt());
    const i = this.faceNormals, s = this.worldFaceNormals;
    for (let y = 0; y !== n; y++) e.vmult(i[y], s[y]);
    this.worldFaceNormalsNeedsUpdate = false;
  }
  updateBoundingSphereRadius() {
    let e = 0;
    const n = this.vertices;
    for (let i = 0; i !== n.length; i++) {
      const s = n[i].lengthSquared();
      s > e && (e = s);
    }
    this.boundingSphereRadius = Math.sqrt(e);
  }
  calculateWorldAABB(e, n, i, s) {
    const y = this.vertices;
    let t, o, u, c, h, f, r = new lt();
    for (let m = 0; m < y.length; m++) {
      r.copy(y[m]), n.vmult(r, r), e.vadd(r, r);
      const g = r;
      (t === void 0 || g.x < t) && (t = g.x), (c === void 0 || g.x > c) && (c = g.x), (o === void 0 || g.y < o) && (o = g.y), (h === void 0 || g.y > h) && (h = g.y), (u === void 0 || g.z < u) && (u = g.z), (f === void 0 || g.z > f) && (f = g.z);
    }
    i.set(t, o, u), s.set(c, h, f);
  }
  volume() {
    return 4 * Math.PI * this.boundingSphereRadius / 3;
  }
  getAveragePointLocal(e) {
    e === void 0 && (e = new lt());
    const n = this.vertices;
    for (let i = 0; i < n.length; i++) e.vadd(n[i], e);
    return e.scale(1 / n.length, e), e;
  }
  transformAllPoints(e, n) {
    const i = this.vertices.length, s = this.vertices;
    if (n) {
      for (let y = 0; y < i; y++) {
        const t = s[y];
        n.vmult(t, t);
      }
      for (let y = 0; y < this.faceNormals.length; y++) {
        const t = this.faceNormals[y];
        n.vmult(t, t);
      }
    }
    if (e) for (let y = 0; y < i; y++) {
      const t = s[y];
      t.vadd(e, t);
    }
  }
  pointIsInside(e) {
    const n = this.vertices, i = this.faces, s = this.faceNormals, y = null, t = new lt();
    this.getAveragePointLocal(t);
    for (let o = 0; o < this.faces.length; o++) {
      let u = s[o];
      const c = n[i[o][0]], h = new lt();
      e.vsub(c, h);
      const f = u.dot(h), r = new lt();
      t.vsub(c, r);
      const m = u.dot(r);
      if (f < 0 && m > 0 || f > 0 && m < 0) return false;
    }
    return y ? 1 : -1;
  }
  static project(e, n, i, s, y) {
    const t = e.vertices.length, o = K1;
    let u = 0, c = 0;
    const h = X1, f = e.vertices;
    h.setZero(), Fn.vectorToLocalFrame(i, s, n, o), Fn.pointToLocalFrame(i, s, h, h);
    const r = h.dot(o);
    c = u = f[0].dot(o);
    for (let m = 1; m < t; m++) {
      const g = f[m].dot(o);
      g > u && (u = g), g < c && (c = g);
    }
    if (c -= r, u -= r, c > u) {
      const m = c;
      c = u, u = m;
    }
    y[0] = u, y[1] = c;
  }
}
const kl = [], Ol = [];
new lt();
const K1 = new lt(), X1 = new lt();
class ff extends hn {
  constructor(e) {
    super({ type: hn.types.BOX }), this.halfExtents = e, this.convexPolyhedronRepresentation = null, this.updateConvexPolyhedronRepresentation(), this.updateBoundingSphereRadius();
  }
  updateConvexPolyhedronRepresentation() {
    const e = this.halfExtents.x, n = this.halfExtents.y, i = this.halfExtents.z, s = lt, y = [new s(-e, -n, -i), new s(e, -n, -i), new s(e, n, -i), new s(-e, n, -i), new s(-e, -n, i), new s(e, -n, i), new s(e, n, i), new s(-e, n, i)], t = [[3, 2, 1, 0], [4, 5, 6, 7], [5, 4, 0, 1], [2, 3, 7, 6], [0, 4, 7, 3], [1, 2, 6, 5]], o = [new s(0, 0, 1), new s(0, 1, 0), new s(1, 0, 0)], u = new ra({ vertices: y, faces: t, axes: o });
    this.convexPolyhedronRepresentation = u, u.material = this.material;
  }
  calculateLocalInertia(e, n) {
    return n === void 0 && (n = new lt()), ff.calculateInertia(this.halfExtents, e, n), n;
  }
  static calculateInertia(e, n, i) {
    const s = e;
    i.x = 1 / 12 * n * (2 * s.y * 2 * s.y + 2 * s.z * 2 * s.z), i.y = 1 / 12 * n * (2 * s.x * 2 * s.x + 2 * s.z * 2 * s.z), i.z = 1 / 12 * n * (2 * s.y * 2 * s.y + 2 * s.x * 2 * s.x);
  }
  getSideNormals(e, n) {
    const i = e, s = this.halfExtents;
    if (i[0].set(s.x, 0, 0), i[1].set(0, s.y, 0), i[2].set(0, 0, s.z), i[3].set(-s.x, 0, 0), i[4].set(0, -s.y, 0), i[5].set(0, 0, -s.z), n !== void 0) for (let y = 0; y !== i.length; y++) n.vmult(i[y], i[y]);
    return i;
  }
  volume() {
    return 8 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = this.halfExtents.length();
  }
  forEachWorldCorner(e, n, i) {
    const s = this.halfExtents, y = [[s.x, s.y, s.z], [-s.x, s.y, s.z], [-s.x, -s.y, s.z], [-s.x, -s.y, -s.z], [s.x, -s.y, -s.z], [s.x, s.y, -s.z], [-s.x, s.y, -s.z], [s.x, -s.y, s.z]];
    for (let t = 0; t < y.length; t++) Do.set(y[t][0], y[t][1], y[t][2]), n.vmult(Do, Do), e.vadd(Do, Do), i(Do.x, Do.y, Do.z);
  }
  calculateWorldAABB(e, n, i, s) {
    const y = this.halfExtents;
    Ji[0].set(y.x, y.y, y.z), Ji[1].set(-y.x, y.y, y.z), Ji[2].set(-y.x, -y.y, y.z), Ji[3].set(-y.x, -y.y, -y.z), Ji[4].set(y.x, -y.y, -y.z), Ji[5].set(y.x, y.y, -y.z), Ji[6].set(-y.x, y.y, -y.z), Ji[7].set(y.x, -y.y, y.z);
    const t = Ji[0];
    n.vmult(t, t), e.vadd(t, t), s.copy(t), i.copy(t);
    for (let o = 1; o < 8; o++) {
      const u = Ji[o];
      n.vmult(u, u), e.vadd(u, u);
      const c = u.x, h = u.y, f = u.z;
      c > s.x && (s.x = c), h > s.y && (s.y = h), f > s.z && (s.z = f), c < i.x && (i.x = c), h < i.y && (i.y = h), f < i.z && (i.z = f);
    }
  }
}
const Do = new lt(), Ji = [new lt(), new lt(), new lt(), new lt(), new lt(), new lt(), new lt(), new lt()], pf = { DYNAMIC: 1, STATIC: 2, KINEMATIC: 4 }, hf = { AWAKE: 0, SLEEPY: 1, SLEEPING: 2 };
class nn extends Dm {
  constructor(e) {
    e === void 0 && (e = {}), super(), this.id = nn.idCounter++, this.index = -1, this.world = null, this.vlambda = new lt(), this.collisionFilterGroup = typeof e.collisionFilterGroup == "number" ? e.collisionFilterGroup : 1, this.collisionFilterMask = typeof e.collisionFilterMask == "number" ? e.collisionFilterMask : -1, this.collisionResponse = typeof e.collisionResponse == "boolean" ? e.collisionResponse : true, this.position = new lt(), this.previousPosition = new lt(), this.interpolatedPosition = new lt(), this.initPosition = new lt(), e.position && (this.position.copy(e.position), this.previousPosition.copy(e.position), this.interpolatedPosition.copy(e.position), this.initPosition.copy(e.position)), this.velocity = new lt(), e.velocity && this.velocity.copy(e.velocity), this.initVelocity = new lt(), this.force = new lt();
    const n = typeof e.mass == "number" ? e.mass : 0;
    this.mass = n, this.invMass = n > 0 ? 1 / n : 0, this.material = e.material || null, this.linearDamping = typeof e.linearDamping == "number" ? e.linearDamping : 0.01, this.type = n <= 0 ? nn.STATIC : nn.DYNAMIC, typeof e.type == typeof nn.STATIC && (this.type = e.type), this.allowSleep = typeof e.allowSleep < "u" ? e.allowSleep : true, this.sleepState = nn.AWAKE, this.sleepSpeedLimit = typeof e.sleepSpeedLimit < "u" ? e.sleepSpeedLimit : 0.1, this.sleepTimeLimit = typeof e.sleepTimeLimit < "u" ? e.sleepTimeLimit : 1, this.timeLastSleepy = 0, this.wakeUpAfterNarrowphase = false, this.torque = new lt(), this.quaternion = new ti(), this.initQuaternion = new ti(), this.previousQuaternion = new ti(), this.interpolatedQuaternion = new ti(), e.quaternion && (this.quaternion.copy(e.quaternion), this.initQuaternion.copy(e.quaternion), this.previousQuaternion.copy(e.quaternion), this.interpolatedQuaternion.copy(e.quaternion)), this.angularVelocity = new lt(), e.angularVelocity && this.angularVelocity.copy(e.angularVelocity), this.initAngularVelocity = new lt(), this.shapes = [], this.shapeOffsets = [], this.shapeOrientations = [], this.inertia = new lt(), this.invInertia = new lt(), this.invInertiaWorld = new Xi(), this.invMassSolve = 0, this.invInertiaSolve = new lt(), this.invInertiaWorldSolve = new Xi(), this.fixedRotation = typeof e.fixedRotation < "u" ? e.fixedRotation : false, this.angularDamping = typeof e.angularDamping < "u" ? e.angularDamping : 0.01, this.linearFactor = new lt(1, 1, 1), e.linearFactor && this.linearFactor.copy(e.linearFactor), this.angularFactor = new lt(1, 1, 1), e.angularFactor && this.angularFactor.copy(e.angularFactor), this.aabb = new Li(), this.aabbNeedsUpdate = true, this.boundingRadius = 0, this.wlambda = new lt(), this.isTrigger = !!e.isTrigger, e.shape && this.addShape(e.shape), this.updateMassProperties();
  }
  wakeUp() {
    const e = this.sleepState;
    this.sleepState = nn.AWAKE, this.wakeUpAfterNarrowphase = false, e === nn.SLEEPING && this.dispatchEvent(nn.wakeupEvent);
  }
  sleep() {
    this.sleepState = nn.SLEEPING, this.velocity.set(0, 0, 0), this.angularVelocity.set(0, 0, 0), this.wakeUpAfterNarrowphase = false;
  }
  sleepTick(e) {
    if (this.allowSleep) {
      const n = this.sleepState, i = this.velocity.lengthSquared() + this.angularVelocity.lengthSquared(), s = this.sleepSpeedLimit ** 2;
      n === nn.AWAKE && i < s ? (this.sleepState = nn.SLEEPY, this.timeLastSleepy = e, this.dispatchEvent(nn.sleepyEvent)) : n === nn.SLEEPY && i > s ? this.wakeUp() : n === nn.SLEEPY && e - this.timeLastSleepy > this.sleepTimeLimit && (this.sleep(), this.dispatchEvent(nn.sleepEvent));
    }
  }
  updateSolveMassProperties() {
    this.sleepState === nn.SLEEPING || this.type === nn.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve.setZero(), this.invInertiaWorldSolve.setZero()) : (this.invMassSolve = this.invMass, this.invInertiaSolve.copy(this.invInertia), this.invInertiaWorldSolve.copy(this.invInertiaWorld));
  }
  pointToLocalFrame(e, n) {
    return n === void 0 && (n = new lt()), e.vsub(this.position, n), this.quaternion.conjugate().vmult(n, n), n;
  }
  vectorToLocalFrame(e, n) {
    return n === void 0 && (n = new lt()), this.quaternion.conjugate().vmult(e, n), n;
  }
  pointToWorldFrame(e, n) {
    return n === void 0 && (n = new lt()), this.quaternion.vmult(e, n), n.vadd(this.position, n), n;
  }
  vectorToWorldFrame(e, n) {
    return n === void 0 && (n = new lt()), this.quaternion.vmult(e, n), n;
  }
  addShape(e, n, i) {
    const s = new lt(), y = new ti();
    return n && s.copy(n), i && y.copy(i), this.shapes.push(e), this.shapeOffsets.push(s), this.shapeOrientations.push(y), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, e.body = this, this;
  }
  removeShape(e) {
    const n = this.shapes.indexOf(e);
    return n === -1 ? (console.warn("Shape does not belong to the body"), this) : (this.shapes.splice(n, 1), this.shapeOffsets.splice(n, 1), this.shapeOrientations.splice(n, 1), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = true, e.body = null, this);
  }
  updateBoundingRadius() {
    const e = this.shapes, n = this.shapeOffsets, i = e.length;
    let s = 0;
    for (let y = 0; y !== i; y++) {
      const t = e[y];
      t.updateBoundingSphereRadius();
      const o = n[y].length(), u = t.boundingSphereRadius;
      o + u > s && (s = o + u);
    }
    this.boundingRadius = s;
  }
  updateAABB() {
    const e = this.shapes, n = this.shapeOffsets, i = this.shapeOrientations, s = e.length, y = $1, t = Y1, o = this.quaternion, u = this.aabb, c = Q1;
    for (let h = 0; h !== s; h++) {
      const f = e[h];
      o.vmult(n[h], y), y.vadd(this.position, y), o.mult(i[h], t), f.calculateWorldAABB(y, t, c.lowerBound, c.upperBound), h === 0 ? u.copy(c) : u.extend(c);
    }
    this.aabbNeedsUpdate = false;
  }
  updateInertiaWorld(e) {
    const n = this.invInertia;
    if (!(n.x === n.y && n.y === n.z && !e)) {
      const i = Z1, s = J1;
      i.setRotationFromQuaternion(this.quaternion), i.transpose(s), i.scale(n, i), i.mmult(s, this.invInertiaWorld);
    }
  }
  applyForce(e, n) {
    if (n === void 0 && (n = new lt()), this.type !== nn.DYNAMIC) return;
    this.sleepState === nn.SLEEPING && this.wakeUp();
    const i = eS;
    n.cross(e, i), this.force.vadd(e, this.force), this.torque.vadd(i, this.torque);
  }
  applyLocalForce(e, n) {
    if (n === void 0 && (n = new lt()), this.type !== nn.DYNAMIC) return;
    const i = tS, s = rS;
    this.vectorToWorldFrame(e, i), this.vectorToWorldFrame(n, s), this.applyForce(i, s);
  }
  applyTorque(e) {
    this.type === nn.DYNAMIC && (this.sleepState === nn.SLEEPING && this.wakeUp(), this.torque.vadd(e, this.torque));
  }
  applyImpulse(e, n) {
    if (n === void 0 && (n = new lt()), this.type !== nn.DYNAMIC) return;
    this.sleepState === nn.SLEEPING && this.wakeUp();
    const i = n, s = nS;
    s.copy(e), s.scale(this.invMass, s), this.velocity.vadd(s, this.velocity);
    const y = iS;
    i.cross(e, y), this.invInertiaWorld.vmult(y, y), this.angularVelocity.vadd(y, this.angularVelocity);
  }
  applyLocalImpulse(e, n) {
    if (n === void 0 && (n = new lt()), this.type !== nn.DYNAMIC) return;
    const i = oS, s = aS;
    this.vectorToWorldFrame(e, i), this.vectorToWorldFrame(n, s), this.applyImpulse(i, s);
  }
  updateMassProperties() {
    const e = sS;
    this.invMass = this.mass > 0 ? 1 / this.mass : 0;
    const n = this.inertia, i = this.fixedRotation;
    this.updateAABB(), e.set((this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2, (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2, (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2), ff.calculateInertia(e, this.mass, n), this.invInertia.set(n.x > 0 && !i ? 1 / n.x : 0, n.y > 0 && !i ? 1 / n.y : 0, n.z > 0 && !i ? 1 / n.z : 0), this.updateInertiaWorld(true);
  }
  getVelocityAtWorldPoint(e, n) {
    const i = new lt();
    return e.vsub(this.position, i), this.angularVelocity.cross(i, n), this.velocity.vadd(n, n), n;
  }
  integrate(e, n, i) {
    if (this.previousPosition.copy(this.position), this.previousQuaternion.copy(this.quaternion), !(this.type === nn.DYNAMIC || this.type === nn.KINEMATIC) || this.sleepState === nn.SLEEPING) return;
    const s = this.velocity, y = this.angularVelocity, t = this.position, o = this.force, u = this.torque, c = this.quaternion, h = this.invMass, f = this.invInertiaWorld, r = this.linearFactor, m = h * e;
    s.x += o.x * m * r.x, s.y += o.y * m * r.y, s.z += o.z * m * r.z;
    const g = f.elements, a = this.angularFactor, l = u.x * a.x, d = u.y * a.y, b = u.z * a.z;
    y.x += e * (g[0] * l + g[1] * d + g[2] * b), y.y += e * (g[3] * l + g[4] * d + g[5] * b), y.z += e * (g[6] * l + g[7] * d + g[8] * b), t.x += s.x * e, t.y += s.y * e, t.z += s.z * e, c.integrate(this.angularVelocity, e, this.angularFactor, c), n && (i ? c.normalizeFast() : c.normalize()), this.aabbNeedsUpdate = true, this.updateInertiaWorld();
  }
}
nn.idCounter = 0;
nn.COLLIDE_EVENT_NAME = "collide";
nn.DYNAMIC = pf.DYNAMIC;
nn.STATIC = pf.STATIC;
nn.KINEMATIC = pf.KINEMATIC;
nn.AWAKE = hf.AWAKE;
nn.SLEEPY = hf.SLEEPY;
nn.SLEEPING = hf.SLEEPING;
nn.wakeupEvent = { type: "wakeup" };
nn.sleepyEvent = { type: "sleepy" };
nn.sleepEvent = { type: "sleep" };
const $1 = new lt(), Y1 = new ti(), Q1 = new Li(), Z1 = new Xi(), J1 = new Xi();
new Xi();
const eS = new lt(), tS = new lt(), rS = new lt(), nS = new lt(), iS = new lt(), oS = new lt(), aS = new lt(), sS = new lt();
class uS {
  constructor() {
    this.world = null, this.useBoundingBoxes = false, this.dirty = true;
  }
  collisionPairs(e, n, i) {
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
  }
  needBroadphaseCollision(e, n) {
    return !((e.collisionFilterGroup & n.collisionFilterMask) === 0 || (n.collisionFilterGroup & e.collisionFilterMask) === 0 || ((e.type & nn.STATIC) !== 0 || e.sleepState === nn.SLEEPING) && ((n.type & nn.STATIC) !== 0 || n.sleepState === nn.SLEEPING));
  }
  intersectionTest(e, n, i, s) {
    this.useBoundingBoxes ? this.doBoundingBoxBroadphase(e, n, i, s) : this.doBoundingSphereBroadphase(e, n, i, s);
  }
  doBoundingSphereBroadphase(e, n, i, s) {
    const y = cS;
    n.position.vsub(e.position, y);
    const t = (e.boundingRadius + n.boundingRadius) ** 2;
    y.lengthSquared() < t && (i.push(e), s.push(n));
  }
  doBoundingBoxBroadphase(e, n, i, s) {
    e.aabbNeedsUpdate && e.updateAABB(), n.aabbNeedsUpdate && n.updateAABB(), e.aabb.overlaps(n.aabb) && (i.push(e), s.push(n));
  }
  makePairsUnique(e, n) {
    const i = lS, s = fS, y = pS, t = e.length;
    for (let o = 0; o !== t; o++) s[o] = e[o], y[o] = n[o];
    e.length = 0, n.length = 0;
    for (let o = 0; o !== t; o++) {
      const u = s[o].id, c = y[o].id, h = u < c ? `${u},${c}` : `${c},${u}`;
      i[h] = o, i.keys.push(h);
    }
    for (let o = 0; o !== i.keys.length; o++) {
      const u = i.keys.pop(), c = i[u];
      e.push(s[c]), n.push(y[c]), delete i[u];
    }
  }
  setWorld(e) {
  }
  static boundingSphereCheck(e, n) {
    const i = new lt();
    e.position.vsub(n.position, i);
    const s = e.shapes[0], y = n.shapes[0];
    return Math.pow(s.boundingSphereRadius + y.boundingSphereRadius, 2) > i.lengthSquared();
  }
  aabbQuery(e, n, i) {
    return console.warn(".aabbQuery is not implemented in this Broadphase subclass."), [];
  }
}
const cS = new lt();
new lt();
new ti();
new lt();
const lS = { keys: [] }, fS = [], pS = [];
new lt();
new lt();
new lt();
class Fm extends uS {
  constructor() {
    super();
  }
  collisionPairs(e, n, i) {
    const s = e.bodies, y = s.length;
    let t, o;
    for (let u = 0; u !== y; u++) for (let c = 0; c !== u; c++) t = s[u], o = s[c], this.needBroadphaseCollision(t, o) && this.intersectionTest(t, o, n, i);
  }
  aabbQuery(e, n, i) {
    i === void 0 && (i = []);
    for (let s = 0; s < e.bodies.length; s++) {
      const y = e.bodies[s];
      y.aabbNeedsUpdate && y.updateAABB(), y.aabb.overlaps(n) && i.push(y);
    }
    return i;
  }
}
class wc {
  constructor() {
    this.rayFromWorld = new lt(), this.rayToWorld = new lt(), this.hitNormalWorld = new lt(), this.hitPointWorld = new lt(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
  }
  reset() {
    this.rayFromWorld.setZero(), this.rayToWorld.setZero(), this.hitNormalWorld.setZero(), this.hitPointWorld.setZero(), this.hasHit = false, this.shape = null, this.body = null, this.hitFaceIndex = -1, this.distance = -1, this.shouldStop = false;
  }
  abort() {
    this.shouldStop = true;
  }
  set(e, n, i, s, y, t, o) {
    this.rayFromWorld.copy(e), this.rayToWorld.copy(n), this.hitNormalWorld.copy(i), this.hitPointWorld.copy(s), this.shape = y, this.body = t, this.distance = o;
  }
}
let Um, jm, Vm, qm, zm, Hm, Gm;
const df = { CLOSEST: 1, ANY: 2, ALL: 4 };
Um = hn.types.SPHERE;
jm = hn.types.PLANE;
Vm = hn.types.BOX;
qm = hn.types.CYLINDER;
zm = hn.types.CONVEXPOLYHEDRON;
Hm = hn.types.HEIGHTFIELD;
Gm = hn.types.TRIMESH;
class ei {
  get [Um]() {
    return this._intersectSphere;
  }
  get [jm]() {
    return this._intersectPlane;
  }
  get [Vm]() {
    return this._intersectBox;
  }
  get [qm]() {
    return this._intersectConvex;
  }
  get [zm]() {
    return this._intersectConvex;
  }
  get [Hm]() {
    return this._intersectHeightfield;
  }
  get [Gm]() {
    return this._intersectTrimesh;
  }
  constructor(e, n) {
    e === void 0 && (e = new lt()), n === void 0 && (n = new lt()), this.from = e.clone(), this.to = n.clone(), this.direction = new lt(), this.precision = 1e-4, this.checkCollisionResponse = true, this.skipBackfaces = false, this.collisionFilterMask = -1, this.collisionFilterGroup = -1, this.mode = ei.ANY, this.result = new wc(), this.hasHit = false, this.callback = (i) => {
    };
  }
  intersectWorld(e, n) {
    return this.mode = n.mode || ei.ANY, this.result = n.result || new wc(), this.skipBackfaces = !!n.skipBackfaces, this.collisionFilterMask = typeof n.collisionFilterMask < "u" ? n.collisionFilterMask : -1, this.collisionFilterGroup = typeof n.collisionFilterGroup < "u" ? n.collisionFilterGroup : -1, this.checkCollisionResponse = typeof n.checkCollisionResponse < "u" ? n.checkCollisionResponse : true, n.from && this.from.copy(n.from), n.to && this.to.copy(n.to), this.callback = n.callback || (() => {
    }), this.hasHit = false, this.result.reset(), this.updateDirection(), this.getAABB(md), Pl.length = 0, e.broadphase.aabbQuery(e, md, Pl), this.intersectBodies(Pl), this.hasHit;
  }
  intersectBody(e, n) {
    n && (this.result = n, this.updateDirection());
    const i = this.checkCollisionResponse;
    if (i && !e.collisionResponse || (this.collisionFilterGroup & e.collisionFilterMask) === 0 || (e.collisionFilterGroup & this.collisionFilterMask) === 0) return;
    const s = hS, y = dS;
    for (let t = 0, o = e.shapes.length; t < o; t++) {
      const u = e.shapes[t];
      if (!(i && !u.collisionResponse) && (e.quaternion.mult(e.shapeOrientations[t], y), e.quaternion.vmult(e.shapeOffsets[t], s), s.vadd(e.position, s), this.intersectShape(u, y, s, e), this.result.shouldStop)) break;
    }
  }
  intersectBodies(e, n) {
    n && (this.result = n, this.updateDirection());
    for (let i = 0, s = e.length; !this.result.shouldStop && i < s; i++) this.intersectBody(e[i]);
  }
  updateDirection() {
    this.to.vsub(this.from, this.direction), this.direction.normalize();
  }
  intersectShape(e, n, i, s) {
    const y = this.from;
    if (OS(y, this.direction, i) > e.boundingSphereRadius) return;
    const t = this[e.type];
    t && t.call(this, e, n, i, s, e);
  }
  _intersectBox(e, n, i, s, y) {
    return this._intersectConvex(e.convexPolyhedronRepresentation, n, i, s, y);
  }
  _intersectPlane(e, n, i, s, y) {
    const t = this.from, o = this.to, u = this.direction, c = new lt(0, 0, 1);
    n.vmult(c, c);
    const h = new lt();
    t.vsub(i, h);
    const f = h.dot(c);
    o.vsub(i, h);
    const r = h.dot(c);
    if (f * r > 0 || t.distanceTo(o) < f) return;
    const m = c.dot(u);
    if (Math.abs(m) < this.precision) return;
    const g = new lt(), a = new lt(), l = new lt();
    t.vsub(i, g);
    const d = -c.dot(g) / m;
    u.scale(d, a), t.vadd(a, l), this.reportIntersection(c, l, y, s, -1);
  }
  getAABB(e) {
    const { lowerBound: n, upperBound: i } = e, s = this.to, y = this.from;
    n.x = Math.min(s.x, y.x), n.y = Math.min(s.y, y.y), n.z = Math.min(s.z, y.z), i.x = Math.max(s.x, y.x), i.y = Math.max(s.y, y.y), i.z = Math.max(s.z, y.z);
  }
  _intersectHeightfield(e, n, i, s, y) {
    e.data, e.elementSize;
    const t = mS;
    t.from.copy(this.from), t.to.copy(this.to), Fn.pointToLocalFrame(i, n, t.from, t.from), Fn.pointToLocalFrame(i, n, t.to, t.to), t.updateDirection();
    const o = yS;
    let u, c, h, f;
    u = c = 0, h = f = e.data.length - 1;
    const r = new Li();
    t.getAABB(r), e.getIndexOfPosition(r.lowerBound.x, r.lowerBound.y, o, true), u = Math.max(u, o[0]), c = Math.max(c, o[1]), e.getIndexOfPosition(r.upperBound.x, r.upperBound.y, o, true), h = Math.min(h, o[0] + 1), f = Math.min(f, o[1] + 1);
    for (let m = u; m < h; m++) for (let g = c; g < f; g++) {
      if (this.result.shouldStop) return;
      if (e.getAabbAtIndex(m, g, r), !!r.overlapsRay(t)) {
        if (e.getConvexTrianglePillar(m, g, false), Fn.pointToWorldFrame(i, n, e.pillarOffset, Xu), this._intersectConvex(e.pillarConvex, n, Xu, s, y, yd), this.result.shouldStop) return;
        e.getConvexTrianglePillar(m, g, true), Fn.pointToWorldFrame(i, n, e.pillarOffset, Xu), this._intersectConvex(e.pillarConvex, n, Xu, s, y, yd);
      }
    }
  }
  _intersectSphere(e, n, i, s, y) {
    const t = this.from, o = this.to, u = e.radius, c = (o.x - t.x) ** 2 + (o.y - t.y) ** 2 + (o.z - t.z) ** 2, h = 2 * ((o.x - t.x) * (t.x - i.x) + (o.y - t.y) * (t.y - i.y) + (o.z - t.z) * (t.z - i.z)), f = (t.x - i.x) ** 2 + (t.y - i.y) ** 2 + (t.z - i.z) ** 2 - u ** 2, r = h ** 2 - 4 * c * f, m = gS, g = vS;
    if (!(r < 0)) if (r === 0) t.lerp(o, r, m), m.vsub(i, g), g.normalize(), this.reportIntersection(g, m, y, s, -1);
    else {
      const a = (-h - Math.sqrt(r)) / (2 * c), l = (-h + Math.sqrt(r)) / (2 * c);
      if (a >= 0 && a <= 1 && (t.lerp(o, a, m), m.vsub(i, g), g.normalize(), this.reportIntersection(g, m, y, s, -1)), this.result.shouldStop) return;
      l >= 0 && l <= 1 && (t.lerp(o, l, m), m.vsub(i, g), g.normalize(), this.reportIntersection(g, m, y, s, -1));
    }
  }
  _intersectConvex(e, n, i, s, y, t) {
    const o = bS, u = gd, c = t && t.faceList || null, h = e.faces, f = e.vertices, r = e.faceNormals, m = this.direction, g = this.from, a = this.to, l = g.distanceTo(a), d = c ? c.length : h.length, b = this.result;
    for (let S = 0; !b.shouldStop && S < d; S++) {
      const E = c ? c[S] : S, R = h[E], k = r[E], w = n, F = i;
      u.copy(f[R[0]]), w.vmult(u, u), u.vadd(F, u), u.vsub(g, u), w.vmult(k, o);
      const I = m.dot(o);
      if (Math.abs(I) < this.precision) continue;
      const q = o.dot(u) / I;
      if (!(q < 0)) {
        m.scale(q, xi), xi.vadd(g, xi), Wi.copy(f[R[0]]), w.vmult(Wi, Wi), F.vadd(Wi, Wi);
        for (let D = 1; !b.shouldStop && D < R.length - 1; D++) {
          eo.copy(f[R[D]]), to.copy(f[R[D + 1]]), w.vmult(eo, eo), w.vmult(to, to), F.vadd(eo, eo), F.vadd(to, to);
          const H = xi.distanceTo(g);
          !(ei.pointInTriangle(xi, Wi, eo, to) || ei.pointInTriangle(xi, eo, Wi, to)) || H > l || this.reportIntersection(o, xi, y, s, E);
        }
      }
    }
  }
  _intersectTrimesh(e, n, i, s, y, t) {
    const o = wS, u = TS, c = kS, h = gd, f = SS, r = _S, m = ES, g = xS, a = AS, l = e.indices;
    e.vertices;
    const d = this.from, b = this.to, S = this.direction;
    c.position.copy(i), c.quaternion.copy(n), Fn.vectorToLocalFrame(i, n, S, f), Fn.pointToLocalFrame(i, n, d, r), Fn.pointToLocalFrame(i, n, b, m), m.x *= e.scale.x, m.y *= e.scale.y, m.z *= e.scale.z, r.x *= e.scale.x, r.y *= e.scale.y, r.z *= e.scale.z, m.vsub(r, f), f.normalize();
    const E = r.distanceSquared(m);
    e.tree.rayQuery(this, c, u);
    for (let R = 0, k = u.length; !this.result.shouldStop && R !== k; R++) {
      const w = u[R];
      e.getNormal(w, o), e.getVertex(l[w * 3], Wi), Wi.vsub(r, h);
      const F = f.dot(o), I = o.dot(h) / F;
      if (I < 0) continue;
      f.scale(I, xi), xi.vadd(r, xi), e.getVertex(l[w * 3 + 1], eo), e.getVertex(l[w * 3 + 2], to);
      const q = xi.distanceSquared(r);
      !(ei.pointInTriangle(xi, eo, Wi, to) || ei.pointInTriangle(xi, Wi, eo, to)) || q > E || (Fn.vectorToWorldFrame(n, o, a), Fn.pointToWorldFrame(i, n, xi, g), this.reportIntersection(a, g, y, s, w));
    }
    u.length = 0;
  }
  reportIntersection(e, n, i, s, y) {
    const t = this.from, o = this.to, u = t.distanceTo(n), c = this.result;
    if (!(this.skipBackfaces && e.dot(this.direction) > 0)) switch (c.hitFaceIndex = typeof y < "u" ? y : -1, this.mode) {
      case ei.ALL:
        this.hasHit = true, c.set(t, o, e, n, i, s, u), c.hasHit = true, this.callback(c);
        break;
      case ei.CLOSEST:
        (u < c.distance || !c.hasHit) && (this.hasHit = true, c.hasHit = true, c.set(t, o, e, n, i, s, u));
        break;
      case ei.ANY:
        this.hasHit = true, c.hasHit = true, c.set(t, o, e, n, i, s, u), c.shouldStop = true;
        break;
    }
  }
  static pointInTriangle(e, n, i, s) {
    s.vsub(n, Jo), i.vsub(n, Ss), e.vsub(n, Cl);
    const y = Jo.dot(Jo), t = Jo.dot(Ss), o = Jo.dot(Cl), u = Ss.dot(Ss), c = Ss.dot(Cl);
    let h, f;
    return (h = u * o - t * c) >= 0 && (f = y * c - t * o) >= 0 && h + f < y * u - t * t;
  }
}
ei.CLOSEST = df.CLOSEST;
ei.ANY = df.ANY;
ei.ALL = df.ALL;
const md = new Li(), Pl = [], Ss = new lt(), Cl = new lt(), hS = new lt(), dS = new ti(), xi = new lt(), Wi = new lt(), eo = new lt(), to = new lt();
new lt();
new wc();
const yd = { faceList: [0] }, Xu = new lt(), mS = new ei(), yS = [], gS = new lt(), vS = new lt(), bS = new lt();
new lt();
new lt();
const gd = new lt(), wS = new lt(), SS = new lt(), _S = new lt(), ES = new lt(), AS = new lt(), xS = new lt();
new Li();
const TS = [], kS = new Fn(), Jo = new lt(), $u = new lt();
function OS(v, e, n) {
  n.vsub(v, Jo);
  const i = Jo.dot(e);
  return e.scale(i, $u), $u.vadd(v, $u), n.distanceTo($u);
}
class PS {
  static defaults(e, n) {
    e === void 0 && (e = {});
    for (let i in n) i in e || (e[i] = n[i]);
    return e;
  }
}
class vd {
  constructor() {
    this.spatial = new lt(), this.rotational = new lt();
  }
  multiplyElement(e) {
    return e.spatial.dot(this.spatial) + e.rotational.dot(this.rotational);
  }
  multiplyVectors(e, n) {
    return e.dot(this.spatial) + n.dot(this.rotational);
  }
}
class zs {
  constructor(e, n, i, s) {
    i === void 0 && (i = -1e6), s === void 0 && (s = 1e6), this.id = zs.idCounter++, this.minForce = i, this.maxForce = s, this.bi = e, this.bj = n, this.a = 0, this.b = 0, this.eps = 0, this.jacobianElementA = new vd(), this.jacobianElementB = new vd(), this.enabled = true, this.multiplier = 0, this.setSpookParams(1e7, 4, 1 / 60);
  }
  setSpookParams(e, n, i) {
    const s = n, y = e, t = i;
    this.a = 4 / (t * (1 + 4 * s)), this.b = 4 * s / (1 + 4 * s), this.eps = 4 / (t * t * y * (1 + 4 * s));
  }
  computeB(e, n, i) {
    const s = this.computeGW(), y = this.computeGq(), t = this.computeGiMf();
    return -y * e - s * n - t * i;
  }
  computeGq() {
    const e = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, y = i.position, t = s.position;
    return e.spatial.dot(y) + n.spatial.dot(t);
  }
  computeGW() {
    const e = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, y = i.velocity, t = s.velocity, o = i.angularVelocity, u = s.angularVelocity;
    return e.multiplyVectors(y, o) + n.multiplyVectors(t, u);
  }
  computeGWlambda() {
    const e = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, y = i.vlambda, t = s.vlambda, o = i.wlambda, u = s.wlambda;
    return e.multiplyVectors(y, o) + n.multiplyVectors(t, u);
  }
  computeGiMf() {
    const e = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, y = i.force, t = i.torque, o = s.force, u = s.torque, c = i.invMassSolve, h = s.invMassSolve;
    return y.scale(c, bd), o.scale(h, wd), i.invInertiaWorldSolve.vmult(t, Sd), s.invInertiaWorldSolve.vmult(u, _d), e.multiplyVectors(bd, Sd) + n.multiplyVectors(wd, _d);
  }
  computeGiMGt() {
    const e = this.jacobianElementA, n = this.jacobianElementB, i = this.bi, s = this.bj, y = i.invMassSolve, t = s.invMassSolve, o = i.invInertiaWorldSolve, u = s.invInertiaWorldSolve;
    let c = y + t;
    return o.vmult(e.rotational, Yu), c += Yu.dot(e.rotational), u.vmult(n.rotational, Yu), c += Yu.dot(n.rotational), c;
  }
  addToWlambda(e) {
    const n = this.jacobianElementA, i = this.jacobianElementB, s = this.bi, y = this.bj, t = CS;
    s.vlambda.addScaledVector(s.invMassSolve * e, n.spatial, s.vlambda), y.vlambda.addScaledVector(y.invMassSolve * e, i.spatial, y.vlambda), s.invInertiaWorldSolve.vmult(n.rotational, t), s.wlambda.addScaledVector(e, t, s.wlambda), y.invInertiaWorldSolve.vmult(i.rotational, t), y.wlambda.addScaledVector(e, t, y.wlambda);
  }
  computeC() {
    return this.computeGiMGt() + this.eps;
  }
}
zs.idCounter = 0;
const bd = new lt(), wd = new lt(), Sd = new lt(), _d = new lt(), Yu = new lt(), CS = new lt();
class RS extends zs {
  constructor(e, n, i) {
    i === void 0 && (i = 1e6), super(e, n, 0, i), this.restitution = 0, this.ri = new lt(), this.rj = new lt(), this.ni = new lt();
  }
  computeB(e) {
    const n = this.a, i = this.b, s = this.bi, y = this.bj, t = this.ri, o = this.rj, u = MS, c = IS, h = s.velocity, f = s.angularVelocity;
    s.force, s.torque;
    const r = y.velocity, m = y.angularVelocity;
    y.force, y.torque;
    const g = LS, a = this.jacobianElementA, l = this.jacobianElementB, d = this.ni;
    t.cross(d, u), o.cross(d, c), d.negate(a.spatial), u.negate(a.rotational), l.spatial.copy(d), l.rotational.copy(c), g.copy(y.position), g.vadd(o, g), g.vsub(s.position, g), g.vsub(t, g);
    const b = d.dot(g), S = this.restitution + 1, E = S * r.dot(d) - S * h.dot(d) + m.dot(c) - f.dot(u), R = this.computeGiMf();
    return -b * n - E * i - e * R;
  }
  getImpactVelocityAlongNormal() {
    const e = BS, n = NS, i = DS, s = FS, y = US;
    return this.bi.position.vadd(this.ri, i), this.bj.position.vadd(this.rj, s), this.bi.getVelocityAtWorldPoint(i, e), this.bj.getVelocityAtWorldPoint(s, n), e.vsub(n, y), this.ni.dot(y);
  }
}
const MS = new lt(), IS = new lt(), LS = new lt(), BS = new lt(), NS = new lt(), DS = new lt(), FS = new lt(), US = new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
class Ed extends zs {
  constructor(e, n, i) {
    super(e, n, -i, i), this.ri = new lt(), this.rj = new lt(), this.t = new lt();
  }
  computeB(e) {
    this.a;
    const n = this.b;
    this.bi, this.bj;
    const i = this.ri, s = this.rj, y = jS, t = VS, o = this.t;
    i.cross(o, y), s.cross(o, t);
    const u = this.jacobianElementA, c = this.jacobianElementB;
    o.negate(u.spatial), y.negate(u.rotational), c.spatial.copy(o), c.rotational.copy(t);
    const h = this.computeGW(), f = this.computeGiMf();
    return -h * n - e * f;
  }
}
const jS = new lt(), VS = new lt();
class na {
  constructor(e, n, i) {
    i = PS.defaults(i, { friction: 0.3, restitution: 0.3, contactEquationStiffness: 1e7, contactEquationRelaxation: 3, frictionEquationStiffness: 1e7, frictionEquationRelaxation: 3 }), this.id = na.idCounter++, this.materials = [e, n], this.friction = i.friction, this.restitution = i.restitution, this.contactEquationStiffness = i.contactEquationStiffness, this.contactEquationRelaxation = i.contactEquationRelaxation, this.frictionEquationStiffness = i.frictionEquationStiffness, this.frictionEquationRelaxation = i.frictionEquationRelaxation;
  }
}
na.idCounter = 0;
class ia {
  constructor(e) {
    e === void 0 && (e = {});
    let n = "";
    typeof e == "string" && (n = e, e = {}), this.name = n, this.id = ia.idCounter++, this.friction = typeof e.friction < "u" ? e.friction : -1, this.restitution = typeof e.restitution < "u" ? e.restitution : -1;
  }
}
ia.idCounter = 0;
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new ei();
new lt();
new lt();
new lt();
new lt(1, 0, 0), new lt(0, 1, 0), new lt(0, 0, 1);
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
class qS extends ra {
  constructor(e, n, i, s) {
    if (e === void 0 && (e = 1), n === void 0 && (n = 1), i === void 0 && (i = 1), s === void 0 && (s = 8), e < 0) throw new Error("The cylinder radiusTop cannot be negative.");
    if (n < 0) throw new Error("The cylinder radiusBottom cannot be negative.");
    const y = s, t = [], o = [], u = [], c = [], h = [], f = Math.cos, r = Math.sin;
    t.push(new lt(-n * r(0), -i * 0.5, n * f(0))), c.push(0), t.push(new lt(-e * r(0), i * 0.5, e * f(0))), h.push(1);
    for (let g = 0; g < y; g++) {
      const a = 2 * Math.PI / y * (g + 1), l = 2 * Math.PI / y * (g + 0.5);
      g < y - 1 ? (t.push(new lt(-n * r(a), -i * 0.5, n * f(a))), c.push(2 * g + 2), t.push(new lt(-e * r(a), i * 0.5, e * f(a))), h.push(2 * g + 3), u.push([2 * g, 2 * g + 1, 2 * g + 3, 2 * g + 2])) : u.push([2 * g, 2 * g + 1, 1, 0]), (y % 2 === 1 || g < y / 2) && o.push(new lt(-r(l), 0, f(l)));
    }
    u.push(c), o.push(new lt(0, 1, 0));
    const m = [];
    for (let g = 0; g < h.length; g++) m.push(h[h.length - g - 1]);
    u.push(m), super({ vertices: t, faces: u, axes: o }), this.type = hn.types.CYLINDER, this.radiusTop = e, this.radiusBottom = n, this.height = i, this.numSegments = s;
  }
}
class _s extends hn {
  constructor() {
    super({ type: hn.types.PLANE }), this.worldNormal = new lt(), this.worldNormalNeedsUpdate = true, this.boundingSphereRadius = Number.MAX_VALUE;
  }
  computeWorldNormal(e) {
    const n = this.worldNormal;
    n.set(0, 0, 1), e.vmult(n, n), this.worldNormalNeedsUpdate = false;
  }
  calculateLocalInertia(e, n) {
    return n === void 0 && (n = new lt()), n;
  }
  volume() {
    return Number.MAX_VALUE;
  }
  calculateWorldAABB(e, n, i, s) {
    go.set(0, 0, 1), n.vmult(go, go);
    const y = Number.MAX_VALUE;
    i.set(-y, -y, -y), s.set(y, y, y), go.x === 1 ? s.x = e.x : go.x === -1 && (i.x = e.x), go.y === 1 ? s.y = e.y : go.y === -1 && (i.y = e.y), go.z === 1 ? s.z = e.z : go.z === -1 && (i.z = e.z);
  }
  updateBoundingSphereRadius() {
    this.boundingSphereRadius = Number.MAX_VALUE;
  }
}
const go = new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new Li();
new lt();
new Li();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new lt();
new Li();
new lt();
new Fn();
new Li();
class zS {
  constructor() {
    this.equations = [];
  }
  solve(e, n) {
    return 0;
  }
  addEquation(e) {
    e.enabled && !e.bi.isTrigger && !e.bj.isTrigger && this.equations.push(e);
  }
  removeEquation(e) {
    const n = this.equations, i = n.indexOf(e);
    i !== -1 && n.splice(i, 1);
  }
  removeAllEquations() {
    this.equations.length = 0;
  }
}
class HS extends zS {
  constructor() {
    super(), this.iterations = 10, this.tolerance = 1e-7;
  }
  solve(e, n) {
    let i = 0;
    const s = this.iterations, y = this.tolerance * this.tolerance, t = this.equations, o = t.length, u = n.bodies, c = u.length, h = e;
    let f, r, m, g, a, l;
    if (o !== 0) for (let E = 0; E !== c; E++) u[E].updateSolveMassProperties();
    const d = WS, b = KS, S = GS;
    d.length = o, b.length = o, S.length = o;
    for (let E = 0; E !== o; E++) {
      const R = t[E];
      S[E] = 0, b[E] = R.computeB(h), d[E] = 1 / R.computeC();
    }
    if (o !== 0) {
      for (let k = 0; k !== c; k++) {
        const w = u[k], F = w.vlambda, I = w.wlambda;
        F.set(0, 0, 0), I.set(0, 0, 0);
      }
      for (i = 0; i !== s; i++) {
        g = 0;
        for (let k = 0; k !== o; k++) {
          const w = t[k];
          f = b[k], r = d[k], l = S[k], a = w.computeGWlambda(), m = r * (f - a - w.eps * l), l + m < w.minForce ? m = w.minForce - l : l + m > w.maxForce && (m = w.maxForce - l), S[k] += m, g += m > 0 ? m : -m, w.addToWlambda(m);
        }
        if (g * g < y) break;
      }
      for (let k = 0; k !== c; k++) {
        const w = u[k], F = w.velocity, I = w.angularVelocity;
        w.vlambda.vmul(w.linearFactor, w.vlambda), F.vadd(w.vlambda, F), w.wlambda.vmul(w.angularFactor, w.wlambda), I.vadd(w.wlambda, I);
      }
      let E = t.length;
      const R = 1 / h;
      for (; E--; ) t[E].multiplier = S[E] * R;
    }
    return i;
  }
}
const GS = [], WS = [], KS = [];
class XS {
  constructor() {
    this.objects = [], this.type = Object;
  }
  release() {
    const e = arguments.length;
    for (let n = 0; n !== e; n++) this.objects.push(n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    return this;
  }
  get() {
    return this.objects.length === 0 ? this.constructObject() : this.objects.pop();
  }
  constructObject() {
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
  }
  resize(e) {
    const n = this.objects;
    for (; n.length > e; ) n.pop();
    for (; n.length < e; ) n.push(this.constructObject());
    return this;
  }
}
class $S extends XS {
  constructor() {
    super(...arguments), this.type = lt;
  }
  constructObject() {
    return new lt();
  }
}
const Wn = { sphereSphere: hn.types.SPHERE, spherePlane: hn.types.SPHERE | hn.types.PLANE, boxBox: hn.types.BOX | hn.types.BOX, sphereBox: hn.types.SPHERE | hn.types.BOX, planeBox: hn.types.PLANE | hn.types.BOX, convexConvex: hn.types.CONVEXPOLYHEDRON, sphereConvex: hn.types.SPHERE | hn.types.CONVEXPOLYHEDRON, planeConvex: hn.types.PLANE | hn.types.CONVEXPOLYHEDRON, boxConvex: hn.types.BOX | hn.types.CONVEXPOLYHEDRON, sphereHeightfield: hn.types.SPHERE | hn.types.HEIGHTFIELD, boxHeightfield: hn.types.BOX | hn.types.HEIGHTFIELD, convexHeightfield: hn.types.CONVEXPOLYHEDRON | hn.types.HEIGHTFIELD, sphereParticle: hn.types.PARTICLE | hn.types.SPHERE, planeParticle: hn.types.PLANE | hn.types.PARTICLE, boxParticle: hn.types.BOX | hn.types.PARTICLE, convexParticle: hn.types.PARTICLE | hn.types.CONVEXPOLYHEDRON, cylinderCylinder: hn.types.CYLINDER, sphereCylinder: hn.types.SPHERE | hn.types.CYLINDER, planeCylinder: hn.types.PLANE | hn.types.CYLINDER, boxCylinder: hn.types.BOX | hn.types.CYLINDER, convexCylinder: hn.types.CONVEXPOLYHEDRON | hn.types.CYLINDER, heightfieldCylinder: hn.types.HEIGHTFIELD | hn.types.CYLINDER, particleCylinder: hn.types.PARTICLE | hn.types.CYLINDER, sphereTrimesh: hn.types.SPHERE | hn.types.TRIMESH, planeTrimesh: hn.types.PLANE | hn.types.TRIMESH };
class YS {
  get [Wn.sphereSphere]() {
    return this.sphereSphere;
  }
  get [Wn.spherePlane]() {
    return this.spherePlane;
  }
  get [Wn.boxBox]() {
    return this.boxBox;
  }
  get [Wn.sphereBox]() {
    return this.sphereBox;
  }
  get [Wn.planeBox]() {
    return this.planeBox;
  }
  get [Wn.convexConvex]() {
    return this.convexConvex;
  }
  get [Wn.sphereConvex]() {
    return this.sphereConvex;
  }
  get [Wn.planeConvex]() {
    return this.planeConvex;
  }
  get [Wn.boxConvex]() {
    return this.boxConvex;
  }
  get [Wn.sphereHeightfield]() {
    return this.sphereHeightfield;
  }
  get [Wn.boxHeightfield]() {
    return this.boxHeightfield;
  }
  get [Wn.convexHeightfield]() {
    return this.convexHeightfield;
  }
  get [Wn.sphereParticle]() {
    return this.sphereParticle;
  }
  get [Wn.planeParticle]() {
    return this.planeParticle;
  }
  get [Wn.boxParticle]() {
    return this.boxParticle;
  }
  get [Wn.convexParticle]() {
    return this.convexParticle;
  }
  get [Wn.cylinderCylinder]() {
    return this.convexConvex;
  }
  get [Wn.sphereCylinder]() {
    return this.sphereConvex;
  }
  get [Wn.planeCylinder]() {
    return this.planeConvex;
  }
  get [Wn.boxCylinder]() {
    return this.boxConvex;
  }
  get [Wn.convexCylinder]() {
    return this.convexConvex;
  }
  get [Wn.heightfieldCylinder]() {
    return this.heightfieldCylinder;
  }
  get [Wn.particleCylinder]() {
    return this.particleCylinder;
  }
  get [Wn.sphereTrimesh]() {
    return this.sphereTrimesh;
  }
  get [Wn.planeTrimesh]() {
    return this.planeTrimesh;
  }
  constructor(e) {
    this.contactPointPool = [], this.frictionEquationPool = [], this.result = [], this.frictionResult = [], this.v3pool = new $S(), this.world = e, this.currentContactMaterial = e.defaultContactMaterial, this.enableFrictionReduction = false;
  }
  createContactEquation(e, n, i, s, y, t) {
    let o;
    this.contactPointPool.length ? (o = this.contactPointPool.pop(), o.bi = e, o.bj = n) : o = new RS(e, n), o.enabled = e.collisionResponse && n.collisionResponse && i.collisionResponse && s.collisionResponse;
    const u = this.currentContactMaterial;
    o.restitution = u.restitution, o.setSpookParams(u.contactEquationStiffness, u.contactEquationRelaxation, this.world.dt);
    const c = i.material || e.material, h = s.material || n.material;
    return c && h && c.restitution >= 0 && h.restitution >= 0 && (o.restitution = c.restitution * h.restitution), o.si = y || i, o.sj = t || s, o;
  }
  createFrictionEquationsFromContact(e, n) {
    const i = e.bi, s = e.bj, y = e.si, t = e.sj, o = this.world, u = this.currentContactMaterial;
    let c = u.friction;
    const h = y.material || i.material, f = t.material || s.material;
    if (h && f && h.friction >= 0 && f.friction >= 0 && (c = h.friction * f.friction), c > 0) {
      const r = c * (o.frictionGravity || o.gravity).length();
      let m = i.invMass + s.invMass;
      m > 0 && (m = 1 / m);
      const g = this.frictionEquationPool, a = g.length ? g.pop() : new Ed(i, s, r * m), l = g.length ? g.pop() : new Ed(i, s, r * m);
      return a.bi = l.bi = i, a.bj = l.bj = s, a.minForce = l.minForce = -r * m, a.maxForce = l.maxForce = r * m, a.ri.copy(e.ri), a.rj.copy(e.rj), l.ri.copy(e.ri), l.rj.copy(e.rj), e.ni.tangents(a.t, l.t), a.setSpookParams(u.frictionEquationStiffness, u.frictionEquationRelaxation, o.dt), l.setSpookParams(u.frictionEquationStiffness, u.frictionEquationRelaxation, o.dt), a.enabled = l.enabled = e.enabled, n.push(a, l), true;
    }
    return false;
  }
  createFrictionFromAverage(e) {
    let n = this.result[this.result.length - 1];
    if (!this.createFrictionEquationsFromContact(n, this.frictionResult) || e === 1) return;
    const i = this.frictionResult[this.frictionResult.length - 2], s = this.frictionResult[this.frictionResult.length - 1];
    Ko.setZero(), Ta.setZero(), ka.setZero();
    const y = n.bi;
    n.bj;
    for (let o = 0; o !== e; o++) n = this.result[this.result.length - 1 - o], n.bi !== y ? (Ko.vadd(n.ni, Ko), Ta.vadd(n.ri, Ta), ka.vadd(n.rj, ka)) : (Ko.vsub(n.ni, Ko), Ta.vadd(n.rj, Ta), ka.vadd(n.ri, ka));
    const t = 1 / e;
    Ta.scale(t, i.ri), ka.scale(t, i.rj), s.ri.copy(i.ri), s.rj.copy(i.rj), Ko.normalize(), Ko.tangents(i.t, s.t);
  }
  getContacts(e, n, i, s, y, t, o) {
    this.contactPointPool = y, this.frictionEquationPool = o, this.result = s, this.frictionResult = t;
    const u = JS, c = e_, h = QS, f = ZS;
    for (let r = 0, m = e.length; r !== m; r++) {
      const g = e[r], a = n[r];
      let l = null;
      g.material && a.material && (l = i.getContactMaterial(g.material, a.material) || null);
      const d = g.type & nn.KINEMATIC && a.type & nn.STATIC || g.type & nn.STATIC && a.type & nn.KINEMATIC || g.type & nn.KINEMATIC && a.type & nn.KINEMATIC;
      for (let b = 0; b < g.shapes.length; b++) {
        g.quaternion.mult(g.shapeOrientations[b], u), g.quaternion.vmult(g.shapeOffsets[b], h), h.vadd(g.position, h);
        const S = g.shapes[b];
        for (let E = 0; E < a.shapes.length; E++) {
          a.quaternion.mult(a.shapeOrientations[E], c), a.quaternion.vmult(a.shapeOffsets[E], f), f.vadd(a.position, f);
          const R = a.shapes[E];
          if (!(S.collisionFilterMask & R.collisionFilterGroup && R.collisionFilterMask & S.collisionFilterGroup) || h.distanceTo(f) > S.boundingSphereRadius + R.boundingSphereRadius) continue;
          let k = null;
          S.material && R.material && (k = i.getContactMaterial(S.material, R.material) || null), this.currentContactMaterial = k || l || i.defaultContactMaterial;
          const w = S.type | R.type, F = this[w];
          if (F) {
            let I = false;
            S.type < R.type ? I = F.call(this, S, R, h, f, u, c, g, a, S, R, d) : I = F.call(this, R, S, f, h, c, u, a, g, S, R, d), I && d && (i.shapeOverlapKeeper.set(S.id, R.id), i.bodyOverlapKeeper.set(g.id, a.id));
          }
        }
      }
    }
  }
  sphereSphere(e, n, i, s, y, t, o, u, c, h, f) {
    if (f) return i.distanceSquared(s) < (e.radius + n.radius) ** 2;
    const r = this.createContactEquation(o, u, e, n, c, h);
    s.vsub(i, r.ni), r.ni.normalize(), r.ri.copy(r.ni), r.rj.copy(r.ni), r.ri.scale(e.radius, r.ri), r.rj.scale(-n.radius, r.rj), r.ri.vadd(i, r.ri), r.ri.vsub(o.position, r.ri), r.rj.vadd(s, r.rj), r.rj.vsub(u.position, r.rj), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
  }
  spherePlane(e, n, i, s, y, t, o, u, c, h, f) {
    const r = this.createContactEquation(o, u, e, n, c, h);
    if (r.ni.set(0, 0, 1), t.vmult(r.ni, r.ni), r.ni.negate(r.ni), r.ni.normalize(), r.ni.scale(e.radius, r.ri), i.vsub(s, Qu), r.ni.scale(r.ni.dot(Qu), Ad), Qu.vsub(Ad, r.rj), -Qu.dot(r.ni) <= e.radius) {
      if (f) return true;
      const m = r.ri, g = r.rj;
      m.vadd(i, m), m.vsub(o.position, m), g.vadd(s, g), g.vsub(u.position, g), this.result.push(r), this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
  }
  boxBox(e, n, i, s, y, t, o, u, c, h, f) {
    return e.convexPolyhedronRepresentation.material = e.material, n.convexPolyhedronRepresentation.material = n.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, n.convexPolyhedronRepresentation.collisionResponse = n.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, n.convexPolyhedronRepresentation, i, s, y, t, o, u, e, n, f);
  }
  sphereBox(e, n, i, s, y, t, o, u, c, h, f) {
    const r = this.v3pool, m = T_;
    i.vsub(s, Zu), n.getSideNormals(m, t);
    const g = e.radius;
    let a = false;
    const l = O_, d = P_, b = C_;
    let S = null, E = 0, R = 0, k = 0, w = null;
    for (let j = 0, z = m.length; j !== z && a === false; j++) {
      const Y = E_;
      Y.copy(m[j]);
      const te = Y.length();
      Y.normalize();
      const G = Zu.dot(Y);
      if (G < te + g && G > 0) {
        const K = A_, J = x_;
        K.copy(m[(j + 1) % 3]), J.copy(m[(j + 2) % 3]);
        const B = K.length(), Z = J.length();
        K.normalize(), J.normalize();
        const ie = Zu.dot(K), $ = Zu.dot(J);
        if (ie < B && ie > -B && $ < Z && $ > -Z) {
          const oe = Math.abs(G - te - g);
          if ((w === null || oe < w) && (w = oe, R = ie, k = $, S = te, l.copy(Y), d.copy(K), b.copy(J), E++, f)) return true;
        }
      }
    }
    if (E) {
      a = true;
      const j = this.createContactEquation(o, u, e, n, c, h);
      l.scale(-g, j.ri), j.ni.copy(l), j.ni.negate(j.ni), l.scale(S, l), d.scale(R, d), l.vadd(d, l), b.scale(k, b), l.vadd(b, j.rj), j.ri.vadd(i, j.ri), j.ri.vsub(o.position, j.ri), j.rj.vadd(s, j.rj), j.rj.vsub(u.position, j.rj), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult);
    }
    let F = r.get();
    const I = k_;
    for (let j = 0; j !== 2 && !a; j++) for (let z = 0; z !== 2 && !a; z++) for (let Y = 0; Y !== 2 && !a; Y++) if (F.set(0, 0, 0), j ? F.vadd(m[0], F) : F.vsub(m[0], F), z ? F.vadd(m[1], F) : F.vsub(m[1], F), Y ? F.vadd(m[2], F) : F.vsub(m[2], F), s.vadd(F, I), I.vsub(i, I), I.lengthSquared() < g * g) {
      if (f) return true;
      a = true;
      const te = this.createContactEquation(o, u, e, n, c, h);
      te.ri.copy(I), te.ri.normalize(), te.ni.copy(te.ri), te.ri.scale(g, te.ri), te.rj.copy(F), te.ri.vadd(i, te.ri), te.ri.vsub(o.position, te.ri), te.rj.vadd(s, te.rj), te.rj.vsub(u.position, te.rj), this.result.push(te), this.createFrictionEquationsFromContact(te, this.frictionResult);
    }
    r.release(F), F = null;
    const q = r.get(), D = r.get(), H = r.get(), _ = r.get(), T = r.get(), L = m.length;
    for (let j = 0; j !== L && !a; j++) for (let z = 0; z !== L && !a; z++) if (j % 3 !== z % 3) {
      m[z].cross(m[j], q), q.normalize(), m[j].vadd(m[z], D), H.copy(i), H.vsub(D, H), H.vsub(s, H);
      const Y = H.dot(q);
      q.scale(Y, _);
      let te = 0;
      for (; te === j % 3 || te === z % 3; ) te++;
      T.copy(i), T.vsub(_, T), T.vsub(D, T), T.vsub(s, T);
      const G = Math.abs(Y), K = T.length();
      if (G < m[te].length() && K < g) {
        if (f) return true;
        a = true;
        const J = this.createContactEquation(o, u, e, n, c, h);
        D.vadd(_, J.rj), J.rj.copy(J.rj), T.negate(J.ni), J.ni.normalize(), J.ri.copy(J.rj), J.ri.vadd(s, J.ri), J.ri.vsub(i, J.ri), J.ri.normalize(), J.ri.scale(g, J.ri), J.ri.vadd(i, J.ri), J.ri.vsub(o.position, J.ri), J.rj.vadd(s, J.rj), J.rj.vsub(u.position, J.rj), this.result.push(J), this.createFrictionEquationsFromContact(J, this.frictionResult);
      }
    }
    r.release(q, D, H, _, T);
  }
  planeBox(e, n, i, s, y, t, o, u, c, h, f) {
    return n.convexPolyhedronRepresentation.material = n.material, n.convexPolyhedronRepresentation.collisionResponse = n.collisionResponse, n.convexPolyhedronRepresentation.id = n.id, this.planeConvex(e, n.convexPolyhedronRepresentation, i, s, y, t, o, u, e, n, f);
  }
  convexConvex(e, n, i, s, y, t, o, u, c, h, f, r, m) {
    const g = G_;
    if (!(i.distanceTo(s) > e.boundingSphereRadius + n.boundingSphereRadius) && e.findSeparatingAxis(n, i, y, s, t, g, r, m)) {
      const a = [], l = W_;
      e.clipAgainstHull(i, y, n, s, t, g, -100, 100, a);
      let d = 0;
      for (let b = 0; b !== a.length; b++) {
        if (f) return true;
        const S = this.createContactEquation(o, u, e, n, c, h), E = S.ri, R = S.rj;
        g.negate(S.ni), a[b].normal.negate(l), l.scale(a[b].depth, l), a[b].point.vadd(l, E), R.copy(a[b].point), E.vsub(i, E), R.vsub(s, R), E.vadd(i, E), E.vsub(o.position, E), R.vadd(s, R), R.vsub(u.position, R), this.result.push(S), d++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(S, this.frictionResult);
      }
      this.enableFrictionReduction && d && this.createFrictionFromAverage(d);
    }
  }
  sphereConvex(e, n, i, s, y, t, o, u, c, h, f) {
    const r = this.v3pool;
    i.vsub(s, R_);
    const m = n.faceNormals, g = n.faces, a = n.vertices, l = e.radius;
    let d = false;
    for (let b = 0; b !== a.length; b++) {
      const S = a[b], E = B_;
      t.vmult(S, E), s.vadd(E, E);
      const R = L_;
      if (E.vsub(i, R), R.lengthSquared() < l * l) {
        if (f) return true;
        d = true;
        const k = this.createContactEquation(o, u, e, n, c, h);
        k.ri.copy(R), k.ri.normalize(), k.ni.copy(k.ri), k.ri.scale(l, k.ri), E.vsub(s, k.rj), k.ri.vadd(i, k.ri), k.ri.vsub(o.position, k.ri), k.rj.vadd(s, k.rj), k.rj.vsub(u.position, k.rj), this.result.push(k), this.createFrictionEquationsFromContact(k, this.frictionResult);
        return;
      }
    }
    for (let b = 0, S = g.length; b !== S && d === false; b++) {
      const E = m[b], R = g[b], k = N_;
      t.vmult(E, k);
      const w = D_;
      t.vmult(a[R[0]], w), w.vadd(s, w);
      const F = F_;
      k.scale(-l, F), i.vadd(F, F);
      const I = U_;
      F.vsub(w, I);
      const q = I.dot(k), D = j_;
      if (i.vsub(w, D), q < 0 && D.dot(k) > 0) {
        const H = [];
        for (let _ = 0, T = R.length; _ !== T; _++) {
          const L = r.get();
          t.vmult(a[R[_]], L), s.vadd(L, L), H.push(L);
        }
        if (__(H, k, i)) {
          if (f) return true;
          d = true;
          const _ = this.createContactEquation(o, u, e, n, c, h);
          k.scale(-l, _.ri), k.negate(_.ni);
          const T = r.get();
          k.scale(-q, T);
          const L = r.get();
          k.scale(-l, L), i.vsub(s, _.rj), _.rj.vadd(L, _.rj), _.rj.vadd(T, _.rj), _.rj.vadd(s, _.rj), _.rj.vsub(u.position, _.rj), _.ri.vadd(i, _.ri), _.ri.vsub(o.position, _.ri), r.release(T), r.release(L), this.result.push(_), this.createFrictionEquationsFromContact(_, this.frictionResult);
          for (let j = 0, z = H.length; j !== z; j++) r.release(H[j]);
          return;
        } else for (let _ = 0; _ !== R.length; _++) {
          const T = r.get(), L = r.get();
          t.vmult(a[R[(_ + 1) % R.length]], T), t.vmult(a[R[(_ + 2) % R.length]], L), s.vadd(T, T), s.vadd(L, L);
          const j = M_;
          L.vsub(T, j);
          const z = I_;
          j.unit(z);
          const Y = r.get(), te = r.get();
          i.vsub(T, te);
          const G = te.dot(z);
          z.scale(G, Y), Y.vadd(T, Y);
          const K = r.get();
          if (Y.vsub(i, K), G > 0 && G * G < j.lengthSquared() && K.lengthSquared() < l * l) {
            if (f) return true;
            const J = this.createContactEquation(o, u, e, n, c, h);
            Y.vsub(s, J.rj), Y.vsub(i, J.ni), J.ni.normalize(), J.ni.scale(l, J.ri), J.rj.vadd(s, J.rj), J.rj.vsub(u.position, J.rj), J.ri.vadd(i, J.ri), J.ri.vsub(o.position, J.ri), this.result.push(J), this.createFrictionEquationsFromContact(J, this.frictionResult);
            for (let B = 0, Z = H.length; B !== Z; B++) r.release(H[B]);
            r.release(T), r.release(L), r.release(Y), r.release(K), r.release(te);
            return;
          }
          r.release(T), r.release(L), r.release(Y), r.release(K), r.release(te);
        }
        for (let _ = 0, T = H.length; _ !== T; _++) r.release(H[_]);
      }
    }
  }
  planeConvex(e, n, i, s, y, t, o, u, c, h, f) {
    const r = V_, m = q_;
    m.set(0, 0, 1), y.vmult(m, m);
    let g = 0;
    const a = z_;
    for (let l = 0; l !== n.vertices.length; l++) if (r.copy(n.vertices[l]), t.vmult(r, r), s.vadd(r, r), r.vsub(i, a), m.dot(a) <= 0) {
      if (f) return true;
      const d = this.createContactEquation(o, u, e, n, c, h), b = H_;
      m.scale(m.dot(a), b), r.vsub(b, b), b.vsub(i, d.ri), d.ni.copy(m), r.vsub(s, d.rj), d.ri.vadd(i, d.ri), d.ri.vsub(o.position, d.ri), d.rj.vadd(s, d.rj), d.rj.vsub(u.position, d.rj), this.result.push(d), g++, this.enableFrictionReduction || this.createFrictionEquationsFromContact(d, this.frictionResult);
    }
    this.enableFrictionReduction && g && this.createFrictionFromAverage(g);
  }
  boxConvex(e, n, i, s, y, t, o, u, c, h, f) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexConvex(e.convexPolyhedronRepresentation, n, i, s, y, t, o, u, e, n, f);
  }
  sphereHeightfield(e, n, i, s, y, t, o, u, c, h, f) {
    const r = n.data, m = e.radius, g = n.elementSize, a = iE, l = nE;
    Fn.pointToLocalFrame(s, t, i, l);
    let d = Math.floor((l.x - m) / g) - 1, b = Math.ceil((l.x + m) / g) + 1, S = Math.floor((l.y - m) / g) - 1, E = Math.ceil((l.y + m) / g) + 1;
    if (b < 0 || E < 0 || d > r.length || S > r[0].length) return;
    d < 0 && (d = 0), b < 0 && (b = 0), S < 0 && (S = 0), E < 0 && (E = 0), d >= r.length && (d = r.length - 1), b >= r.length && (b = r.length - 1), E >= r[0].length && (E = r[0].length - 1), S >= r[0].length && (S = r[0].length - 1);
    const R = [];
    n.getRectMinMax(d, S, b, E, R);
    const k = R[0], w = R[1];
    if (l.z - m > w || l.z + m < k) return;
    const F = this.result;
    for (let I = d; I < b; I++) for (let q = S; q < E; q++) {
      const D = F.length;
      let H = false;
      if (n.getConvexTrianglePillar(I, q, false), Fn.pointToWorldFrame(s, t, n.pillarOffset, a), i.distanceTo(a) < n.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (H = this.sphereConvex(e, n.pillarConvex, i, a, y, t, o, u, e, n, f)), f && H || (n.getConvexTrianglePillar(I, q, true), Fn.pointToWorldFrame(s, t, n.pillarOffset, a), i.distanceTo(a) < n.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (H = this.sphereConvex(e, n.pillarConvex, i, a, y, t, o, u, e, n, f)), f && H)) return true;
      if (F.length - D > 2) return;
    }
  }
  boxHeightfield(e, n, i, s, y, t, o, u, c, h, f) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexHeightfield(e.convexPolyhedronRepresentation, n, i, s, y, t, o, u, e, n, f);
  }
  convexHeightfield(e, n, i, s, y, t, o, u, c, h, f) {
    const r = n.data, m = n.elementSize, g = e.boundingSphereRadius, a = tE, l = rE, d = eE;
    Fn.pointToLocalFrame(s, t, i, d);
    let b = Math.floor((d.x - g) / m) - 1, S = Math.ceil((d.x + g) / m) + 1, E = Math.floor((d.y - g) / m) - 1, R = Math.ceil((d.y + g) / m) + 1;
    if (S < 0 || R < 0 || b > r.length || E > r[0].length) return;
    b < 0 && (b = 0), S < 0 && (S = 0), E < 0 && (E = 0), R < 0 && (R = 0), b >= r.length && (b = r.length - 1), S >= r.length && (S = r.length - 1), R >= r[0].length && (R = r[0].length - 1), E >= r[0].length && (E = r[0].length - 1);
    const k = [];
    n.getRectMinMax(b, E, S, R, k);
    const w = k[0], F = k[1];
    if (!(d.z - g > F || d.z + g < w)) for (let I = b; I < S; I++) for (let q = E; q < R; q++) {
      let D = false;
      if (n.getConvexTrianglePillar(I, q, false), Fn.pointToWorldFrame(s, t, n.pillarOffset, a), i.distanceTo(a) < n.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (D = this.convexConvex(e, n.pillarConvex, i, a, y, t, o, u, null, null, f, l, null)), f && D || (n.getConvexTrianglePillar(I, q, true), Fn.pointToWorldFrame(s, t, n.pillarOffset, a), i.distanceTo(a) < n.pillarConvex.boundingSphereRadius + e.boundingSphereRadius && (D = this.convexConvex(e, n.pillarConvex, i, a, y, t, o, u, null, null, f, l, null)), f && D)) return true;
    }
  }
  sphereParticle(e, n, i, s, y, t, o, u, c, h, f) {
    const r = Y_;
    if (r.set(0, 0, 1), s.vsub(i, r), r.lengthSquared() <= e.radius * e.radius) {
      if (f) return true;
      const m = this.createContactEquation(u, o, n, e, c, h);
      r.normalize(), m.rj.copy(r), m.rj.scale(e.radius, m.rj), m.ni.copy(r), m.ni.negate(m.ni), m.ri.set(0, 0, 0), this.result.push(m), this.createFrictionEquationsFromContact(m, this.frictionResult);
    }
  }
  planeParticle(e, n, i, s, y, t, o, u, c, h, f) {
    const r = K_;
    r.set(0, 0, 1), o.quaternion.vmult(r, r);
    const m = X_;
    if (s.vsub(o.position, m), r.dot(m) <= 0) {
      if (f) return true;
      const g = this.createContactEquation(u, o, n, e, c, h);
      g.ni.copy(r), g.ni.negate(g.ni), g.ri.set(0, 0, 0);
      const a = $_;
      r.scale(r.dot(s), a), s.vsub(a, a), g.rj.copy(a), this.result.push(g), this.createFrictionEquationsFromContact(g, this.frictionResult);
    }
  }
  boxParticle(e, n, i, s, y, t, o, u, c, h, f) {
    return e.convexPolyhedronRepresentation.material = e.material, e.convexPolyhedronRepresentation.collisionResponse = e.collisionResponse, this.convexParticle(e.convexPolyhedronRepresentation, n, i, s, y, t, o, u, e, n, f);
  }
  convexParticle(e, n, i, s, y, t, o, u, c, h, f) {
    let r = -1;
    const m = Z_, g = J_;
    let a = null;
    const l = Q_;
    if (l.copy(s), l.vsub(i, l), y.conjugate(xd), xd.vmult(l, l), e.pointIsInside(l)) {
      e.worldVerticesNeedsUpdate && e.computeWorldVertices(i, y), e.worldFaceNormalsNeedsUpdate && e.computeWorldFaceNormals(y);
      for (let d = 0, b = e.faces.length; d !== b; d++) {
        const S = [e.worldVertices[e.faces[d][0]]], E = e.worldFaceNormals[d];
        s.vsub(S[0], Td);
        const R = -E.dot(Td);
        if (a === null || Math.abs(R) < Math.abs(a)) {
          if (f) return true;
          a = R, r = d, m.copy(E);
        }
      }
      if (r !== -1) {
        const d = this.createContactEquation(u, o, n, e, c, h);
        m.scale(a, g), g.vadd(s, g), g.vsub(i, g), d.rj.copy(g), m.negate(d.ni), d.ri.set(0, 0, 0);
        const b = d.ri, S = d.rj;
        b.vadd(s, b), b.vsub(u.position, b), S.vadd(i, S), S.vsub(o.position, S), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
      } else console.warn("Point found inside convex, but did not find penetrating face!");
    }
  }
  heightfieldCylinder(e, n, i, s, y, t, o, u, c, h, f) {
    return this.convexHeightfield(n, e, s, i, t, y, u, o, c, h, f);
  }
  particleCylinder(e, n, i, s, y, t, o, u, c, h, f) {
    return this.convexParticle(n, e, s, i, t, y, u, o, c, h, f);
  }
  sphereTrimesh(e, n, i, s, y, t, o, u, c, h, f) {
    const r = u_, m = c_, g = l_, a = f_, l = p_, d = h_, b = g_, S = s_, E = o_, R = v_;
    Fn.pointToLocalFrame(s, t, i, l);
    const k = e.radius;
    b.lowerBound.set(l.x - k, l.y - k, l.z - k), b.upperBound.set(l.x + k, l.y + k, l.z + k), n.getTrianglesInAABB(b, R);
    const w = a_, F = e.radius * e.radius;
    for (let _ = 0; _ < R.length; _++) for (let T = 0; T < 3; T++) if (n.getVertex(n.indices[R[_] * 3 + T], w), w.vsub(l, E), E.lengthSquared() <= F) {
      if (S.copy(w), Fn.pointToWorldFrame(s, t, S, w), w.vsub(i, E), f) return true;
      let L = this.createContactEquation(o, u, e, n, c, h);
      L.ni.copy(E), L.ni.normalize(), L.ri.copy(L.ni), L.ri.scale(e.radius, L.ri), L.ri.vadd(i, L.ri), L.ri.vsub(o.position, L.ri), L.rj.copy(w), L.rj.vsub(u.position, L.rj), this.result.push(L), this.createFrictionEquationsFromContact(L, this.frictionResult);
    }
    for (let _ = 0; _ < R.length; _++) for (let T = 0; T < 3; T++) {
      n.getVertex(n.indices[R[_] * 3 + T], r), n.getVertex(n.indices[R[_] * 3 + (T + 1) % 3], m), m.vsub(r, g), l.vsub(m, d);
      const L = d.dot(g);
      l.vsub(r, d);
      let j = d.dot(g);
      if (j > 0 && L < 0 && (l.vsub(r, d), a.copy(g), a.normalize(), j = d.dot(a), a.scale(j, d), d.vadd(r, d), d.distanceTo(l) < e.radius)) {
        if (f) return true;
        const z = this.createContactEquation(o, u, e, n, c, h);
        d.vsub(l, z.ni), z.ni.normalize(), z.ni.scale(e.radius, z.ri), z.ri.vadd(i, z.ri), z.ri.vsub(o.position, z.ri), Fn.pointToWorldFrame(s, t, d, d), d.vsub(u.position, z.rj), Fn.vectorToWorldFrame(t, z.ni, z.ni), Fn.vectorToWorldFrame(t, z.ri, z.ri), this.result.push(z), this.createFrictionEquationsFromContact(z, this.frictionResult);
      }
    }
    const I = d_, q = m_, D = y_, H = i_;
    for (let _ = 0, T = R.length; _ !== T; _++) {
      n.getTriangleVertices(R[_], I, q, D), n.getNormal(R[_], H), l.vsub(I, d);
      let L = d.dot(H);
      if (H.scale(L, d), l.vsub(d, d), L = d.distanceTo(l), ei.pointInTriangle(d, I, q, D) && L < e.radius) {
        if (f) return true;
        let j = this.createContactEquation(o, u, e, n, c, h);
        d.vsub(l, j.ni), j.ni.normalize(), j.ni.scale(e.radius, j.ri), j.ri.vadd(i, j.ri), j.ri.vsub(o.position, j.ri), Fn.pointToWorldFrame(s, t, d, d), d.vsub(u.position, j.rj), Fn.vectorToWorldFrame(t, j.ni, j.ni), Fn.vectorToWorldFrame(t, j.ri, j.ri), this.result.push(j), this.createFrictionEquationsFromContact(j, this.frictionResult);
      }
    }
    R.length = 0;
  }
  planeTrimesh(e, n, i, s, y, t, o, u, c, h, f) {
    const r = new lt(), m = t_;
    m.set(0, 0, 1), y.vmult(m, m);
    for (let g = 0; g < n.vertices.length / 3; g++) {
      n.getVertex(g, r);
      const a = new lt();
      a.copy(r), Fn.pointToWorldFrame(s, t, a, r);
      const l = r_;
      if (r.vsub(i, l), m.dot(l) <= 0) {
        if (f) return true;
        const d = this.createContactEquation(o, u, e, n, c, h);
        d.ni.copy(m);
        const b = n_;
        m.scale(l.dot(m), b), r.vsub(b, b), d.ri.copy(b), d.ri.vsub(o.position, d.ri), d.rj.copy(r), d.rj.vsub(u.position, d.rj), this.result.push(d), this.createFrictionEquationsFromContact(d, this.frictionResult);
      }
    }
  }
}
const Ko = new lt(), Ta = new lt(), ka = new lt(), QS = new lt(), ZS = new lt(), JS = new ti(), e_ = new ti(), t_ = new lt(), r_ = new lt(), n_ = new lt(), i_ = new lt(), o_ = new lt();
new lt();
const a_ = new lt(), s_ = new lt(), u_ = new lt(), c_ = new lt(), l_ = new lt(), f_ = new lt(), p_ = new lt(), h_ = new lt(), d_ = new lt(), m_ = new lt(), y_ = new lt(), g_ = new Li(), v_ = [], Qu = new lt(), Ad = new lt(), b_ = new lt(), w_ = new lt(), S_ = new lt();
function __(v, e, n) {
  let i = null;
  const s = v.length;
  for (let y = 0; y !== s; y++) {
    const t = v[y], o = b_;
    v[(y + 1) % s].vsub(t, o);
    const u = w_;
    o.cross(e, u);
    const c = S_;
    n.vsub(t, c);
    const h = u.dot(c);
    if (i === null || h > 0 && i === true || h <= 0 && i === false) {
      i === null && (i = h > 0);
      continue;
    } else return false;
  }
  return true;
}
const Zu = new lt(), E_ = new lt(), A_ = new lt(), x_ = new lt(), T_ = [new lt(), new lt(), new lt(), new lt(), new lt(), new lt()], k_ = new lt(), O_ = new lt(), P_ = new lt(), C_ = new lt(), R_ = new lt(), M_ = new lt(), I_ = new lt(), L_ = new lt(), B_ = new lt(), N_ = new lt(), D_ = new lt(), F_ = new lt(), U_ = new lt(), j_ = new lt();
new lt();
new lt();
const V_ = new lt(), q_ = new lt(), z_ = new lt(), H_ = new lt(), G_ = new lt(), W_ = new lt(), K_ = new lt(), X_ = new lt(), $_ = new lt(), Y_ = new lt(), xd = new ti(), Q_ = new lt();
new lt();
const Z_ = new lt(), Td = new lt(), J_ = new lt(), eE = new lt(), tE = new lt(), rE = [0], nE = new lt(), iE = new lt();
class kd {
  constructor() {
    this.current = [], this.previous = [];
  }
  getKey(e, n) {
    if (n < e) {
      const i = n;
      n = e, e = i;
    }
    return e << 16 | n;
  }
  set(e, n) {
    const i = this.getKey(e, n), s = this.current;
    let y = 0;
    for (; i > s[y]; ) y++;
    if (i !== s[y]) {
      for (let t = s.length - 1; t >= y; t--) s[t + 1] = s[t];
      s[y] = i;
    }
  }
  tick() {
    const e = this.current;
    this.current = this.previous, this.previous = e, this.current.length = 0;
  }
  getDiff(e, n) {
    const i = this.current, s = this.previous, y = i.length, t = s.length;
    let o = 0;
    for (let u = 0; u < y; u++) {
      let c = false;
      const h = i[u];
      for (; h > s[o]; ) o++;
      c = h === s[o], c || Od(e, h);
    }
    o = 0;
    for (let u = 0; u < t; u++) {
      let c = false;
      const h = s[u];
      for (; h > i[o]; ) o++;
      c = i[o] === h, c || Od(n, h);
    }
  }
}
function Od(v, e) {
  v.push((e & 4294901760) >> 16, e & 65535);
}
const Rl = (v, e) => v < e ? `${v}-${e}` : `${e}-${v}`;
class oE {
  constructor() {
    this.data = { keys: [] };
  }
  get(e, n) {
    const i = Rl(e, n);
    return this.data[i];
  }
  set(e, n, i) {
    const s = Rl(e, n);
    this.get(e, n) || this.data.keys.push(s), this.data[s] = i;
  }
  delete(e, n) {
    const i = Rl(e, n), s = this.data.keys.indexOf(i);
    s !== -1 && this.data.keys.splice(s, 1), delete this.data[i];
  }
  reset() {
    const e = this.data, n = e.keys;
    for (; n.length > 0; ) {
      const i = n.pop();
      delete e[i];
    }
  }
}
class aE extends Dm {
  constructor(e) {
    e === void 0 && (e = {}), super(), this.dt = -1, this.allowSleep = !!e.allowSleep, this.contacts = [], this.frictionEquations = [], this.quatNormalizeSkip = e.quatNormalizeSkip !== void 0 ? e.quatNormalizeSkip : 0, this.quatNormalizeFast = e.quatNormalizeFast !== void 0 ? e.quatNormalizeFast : false, this.time = 0, this.stepnumber = 0, this.default_dt = 1 / 60, this.nextId = 0, this.gravity = new lt(), e.gravity && this.gravity.copy(e.gravity), e.frictionGravity && (this.frictionGravity = new lt(), this.frictionGravity.copy(e.frictionGravity)), this.broadphase = e.broadphase !== void 0 ? e.broadphase : new Fm(), this.bodies = [], this.hasActiveBodies = false, this.solver = e.solver !== void 0 ? e.solver : new HS(), this.constraints = [], this.narrowphase = new YS(this), this.collisionMatrix = new hd(), this.collisionMatrixPrevious = new hd(), this.bodyOverlapKeeper = new kd(), this.shapeOverlapKeeper = new kd(), this.contactmaterials = [], this.contactMaterialTable = new oE(), this.defaultMaterial = new ia("default"), this.defaultContactMaterial = new na(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0 }), this.doProfiling = false, this.profile = { solve: 0, makeContactConstraints: 0, broadphase: 0, integrate: 0, narrowphase: 0 }, this.accumulator = 0, this.subsystems = [], this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.idToBodyMap = {}, this.broadphase.setWorld(this);
  }
  getContactMaterial(e, n) {
    return this.contactMaterialTable.get(e.id, n.id);
  }
  collisionMatrixTick() {
    const e = this.collisionMatrixPrevious;
    this.collisionMatrixPrevious = this.collisionMatrix, this.collisionMatrix = e, this.collisionMatrix.reset(), this.bodyOverlapKeeper.tick(), this.shapeOverlapKeeper.tick();
  }
  addConstraint(e) {
    this.constraints.push(e);
  }
  removeConstraint(e) {
    const n = this.constraints.indexOf(e);
    n !== -1 && this.constraints.splice(n, 1);
  }
  rayTest(e, n, i) {
    i instanceof wc ? this.raycastClosest(e, n, { skipBackfaces: true }, i) : this.raycastAll(e, n, { skipBackfaces: true }, i);
  }
  raycastAll(e, n, i, s) {
    return i === void 0 && (i = {}), i.mode = ei.ALL, i.from = e, i.to = n, i.callback = s, Ml.intersectWorld(this, i);
  }
  raycastAny(e, n, i, s) {
    return i === void 0 && (i = {}), i.mode = ei.ANY, i.from = e, i.to = n, i.result = s, Ml.intersectWorld(this, i);
  }
  raycastClosest(e, n, i, s) {
    return i === void 0 && (i = {}), i.mode = ei.CLOSEST, i.from = e, i.to = n, i.result = s, Ml.intersectWorld(this, i);
  }
  addBody(e) {
    this.bodies.includes(e) || (e.index = this.bodies.length, this.bodies.push(e), e.world = this, e.initPosition.copy(e.position), e.initVelocity.copy(e.velocity), e.timeLastSleepy = this.time, e instanceof nn && (e.initAngularVelocity.copy(e.angularVelocity), e.initQuaternion.copy(e.quaternion)), this.collisionMatrix.setNumObjects(this.bodies.length), this.addBodyEvent.body = e, this.idToBodyMap[e.id] = e, this.dispatchEvent(this.addBodyEvent));
  }
  removeBody(e) {
    e.world = null;
    const n = this.bodies.length - 1, i = this.bodies, s = i.indexOf(e);
    if (s !== -1) {
      i.splice(s, 1);
      for (let y = 0; y !== i.length; y++) i[y].index = y;
      this.collisionMatrix.setNumObjects(n), this.removeBodyEvent.body = e, delete this.idToBodyMap[e.id], this.dispatchEvent(this.removeBodyEvent);
    }
  }
  getBodyById(e) {
    return this.idToBodyMap[e];
  }
  getShapeById(e) {
    const n = this.bodies;
    for (let i = 0; i < n.length; i++) {
      const s = n[i].shapes;
      for (let y = 0; y < s.length; y++) {
        const t = s[y];
        if (t.id === e) return t;
      }
    }
    return null;
  }
  addContactMaterial(e) {
    this.contactmaterials.push(e), this.contactMaterialTable.set(e.materials[0].id, e.materials[1].id, e);
  }
  removeContactMaterial(e) {
    const n = this.contactmaterials.indexOf(e);
    n !== -1 && (this.contactmaterials.splice(n, 1), this.contactMaterialTable.delete(e.materials[0].id, e.materials[1].id));
  }
  fixedStep(e, n) {
    e === void 0 && (e = 1 / 60), n === void 0 && (n = 10);
    const i = ui.now() / 1e3;
    if (!this.lastCallTime) this.step(e, void 0, n);
    else {
      const s = i - this.lastCallTime;
      this.step(e, s, n);
    }
    this.lastCallTime = i;
  }
  step(e, n, i) {
    if (i === void 0 && (i = 10), n === void 0) this.internalStep(e), this.time += e;
    else {
      this.accumulator += n;
      const s = ui.now();
      let y = 0;
      for (; this.accumulator >= e && y < i && (this.internalStep(e), this.accumulator -= e, y++, !(ui.now() - s > e * 1e3)); ) ;
      this.accumulator = this.accumulator % e;
      const t = this.accumulator / e;
      for (let o = 0; o !== this.bodies.length; o++) {
        const u = this.bodies[o];
        u.previousPosition.lerp(u.position, t, u.interpolatedPosition), u.previousQuaternion.slerp(u.quaternion, t, u.interpolatedQuaternion), u.previousQuaternion.normalize();
      }
      this.time += n;
    }
  }
  internalStep(e) {
    this.dt = e;
    const n = this.contacts, i = fE, s = pE, y = this.bodies.length, t = this.bodies, o = this.solver, u = this.gravity, c = this.doProfiling, h = this.profile, f = nn.DYNAMIC;
    let r = -1 / 0;
    const m = this.constraints, g = lE;
    u.length();
    const a = u.x, l = u.y, d = u.z;
    let b = 0;
    for (c && (r = ui.now()), b = 0; b !== y; b++) {
      const H = t[b];
      if (H.type === f) {
        const _ = H.force, T = H.mass;
        _.x += T * a, _.y += T * l, _.z += T * d;
      }
    }
    for (let H = 0, _ = this.subsystems.length; H !== _; H++) this.subsystems[H].update();
    c && (r = ui.now()), i.length = 0, s.length = 0, this.broadphase.collisionPairs(this, i, s), c && (h.broadphase = ui.now() - r);
    let S = m.length;
    for (b = 0; b !== S; b++) {
      const H = m[b];
      if (!H.collideConnected) for (let _ = i.length - 1; _ >= 0; _ -= 1) (H.bodyA === i[_] && H.bodyB === s[_] || H.bodyB === i[_] && H.bodyA === s[_]) && (i.splice(_, 1), s.splice(_, 1));
    }
    this.collisionMatrixTick(), c && (r = ui.now());
    const E = cE, R = n.length;
    for (b = 0; b !== R; b++) E.push(n[b]);
    n.length = 0;
    const k = this.frictionEquations.length;
    for (b = 0; b !== k; b++) g.push(this.frictionEquations[b]);
    for (this.frictionEquations.length = 0, this.narrowphase.getContacts(i, s, this, n, E, this.frictionEquations, g), c && (h.narrowphase = ui.now() - r), c && (r = ui.now()), b = 0; b < this.frictionEquations.length; b++) o.addEquation(this.frictionEquations[b]);
    const w = n.length;
    for (let H = 0; H !== w; H++) {
      const _ = n[H], T = _.bi, L = _.bj, j = _.si, z = _.sj;
      let Y;
      if (T.material && L.material ? Y = this.getContactMaterial(T.material, L.material) || this.defaultContactMaterial : Y = this.defaultContactMaterial, Y.friction, T.material && L.material && (T.material.friction >= 0 && L.material.friction >= 0 && T.material.friction * L.material.friction, T.material.restitution >= 0 && L.material.restitution >= 0 && (_.restitution = T.material.restitution * L.material.restitution)), o.addEquation(_), T.allowSleep && T.type === nn.DYNAMIC && T.sleepState === nn.SLEEPING && L.sleepState === nn.AWAKE && L.type !== nn.STATIC) {
        const te = L.velocity.lengthSquared() + L.angularVelocity.lengthSquared(), G = L.sleepSpeedLimit ** 2;
        te >= G * 2 && (T.wakeUpAfterNarrowphase = true);
      }
      if (L.allowSleep && L.type === nn.DYNAMIC && L.sleepState === nn.SLEEPING && T.sleepState === nn.AWAKE && T.type !== nn.STATIC) {
        const te = T.velocity.lengthSquared() + T.angularVelocity.lengthSquared(), G = T.sleepSpeedLimit ** 2;
        te >= G * 2 && (L.wakeUpAfterNarrowphase = true);
      }
      this.collisionMatrix.set(T, L, true), this.collisionMatrixPrevious.get(T, L) || (Es.body = L, Es.contact = _, T.dispatchEvent(Es), Es.body = T, L.dispatchEvent(Es)), this.bodyOverlapKeeper.set(T.id, L.id), this.shapeOverlapKeeper.set(j.id, z.id);
    }
    for (this.emitContactEvents(), c && (h.makeContactConstraints = ui.now() - r, r = ui.now()), b = 0; b !== y; b++) {
      const H = t[b];
      H.wakeUpAfterNarrowphase && (H.wakeUp(), H.wakeUpAfterNarrowphase = false);
    }
    for (S = m.length, b = 0; b !== S; b++) {
      const H = m[b];
      H.update();
      for (let _ = 0, T = H.equations.length; _ !== T; _++) {
        const L = H.equations[_];
        o.addEquation(L);
      }
    }
    o.solve(e, this), c && (h.solve = ui.now() - r), o.removeAllEquations();
    const F = Math.pow;
    for (b = 0; b !== y; b++) {
      const H = t[b];
      if (H.type & f) {
        const _ = F(1 - H.linearDamping, e), T = H.velocity;
        T.scale(_, T);
        const L = H.angularVelocity;
        if (L) {
          const j = F(1 - H.angularDamping, e);
          L.scale(j, L);
        }
      }
    }
    this.dispatchEvent(uE), c && (r = ui.now());
    const I = this.stepnumber % (this.quatNormalizeSkip + 1) === 0, q = this.quatNormalizeFast;
    for (b = 0; b !== y; b++) t[b].integrate(e, I, q);
    this.clearForces(), this.broadphase.dirty = true, c && (h.integrate = ui.now() - r), this.stepnumber += 1, this.dispatchEvent(sE);
    let D = true;
    if (this.allowSleep) for (D = false, b = 0; b !== y; b++) {
      const H = t[b];
      H.sleepTick(this.time), H.sleepState !== nn.SLEEPING && (D = true);
    }
    this.hasActiveBodies = D;
  }
  emitContactEvents() {
    const e = this.hasAnyEventListener("beginContact"), n = this.hasAnyEventListener("endContact");
    if ((e || n) && this.bodyOverlapKeeper.getDiff(vo, bo), e) {
      for (let y = 0, t = vo.length; y < t; y += 2) As.bodyA = this.getBodyById(vo[y]), As.bodyB = this.getBodyById(vo[y + 1]), this.dispatchEvent(As);
      As.bodyA = As.bodyB = null;
    }
    if (n) {
      for (let y = 0, t = bo.length; y < t; y += 2) xs.bodyA = this.getBodyById(bo[y]), xs.bodyB = this.getBodyById(bo[y + 1]), this.dispatchEvent(xs);
      xs.bodyA = xs.bodyB = null;
    }
    vo.length = bo.length = 0;
    const i = this.hasAnyEventListener("beginShapeContact"), s = this.hasAnyEventListener("endShapeContact");
    if ((i || s) && this.shapeOverlapKeeper.getDiff(vo, bo), i) {
      for (let y = 0, t = vo.length; y < t; y += 2) {
        const o = this.getShapeById(vo[y]), u = this.getShapeById(vo[y + 1]);
        wo.shapeA = o, wo.shapeB = u, o && (wo.bodyA = o.body), u && (wo.bodyB = u.body), this.dispatchEvent(wo);
      }
      wo.bodyA = wo.bodyB = wo.shapeA = wo.shapeB = null;
    }
    if (s) {
      for (let y = 0, t = bo.length; y < t; y += 2) {
        const o = this.getShapeById(bo[y]), u = this.getShapeById(bo[y + 1]);
        So.shapeA = o, So.shapeB = u, o && (So.bodyA = o.body), u && (So.bodyB = u.body), this.dispatchEvent(So);
      }
      So.bodyA = So.bodyB = So.shapeA = So.shapeB = null;
    }
  }
  clearForces() {
    const e = this.bodies, n = e.length;
    for (let i = 0; i !== n; i++) {
      const s = e[i];
      s.force, s.torque, s.force.set(0, 0, 0), s.torque.set(0, 0, 0);
    }
  }
}
new Li();
const Ml = new ei(), ui = globalThis.performance || {};
if (!ui.now) {
  let v = Date.now();
  ui.timing && ui.timing.navigationStart && (v = ui.timing.navigationStart), ui.now = () => Date.now() - v;
}
new lt();
const sE = { type: "postStep" }, uE = { type: "preStep" }, Es = { type: nn.COLLIDE_EVENT_NAME, body: null, contact: null }, cE = [], lE = [], fE = [], pE = [], vo = [], bo = [], As = { type: "beginContact", bodyA: null, bodyB: null }, xs = { type: "endContact", bodyA: null, bodyB: null }, wo = { type: "beginShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null }, So = { type: "endShapeContact", bodyA: null, bodyB: null, shapeA: null, shapeB: null };
class Pd {
  constructor(e) {
    typeof e == "object" && (e = e.notation), this.set = [], this.setkeys = [], this.setid = 0, this.groups = [], this.totalDice = 0, this.op = "", this.constant = null, this.result = [], this.error = false, this.boost = 1, this.notation = "", this.vectors = [], (!e || e == "0") && (this.error = true), this.parseNotation(e);
  }
  parseNotation(e) {
    if (e) {
      let r = e.split("!").length - 1 || 0;
      r > 0 && (this.boost = Math.min(Math.max(r, 0), 3) * 4), e = e.split("!").join(""), e = e.split(" ").join("");
      let m = e.split("(").length - 1, g = e.split(")").length - 1;
      m != g && (this.error = true);
    }
    const n = this.notation.length > 0 ? "+" : "";
    this.notation += n + e;
    let i = e.split("@"), s = i[0], y = new RegExp(/(\+|\-|\*|\/|\%|\^|){0,1}()(\d*)([a-z]+\d+|[a-z]+|)(?:\{([a-z]+)(.*?|)\}|)()/, "i"), t = new RegExp(/(\b)*(\-\d+|\d+)(\b)*/, "gi"), o, u = 0, c = 30, h = 0, f = 0;
    for (; !this.error && s.length > 0 && (o = y.exec(s)) !== null && u < c; ) {
      u++, s = s.substring(o[0].length);
      let r = o[1], m = o[2] && o[2].length > 0, g = o[3], a = o[4], l = o[5] || "", d = o[6] || "", b = o[7] && o[7].length > 0, S = true;
      m && (h += o[2].length), d = d.split(","), (!d || d.length < 1) && (d = ""), d.shift(), u == 1 && s.length == 0 && !a && r && g ? (a = "d20", this.op = r, this.constant = parseInt(g), g = 1) : u > 1 && s.length == 0 && !a && (this.op = r, this.constant = parseInt(g), S = false), S && this.addSet(g, a, f, h, l, d, r), b && (h -= o[7].length, f += o[7].length);
    }
    !this.error && i[1] && (o = i[1].match(t)) !== null && this.result.push(...o);
  }
  stringify(e = true) {
    let n = "";
    if (this.set.length < 1) return n;
    for (let i = 0; i < this.set.length; i++) {
      let s = this.set[i];
      n += i > 0 && s.op ? s.op : "", n += s.num + s.type, s.func && (n += "{", n += s.func ? s.func : "", n += s.args ? "," + (Array.isArray(s.args) ? s.args.join(",") : s.args) : "", n += "}");
    }
    return n += this.constant ? this.op + "" + Math.abs(this.constant) : "", e && this.result && this.result.length > 0 && (n += "@" + this.result.join(",")), this.boost > 1 && (n += "!".repeat(this.boost / 4)), n;
  }
  addSet(e, n, i = 0, s = 0, y = "", t = "", o = "+") {
    e = Math.abs(parseInt(e || 1));
    let u = o + "" + n + i + s + y + t, c = this.setkeys[u] != null, h = {};
    c && (h = this.set[this.setkeys[u] - 1]), e > 0 && (h.num = c ? e + h.num : e, h.type = n, h.sid = this.setid, h.gid = i, h.glvl = s, y && (h.func = y), t && (h.args = t), o && (h.op = o), c ? this.set[this.setkeys[u] - 1] = h : this.setkeys[u] = this.set.push(h)), c || ++this.setid;
  }
  static mergeNotation(e, n) {
    return { ...e, constant: e.constant + n.constant, notation: e.notation + "+" + n.notation, set: [...e.set, ...n.set], totalDice: e.vectors.length + n.vectors.length, vectors: [...e.vectors, ...n.vectors] };
  }
}
const Il = { d2: { name: "d2", labels: ["1", "2"], values: [1, 2], inertia: 8, mass: 400, scale: 0.9, system: "dweird" }, dc: { type: "d2", name: "Coin", labels: ["textures/silvercoin/tail.png", "textures/silvercoin/heads.png"], setBumpMaps: ["textures/silvercoin/tail_bump.png", "textures/silvercoin/heads_bump.png"], values: [0, 1], inertia: 8, mass: 400, scale: 0.9, colorset: "coin_silver" }, d1: { name: "One-sided Dice", type: "d6", labels: ["1"], values: [1, 1], scale: 0.9, system: "dweird" }, d3: { name: "Three-Sided Dice", type: "d6", labels: ["1", "2", "3"], values: [1, 3], scale: 0.9, system: "dweird" }, df: { name: "Fudge Dice", type: "d6", labels: ["-", "0", "+"], values: [-1, 1], scale: 0.9, system: "dweird" }, d4: { name: "Four-Sided Dice", labels: ["1", "2", "3", "4"], values: [1, 4], inertia: 5, scale: 1.2 }, d6: { name: "Six-Sided Dice (Numbers)", labels: ["1", "2", "3", "4", "5", "6"], values: [1, 6], scale: 0.9 }, dpip: { name: "Six-Sided Dice (Pips)", type: "d6", labels: [`   
 \u2B24 
   `, `\u2B24  
   
  \u2B24`, `\u2B24  
 \u2B24 
  \u2B24`, `\u2B24 \u2B24
   
\u2B24 \u2B24`, `\u2B24 \u2B24
 \u2B24 
\u2B24 \u2B24`, `\u2B24 \u2B24
\u2B24 \u2B24
\u2B24 \u2B24`], values: [1, 6], scale: 0.9, font: "monospace" }, dsex: { name: "Sex-Sided Emoji Dice", type: "d6", labels: ["\u{1F346}", "\u{1F351}", "\u{1F44C}", "\u{1F4A6}", "\u{1F64F}", "\u{1F4A5}"], values: [1, 6], scale: 0.9, display: "labels", system: "dweird" }, dpoker: { name: "Poker Dice (9-Ace)", type: "d6", labels: ["A", "9", "10", "J", "Q", "K"], values: [1, 6], scale: 0.9, display: "labels", system: "dweird", font: "Times New Roman" }, dspanpoker: { name: "Spanish Poker Dice (7-Ace)", type: "d8", labels: ["A", "7", "8", "9", "10", "J", "Q", "K"], values: [1, 8], display: "labels", system: "dweird", font: "Times New Roman" }, disotope: { name: "Radioactive Twelve-Sided Dice", type: "d12", labels: ["", "", "", "", "", "", "", "", "", "", "", "\u2622\uFE0F"], values: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], mass: 350, inertia: 8, scale: 0.9, system: "dweird" }, dsuit: { name: "Four-Suited Dice", type: "d4", labels: ["\u2660\uFE0F", "\u2665\uFE0F", "\u2666\uFE0F", "\u2663\uFE0F"], values: [1, 4], inertia: 5, scale: 1.2, display: "labels", system: "dweird" }, d8: { name: "Eight-Sided Dice", labels: ["1", "2", "3", "4", "5", "6", "7", "8"], values: [1, 8] }, d10: { name: "Ten-Sided Dice (Single Digit)", labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"], values: [1, 10], mass: 350, inertia: 9, scale: 0.9 }, d100: { name: "Ten-Sided Dice (Tens Digit)", type: "d10", labels: ["10", "20", "30", "40", "50", "60", "70", "80", "90", "00"], values: [10, 100, 10], mass: 350, inertia: 9, scale: 0.9 }, d12: { name: "Twelve-Sided Dice", labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], values: [1, 12], mass: 350, inertia: 8, scale: 0.9 }, d20: { name: "Twenty-Sided Dice", labels: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"], values: [1, 20], mass: 400, inertia: 6 }, dabi: { name: "Star Wars RPG: Ability Dice", type: "d8", labels: ["s", "a", `s
a`, `s
s`, "a", "s", `a
a`, ""], values: [1, 8], font: "SWRPG-Symbol-Regular", color: "#00FF00", colorset: "swrpg_abi", display: "labels", system: "swrpg" }, ddif: { name: "Star Wars RPG: Difficulty Dice", type: "d8", labels: ["t", "f", `f
t`, "t", "", `t
t`, `f
f`, "t"], values: [1, 8], font: "SWRPG-Symbol-Regular", color: "#8000FC", colorset: "swrpg_dif", display: "labels", system: "swrpg" }, dpro: { name: "Star Wars RPG: Proficiency Dice", type: "d12", labels: [`a
a`, "a", `a
a`, "x", "s", `s
a`, "s", `s
a`, `s
s`, `s
a`, `s
s`, ""], values: [1, 12], mass: 350, inertia: 8, scale: 0.9, font: "SWRPG-Symbol-Regular", color: "#FFFF00", colorset: "swrpg_pro", display: "labels", system: "swrpg" }, dcha: { name: "Star Wars RPG: Challenge Dice", type: "d12", labels: [`t
t`, "t", `t
t`, "t", `t
f`, "f", `t
f`, "f", `f
f`, "y", `f
f`, ""], values: [1, 12], mass: 350, inertia: 8, scale: 0.9, font: "SWRPG-Symbol-Regular", color: "#FF0000", colorset: "swrpg_cha", display: "labels", system: "swrpg" }, dfor: { name: "Star Wars RPG: Force Dice", type: "d12", labels: ["z", `Z
Z`, "z", `Z
Z`, "z", `Z
Z`, "z", "Z", "z", "Z", "z", `z
z`], values: [1, 12], mass: 350, inertia: 8, scale: 0.9, font: "SWRPG-Symbol-Regular", color: "#FFFFFF", colorset: "swrpg_for", display: "labels", system: "swrpg" }, dboo: { name: "Star Wars RPG: Boost Dice", type: "d6", labels: [`s  
  a`, `a  
  a`, "s", "a", "", ""], values: [1, 6], scale: 0.9, font: "SWRPG-Symbol-Regular", color: "#00FFFF", colorset: "swrpg_boo", display: "labels", system: "swrpg" }, dset: { name: "Star Wars RPG: Setback Dice", type: "d6", labels: ["", "t", "f"], values: [1, 3], scale: 0.9, font: "SWRPG-Symbol-Regular", color: "#111111", colorset: "swrpg_set", display: "labels", system: "swrpg" }, swar: { name: "Star Wars Armada: Red Attack Dice", type: "d8", labels: ["F", "F", `F
F`, "E", "E", "G", "", ""], values: [1, 8], font: "Armada-Symbol-Regular", color: "#FF0000", colorset: "swa_red", display: "labels", system: "swarmada" }, swab: { name: "Star Wars Armada: Blue Attack Dice", type: "d8", labels: ["F", "F", "F", "F", "E", "E", "G", "G"], values: [1, 8], font: "Armada-Symbol-Regular", color: "#0000FF", colorset: "swa_blue", display: "labels", system: "swarmada" }, swak: { name: "Star Wars Armada: Black Attack Dice", type: "d8", labels: ["F", "F", "F", "F", `F
E`, `F
E`, "", ""], values: [1, 8], font: "Armada-Symbol-Regular", color: "#111111", colorset: "swa_black", display: "labels", system: "swarmada" }, xwatk: { name: "Star Wars X-Wing: Red Attack Dice", type: "d8", labels: ["c", "d", "d", "d", "f", "f", "", ""], values: [1, 8], font: "XWing-Symbol-Regular", color: "#FF0000", colorset: "xwing_red", display: "labels", system: "xwing" }, xwdef: { name: "Star Wars X-Wing: Green Defense Dice", type: "d8", labels: ["e", "e", "e", "f", "f", "", "", ""], values: [1, 8], font: "XWing-Symbol-Regular", color: "#00FF00", colorset: "xwing_green", display: "labels", system: "xwing" }, swlar: { name: "Star Wars Legion: Red Attack Dice", type: "d8", labels: ["h", "h", "h", "h", "h", "c", "o", ""], values: [1, 8], font: "Legion-Symbol-Regular", color: "#FF0000", colorset: "swl_atkred", display: "labels", system: "legion" }, swlab: { name: "Star Wars Legion: Black Attack Dice", type: "d8", labels: ["h", "h", "h", "", "", "c", "o", ""], values: [1, 8], font: "Legion-Symbol-Regular", color: "#111111", colorset: "swl_atkblack", display: "labels", system: "legion" }, swlaw: { name: "Star Wars Legion: White Attack Dice", type: "d8", labels: ["h", "", "", "", "", "c", "o", ""], values: [1, 8], font: "Legion-Symbol-Regular", color: "#FFFFFF", colorset: "swl_atkwhite", display: "labels", system: "legion" }, swldr: { name: "Star Wars Legion: Red Defense Dice", type: "d6", labels: ["s", "s", "s", "d", "", ""], values: [1, 6], scale: 0.9, font: "Legion-Symbol-Regular", color: "#FF0000", colorset: "swl_defred", display: "labels", system: "legion" }, swldw: { name: "Star Wars Legion: White Defense Dice", type: "d6", labels: ["s", "", "", "d", "", ""], values: [1, 6], scale: 0.9, font: "Legion-Symbol-Regular", color: "#FFFFFF", colorset: "swl_defwhite", display: "labels", system: "legion" } }, Ui = { d4: { vertices: [[1, 1, 1], [-1, -1, 1], [-1, 1, -1], [1, -1, -1]], faces: [[1, 0, 2, 1], [0, 1, 3, 2], [0, 3, 2, 3], [1, 2, 3, 4]] }, d6: { vertices: [[-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1], [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]], faces: [[0, 3, 2, 1, 1], [1, 2, 6, 5, 2], [0, 1, 5, 4, 3], [3, 7, 6, 2, 4], [0, 4, 7, 3, 5], [4, 5, 6, 7, 6]] }, d8: { vertices: [[1, 0, 0], [-1, 0, 0], [0, 1, 0], [0, -1, 0], [0, 0, 1], [0, 0, -1]], faces: [[0, 2, 4, 1], [0, 4, 3, 2], [0, 3, 5, 3], [0, 5, 2, 4], [1, 3, 4, 5], [1, 4, 2, 6], [1, 2, 5, 7], [1, 5, 3, 8]] }, d10: { vertices: [[1, 0, -0.105], [0.809, 0.5877, 0.105], [0.309, 0.951, -0.105], [-0.309, 0.951, 0.105], [-0.809, 0.5877, -0.105], [-1, 0, 0.105], [-0.809, -0.587, -0.105], [-0.309, -0.951, 0.105], [0.309, -0.951, -0.105], [0.809, -0.5877, 0.105], [0, 0, -1], [0, 0, 1]], faces: [[5, 6, 7, 11, 0], [4, 3, 2, 10, 1], [1, 2, 3, 11, 2], [0, 9, 8, 10, 3], [7, 8, 9, 11, 4], [8, 7, 6, 10, 5], [9, 0, 1, 11, 6], [2, 1, 0, 10, 7], [3, 4, 5, 11, 8], [6, 5, 4, 10, 9]] }, d12: { vertices: [[0, 0.618, 1.618], [0, 0.618, -1.618], [0, -0.618, 1.618], [0, -0.618, -1.618], [1.618, 0, 0.618], [1.618, 0, -0.618], [-1.618, 0, 0.618], [-1.618, 0, -0.618], [0.618, 1.618, 0], [0.618, -1.618, 0], [-0.618, 1.618, 0], [-0.618, -1.618, 0], [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1], [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1]], faces: [[2, 14, 4, 12, 0, 1], [15, 9, 11, 19, 3, 2], [16, 10, 17, 7, 6, 3], [6, 7, 19, 11, 18, 4], [6, 18, 2, 0, 16, 5], [18, 11, 9, 14, 2, 6], [1, 17, 10, 8, 13, 7], [1, 13, 5, 15, 3, 8], [13, 8, 12, 4, 5, 9], [5, 4, 14, 9, 15, 10], [0, 12, 8, 10, 16, 11], [3, 19, 7, 17, 1, 12]] }, d20: { vertices: [[-1, 1.618, 0], [1, 1.618, 0], [-1, -1.618, 0], [1, -1.618, 0], [0, -1, 1.618], [0, 1, 1.618], [0, -1, -1.618], [0, 1, -1.618], [1.618, 0, -1], [1.618, 0, 1], [-1.618, 0, -1], [-1.618, 0, 1]], faces: [[0, 11, 5, 1], [0, 5, 1, 2], [0, 1, 7, 3], [0, 7, 10, 4], [0, 10, 11, 5], [1, 5, 9, 6], [5, 11, 4, 7], [11, 10, 2, 8], [10, 7, 6, 9], [7, 1, 8, 10], [3, 9, 4, 11], [3, 4, 2, 12], [3, 2, 6, 13], [3, 6, 8, 14], [3, 8, 9, 15], [4, 9, 5, 16], [2, 4, 11, 17], [6, 2, 10, 18], [8, 6, 7, 19], [9, 8, 1, 20]] } }, hE = { name: "", scale: 1, font: "Arial", color: "", labels: [], valueMap: [], values: [], normals: [], mass: 300, inertia: 13, geometry: null, display: "values", system: "d20" };
class dE {
  constructor(e) {
    if (!Il.hasOwnProperty(e)) return console.error("dice type unavailable");
    Object.assign(this, hE, Il[e]), this.shape = Il[e].type || e, this.type = e, this.setLabels(this.labels), this.setValues(this.values[0], this.values[1], this.values[2]), this.setValueMap(this.valueMap), this.bumpMaps && this.setBumpMaps(this.bumpMaps);
  }
  setValues(e = 1, n = 20, i = 1) {
    this.values = this.range(e, n, i);
  }
  setValueMap(e) {
    for (let n = 0; n < this.values.length; n++) {
      let i = this.values[n];
      e[i] != null && (this.valueMap[i] = e[i]);
    }
  }
  registerFaces(e, n = "labels") {
    let i;
    if (n == "labels" ? i = this.labels : i = this.normals, i.unshift(""), ["d2", "d10"].includes(this.shape) || i.unshift(""), this.shape == "d4") {
      let s = e[0], y = e[1], t = e[2], o = e[3];
      this.labels = [[[], [0, 0, 0], [y, o, t], [s, t, o], [y, s, o], [s, y, t]], [[], [0, 0, 0], [y, t, o], [t, s, o], [y, o, s], [t, y, s]], [[], [0, 0, 0], [o, t, y], [t, o, s], [o, y, s], [t, s, y]], [[], [0, 0, 0], [o, y, t], [s, o, t], [o, s, y], [s, t, y]]];
    } else Array.prototype.push.apply(i, e);
  }
  setLabels(e) {
    this.loadTextures(e, this.registerFaces.bind(this), "labels");
  }
  setBumpMaps(e) {
    this.loadTextures(e, this.registerFaces.bind(this), "bump");
  }
  loadTextures(e, n, i) {
    let s = 0, y = e.length, t = /\.(PNG|JPG|GIF|WEBP)$/i, o = Array(e.length), u = false;
    for (let c = 0; c < y; c++) {
      if (e[c] == "" || !e[c].match(t)) {
        o[c] = e[c], ++s;
        continue;
      }
      u = true, o[c] = new Image(), o[c].onload = function() {
        ++s >= y && n(o, i);
      }, o[c].src = e[c];
    }
    u || n(o, i);
  }
  range(e, n, i = 1) {
    for (var s = [e], y = e; y < n; ) s.push(y += i || 1);
    return s;
  }
}
const mE = { none: { name: "Plastic" }, perfectmetal: { name: "Perfect Metal", color: 14540253, roughness: 0, metalness: 1, envMapIntensity: 1 }, metal: { name: "Metal", color: 14540253, roughness: 0.5, metalness: 0.6, envMapIntensity: 1 }, wood: { name: "Wood", color: 14540253, roughness: 0.9, metalness: 0, envMapIntensity: 1 }, glass: { name: "Glass", color: 14540253, roughness: 0.1, metalness: 0, envMapIntensity: 1 } }, yE = { baseScale: 100, bumpMapping: true }, Bs = class {
  constructor(v) {
    this.geometries = {}, this.materials_cache = {}, this.cache_hits = 0, this.cache_misses = 0, this.label_color = "", this.dice_color = "", this.edge_color = "", this.label_outline = "", this.dice_texture = "", this.dice_material = "", this.material_options = { specular: 16777215, color: 11908533, shininess: 5, flatShading: true }, Object.assign(this, yE, v);
  }
  updateConfig(v = {}) {
    Object.assign(this, v), v.scale && this.scaleGeometry();
  }
  setBumpMapping(v) {
    this.bumpMapping = v, this.materials_cache = {};
  }
  create(v) {
    let e = this.get(v);
    if (!e) return null;
    let n = this.geometries[v];
    if (n || (n = this.createGeometry(e.shape, e.scale * this.baseScale), this.geometries[v] = n), !n) return null;
    this.setMaterialInfo();
    let i = new io(n, this.createMaterials(e, this.baseScale / 2, 1));
    switch (i.result = [], i.shape = e.shape, i.rerolls = 0, i.resultReason = "natural", i.mass = e.mass, i.getFaceValue = function() {
      let s = this.resultReason, y = new _r(0, 0, this.shape == "d4" ? -1 : 1), t, o = Math.PI * 2, u = this.geometry.getAttribute("normal").array;
      for (let g = 0, a = this.geometry.groups.length; g < a; ++g) {
        let l = this.geometry.groups[g];
        if (l.materialIndex == 0) continue;
        let d = g * 9, b = new _r(u[d], u[d + 1], u[d + 2]).clone().applyQuaternion(this.body.quaternion).angleTo(y);
        b < o && (o = b, t = l);
      }
      let c = t.materialIndex - 1, h = 2;
      const f = Bs.dice[this.notation.type];
      if (this.shape == "d4") {
        let g = c - 1 == 0 ? 5 : c;
        return { value: c, label: f.labels[c - 1][g][0], reason: s };
      }
      ["d10", "d2"].includes(this.shape) && (c += 1, h -= 1);
      let r = f.values[(c - 1) % f.values.length], m = f.labels[(c - 1) % (f.labels.length - 2) + h];
      return { value: r, label: m, reason: s };
    }, i.storeRolledValue = function(s) {
      this.resultReason = s || this.resultReason, this.result.push(this.getFaceValue());
    }, i.getLastValue = function() {
      return !this.result || this.result.length < 1 ? { value: void 0, label: "", reason: "" } : this.result[this.result.length - 1];
    }, i.ignoreLastValue = function(s) {
      let y = this.getLastValue();
      y.value !== void 0 && (y.ignore = s, this.setLastValue(y));
    }, i.setLastValue = function(s) {
      if (!(!this.result || this.result.length < 1) && !(!s || s.length < 1)) return this.result[this.result.length - 1] = s;
    }, e.color && (i.material[0].color = new Mn(e.color), i.material[0].emissive = new Mn(e.color), i.material[0].emissiveIntensity = 1, i.material[0].needsUpdate = true), e.values.length) {
      case 1:
        return this.fixmaterials(i, 1);
      case 2:
        return this.fixmaterials(i, 2);
      case 3:
        return this.fixmaterials(i, 3);
      default:
        return i;
    }
  }
  get(v) {
    let e;
    return Bs.dice.hasOwnProperty(v) ? e = Bs.dice[v] : (e = new dE(v), Bs.dice[v] = e), e;
  }
  getGeometry(v) {
    return this.geometries[v];
  }
  scaleGeometry() {
  }
  createMaterials(v, e, n, i = true, s = 0) {
    let y = [], t = v.labels;
    v.shape == "d4" && (t = v.labels[s], e = this.baseScale / 2, n = this.baseScale * 2);
    for (var o = 0; o < t.length; ++o) {
      var u;
      this.dice_material != "none" ? (u = new B1(mE[this.dice_material]), u.envMapIntensity = 0) : u = new N1(this.material_options);
      let c;
      if (o == 0) {
        let h = { name: "none" };
        this.dice_texture_rand.composite != "source-over" && (h = this.dice_texture_rand), c = this.createTextMaterial(v, t, o, e, n, h, this.label_color_rand, this.label_outline_rand, this.edge_color_rand, i), u.map = c.composite;
      } else if (c = this.createTextMaterial(v, t, o, e, n, this.dice_texture_rand, this.label_color_rand, this.label_outline_rand, this.dice_color_rand, i), u.map = c.composite, this.bumpMapping) {
        {
          let h = 0.75;
          e > 35 && (h = 1), e > 40 && (h = 2.5), e > 45 && (h = 4), u.bumpScale = h;
        }
        c.bump && (u.bumpMap = c.bump), v.shape != "d4" && v.normals[o] && (u.bumpMap = new Mi(v.normals[o]), u.bumpScale = 4, u.bumpMap.needsUpdate = true);
      }
      u.opacity = 1, u.transparent = true, u.depthTest = false, u.needUpdate = true, y.push(u);
    }
    return y;
  }
  createTextMaterial(v, e, n, i, s, y, t, o, u, c) {
    if (e[n] === void 0) return null;
    y = y || this.dice_texture_rand, t = t || this.label_color_rand, o = o || this.label_outline_rand, u = u || this.dice_color_rand, c = c ?? true;
    let h = e[n], f = false, r = h;
    h instanceof HTMLImageElement ? r = h.src : h instanceof Array && h.forEach((w) => {
      r += w.src;
    });
    let m = v.type + r + n + y.name + t + o + u;
    if (v.shape == "d4" && (m = v.type + r + y.name + t + o + u), c && this.materials_cache[m] != null) return this.cache_hits++, this.materials_cache[m];
    let g = document.createElement("canvas"), a = g.getContext("2d", { alpha: true });
    a.globalAlpha = 0, a.clearRect(0, 0, g.width, g.height);
    let l = document.createElement("canvas"), d = l.getContext("2d", { alpha: true });
    d.globalAlpha = 0, d.clearRect(0, 0, l.width, l.height);
    let b;
    if (v.shape == "d4" ? b = this.calc_texture_size(i + s) * 4 : b = this.calc_texture_size(i + i * 2 * s) * 4, g.width = g.height = b, l.width = l.height = b, a.fillStyle = u, a.fillRect(0, 0, g.width, g.height), d.fillStyle = "#FFFFFF", d.fillRect(0, 0, l.width, l.height), y.texture && y.name != "" && y.name != "none" ? (a.globalCompositeOperation = y.composite || "source-over", a.drawImage(y.texture, 0, 0, g.width, g.height), a.globalCompositeOperation = "source-over", y.bump && (d.globalCompositeOperation = "source-over", d.drawImage(y.bump, 0, 0, g.width, g.height))) : a.globalCompositeOperation = "source-over", a.globalCompositeOperation = "source-over", a.textAlign = "center", a.textBaseline = "middle", d.textAlign = "center", d.textBaseline = "middle", v.shape != "d4") {
      let w = { d8: { even: -7.5, odd: -127.5 }, d10: { all: -6 }, d12: { all: 5 }, d20: { all: -7.5 } }[v.shape];
      if (w) {
        let F;
        if (w.hasOwnProperty("all") ? F = w.all : n > 0 && n % 2 != 0 ? F = w.odd : F = w.even, F && F != 0) {
          var S = g.width / 2, E = g.height / 2;
          a.translate(S, E), a.rotate(F * (Math.PI / 180)), a.translate(-S, -E), d.translate(S, E), d.rotate(F * (Math.PI / 180)), d.translate(-S, -E);
        }
      }
      if (h instanceof HTMLImageElement) f = true, a.drawImage(h, 0, 0, h.width, h.height, 0, 0, g.width, g.height);
      else {
        let F = b / (1 + 2 * s), I = g.height / 2 + 10, q = g.width / 2;
        v.shape == "d10" ? (F = F * 0.75, I = I * 1.15 - 10) : v.shape == "d20" && (q = q * 0.98), a.font = F + "pt " + v.font, d.font = F + "pt " + v.font;
        let D = a.measureText("M").width * 1.4, H = h.split(`
`);
        H.length > 1 && (F = F / H.length, a.font = F + "pt " + v.font, d.font = F + "pt " + v.font, D = a.measureText("M").width * 1.2, I -= D * H.length / 2);
        for (let _ = 0, T = H.length; _ < T; _++) {
          let L = H[_].trim();
          o != "none" && o != u && (a.strokeStyle = o, a.lineWidth = 5, a.strokeText(H[_], q, I), d.strokeStyle = "#000000", d.lineWidth = 5, d.strokeText(H[_], q, I), (L == "6" || L == "9") && (a.strokeText("  .", q, I), d.strokeText("  .", q, I))), a.fillStyle = t, a.fillText(H[_], q, I), d.fillStyle = "#000000", d.fillText(H[_], q, I), (L == "6" || L == "9") && (a.fillText("  .", q, I), d.fillText("  .", q, I)), I += D * 1.5;
        }
      }
    } else {
      var S = g.width / 2, E = g.height / 2;
      a.font = b / 128 * 24 + "pt " + v.font, d.font = b / 128 * 24 + "pt " + v.font;
      for (let I = 0; I < h.length; I++) {
        if (h[I] instanceof HTMLImageElement) {
          let q = h[I].width / g.width;
          a.drawImage(h[I], 0, 0, h[I].width, h[I].height, 100 / q, 25 / q, 60 / q, 60 / q);
        } else o != "none" && o != u && (a.strokeStyle = o, a.lineWidth = 5, a.strokeText(h[I], S, E - b * 0.3), d.strokeStyle = "#000000", d.lineWidth = 5, d.strokeText(h[I], S, E - b * 0.3)), a.fillStyle = t, a.fillText(h[I], S, E - b * 0.3), d.fillStyle = "#000000", d.fillText(h[I], S, E - b * 0.3);
        a.translate(S, E), a.rotate(Math.PI * 2 / 3), a.translate(-S, -E), d.translate(S, E), d.rotate(Math.PI * 2 / 3), d.translate(-S, -E);
      }
    }
    var R = new ad(g), k;
    return f ? k = null : k = new ad(l), c && (this.cache_misses++, this.materials_cache[m] = { composite: R, bump: k }), { composite: R, bump: k };
  }
  applyColorSet(v) {
    var e;
    this.colordata = v, this.label_color = v.foreground, this.dice_color = v.background, this.label_outline = v.outline, this.dice_texture = v.texture, this.dice_material = ((e = v == null ? void 0 : v.texture) == null ? void 0 : e.material) || "none", this.edge_color = v.hasOwnProperty("edge") ? v.edge : v.background;
  }
  setMaterialInfo(v = "") {
    let e = this.colordata, n = this.dice_texture, i = this.dice_material;
    if (this.dice_color_rand = "", this.label_color_rand = "", this.label_outline_rand = "", this.dice_texture_rand = "", this.dice_material_rand = "", this.edge_color_rand = "", Array.isArray(this.dice_color)) {
      var s = Math.floor(Math.random() * this.dice_color.length);
      Array.isArray(this.label_color) && this.label_color.length == this.dice_color.length && (this.label_color_rand = this.label_color[s], Array.isArray(this.label_outline) && this.label_outline.length == this.label_color.length && (this.label_outline_rand = this.label_outline[s])), Array.isArray(this.dice_texture) && this.dice_texture.length == this.dice_color.length && (this.dice_texture_rand = this.dice_texture[s], this.dice_material_rand = this.dice_texture_rand.material), Array.isArray(this.edge_color) && this.edge_color.length == this.dice_color.length && (this.edge_color_rand = this.edge_color[s]), this.dice_color_rand = this.dice_color[s];
    } else this.dice_color_rand = this.dice_color;
    if (this.edge_color_rand == "") if (Array.isArray(this.edge_color)) {
      var s = Math.floor(Math.random() * this.edge_color.length);
      this.edge_color_rand = this.edge_color[s];
    } else this.edge_color_rand = this.edge_color;
    if (this.label_color_rand == "" && Array.isArray(this.label_color)) {
      var s = this.label_color[Math.floor(Math.random() * this.label_color.length)];
      Array.isArray(this.label_outline) && this.label_outline.length == this.label_color.length && (this.label_outline_rand = this.label_outline[s]), this.label_color_rand = this.label_color[s];
    } else this.label_color_rand == "" && (this.label_color_rand = this.label_color);
    if (this.label_outline_rand == "" && Array.isArray(this.label_outline)) {
      var s = this.label_outline[Math.floor(Math.random() * this.label_outline.length)];
      this.label_outline_rand = this.label_outline[s];
    } else this.label_outline_rand == "" && (this.label_outline_rand = this.label_outline);
    this.dice_texture_rand == "" && Array.isArray(this.dice_texture) ? (this.dice_texture_rand = this.dice_texture[Math.floor(Math.random() * this.dice_texture.length)], this.dice_material_rand = this.dice_texture_rand.material || this.dice_material) : this.dice_texture_rand == "" && (this.dice_texture_rand = this.dice_texture, this.dice_material_rand = this.dice_texture_rand.material || this.dice_material), this.dice_material_rand == "" && Array.isArray(this.dice_material) ? this.dice_material_rand = this.dice_material[Math.floor(Math.random() * this.dice_material.length)] : this.dice_material_rand == "" && (this.dice_material_rand = this.dice_material), this.colordata && this.colordata.id != e.id && this.applyColorSet(e, n, i);
  }
  calc_texture_size(v) {
    return Math.pow(2, Math.floor(Math.log(v) / Math.log(2)));
  }
  createGeometry(v, e, n = false) {
    const i = n ? "create_shape" : "create_geom";
    switch (v) {
      case "d2":
        var s = new lf(1 * e, 1 * e, 0.1 * e, 32);
        return s.cannon_shape = new qS(1 * e, 1 * e, 0.1 * e, 8), s;
      case "d4":
        return this[i](Ui.d4.vertices, Ui.d4.faces, e, -0.1, Math.PI * 7 / 6, 0.96);
      case "d6":
        return this[i](Ui.d6.vertices, Ui.d6.faces, e, 0.1, Math.PI / 4, 0.96);
      case "d8":
        return this[i](Ui.d8.vertices, Ui.d8.faces, e, 0, -Math.PI / 4 / 2, 0.965);
      case "d10":
        return this[i](Ui.d10.vertices, Ui.d10.faces, e, 0.3, Math.PI, 0.945);
      case "d12":
        return this[i](Ui.d12.vertices, Ui.d12.faces, e, 0.2, -Math.PI / 4 / 2, 0.968);
      case "d20":
        return this[i](Ui.d20.vertices, Ui.d20.faces, e, -0.2, -Math.PI / 4 / 2, 0.955);
      default:
        return console.error(`Geometry for ${v} is not available`), null;
    }
  }
  fixmaterials(v, e) {
    for (let i = 0, s = v.geometry.groups.length; i < s; ++i) {
      var n = v.geometry.groups[i].materialIndex - 2;
      if (n < e) continue;
      let y = n % e;
      v.geometry.groups[i].materialIndex = y + 2;
    }
    return v.geometry.elementsNeedUpdate = true, v;
  }
  create_shape(v, e, n) {
    for (var i = new Array(v.length), s = 0; s < v.length; ++s) i[s] = new _r().fromArray(v[s]).normalize();
    for (var y = new Array(v.length), t = new Array(e.length), s = 0; s < i.length; ++s) {
      var o = i[s];
      y[s] = new lt(o.x * n, o.y * n, o.z * n);
    }
    for (var s = 0; s < e.length; ++s) t[s] = e[s].slice(0, e[s].length - 1);
    return new ra({ vertices: y, faces: t });
  }
  make_geom(v, e, n, i, s) {
    let y = new ao();
    for (let m = 0; m < v.length; ++m) v[m] = v[m].multiplyScalar(n);
    let t = [];
    const o = [], u = [], c = new _r(), h = new _r();
    let f, r = 0;
    for (let m = 0; m < e.length; ++m) {
      let g = e[m], a = g.length - 1, l = Math.PI * 2 / a;
      f = g[a] + 1;
      for (let b = 0; b < a - 2; ++b) t.push(...v[g[0]].toArray()), t.push(...v[g[b + 1]].toArray()), t.push(...v[g[b + 2]].toArray()), c.subVectors(v[g[b + 2]], v[g[b + 1]]), h.subVectors(v[g[0]], v[g[b + 1]]), c.cross(h), c.normalize(), o.push(...c.toArray()), o.push(...c.toArray()), o.push(...c.toArray()), u.push((Math.cos(s) + 1 + i) / 2 / (1 + i), (Math.sin(s) + 1 + i) / 2 / (1 + i)), u.push((Math.cos(l * (b + 1) + s) + 1 + i) / 2 / (1 + i), (Math.sin(l * (b + 1) + s) + 1 + i) / 2 / (1 + i)), u.push((Math.cos(l * (b + 2) + s) + 1 + i) / 2 / (1 + i), (Math.sin(l * (b + 2) + s) + 1 + i) / 2 / (1 + i));
      let d = (a - 2) * 3;
      for (let b = 0; b < d / 3; b++) y.addGroup(r, 3, f), r += 3;
    }
    return y.setAttribute("position", new gi(t, 3)), y.setAttribute("normal", new gi(o, 3)), y.setAttribute("uv", new gi(u, 2)), y.boundingSphere = new Ds(new _r(), n), y;
  }
  make_d10_geom(v, e, n, i, s) {
    let y = new ao();
    for (let b = 0; b < v.length; ++b) v[b] = v[b].multiplyScalar(n);
    let t = [];
    const o = [], u = [], c = new _r(), h = new _r();
    let f, r = 0;
    for (let b = 0; b < e.length; ++b) {
      let S = e[b], E = S.length - 1, R = Math.PI * 2 / E;
      f = S[E] + 1;
      var m = 0.65, g = 0.85, a = 1 - 1 * g, l = 1 - 0.895 / 1.105 * g, d = 1;
      for (let w = 0; w < E - 2; ++w) t.push(...v[S[0]].toArray()), t.push(...v[S[w + 1]].toArray()), t.push(...v[S[w + 2]].toArray()), c.subVectors(v[S[w + 2]], v[S[w + 1]]), h.subVectors(v[S[0]], v[S[w + 1]]), c.cross(h), c.normalize(), o.push(...c.toArray()), o.push(...c.toArray()), o.push(...c.toArray()), e[b][e[b].length - 1] == -1 || w >= 2 ? (u.push((Math.cos(s) + 1 + i) / 2 / (1 + i), (Math.sin(s) + 1 + i) / 2 / (1 + i)), u.push((Math.cos(R * (w + 1) + s) + 1 + i) / 2 / (1 + i), (Math.sin(R * (w + 1) + s) + 1 + i) / 2 / (1 + i)), u.push((Math.cos(R * (w + 2) + s) + 1 + i) / 2 / (1 + i), (Math.sin(R * (w + 2) + s) + 1 + i) / 2 / (1 + i))) : w == 0 ? (u.push(0.5 - m / 2, l), u.push(0.5, a), u.push(0.5 + m / 2, l)) : w == 1 && (u.push(0.5 - m / 2, l), u.push(0.5 + m / 2, l), u.push(0.5, d));
      let k = (E - 2) * 3;
      for (let w = 0; w < k / 3; w++) y.addGroup(r, 3, f), r += 3;
    }
    return y.setAttribute("position", new gi(t, 3)), y.setAttribute("normal", new gi(o, 3)), y.setAttribute("uv", new gi(u, 2)), y.boundingSphere = new Ds(new _r(), n), y;
  }
  chamfer_geom(v, e, n) {
    for (var i = [], s = [], y = new Array(v.length), t = 0; t < v.length; ++t) y[t] = [];
    for (var t = 0; t < e.length; ++t) {
      for (var o = e[t], u = o.length - 1, c = new _r(), h = new Array(u), f = 0; f < u; ++f) {
        var r = v[o[f]].clone();
        c.add(r), y[o[f]].push(h[f] = i.push(r) - 1);
      }
      c.divideScalar(u);
      for (var f = 0; f < u; ++f) {
        var r = i[h[f]];
        r.subVectors(r, c).multiplyScalar(n).addVectors(r, c);
      }
      h.push(o[u]), s.push(h);
    }
    for (var t = 0; t < e.length - 1; ++t) for (var f = t + 1; f < e.length; ++f) {
      for (var m = [], g = -1, a = 0; a < e[t].length - 1; ++a) {
        var l = e[f].indexOf(e[t][a]);
        l >= 0 && l < e[f].length - 1 && (g >= 0 && a != g + 1 ? m.unshift([t, a], [f, l]) : m.push([t, a], [f, l]), g = a);
      }
      m.length == 4 && s.push([s[m[0][0]][m[0][1]], s[m[1][0]][m[1][1]], s[m[3][0]][m[3][1]], s[m[2][0]][m[2][1]], -1]);
    }
    for (var t = 0; t < y.length; ++t) {
      for (var d = y[t], h = [d[0]], b = d.length - 1; b; ) {
        for (var a = e.length; a < s.length; ++a) {
          var S = s[a].indexOf(h[h.length - 1]);
          if (S >= 0 && S < 4) {
            --S == -1 && (S = 3);
            var E = s[a][S];
            if (d.indexOf(E) >= 0) {
              h.push(E);
              break;
            }
          }
        }
        --b;
      }
      h.push(-1), s.push(h);
    }
    return { vectors: i, faces: s };
  }
  create_geom(v, e, n, i, s, y) {
    for (var t = new Array(v.length), o = 0; o < v.length; ++o) t[o] = new _r().fromArray(v[o]).normalize();
    var u = this.chamfer_geom(t, e, y);
    if (e.length != 10) var c = this.make_geom(u.vectors, u.faces, n, i, s);
    else var c = this.make_d10_geom(u.vectors, u.faces, n, i, s);
    return c.cannon_shape = this.create_shape(v, e, n), c.name = "d" + e.length, c;
  }
};
let Wm = Bs;
Mg(Wm, "dice", {});
const Ll = { cloudy: { name: "Clouds (Transparent)", composite: "destination-in", source: "textures/cloudy.webp", source_bump: "textures/cloudy.alt.webp" }, cloudy_2: { name: "Clouds", composite: "multiply", source: "textures/cloudy.alt.webp", source_bump: "textures/cloudy.alt.webp" }, fire: { name: "Fire", composite: "multiply", source: "textures/fire.webp", source_bump: "textures/fire.webp", material: "metal" }, marble: { name: "Marble", composite: "multiply", source: "textures/marble.webp", source_bump: "", material: "glass" }, water: { name: "Water", composite: "destination-in", source: "textures/water.webp", source_bump: "textures/water.webp", material: "glass" }, ice: { name: "Ice", composite: "destination-in", source: "textures/ice.webp", source_bump: "textures/ice.webp", material: "glass" }, paper: { name: "Paper", composite: "multiply", source: "textures/paper.webp", source_bump: "textures/paper-bump.webp", material: "wood" }, speckles: { name: "Speckles", composite: "multiply", source: "textures/speckles.webp", source_bump: "textures/speckles.webp", material: "none" }, glitter: { name: "Glitter", composite: "multiply", source: "textures/glitter.webp", source_bump: "textures/glitter-bump.webp", material: "none" }, glitter_2: { name: "Glitter (Transparent)", composite: "destination-in", source: "textures/glitter-alpha.webp", source_bump: "", material: "none" }, stars: { name: "Stars", composite: "multiply", source: "textures/stars.webp", source_bump: "textures/stars.webp", material: "none" }, stainedglass: { name: "Stained Glass", composite: "multiply", source: "textures/stainedglass.webp", source_bump: "textures/stainedglass-bump.webp", material: "glass" }, wood: { name: "Wood", composite: "multiply", source: "textures/wood.webp", source_bump: "textures/wood.webp", material: "wood" }, metal: { name: "Stainless Steel", composite: "multiply", source: "textures/metal.webp", source_bump: "textures/metal-bump.webp", material: "metal" }, skulls: { name: "Skulls", composite: "multiply", source: "textures/skulls.webp", source_bump: "textures/skulls.webp" }, leopard: { name: "Leopard", composite: "multiply", source: "textures/leopard.webp", source_bump: "textures/leopard.webp", material: "wood" }, tiger: { name: "Tiger", composite: "multiply", source: "textures/tiger.webp", source_bump: "textures/tiger.webp", material: "wood" }, cheetah: { name: "Cheetah", composite: "multiply", source: "textures/cheetah.webp", source_bump: "textures/cheetah.webp", material: "wood" }, dragon: { name: "Dragon", composite: "multiply", source: "textures/dragon.webp", source_bump: "textures/dragon-bump.webp", material: "none" }, lizard: { name: "Lizard", composite: "multiply", source: "textures/lizard.webp", source_bump: "textures/lizard.webp", material: "none" }, bird: { name: "Bird", composite: "multiply", source: "textures/feather.webp", source_bump: "textures/feather-bump.webp", material: "wood" }, astral: { name: "Astral Sea", composite: "multiply", source: "textures/astral.webp", source_bump: "textures/stars.webp", material: "none" }, acleaf: { name: "AC Leaf", composite: "multiply", source: "textures/acleaf.webp", source_bump: "textures/acleaf.webp", material: "none" }, thecage: { name: "Nicholas Cage", composite: "multiply", source: "textures/thecage.webp", source_bump: "", material: "metal" }, isabelle: { name: "Isabelle", composite: "source-over", source: "textures/isabelle.webp", source_bump: "", material: "none" }, bronze01: { name: "bronze01", composite: "difference", source: "textures/bronze01.webp", source_bump: "", material: "metal" }, bronze02: { name: "bronze02", composite: "difference", source: "textures/bronze02.webp", source_bump: "", material: "metal" }, bronze03: { name: "bronze03", composite: "difference", source: "textures/bronze03.webp", source_bump: "", material: "metal" }, bronze03a: { name: "bronze03a", composite: "difference", source: "textures/bronze03a.webp", source_bump: "", material: "metal" }, bronze03b: { name: "bronze03b", composite: "difference", source: "textures/bronze03b.webp", source_bump: "", material: "metal" }, bronze04: { name: "bronze04", composite: "difference", source: "textures/bronze04.webp", source_bump: "", material: "metal" }, none: { name: "none", composite: "source-over", source: "", source_bump: "", material: "" }, "": { name: "~ Preset ~", composite: "source-over", source: "", source_bump: "", material: "" } }, Cd = { coin_default: { name: "Gold Coin", description: "Gold Dragonhead Coin", category: "Other", foreground: "#f6c928", background: "#f6c928", outline: "none", texture: "metal" }, coin_silver: { name: "Silver Coin", description: "Gold Dragonhead Coin", category: "Other", foreground: "#f6c928", background: "#f6c928", outline: "none", texture: "metal" }, radiant: { name: "Radiant", category: "Damage Types", foreground: "#F9B333", background: "#FFFFFF", outline: "", texture: "paper", description: "Radiant" }, fire: { name: "Fire", category: "Damage Types", foreground: "#f8d84f", background: ["#f8d84f", "#f9b02d", "#f43c04", "#910200", "#4c1009"], outline: "black", texture: "fire", description: "Fire" }, ice: { name: "Ice", category: "Damage Types", foreground: "#60E9FF", background: ["#214fa3", "#3c6ac1", "#253f70", "#0b56e2", "#09317a"], outline: "black", texture: "ice", description: "Ice" }, poison: { name: "Poison", category: "Damage Types", foreground: "#D6A8FF", background: ["#313866", "#504099", "#66409e", "#934fc3", "#c949fc"], outline: "black", texture: "cloudy", description: "Poison" }, acid: { name: "Acid", category: "Damage Types", foreground: "#A9FF70", background: ["#a6ff00", "#83b625", "#5ace04", "#69f006", "#b0f006", "#93bc25"], outline: "black", texture: "marble", description: "Acid" }, thunder: { name: "Thunder", category: "Damage Types", foreground: "#FFC500", background: "#7D7D7D", outline: "black", texture: "cloudy", description: "Thunder" }, lightning: { name: "Lightning", category: "Damage Types", foreground: "#FFC500", background: ["#f17105", "#f3ca40", "#eddea4", "#df9a57", "#dea54b"], outline: "#7D7D7D", texture: "ice", description: "Lightning" }, air: { name: "Air", category: "Damage Types", foreground: "#ffffff", background: ["#d0e5ea", "#c3dee5", "#a4ccd6", "#8dafb7", "#80a4ad"], outline: "black", texture: "cloudy", description: "Air" }, water: { name: "Water", category: "Damage Types", foreground: "#60E9FF", background: ["#87b8c4", "#77a6b2", "#6b98a3", "#5b8691", "#4b757f"], outline: "black", texture: "water", description: "Water" }, earth: { name: "Earth", category: "Damage Types", foreground: "#6C9943", background: ["#346804", "#184200", "#527f22", "#3a1d04", "#56341a", "#331c17", "#5a352a", "#302210"], outline: "black", texture: "speckles", description: "Earth" }, force: { name: "Force", category: "Damage Types", foreground: "white", background: ["#FF97FF", "#FF68FF", "#C651C6"], outline: "#570000", texture: "stars", description: "Force" }, psychic: { name: "Psychic", category: "Damage Types", foreground: "#D6A8FF", background: ["#313866", "#504099", "#66409E", "#934FC3", "#C949FC", "#313866"], outline: "black", texture: "speckles", description: "Psychic" }, necrotic: { name: "Necrotic", category: "Damage Types", foreground: "#ffffff", background: "#6F0000", outline: "black", texture: "skulls", description: "Necrotic" }, breebaby: { name: "Pastel Sunset", category: "Custom Sets", foreground: ["#5E175E", "#564A5E", "#45455E", "#3D5A5E", "#1E595E", "#5E3F3D", "#5E1E29", "#283C5E", "#25295E"], background: ["#FE89CF", "#DFD4F2", "#C2C2E8", "#CCE7FA", "#A1D9FC", "#F3C3C2", "#EB8993", "#8EA1D2", "#7477AD"], outline: "white", texture: "marble", description: "Pastel Sunset, for Breyanna" }, pinkdreams: { name: "Pink Dreams", category: "Custom Sets", foreground: "white", background: ["#ff007c", "#df73ff", "#f400a1", "#df00ff", "#ff33cc"], outline: "#570000", texture: "skulls", description: "Pink Dreams, for Ethan" }, inspired: { name: "Inspired", category: "Custom Sets", foreground: "#FFD800", background: "#C4C4B6", outline: "#8E8E86", texture: "none", description: "Inspired, for Austin" }, bloodmoon: { name: "Blood Moon", category: "Custom Sets", foreground: "#CDB800", background: "#6F0000", outline: "black", texture: "marble", description: "Blood Moon, for Jared" }, starynight: { name: "Stary Night", category: "Custom Sets", foreground: "#4F708F", background: ["#091636", "#233660", "#4F708F", "#8597AD", "#E2E2E2"], outline: "white", texture: "speckles", description: "Stary Night, for Mai" }, glitterparty: { name: "Glitter Party", category: "Custom Sets", foreground: "white", background: ["#FFB5F5", "#7FC9FF", "#A17FFF"], outline: "none", texture: "glitter", description: "Glitter Party, for Austin" }, astralsea: { name: "Astral Sea", category: "Custom Sets", foreground: "#565656", background: "white", outline: "none", texture: "astral", description: "The Astral Sea, for Austin" }, bronze: { name: "Thylean Bronze", description: "Thylean Bronze by @SpencerThayer", category: "Custom Sets", foreground: ["#FF9159", "#FFB066", "#FFBF59", "#FFD059"], background: ["#705206", "#7A4E06", "#643100", "#7A2D06"], outline: ["#3D2D03", "#472D04", "#301700", "#471A04"], edge: ["#FF5D0D", "#FF7B00", "#FFA20D", "#FFBA0D"], texture: ["bronze01", "bronze02", "bronze03", "bronze03a", "bronze03b", "bronze04"] }, dragons: { name: "Here be Dragons", category: "Custom Sets", foreground: "#FFFFFF", background: ["#B80000", "#4D5A5A", "#5BB8FF", "#7E934E", "#FFFFFF", "#F6ED7C", "#7797A3", "#A78437", "#862C1A", "#FFDF8A"], outline: "black", texture: ["dragon", "lizard"], description: "Here be Dragons" }, birdup: { name: "Bird Up", category: "Custom Sets", foreground: "#FFFFFF", background: ["#F11602", "#FFC000", "#6EC832", "#0094BC", "#05608D", "#FEABB3", "#F75680", "#F3F0DF", "#C7A57F"], outline: "black", texture: "bird", description: "Bird Up!" }, tigerking: { name: "Tiger King", category: "Other", foreground: "#ffffff", background: "#FFCC40", outline: "black", texture: ["leopard", "tiger", "cheetah"], description: "Leopard Print" }, covid: { name: "COViD", category: "Other", foreground: "#A9FF70", background: ["#a6ff00", "#83b625", "#5ace04", "#69f006", "#b0f006", "#93bc25"], outline: "black", texture: "fire", description: "Covid-19" }, acleaf: { name: "Animal Crossing", category: "Other", foreground: "#00FF00", background: "#07540A", outline: "black", texture: "acleaf", description: "Animal Crossing Leaf" }, isabelle: { name: "Isabelle", category: "Other", foreground: "white", background: "#FEE5CC", outline: "black", texture: "isabelle", description: "Isabelle" }, thecage: { name: "Nicholas Cage", category: "Other", foreground: "#ffffff", background: "#ffffff", outline: "black", texture: "thecage", description: "Nicholas Cage" }, test: { name: "Test", category: "Colors", foreground: ["#00FF00", "#0000FF", "#FF0000"], background: ["#FF0000", "#00FF00", "#0000FF"], outline: "black", texture: "none", description: "Test" }, rainbow: { name: "Rainblow", category: "Colors", foreground: ["#FF5959", "#FFA74F", "#FFFF56", "#59FF59", "#2374FF", "#00FFFF", "#FF59FF"], background: ["#900000", "#CE3900", "#BCBC00", "#00B500", "#00008E", "#008282", "#A500A5"], outline: "black", texture: "none", description: "Rainblow" }, black: { name: "Black", category: "Colors", foreground: "#ffffff", background: "#000000", outline: "black", texture: "none", description: "Black" }, white: { name: "White", category: "Colors", foreground: "#000000", background: "#FFFFFF", outline: "#FFFFFF", texture: "none", description: "White" }, swrpg_abi: { name: "Star Wars RPG - Ability", category: "Star Wars\u2122 RPG", foreground: "#00FF00", background: ["#3D9238", "#52B848", "#5EAC56", "#9ECB9A"], outline: "#000000", texture: "cloudy_2", description: "Star Wars\u2122 RPG Ability Dice" }, swrpg_pro: { name: "Star Wars RPG - Proficiency", category: "Star Wars\u2122 RPG", foreground: "#FFFF00", background: ["#CABB1C", "#F9E33B", "#FFE900", "#F0E49D"], outline: "#000000", texture: "paper", description: "Star Wars\u2122 RPG Proficiency Dice" }, swrpg_dif: { name: "Star Wars RPG - Difficulty", category: "Star Wars\u2122 RPG", foreground: "#8000FC", background: ["#39165F", "#664B84", "#50247E", "#745F88"], outline: "#000000", texture: "cloudy_2", description: "Star Wars\u2122 RPG Difficulty Dice" }, swrpg_cha: { name: "Star Wars RPG - Challenge", category: "Star Wars\u2122 RPG", foreground: "#FF0000", background: ["#A91F32", "#EB4254", "#E51836", "#BA3645"], outline: "#000000", texture: "paper", description: "Star Wars\u2122 RPG Challenge Dice" }, swrpg_boo: { name: "Star Wars RPG - Boost", category: "Star Wars\u2122 RPG", foreground: "#00FFFF", background: ["#4B9DC6", "#689FC4", "#85CFF2", "#8FC0D8"], outline: "#000000", texture: "glitter", description: "Star Wars\u2122 RPG Boost Dice" }, swrpg_set: { name: "Star Wars RPG - Setback", category: "Star Wars\u2122 RPG", foreground: "#111111", background: ["#252223", "#241F21", "#282828", "#111111"], outline: "#ffffff", texture: "glitter", description: "Star Wars\u2122 RPG Setback Dice" }, swrpg_for: { name: "Star Wars RPG - Force", category: "Star Wars\u2122 RPG", foreground: "#000000", background: ["#F3F3F3", "#D3D3D3", "#BABABA", "#FFFFFF"], outline: "#FFFFFF", texture: "stars", description: "Star Wars\u2122 RPG Force Dice" }, swa_red: { name: "Armada Attack - Red", category: "Star Wars\u2122 Armada", foreground: "#ffffff", background: ["#440D19", "#8A1425", "#C72336", "#C04551"], outline: "none", texture: "stainedglass", description: "Star Wars\u2122 Armada Red Attack Dice" }, swa_blue: { name: "Armada Attack - Blue", category: "Star Wars\u2122 Armada", foreground: "#ffffff", background: ["#212642", "#28286E", "#2B348C", "#3D4BB5", "#5D64AB"], outline: "none", texture: "stainedglass", description: "Star Wars\u2122 Armada Blue Attack Dice" }, swa_black: { name: "Armada Attack - Black", category: "Star Wars\u2122 Armada", foreground: "#ffffff", background: ["#252223", "#241F21", "#282828", "#111111"], outline: "none", texture: "stainedglass", description: "Star Wars\u2122 Armada Black Attack Dice" }, xwing_red: { name: "X-Wing Attack - Red", category: "Star Wars\u2122 X-Wing", foreground: "#ffffff", background: ["#440D19", "#8A1425", "#C72336", "#C04551"], outline: "none", texture: "stars", description: "Star Wars\u2122 X-Wing Red Attack Dice" }, xwing_green: { name: "X-Wing Attack - Green", category: "Star Wars\u2122 X-Wing", foreground: "#ffffff", background: ["#3D9238", "#52B848", "#5EAC56", "#9ECB9A"], outline: "none", texture: "stars", description: "Star Wars\u2122 X-Wing Green Attack Dice" }, swl_atkred: { name: "Legion Attack - Red", category: "Star Wars\u2122 Legion", foreground: "#ffffff", background: ["#440D19", "#8A1425", "#C72336", "#C04551"], outline: "none", texture: "fire", description: "Star Wars\u2122 Legion Red Attack Dice" }, swl_atkblack: { name: "Legion Attack - Black", category: "Star Wars\u2122 Legion", foreground: "#ffffff", background: ["#252223", "#241F21", "#282828", "#111111"], outline: "none", texture: "fire", description: "Star Wars\u2122 Legion Black Attack Dice" }, swl_atkwhite: { name: "Legion Attack - White", category: "Star Wars\u2122 Legion", foreground: "#000000", background: ["#ffffff", "#DFF4FA", "#BCBCBC", "#F1EDE2", "#F2ECE0"], outline: "none", texture: "fire", description: "Star Wars\u2122 Legion White Attack Dice" }, swl_defred: { name: "Legion Defense - Red", category: "Star Wars\u2122 Legion", foreground: "#ffffff", background: ["#440D19", "#8A1425", "#C72336", "#C04551"], outline: "none", texture: "fire", description: "Star Wars\u2122 Legion Red Defense Dice" }, swl_defwhite: { name: "Legion Defense - White", category: "Star Wars\u2122 Legion", foreground: "#000000", background: ["#ffffff", "#DFF4FA", "#BCBCBC", "#F1EDE2", "#F2ECE0"], outline: "none", texture: "fire", description: "Star Wars\u2122 Legion White Defense Dice" } };
class gE {
  constructor(e = {}) {
    this.colorsets = [], this.assetPath = e.assetPath;
  }
  async ImageLoader(e) {
    if (Array.isArray(e)) {
      for (let n = 0, i = e.length; n < i; n++) e[n] = await this.ImageLoader(e[n]);
      return e;
    }
    return e.source && e.source != "" && (e.texture = await this.loadImage(e.source)), e.source_bump && e.source_bump != "" && (e.bump = await this.loadImage(e.source_bump)), e;
  }
  loadImage(e) {
    return new Promise((n, i) => {
      let s = new Image();
      s.onload = () => n(s), s.crossOrigin = "anonymous", s.src = this.assetPath + e, s.onerror = (y) => i(y);
    }).catch((n) => {
      console.error("Unable to load image texture");
    });
  }
  async getColorSet(e) {
    let n, i;
    if (typeof e == "string" && (n = e), typeof e == "object" && (n = e.colorset), this.colorsets.hasOwnProperty(n)) return this.colorsets[n];
    let s = Cd[n];
    return i = e.texture || s.texture, s.texture = this.getTexture(i), s.texture = await this.ImageLoader(s.texture), e.material && (s.texture.material = e.material), this.colorsets[n] = s, s;
  }
  async makeColorSet(e = {}) {
    if (this.colorsets.hasOwnProperty(e.name)) return this.colorsets[e.name];
    let n = Cd.white, i = Object.assign({}, n, e), s = this.getTexture(i.texture);
    return i.texture = await this.ImageLoader(s), e.material && (i.texture.material = e.material), i.name.toLowerCase() === "white" && (i.name = `${Date.now()}`), this.colorsets[i.name] = i, i;
  }
  getTexture(e) {
    if (Array.isArray(e)) {
      let n = [];
      for (let i = 0, s = e.length; i < s; i++) n.push(this.getTexture(e[i]));
      return n;
    }
    return Ll.hasOwnProperty(e) ? Ll[e] : Ll.none;
  }
}
const vE = { default: { name: "Solid Color", author: "MajorVictory", showColorPicker: true, surface: "wood_tray", colors: { fg: "#9794ff", bg: "#0b1a3e" }, cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"] }, "blue-felt": { name: "Blue Felt", author: "MajorVictory", showColorPicker: true, surface: "felt", colors: { fg: "#9794ff", bg: "#0b1a3e" }, cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"] }, "red-felt": { name: "Red Felt", author: "MajorVictory", showColorPicker: true, surface: "felt", colors: { fg: "#ff9494", bg: "#4d1e1e" }, cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"] }, "green-felt": { name: "Green Felt", author: "MajorVictory", showColorPicker: true, surface: "felt", colors: { fg: "#97ff94", bg: "#244d1e" }, cubeMap: ["envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg", "envmap.jpg"] }, taverntable: { name: "Old Tavern Table", author: "MajorVictory", showColorPicker: true, surface: "wood_table", colors: { fg: "#9794ff", bg: "#0b1a3e" }, cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"] }, mahogany: { name: "(Mah-Hog-Any)", author: "MajorVictory", showColorPicker: true, surface: "wood_table", colors: { fg: "#9794ff", bg: "#0b1a3e" }, cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"] }, stainless: { name: "Stainless Steel", author: "MajorVictory", showColorPicker: true, surface: "metal", colors: { fg: "#9794ff", bg: "#0b1a3e" }, cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"] }, cyberpunk: { name: "Neo-New-Future-City", author: "MajorVictory", showColorPicker: true, surface: "metal", colors: { fg: "#3494A6", bg: "#440B28" }, cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"] }, cagetown: { name: "Cage Town", author: "MajorVictory", showColorPicker: true, surface: "wood_table", colors: { fg: "#D7A866", bg: "#282811" }, cubeMap: ["px.png", "nx.png", "py.png", "ny.png", "pz.png", "nz.png"] } }, bE = (v) => {
  let e;
  return function() {
    let n = this, i = arguments;
    e && window.cancelAnimationFrame(e), e = window.requestAnimationFrame(function() {
      v.apply(n, i);
    });
  };
}, wE = { assetPath: "./", framerate: 1 / 60, sounds: false, volume: 100, color_spotlight: 15720405, shadows: true, theme_surface: "green-felt", sound_dieMaterial: "plastic", theme_customColorset: null, theme_colorset: "white", theme_texture: "", theme_material: "glass", gravity_multiplier: 400, light_intensity: 0.7, baseScale: 100, strength: 1, iterationLimit: 1e3, onRollComplete: () => {
}, onRerollComplete: () => {
}, onAddDiceComplete: () => {
}, onRemoveDiceComplete: () => {
} };
class SE {
  constructor(e, n = {}) {
    this.initialized = false, this.container = document.querySelector(e), this.dimensions = new In(this.container.clientWidth, this.container.clientHeight), this.adaptive_timestep = false, this.last_time = 0, this.running = false, this.rolling = false, this.threadid, this.display = { currentWidth: null, currentHeight: null, containerWidth: null, containerHeight: null, aspect: null, scale: null }, this.cameraHeight = { max: null, close: null, medium: null, far: null }, this.scene = new I1(), this.world = new aE(), this.dice_body_material = new ia(), this.sounds_table = {}, this.sounds_dice = [], this.lastSoundType = "", this.lastSoundStep = 0, this.lastSound = 0, this.iteration, this.renderer, this.barrier, this.camera, this.light, this.light_amb, this.desk, this.box_body = {}, this.bodies = [], this.meshes = [], this.diceList = [], this.notationVectors = null, this.dieIndex = 0, this.soundDelay = 10, this.animstate = "", this.selector = { animate: true, rotate: true, intersected: null, dice: [] }, Object.assign(this, wE, n), this.DiceColors = new gE({ assetPath: this.assetPath }), this.DiceFactory = new Wm({ baseScale: this.baseScale }), this.DiceFactory.setBumpMapping(true), this.surface = vE[this.theme_surface].surface;
  }
  enableShadows() {
    this.shadows = true, this.renderer && (this.renderer.shadowMap.enabled = this.shadows), this.light && (this.light.castShadow = this.shadows), this.desk && (this.desk.receiveShadow = this.shadows);
  }
  disableShadows() {
    this.shadows = false, this.renderer && (this.renderer.shadowMap.enabled = this.shadows), this.light && (this.light.castShadow = this.shadows), this.desk && (this.desk.receiveShadow = this.shadows);
  }
  async initialize() {
    this.renderer = new Bm({ antialias: true, alpha: true }), this.container.appendChild(this.renderer.domElement), this.renderer.shadowMap.enabled = this.shadows, this.renderer.shadowMap.type = 2, this.renderer.setClearColor(0, 0), this.setDimensions(this.dimensions), this.world.gravity.set(0, 0, -9.8 * this.gravity_multiplier), this.world.broadphase = new Fm(), this.world.solver.iterations = 14, this.world.allowSleep = true, this.makeWorldBox(), this.resizeWorld(), await this.loadTheme({ colorset: this.theme_colorset, texture: this.theme_texture, material: this.theme_material }).catch((e) => {
      throw new Error("Unable to load theme");
    }), this.sounds && await this.loadSounds().catch((e) => {
      throw new Error("Unable to load sounds");
    }), this.initialized = true, this.renderer.render(this.scene, this.camera);
  }
  makeWorldBox() {
    Object.keys(this.box_body).length && (this.world.removeBody(this.box_body.desk), this.world.removeBody(this.box_body.topWall), this.world.removeBody(this.box_body.bottomWall), this.world.removeBody(this.box_body.leftWall), this.world.removeBody(this.box_body.rightWall));
    const e = new ia(), n = new ia();
    this.world.addContactMaterial(new na(e, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 0.5 })), this.world.addContactMaterial(new na(n, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 1 })), this.world.addContactMaterial(new na(this.dice_body_material, this.dice_body_material, { mass: 0, friction: 0.6, restitution: 0.5 })), this.box_body.desk = new nn({ allowSleep: false, mass: 0, shape: new _s(), material: e }), this.world.addBody(this.box_body.desk), this.box_body.topWall = new nn({ allowSleep: false, mass: 0, shape: new _s(), material: n }), this.box_body.topWall.quaternion.setFromAxisAngle(new lt(1, 0, 0), Math.PI / 2), this.box_body.topWall.position.set(0, this.display.containerHeight * 0.93, 0), this.world.addBody(this.box_body.topWall), this.box_body.bottomWall = new nn({ allowSleep: false, mass: 0, shape: new _s(), material: n }), this.box_body.bottomWall.quaternion.setFromAxisAngle(new lt(1, 0, 0), -Math.PI / 2), this.box_body.bottomWall.position.set(0, -this.display.containerHeight * 0.93, 0), this.world.addBody(this.box_body.bottomWall), this.box_body.leftWall = new nn({ allowSleep: false, mass: 0, shape: new _s(), material: n }), this.box_body.leftWall.quaternion.setFromAxisAngle(new lt(0, 1, 0), -Math.PI / 2), this.box_body.leftWall.position.set(this.display.containerWidth * 0.93, 0, 0), this.world.addBody(this.box_body.leftWall), this.box_body.rightWall = new nn({ allowSleep: false, mass: 0, shape: new _s(), material: n }), this.box_body.rightWall.quaternion.setFromAxisAngle(new lt(0, 1, 0), Math.PI / 2), this.box_body.rightWall.position.set(-this.display.containerWidth * 0.93, 0, 0), this.world.addBody(this.box_body.rightWall);
  }
  async loadTheme(e) {
    let n;
    this.theme_customColorset ? n = await this.DiceColors.makeColorSet(this.theme_customColorset) : n = await this.DiceColors.getColorSet(e), this.DiceFactory.applyColorSet(n), this.colorData = n;
  }
  async loadSounds() {
    let e = { felt: 7, wood_table: 7, wood_tray: 7, metal: 9 }, n = { coin: 6, metal: 12, plastic: 15, wood: 12 };
    const i = this.colorData.texture.material.match(/wood|metal/g);
    if (this.sound_dieMaterial = i ? this.colorData.texture.material : "plastic", !this.sounds_table.hasOwnProperty(this.surface)) {
      this.sounds_table[this.surface] = [];
      let s = e[this.surface];
      for (let y = 1; y <= s; ++y) {
        const t = await this.loadAudio(this.assetPath + "sounds/surfaces/surface_" + this.surface + y + ".mp3");
        this.sounds_table[this.surface].push(t);
      }
    }
    if (!this.sounds_dice.hasOwnProperty("coin")) {
      this.sounds_dice.coin = [];
      let s = n.coin;
      for (let y = 1; y <= s; ++y) {
        const t = await this.loadAudio(this.assetPath + "sounds/dicehit/dicehit_coin" + y + ".mp3");
        this.sounds_dice.coin.push(t);
      }
    }
    if (!this.sounds_dice.hasOwnProperty(this.sound_dieMaterial)) {
      this.sounds_dice[this.sound_dieMaterial] = [];
      let s = n[this.sound_dieMaterial];
      for (let y = 1; y <= s; ++y) {
        const t = await this.loadAudio(this.assetPath + "sounds/dicehit/dicehit_" + this.sound_dieMaterial + y + ".mp3");
        this.sounds_dice[this.sound_dieMaterial].push(t);
      }
    }
  }
  loadAudio(e) {
    return new Promise((n, i) => {
      let s = new Audio();
      s.oncanplaythrough = () => n(s), s.crossOrigin = "anonymous", s.src = e, s.onerror = (y) => i(y);
    }).catch((n) => {
      console.error("Unable to load audio");
    });
  }
  async updateConfig(e = {}) {
    Object.apply(this, e), this.theme_customColorset = e.theme_customColorset ? e.theme_customColorset : null, e.theme_colorset && (this.theme_colorset = e.theme_colorset), e.theme_texture && (this.theme_texture = e.theme_texture), e.theme_material && (this.theme_material = e.theme_material), (e.theme_colorset || e.theme_texture || e.theme_material || e.theme_customColorset) && await this.loadTheme({ colorset: this.theme_colorset, texture: this.theme_texture, material: this.theme_material });
  }
  setDimensions(e) {
    switch (this.display.currentWidth = this.container.clientWidth / 2, this.display.currentHeight = this.container.clientHeight / 2, e ? (this.display.containerWidth = e.x, this.display.containerHeight = e.y) : (this.display.containerWidth = this.display.currentWidth, this.display.containerHeight = this.display.currentHeight), this.display.aspect = Math.min(this.display.currentWidth / this.display.containerWidth, this.display.currentHeight / this.display.containerHeight), this.display.scale = Math.sqrt(this.display.containerWidth * this.display.containerWidth + this.display.containerHeight * this.display.containerHeight) / 13, this.makeWorldBox(), this.renderer.setSize(this.display.currentWidth * 2, this.display.currentHeight * 2), this.cameraHeight.max = this.display.currentHeight / this.display.aspect / Math.tan(10 * Math.PI / 180), this.cameraHeight.medium = this.cameraHeight.max / 1.5, this.cameraHeight.far = this.cameraHeight.max, this.cameraHeight.close = this.cameraHeight.max / 2, this.camera && this.scene.remove(this.camera), this.camera = new Ri(20, this.display.currentWidth / this.display.currentHeight, 1, this.cameraHeight.max * 1.3), this.animstate) {
      case "selector":
        this.camera.position.z = this.selector.dice.length > 9 ? this.cameraHeight.far : this.selector.dice.length < 6 ? this.cameraHeight.close : this.cameraHeight.medium;
        break;
      case "throw":
      case "afterthrow":
      default:
        this.camera.position.z = this.cameraHeight.far;
    }
    this.camera.lookAt(new _r(0, 0, 0));
    const n = Math.max(this.display.containerWidth, this.display.containerHeight);
    this.light && this.scene.remove(this.light), this.light_amb && this.scene.remove(this.light_amb), this.light = new j1(this.color_spotlight, this.light_intensity), this.light.position.set(-n / 2, n / 2, n * 3), this.light.target.position.set(0, 0, 0), this.light.distance = n * 5, this.light.angle = Math.PI / 4, this.light.castShadow = this.shadows, this.light.shadow.camera.near = n / 10, this.light.shadow.camera.far = n * 5, this.light.shadow.camera.fov = 50, this.light.shadow.bias = 1e-3, this.light.shadow.mapSize.width = 1024, this.light.shadow.mapSize.height = 1024, this.scene.add(this.light), this.light_amb = new D1(16777147, 6776689, this.light_intensity), this.scene.add(this.light_amb), this.desk && this.scene.remove(this.desk);
    let i = new L1();
    i.opacity = 0.5, this.desk = new io(new xc(this.display.containerWidth * 6, this.display.containerHeight * 6, 1, 1), i), this.desk.receiveShadow = this.shadows, this.scene.add(this.desk), this.renderer.render(this.scene, this.camera);
  }
  resizeWorld() {
    const e = bE(() => {
      const n = this.renderer.domElement, i = this.container.clientWidth, s = this.container.clientHeight, y = n.width !== i || n.height !== s;
      return y && this.setDimensions(new In(this.container.clientWidth, this.container.clientHeight)), y;
    });
    window.addEventListener("resize", e);
  }
  vectorRand({ x: e, y: n }) {
    let i = Math.random() * Math.PI / 5 - Math.PI / 5 / 2, s = { x: e * Math.cos(i) - n * Math.sin(i), y: e * Math.sin(i) + n * Math.cos(i) };
    return s.x == 0 && (s.x = 0.01), s.y == 0 && (s.y = 0.01), s;
  }
  getNotationVectors(e, n, i, s) {
    let y = new Pd(e);
    for (let t in y.set) {
      const o = this.DiceFactory.get(y.set[t].type);
      let u = y.set[t].num, c = y.set[t].op, h = y.set[t].sid, f = y.set[t].gid, r = y.set[t].glvl, m = y.set[t].func, g = y.set[t].args;
      for (let a = 0; a < u; a++) {
        let l = this.vectorRand(n);
        l.x /= s, l.y /= s;
        let d = { x: this.display.containerWidth * (l.x > 0 ? -1 : 1) * 0.9, y: this.display.containerHeight * (l.y > 0 ? -1 : 1) * 0.9, z: Math.random() * 200 + 200 }, b = Math.abs(l.x / l.y);
        b > 1 ? d.y /= b : d.x *= b;
        let S = this.vectorRand(n);
        S.x /= s, S.y /= s;
        let E, R, k;
        o.shape != "d2" ? (E = { x: S.x * i, y: S.y * i, z: -10 }, R = { x: -(Math.random() * l.y * 5 + o.inertia * l.y), y: Math.random() * l.x * 5 + o.inertia * l.x, z: 0 }, k = { x: Math.random(), y: Math.random(), z: Math.random(), a: Math.random() }) : (E = { x: S.x * i / 10, y: S.y * i / 10, z: 3e3 }, R = { x: 12 * o.inertia, y: 1 * o.inertia, z: 0 }, k = { x: 1, y: 1, z: Math.random(), a: Math.random() }), y.vectors.push({ index: this.dieIndex++, type: o.type, op: c, sid: h, gid: f, glvl: r, func: m, args: g, pos: d, velocity: E, angle: R, axis: k });
      }
    }
    return y;
  }
  swapDiceFace(e, n) {
    const i = this.DiceFactory.get(e.notation.type);
    if (e.resultReason = "forced", i.shape == "d4") {
      this.swapDiceFace_D4(e, n);
      return;
    }
    i.values;
    let s = parseInt(e.getLastValue().value);
    n = parseInt(n), e.notation.type == "d10" && s == 0 && (s = 10), e.notation.type == "d100" && s == 0 && (s = 100), e.notation.type == "d100" && s > 0 && s < 10 && (s *= 10), e.notation.type == "d10" && n == 0 && (n = 10), e.notation.type == "d100" && n == 0 && (n = 100), e.notation.type == "d100" && n > 0 && n < 10 && (n *= 10);
    let y = i.values.indexOf(s), t = i.values.indexOf(n);
    if (y < 0 || t < 0 || y == t) return;
    let o = e.geometry.clone(), u = [], c = [], h = 2;
    i.shape == "d10" && (h = 1);
    let f, r = t + h;
    i.shape != "d2" ? (f = y + h, r = t + h) : (f = y + 1, r = t + 1);
    for (var m = 0, g = o.groups.length; m < g; ++m) {
      const a = o.groups[m].materialIndex;
      if (a == f) {
        u.push(m);
        continue;
      }
      if (a == r) {
        c.push(m);
        continue;
      }
    }
    if (!(u.length <= 0 || c.length <= 0)) {
      for (let a = 0, l = c.length; a < l; a++) o.groups[c[a]].materialIndex = f;
      for (let a = 0, l = u.length; a < l; a++) o.groups[u[a]].materialIndex = r;
      e.geometry = o, e.result = [];
    }
  }
  swapDiceFace_D4(e, n) {
    const i = this.DiceFactory.get(e.notation.type);
    let s = parseInt(e.getLastValue().value);
    if (n = parseInt(n), !(s >= 1 && s <= 4)) return;
    let y = n - s, t = e.geometry.clone();
    for (let o = 0, u = t.groups.length; o < u; ++o) {
      const c = t.groups[o];
      let h = c.materialIndex;
      if (h != 0) {
        for (h += y - 1; h > 4; ) h -= 4;
        for (; h < 1; ) h += 4;
        c.materialIndex = h + 1;
      }
    }
    y != 0 && (y < 0 && (y += 4), e.material = this.DiceFactory.createMaterials(i, 0, 0, false, y)), e.geometry = t;
  }
  spawnDice(e, n = false) {
    const { pos: i, axis: s, angle: y, velocity: t } = e;
    let o;
    if (n) o = n, o.stopped = 0, this.world.removeBody(o.body);
    else {
      if (o = this.DiceFactory.create(e.type, this.colorData), !o) return;
      o.notation = e, o.result = [], o.stopped = 0, o.castShadow = this.shadows, this.scene.add(o), this.diceList.push(o);
    }
    o.body = new nn({ allowSleep: true, sleepSpeedLimit: 75, sleepTimeLimit: 0.9, mass: o.mass, shape: o.geometry.cannon_shape, material: this.dice_body_material }), o.body.type = nn.DYNAMIC, o.body.position.set(i.x, i.y, i.z), o.body.quaternion.setFromAxisAngle(new lt(s.x, s.y, s.z), s.a * Math.PI * 2), o.body.angularVelocity.set(y.x, y.y, y.z), o.body.velocity.set(t.x, t.y, t.z), o.body.linearDamping = 0.1, o.body.angularDamping = 0.1, o.body.diceShape = o.shape, o.body.sleepState = 0, o.body.addEventListener("collide", this.eventCollide.bind(this)), this.world.addBody(o.body);
  }
  eventCollide({ body: e, target: n }) {
    if (this.animstate == "simulate" || !this.sounds || !e || this.volume <= 0) return;
    let i = Date.now(), s = e.mass > 0 ? "dice" : "table";
    if (!((this.lastSoundStep == e.world.stepnumber || this.lastSound > i) && s != "dice") && !((this.lastSoundStep == e.world.stepnumber || this.lastSound > i) && s == "dice" && this.lastSoundType == "dice")) {
      if (e.mass > 0) {
        let y = e.velocity.length();
        if (y < 250) return;
        let t;
        e.diceShape === "d2" ? t = this.sounds_dice.coin[Math.floor(Math.random() * this.sounds_dice.coin.length)] : t = this.sounds_dice[this.sound_dieMaterial][Math.floor(Math.random() * this.sounds_dice[this.sound_dieMaterial].length)], t && (t.volume = Math.min(y / 8e3, this.volume / 100), t.play().catch((o) => {
        })), this.lastSoundType = "dice";
      } else {
        let y = n.velocity.length();
        if (y < 250) return;
        let t = this.surface, o = this.sounds_table[t], u = o[Math.floor(Math.random() * o.length)];
        u && (u.volume = Math.min(y / 8e3, this.volume / 100), u.play().catch((c) => {
        })), this.lastSoundType = "table";
      }
      this.lastSoundStep = e.world.stepnumber, this.lastSound = i + this.soundDelay;
    }
  }
  checkForRethrow(e) {
    return e.notation.func && e.notation.func.toLowerCase(), false;
  }
  throwFinished() {
    const e = this.iteration > this.iterationLimit;
    for (let n = 0, i = this.diceList.length; n < i; ++n) {
      const s = this.diceList[n], y = nn.SLEEPING;
      if (s.body.sleepState < y && !e) return false;
      if (s.body.sleepState == y || e) {
        if (s.body.type === nn.KINEMATIC) continue;
        let t = false;
        if (s.result.length == 0 ? (s.storeRolledValue(s.resultReason), t = this.checkForRethrow(s)) : s.result.length > 0 && s.rerolling && (s.rerolling = false, s.storeRolledValue("reroll"), t = this.checkForRethrow(s)), t) return s.rerolls += 1, s.rerolling = true, s.body.wakeUp(), s.body.type = nn.DYNAMIC, s.body.angularVelocity = new lt(25, 25, 25), s.body.velocity = new lt(0, 0, 3e3), false;
        s.rerolling = false, s.body.type = nn.KINEMATIC;
      }
    }
    return true;
  }
  simulateThrow() {
    for (this.animstate = "simulate", this.iteration = 0, this.rolling = true; !this.throwFinished(true); ) ++this.iteration, this.world.step(this.framerate);
  }
  animateThrow(e, n) {
    this.animstate = "throw";
    let i = Date.now();
    this.last_time = this.last_time || i - this.framerate * 1e3;
    let s = (i - this.last_time) / 1e3;
    ++this.iteration;
    let y = Math.floor(s / this.framerate);
    for (let t = 0; t < y; t++) this.world.step(this.framerate), ++this.steps;
    for (let t in this.scene.children) {
      let o = this.scene.children[t];
      o.body != null && (o.position.copy(o.body.position), o.quaternion.copy(o.body.quaternion));
    }
    if (this.renderer.render(this.scene, this.camera), this.last_time = this.last_time + y * this.framerate * 1e3, this.running == e && this.throwFinished()) {
      this.running = false, this.rolling = false, n && n.call(this, this.notationVectors), this.running = Date.now(), this.animateAfterThrow(this.running);
      return;
    }
    this.running == e && ((t, o, u, c, h) => {
      !u && s < this.framerate ? setTimeout(() => {
        requestAnimationFrame(() => {
          t.call(this, o, c, h);
        });
      }, (this.framerate - s) * 1e3) : requestAnimationFrame(() => {
        t.call(this, o, c, h);
      });
    }).bind(this)(this.animateThrow, e, this.adaptive_timestep, n);
  }
  animateAfterThrow(e) {
    this.animstate = "afterthrow";
    let n = Date.now(), i = (n - this.last_time) / 1e3;
    i > 3 && (i = this.framerate), this.running = false, this.last_time = n, this.renderer.render(this.scene, this.camera), this.running == e && ((s, y, t) => {
      !t && i < this.framerate ? setTimeout(() => {
        requestAnimationFrame(() => {
          s.call(this, y);
        });
      }, (this.framerate - i) * 1e3) : requestAnimationFrame(() => {
        s.call(this, y);
      });
    }).bind(this)(this.animateAfterThrow, e, this.adaptive_timestep);
  }
  startClickThrow(e) {
    this.rolling && (this.clearDice(), this.rolling = false);
    let n = { x: (Math.random() * 2 - 0.5) * this.display.currentWidth, y: -(Math.random() * 2 - 0.5) * this.display.currentHeight }, i = Math.sqrt(n.x * n.x + n.y * n.y) + 100, s = (Math.random() + 3) * i * this.strength;
    return this.getNotationVectors(e, n, s, i);
  }
  clearDice() {
    this.running = false;
    let e;
    for (; e = this.diceList.pop(); ) this.scene.remove(e), e.body && this.world.removeBody(e.body);
    this.renderer.render(this.scene, this.camera), setTimeout(() => {
      this.renderer.render(this.scene, this.camera);
    }, 100);
  }
  getDiceResults(e) {
    if (e !== void 0) return { type: this.diceList[e].shape, sides: parseInt(this.diceList[e].shape.substring(1)), id: e, ...this.diceList[e].result.at(-1) };
    let n = 0;
    const i = this.notationVectors.constant ? parseInt(`${this.notationVectors.op}${this.notationVectors.constant}`) : 0;
    let s = i;
    return { notation: this.notationVectors.notation, sets: this.notationVectors.set.map((y) => {
      const t = n + y.num - 1;
      let o = 0;
      const u = [];
      for (let h = n; h <= t; h++) {
        if (this.diceList[n].result.at(-1).reason === "remove") {
          n++;
          continue;
        }
        u.push({ type: y.type, sides: parseInt(y.type.substring(1)), id: n, ...this.diceList[n].result.at(-1) }), o += this.diceList[n].result.at(-1).value, n++;
      }
      const c = { num: y.num, type: y.type, sides: parseInt(y.type.substring(1)), rolls: u, total: o };
      return s += o, c;
    }), modifier: i, total: s };
  }
  async roll(e) {
    if (this.notationVectors = this.startClickThrow(e), this.notationVectors) return new Promise((n, i) => {
      this.rollDice(() => {
        const s = this.getDiceResults();
        this.onRollComplete(s);
        const y = new CustomEvent("rollComplete", { detail: s });
        document.dispatchEvent(y), n(s);
      });
    });
  }
  async reroll(e) {
    return this.rolling = true, this.running = Date.now(), this.iteration = 0, new Promise((n, i) => {
      e.forEach((s) => {
        const y = this.diceList[s];
        y.rerolls += 1, y.rerolling = true, y.body.wakeUp(), y.body.type = nn.DYNAMIC, y.body.angularVelocity = new lt(25, 25, 25), y.body.velocity = new lt(0, 0, 3e3);
      }), this.animateThrow(this.running, () => {
        const s = e.map((t) => this.getDiceResults(t));
        this.onRerollComplete(s);
        const y = new CustomEvent("rerollComplete", { detail: s });
        document.dispatchEvent(y), n(s);
      });
    });
  }
  async add(e) {
    let n = this.diceList.length;
    if (!n) return this.roll(e);
    let i = this.startClickThrow(e), s = [];
    for (let y = 0, t = i.vectors.length; y < t; ++y) this.spawnDice(i.vectors[y]);
    this.simulateThrow(), this.steps = 0, this.iteration = 0;
    for (let y = 0, t = i.vectors.length; y < t; ++y) {
      const o = n + y;
      !this.diceList[o] || (this.spawnDice(i.vectors[y], this.diceList[o]), s.push(o));
    }
    if (i.result && i.result.length > 0) for (let y = 0; y < i.result.length; y++) {
      const t = n + y;
      let o = this.diceList[t];
      !o || o.getLastValue().value != i.result[y] && this.swapDiceFace(o, i.result[y]);
    }
    return this.notationVectors = Pd.mergeNotation(this.notationVectors, i), new Promise((y, t) => {
      const o = () => {
        const u = s.map((h) => this.getDiceResults(h));
        this.onAddDiceComplete(u);
        const c = new CustomEvent("addDiceComplete", { detail: u });
        document.dispatchEvent(c), y(u);
      };
      this.rolling = true, this.running = Date.now(), this.last_time = 0, this.animateThrow(this.running, o);
    });
  }
  async remove(e) {
    return new Promise((n, i) => {
      const s = [];
      e.forEach((t) => {
        const o = this.diceList[t];
        o.body && this.world.removeBody(o.body), this.scene.remove(o), o.storeRolledValue("remove"), s.push(this.getDiceResults(t));
      }), this.renderer.render(this.scene, this.camera), this.onRemoveDiceComplete(s);
      const y = new CustomEvent("removeDiceComplete", { detail: s });
      document.dispatchEvent(y), n(s);
    });
  }
  rollDice(e) {
    if (this.notationVectors.error) {
      e.call(this);
      return;
    }
    this.clearDice();
    for (let n = 0, i = this.notationVectors.vectors.length; n < i; ++n) this.spawnDice(this.notationVectors.vectors[n]);
    this.simulateThrow(), this.steps = 0, this.iteration = 0;
    for (let n = 0, i = this.diceList.length; n < i; ++n) !this.diceList[n] || this.spawnDice(this.notationVectors.vectors[n], this.diceList[n]);
    if (this.notationVectors.result && this.notationVectors.result.length > 0) for (let n = 0; n < this.notationVectors.result.length; n++) {
      let i = this.diceList[n];
      !i || i.getLastValue().value != this.notationVectors.result[n] && this.swapDiceFace(i, this.notationVectors.result[n]);
    }
    this.rolling = true, this.running = Date.now(), this.last_time = 0, this.animateThrow(this.running, e);
  }
}
var Bl = {}, Ts = {}, Xo = {}, Rd;
function mf() {
  if (Rd) return Xo;
  Rd = 1, Object.defineProperty(Xo, "__esModule", { value: true }), Xo.Ok = Xo.Err = void 0;
  function v(t) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, v(t);
  }
  function e(t, o) {
    if (!(t instanceof o)) throw new TypeError("Cannot call a class as a function");
  }
  function n(t, o) {
    for (var u = 0; u < o.length; u++) {
      var c = o[u];
      c.enumerable = c.enumerable || false, c.configurable = true, "value" in c && (c.writable = true), Object.defineProperty(t, s(c.key), c);
    }
  }
  function i(t, o, u) {
    return o && n(t.prototype, o), Object.defineProperty(t, "prototype", { writable: false }), t;
  }
  function s(t) {
    var o = y(t, "string");
    return v(o) == "symbol" ? o : o + "";
  }
  function y(t, o) {
    if (v(t) != "object" || !t) return t;
    var u = t[Symbol.toPrimitive];
    if (u !== void 0) {
      var c = u.call(t, o);
      if (v(c) != "object") return c;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(t);
  }
  return Xo.Ok = function() {
    function t(o) {
      e(this, t), this.value = o;
    }
    return i(t, [{ key: "unwrapErr", value: function() {
      throw new Error("No error");
    } }, { key: "unwrap", value: function() {
      return this.value;
    } }, { key: "isOk", value: function() {
      return true;
    } }, { key: "isErr", value: function() {
      return false;
    } }]);
  }(), Xo.Err = function() {
    function t(o) {
      e(this, t), this.error = o;
    }
    return i(t, [{ key: "unwrapErr", value: function() {
      return this.error;
    } }, { key: "unwrap", value: function() {
      throw new Error(this.error.message);
    } }, { key: "isOk", value: function() {
      return false;
    } }, { key: "isErr", value: function() {
      return true;
    } }]);
  }(), Xo;
}
var _o = {}, $o = {}, Md;
function kc() {
  return Md || (Md = 1, Object.defineProperty($o, "__esModule", { value: true }), $o.NULL_ACCOUNT = $o.DEFAULT_TIMEOUT = void 0, ko(), $o.DEFAULT_TIMEOUT = 5 * 60, $o.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"), $o;
}
var Id;
function yf() {
  if (Id) return _o;
  Id = 1, Object.defineProperty(_o, "__esModule", { value: true }), _o.contractErrorPattern = void 0, _o.getAccount = h, _o.implementsToString = u, _o.processSpecEntryStream = c, _o.withExponentialBackoff = t;
  var v = ko(), e = kc();
  function n() {
    n = function() {
      return m;
    };
    var r, m = {}, g = Object.prototype, a = g.hasOwnProperty, l = Object.defineProperty || function(ce, ye, ae) {
      ce[ye] = ae.value;
    }, d = typeof Symbol == "function" ? Symbol : {}, b = d.iterator || "@@iterator", S = d.asyncIterator || "@@asyncIterator", E = d.toStringTag || "@@toStringTag";
    function R(ce, ye, ae) {
      return Object.defineProperty(ce, ye, { value: ae, enumerable: true, configurable: true, writable: true }), ce[ye];
    }
    try {
      R({}, "");
    } catch {
      R = function(ae, ue, ne) {
        return ae[ue] = ne;
      };
    }
    function k(ce, ye, ae, ue) {
      var ne = ye && ye.prototype instanceof _ ? ye : _, ge = Object.create(ne.prototype), Te = new $(ue || []);
      return l(ge, "_invoke", { value: J(ce, ae, Te) }), ge;
    }
    function w(ce, ye, ae) {
      try {
        return { type: "normal", arg: ce.call(ye, ae) };
      } catch (ue) {
        return { type: "throw", arg: ue };
      }
    }
    m.wrap = k;
    var F = "suspendedStart", I = "suspendedYield", q = "executing", D = "completed", H = {};
    function _() {
    }
    function T() {
    }
    function L() {
    }
    var j = {};
    R(j, b, function() {
      return this;
    });
    var z = Object.getPrototypeOf, Y = z && z(z(oe([])));
    Y && Y !== g && a.call(Y, b) && (j = Y);
    var te = L.prototype = _.prototype = Object.create(j);
    function G(ce) {
      ["next", "throw", "return"].forEach(function(ye) {
        R(ce, ye, function(ae) {
          return this._invoke(ye, ae);
        });
      });
    }
    function K(ce, ye) {
      function ae(ne, ge, Te, pe) {
        var Oe = w(ce[ne], ce, ge);
        if (Oe.type !== "throw") {
          var xe = Oe.arg, Ve = xe.value;
          return Ve && i(Ve) == "object" && a.call(Ve, "__await") ? ye.resolve(Ve.__await).then(function(_e) {
            ae("next", _e, Te, pe);
          }, function(_e) {
            ae("throw", _e, Te, pe);
          }) : ye.resolve(Ve).then(function(_e) {
            xe.value = _e, Te(xe);
          }, function(_e) {
            return ae("throw", _e, Te, pe);
          });
        }
        pe(Oe.arg);
      }
      var ue;
      l(this, "_invoke", { value: function(ge, Te) {
        function pe() {
          return new ye(function(Oe, xe) {
            ae(ge, Te, Oe, xe);
          });
        }
        return ue = ue ? ue.then(pe, pe) : pe();
      } });
    }
    function J(ce, ye, ae) {
      var ue = F;
      return function(ne, ge) {
        if (ue === q) throw Error("Generator is already running");
        if (ue === D) {
          if (ne === "throw") throw ge;
          return { value: r, done: true };
        }
        for (ae.method = ne, ae.arg = ge; ; ) {
          var Te = ae.delegate;
          if (Te) {
            var pe = B(Te, ae);
            if (pe) {
              if (pe === H) continue;
              return pe;
            }
          }
          if (ae.method === "next") ae.sent = ae._sent = ae.arg;
          else if (ae.method === "throw") {
            if (ue === F) throw ue = D, ae.arg;
            ae.dispatchException(ae.arg);
          } else ae.method === "return" && ae.abrupt("return", ae.arg);
          ue = q;
          var Oe = w(ce, ye, ae);
          if (Oe.type === "normal") {
            if (ue = ae.done ? D : I, Oe.arg === H) continue;
            return { value: Oe.arg, done: ae.done };
          }
          Oe.type === "throw" && (ue = D, ae.method = "throw", ae.arg = Oe.arg);
        }
      };
    }
    function B(ce, ye) {
      var ae = ye.method, ue = ce.iterator[ae];
      if (ue === r) return ye.delegate = null, ae === "throw" && ce.iterator.return && (ye.method = "return", ye.arg = r, B(ce, ye), ye.method === "throw") || ae !== "return" && (ye.method = "throw", ye.arg = new TypeError("The iterator does not provide a '" + ae + "' method")), H;
      var ne = w(ue, ce.iterator, ye.arg);
      if (ne.type === "throw") return ye.method = "throw", ye.arg = ne.arg, ye.delegate = null, H;
      var ge = ne.arg;
      return ge ? ge.done ? (ye[ce.resultName] = ge.value, ye.next = ce.nextLoc, ye.method !== "return" && (ye.method = "next", ye.arg = r), ye.delegate = null, H) : ge : (ye.method = "throw", ye.arg = new TypeError("iterator result is not an object"), ye.delegate = null, H);
    }
    function Z(ce) {
      var ye = { tryLoc: ce[0] };
      1 in ce && (ye.catchLoc = ce[1]), 2 in ce && (ye.finallyLoc = ce[2], ye.afterLoc = ce[3]), this.tryEntries.push(ye);
    }
    function ie(ce) {
      var ye = ce.completion || {};
      ye.type = "normal", delete ye.arg, ce.completion = ye;
    }
    function $(ce) {
      this.tryEntries = [{ tryLoc: "root" }], ce.forEach(Z, this), this.reset(true);
    }
    function oe(ce) {
      if (ce || ce === "") {
        var ye = ce[b];
        if (ye) return ye.call(ce);
        if (typeof ce.next == "function") return ce;
        if (!isNaN(ce.length)) {
          var ae = -1, ue = function ne() {
            for (; ++ae < ce.length; ) if (a.call(ce, ae)) return ne.value = ce[ae], ne.done = false, ne;
            return ne.value = r, ne.done = true, ne;
          };
          return ue.next = ue;
        }
      }
      throw new TypeError(i(ce) + " is not iterable");
    }
    return T.prototype = L, l(te, "constructor", { value: L, configurable: true }), l(L, "constructor", { value: T, configurable: true }), T.displayName = R(L, E, "GeneratorFunction"), m.isGeneratorFunction = function(ce) {
      var ye = typeof ce == "function" && ce.constructor;
      return !!ye && (ye === T || (ye.displayName || ye.name) === "GeneratorFunction");
    }, m.mark = function(ce) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(ce, L) : (ce.__proto__ = L, R(ce, E, "GeneratorFunction")), ce.prototype = Object.create(te), ce;
    }, m.awrap = function(ce) {
      return { __await: ce };
    }, G(K.prototype), R(K.prototype, S, function() {
      return this;
    }), m.AsyncIterator = K, m.async = function(ce, ye, ae, ue, ne) {
      ne === void 0 && (ne = Promise);
      var ge = new K(k(ce, ye, ae, ue), ne);
      return m.isGeneratorFunction(ye) ? ge : ge.next().then(function(Te) {
        return Te.done ? Te.value : ge.next();
      });
    }, G(te), R(te, E, "Generator"), R(te, b, function() {
      return this;
    }), R(te, "toString", function() {
      return "[object Generator]";
    }), m.keys = function(ce) {
      var ye = Object(ce), ae = [];
      for (var ue in ye) ae.push(ue);
      return ae.reverse(), function ne() {
        for (; ae.length; ) {
          var ge = ae.pop();
          if (ge in ye) return ne.value = ge, ne.done = false, ne;
        }
        return ne.done = true, ne;
      };
    }, m.values = oe, $.prototype = { constructor: $, reset: function(ye) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = false, this.delegate = null, this.method = "next", this.arg = r, this.tryEntries.forEach(ie), !ye) for (var ae in this) ae.charAt(0) === "t" && a.call(this, ae) && !isNaN(+ae.slice(1)) && (this[ae] = r);
    }, stop: function() {
      this.done = true;
      var ye = this.tryEntries[0].completion;
      if (ye.type === "throw") throw ye.arg;
      return this.rval;
    }, dispatchException: function(ye) {
      if (this.done) throw ye;
      var ae = this;
      function ue(xe, Ve) {
        return Te.type = "throw", Te.arg = ye, ae.next = xe, Ve && (ae.method = "next", ae.arg = r), !!Ve;
      }
      for (var ne = this.tryEntries.length - 1; ne >= 0; --ne) {
        var ge = this.tryEntries[ne], Te = ge.completion;
        if (ge.tryLoc === "root") return ue("end");
        if (ge.tryLoc <= this.prev) {
          var pe = a.call(ge, "catchLoc"), Oe = a.call(ge, "finallyLoc");
          if (pe && Oe) {
            if (this.prev < ge.catchLoc) return ue(ge.catchLoc, true);
            if (this.prev < ge.finallyLoc) return ue(ge.finallyLoc);
          } else if (pe) {
            if (this.prev < ge.catchLoc) return ue(ge.catchLoc, true);
          } else {
            if (!Oe) throw Error("try statement without catch or finally");
            if (this.prev < ge.finallyLoc) return ue(ge.finallyLoc);
          }
        }
      }
    }, abrupt: function(ye, ae) {
      for (var ue = this.tryEntries.length - 1; ue >= 0; --ue) {
        var ne = this.tryEntries[ue];
        if (ne.tryLoc <= this.prev && a.call(ne, "finallyLoc") && this.prev < ne.finallyLoc) {
          var ge = ne;
          break;
        }
      }
      ge && (ye === "break" || ye === "continue") && ge.tryLoc <= ae && ae <= ge.finallyLoc && (ge = null);
      var Te = ge ? ge.completion : {};
      return Te.type = ye, Te.arg = ae, ge ? (this.method = "next", this.next = ge.finallyLoc, H) : this.complete(Te);
    }, complete: function(ye, ae) {
      if (ye.type === "throw") throw ye.arg;
      return ye.type === "break" || ye.type === "continue" ? this.next = ye.arg : ye.type === "return" ? (this.rval = this.arg = ye.arg, this.method = "return", this.next = "end") : ye.type === "normal" && ae && (this.next = ae), H;
    }, finish: function(ye) {
      for (var ae = this.tryEntries.length - 1; ae >= 0; --ae) {
        var ue = this.tryEntries[ae];
        if (ue.finallyLoc === ye) return this.complete(ue.completion, ue.afterLoc), ie(ue), H;
      }
    }, catch: function(ye) {
      for (var ae = this.tryEntries.length - 1; ae >= 0; --ae) {
        var ue = this.tryEntries[ae];
        if (ue.tryLoc === ye) {
          var ne = ue.completion;
          if (ne.type === "throw") {
            var ge = ne.arg;
            ie(ue);
          }
          return ge;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(ye, ae, ue) {
      return this.delegate = { iterator: oe(ye), resultName: ae, nextLoc: ue }, this.method === "next" && (this.arg = r), H;
    } }, m;
  }
  function i(r) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(m) {
      return typeof m;
    } : function(m) {
      return m && typeof Symbol == "function" && m.constructor === Symbol && m !== Symbol.prototype ? "symbol" : typeof m;
    }, i(r);
  }
  function s(r, m, g, a, l, d, b) {
    try {
      var S = r[d](b), E = S.value;
    } catch (R) {
      return void g(R);
    }
    S.done ? m(E) : Promise.resolve(E).then(a, l);
  }
  function y(r) {
    return function() {
      var m = this, g = arguments;
      return new Promise(function(a, l) {
        var d = r.apply(m, g);
        function b(E) {
          s(d, a, l, b, S, "next", E);
        }
        function S(E) {
          s(d, a, l, b, S, "throw", E);
        }
        b(void 0);
      });
    };
  }
  function t(r, m, g) {
    return o.apply(this, arguments);
  }
  function o() {
    return o = y(n().mark(function r(m, g, a) {
      var l, d, b, S, E, R, k, w = arguments;
      return n().wrap(function(I) {
        for (; ; ) switch (I.prev = I.next) {
          case 0:
            return l = w.length > 3 && w[3] !== void 0 ? w[3] : 1.5, d = w.length > 4 && w[4] !== void 0 ? w[4] : false, b = [], S = 0, I.t0 = b, I.next = 7, m();
          case 7:
            if (I.t1 = I.sent, I.t0.push.call(I.t0, I.t1), g(b[b.length - 1])) {
              I.next = 11;
              break;
            }
            return I.abrupt("return", b);
          case 11:
            E = new Date(Date.now() + a * 1e3).valueOf(), R = 1e3, k = R;
          case 14:
            if (!(Date.now() < E && g(b[b.length - 1]))) {
              I.next = 30;
              break;
            }
            return S += 1, d && console.info("Waiting ".concat(R, "ms before trying again (bringing the total wait time to ").concat(k, "ms so far, of total ").concat(a * 1e3, "ms)")), I.next = 19, new Promise(function(q) {
              return setTimeout(q, R);
            });
          case 19:
            return R *= l, new Date(Date.now() + R).valueOf() > E && (R = E - Date.now(), d && console.info("was gonna wait too long; new waitTime: ".concat(R, "ms"))), k = R + k, I.t2 = b, I.next = 25, m(b[b.length - 1]);
          case 25:
            I.t3 = I.sent, I.t2.push.call(I.t2, I.t3), d && g(b[b.length - 1]) && console.info("".concat(S, ". Called ").concat(m, "; ").concat(b.length, " prev attempts. Most recent: ").concat(JSON.stringify(b[b.length - 1], null, 2))), I.next = 14;
            break;
          case 30:
            return I.abrupt("return", b);
          case 31:
          case "end":
            return I.stop();
        }
      }, r);
    })), o.apply(this, arguments);
  }
  _o.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
  function u(r) {
    return i(r) === "object" && r !== null && "toString" in r;
  }
  function c(r) {
    for (var m = new v.cereal.XdrReader(r), g = []; !m.eof; ) g.push(v.xdr.ScSpecEntry.read(m));
    return g;
  }
  function h(r, m) {
    return f.apply(this, arguments);
  }
  function f() {
    return f = y(n().mark(function r(m, g) {
      return n().wrap(function(l) {
        for (; ; ) switch (l.prev = l.next) {
          case 0:
            return l.abrupt("return", m.publicKey ? g.getAccount(m.publicKey) : new v.Account(e.NULL_ACCOUNT, "0"));
          case 1:
          case "end":
            return l.stop();
        }
      }, r);
    })), f.apply(this, arguments);
  }
  return _o;
}
var ks = {}, Ld;
function Km() {
  if (Ld) return ks;
  Ld = 1, Object.defineProperty(ks, "__esModule", { value: true }), ks.SentTransaction = void 0;
  var v = Ac(), e = Ia(), n = yf(), i = kc(), s;
  function y(q, D, H) {
    return D = g(D), t(q, f() ? Reflect.construct(D, H || [], g(q).constructor) : D.apply(q, H));
  }
  function t(q, D) {
    if (D && (a(D) == "object" || typeof D == "function")) return D;
    if (D !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return o(q);
  }
  function o(q) {
    if (q === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return q;
  }
  function u(q, D) {
    if (typeof D != "function" && D !== null) throw new TypeError("Super expression must either be null or a function");
    q.prototype = Object.create(D && D.prototype, { constructor: { value: q, writable: true, configurable: true } }), Object.defineProperty(q, "prototype", { writable: false }), D && m(q, D);
  }
  function c(q) {
    var D = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return c = function(_) {
      if (_ === null || !r(_)) return _;
      if (typeof _ != "function") throw new TypeError("Super expression must either be null or a function");
      if (D !== void 0) {
        if (D.has(_)) return D.get(_);
        D.set(_, T);
      }
      function T() {
        return h(_, arguments, g(this).constructor);
      }
      return T.prototype = Object.create(_.prototype, { constructor: { value: T, enumerable: false, writable: true, configurable: true } }), m(T, _);
    }, c(q);
  }
  function h(q, D, H) {
    if (f()) return Reflect.construct.apply(null, arguments);
    var _ = [null];
    _.push.apply(_, D);
    var T = new (q.bind.apply(q, _))();
    return H && m(T, H.prototype), T;
  }
  function f() {
    try {
      var q = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (f = function() {
      return !!q;
    })();
  }
  function r(q) {
    try {
      return Function.toString.call(q).indexOf("[native code]") !== -1;
    } catch {
      return typeof q == "function";
    }
  }
  function m(q, D) {
    return m = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(H, _) {
      return H.__proto__ = _, H;
    }, m(q, D);
  }
  function g(q) {
    return g = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(D) {
      return D.__proto__ || Object.getPrototypeOf(D);
    }, g(q);
  }
  function a(q) {
    "@babel/helpers - typeof";
    return a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(D) {
      return typeof D;
    } : function(D) {
      return D && typeof Symbol == "function" && D.constructor === Symbol && D !== Symbol.prototype ? "symbol" : typeof D;
    }, a(q);
  }
  function l() {
    l = function() {
      return D;
    };
    var q, D = {}, H = Object.prototype, _ = H.hasOwnProperty, T = Object.defineProperty || function(ee, P, x) {
      ee[P] = x.value;
    }, L = typeof Symbol == "function" ? Symbol : {}, j = L.iterator || "@@iterator", z = L.asyncIterator || "@@asyncIterator", Y = L.toStringTag || "@@toStringTag";
    function te(ee, P, x) {
      return Object.defineProperty(ee, P, { value: x, enumerable: true, configurable: true, writable: true }), ee[P];
    }
    try {
      te({}, "");
    } catch {
      te = function(x, O, V) {
        return x[O] = V;
      };
    }
    function G(ee, P, x, O) {
      var V = P && P.prototype instanceof oe ? P : oe, N = Object.create(V.prototype), C = new Be(O || []);
      return T(N, "_invoke", { value: Oe(ee, x, C) }), N;
    }
    function K(ee, P, x) {
      try {
        return { type: "normal", arg: ee.call(P, x) };
      } catch (O) {
        return { type: "throw", arg: O };
      }
    }
    D.wrap = G;
    var J = "suspendedStart", B = "suspendedYield", Z = "executing", ie = "completed", $ = {};
    function oe() {
    }
    function ce() {
    }
    function ye() {
    }
    var ae = {};
    te(ae, j, function() {
      return this;
    });
    var ue = Object.getPrototypeOf, ne = ue && ue(ue(Qe([])));
    ne && ne !== H && _.call(ne, j) && (ae = ne);
    var ge = ye.prototype = oe.prototype = Object.create(ae);
    function Te(ee) {
      ["next", "throw", "return"].forEach(function(P) {
        te(ee, P, function(x) {
          return this._invoke(P, x);
        });
      });
    }
    function pe(ee, P) {
      function x(V, N, C, p) {
        var A = K(ee[V], ee, N);
        if (A.type !== "throw") {
          var U = A.arg, Q = U.value;
          return Q && a(Q) == "object" && _.call(Q, "__await") ? P.resolve(Q.__await).then(function(se) {
            x("next", se, C, p);
          }, function(se) {
            x("throw", se, C, p);
          }) : P.resolve(Q).then(function(se) {
            U.value = se, C(U);
          }, function(se) {
            return x("throw", se, C, p);
          });
        }
        p(A.arg);
      }
      var O;
      T(this, "_invoke", { value: function(N, C) {
        function p() {
          return new P(function(A, U) {
            x(N, C, A, U);
          });
        }
        return O = O ? O.then(p, p) : p();
      } });
    }
    function Oe(ee, P, x) {
      var O = J;
      return function(V, N) {
        if (O === Z) throw Error("Generator is already running");
        if (O === ie) {
          if (V === "throw") throw N;
          return { value: q, done: true };
        }
        for (x.method = V, x.arg = N; ; ) {
          var C = x.delegate;
          if (C) {
            var p = xe(C, x);
            if (p) {
              if (p === $) continue;
              return p;
            }
          }
          if (x.method === "next") x.sent = x._sent = x.arg;
          else if (x.method === "throw") {
            if (O === J) throw O = ie, x.arg;
            x.dispatchException(x.arg);
          } else x.method === "return" && x.abrupt("return", x.arg);
          O = Z;
          var A = K(ee, P, x);
          if (A.type === "normal") {
            if (O = x.done ? ie : B, A.arg === $) continue;
            return { value: A.arg, done: x.done };
          }
          A.type === "throw" && (O = ie, x.method = "throw", x.arg = A.arg);
        }
      };
    }
    function xe(ee, P) {
      var x = P.method, O = ee.iterator[x];
      if (O === q) return P.delegate = null, x === "throw" && ee.iterator.return && (P.method = "return", P.arg = q, xe(ee, P), P.method === "throw") || x !== "return" && (P.method = "throw", P.arg = new TypeError("The iterator does not provide a '" + x + "' method")), $;
      var V = K(O, ee.iterator, P.arg);
      if (V.type === "throw") return P.method = "throw", P.arg = V.arg, P.delegate = null, $;
      var N = V.arg;
      return N ? N.done ? (P[ee.resultName] = N.value, P.next = ee.nextLoc, P.method !== "return" && (P.method = "next", P.arg = q), P.delegate = null, $) : N : (P.method = "throw", P.arg = new TypeError("iterator result is not an object"), P.delegate = null, $);
    }
    function Ve(ee) {
      var P = { tryLoc: ee[0] };
      1 in ee && (P.catchLoc = ee[1]), 2 in ee && (P.finallyLoc = ee[2], P.afterLoc = ee[3]), this.tryEntries.push(P);
    }
    function _e(ee) {
      var P = ee.completion || {};
      P.type = "normal", delete P.arg, ee.completion = P;
    }
    function Be(ee) {
      this.tryEntries = [{ tryLoc: "root" }], ee.forEach(Ve, this), this.reset(true);
    }
    function Qe(ee) {
      if (ee || ee === "") {
        var P = ee[j];
        if (P) return P.call(ee);
        if (typeof ee.next == "function") return ee;
        if (!isNaN(ee.length)) {
          var x = -1, O = function V() {
            for (; ++x < ee.length; ) if (_.call(ee, x)) return V.value = ee[x], V.done = false, V;
            return V.value = q, V.done = true, V;
          };
          return O.next = O;
        }
      }
      throw new TypeError(a(ee) + " is not iterable");
    }
    return ce.prototype = ye, T(ge, "constructor", { value: ye, configurable: true }), T(ye, "constructor", { value: ce, configurable: true }), ce.displayName = te(ye, Y, "GeneratorFunction"), D.isGeneratorFunction = function(ee) {
      var P = typeof ee == "function" && ee.constructor;
      return !!P && (P === ce || (P.displayName || P.name) === "GeneratorFunction");
    }, D.mark = function(ee) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(ee, ye) : (ee.__proto__ = ye, te(ee, Y, "GeneratorFunction")), ee.prototype = Object.create(ge), ee;
    }, D.awrap = function(ee) {
      return { __await: ee };
    }, Te(pe.prototype), te(pe.prototype, z, function() {
      return this;
    }), D.AsyncIterator = pe, D.async = function(ee, P, x, O, V) {
      V === void 0 && (V = Promise);
      var N = new pe(G(ee, P, x, O), V);
      return D.isGeneratorFunction(P) ? N : N.next().then(function(C) {
        return C.done ? C.value : N.next();
      });
    }, Te(ge), te(ge, Y, "Generator"), te(ge, j, function() {
      return this;
    }), te(ge, "toString", function() {
      return "[object Generator]";
    }), D.keys = function(ee) {
      var P = Object(ee), x = [];
      for (var O in P) x.push(O);
      return x.reverse(), function V() {
        for (; x.length; ) {
          var N = x.pop();
          if (N in P) return V.value = N, V.done = false, V;
        }
        return V.done = true, V;
      };
    }, D.values = Qe, Be.prototype = { constructor: Be, reset: function(P) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = q, this.done = false, this.delegate = null, this.method = "next", this.arg = q, this.tryEntries.forEach(_e), !P) for (var x in this) x.charAt(0) === "t" && _.call(this, x) && !isNaN(+x.slice(1)) && (this[x] = q);
    }, stop: function() {
      this.done = true;
      var P = this.tryEntries[0].completion;
      if (P.type === "throw") throw P.arg;
      return this.rval;
    }, dispatchException: function(P) {
      if (this.done) throw P;
      var x = this;
      function O(U, Q) {
        return C.type = "throw", C.arg = P, x.next = U, Q && (x.method = "next", x.arg = q), !!Q;
      }
      for (var V = this.tryEntries.length - 1; V >= 0; --V) {
        var N = this.tryEntries[V], C = N.completion;
        if (N.tryLoc === "root") return O("end");
        if (N.tryLoc <= this.prev) {
          var p = _.call(N, "catchLoc"), A = _.call(N, "finallyLoc");
          if (p && A) {
            if (this.prev < N.catchLoc) return O(N.catchLoc, true);
            if (this.prev < N.finallyLoc) return O(N.finallyLoc);
          } else if (p) {
            if (this.prev < N.catchLoc) return O(N.catchLoc, true);
          } else {
            if (!A) throw Error("try statement without catch or finally");
            if (this.prev < N.finallyLoc) return O(N.finallyLoc);
          }
        }
      }
    }, abrupt: function(P, x) {
      for (var O = this.tryEntries.length - 1; O >= 0; --O) {
        var V = this.tryEntries[O];
        if (V.tryLoc <= this.prev && _.call(V, "finallyLoc") && this.prev < V.finallyLoc) {
          var N = V;
          break;
        }
      }
      N && (P === "break" || P === "continue") && N.tryLoc <= x && x <= N.finallyLoc && (N = null);
      var C = N ? N.completion : {};
      return C.type = P, C.arg = x, N ? (this.method = "next", this.next = N.finallyLoc, $) : this.complete(C);
    }, complete: function(P, x) {
      if (P.type === "throw") throw P.arg;
      return P.type === "break" || P.type === "continue" ? this.next = P.arg : P.type === "return" ? (this.rval = this.arg = P.arg, this.method = "return", this.next = "end") : P.type === "normal" && x && (this.next = x), $;
    }, finish: function(P) {
      for (var x = this.tryEntries.length - 1; x >= 0; --x) {
        var O = this.tryEntries[x];
        if (O.finallyLoc === P) return this.complete(O.completion, O.afterLoc), _e(O), $;
      }
    }, catch: function(P) {
      for (var x = this.tryEntries.length - 1; x >= 0; --x) {
        var O = this.tryEntries[x];
        if (O.tryLoc === P) {
          var V = O.completion;
          if (V.type === "throw") {
            var N = V.arg;
            _e(O);
          }
          return N;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(P, x, O) {
      return this.delegate = { iterator: Qe(P), resultName: x, nextLoc: O }, this.method === "next" && (this.arg = q), $;
    } }, D;
  }
  function d(q, D, H, _, T, L, j) {
    try {
      var z = q[L](j), Y = z.value;
    } catch (te) {
      return void H(te);
    }
    z.done ? D(Y) : Promise.resolve(Y).then(_, T);
  }
  function b(q) {
    return function() {
      var D = this, H = arguments;
      return new Promise(function(_, T) {
        var L = q.apply(D, H);
        function j(Y) {
          d(L, _, T, j, z, "next", Y);
        }
        function z(Y) {
          d(L, _, T, j, z, "throw", Y);
        }
        j(void 0);
      });
    };
  }
  function S(q, D) {
    if (!(q instanceof D)) throw new TypeError("Cannot call a class as a function");
  }
  function E(q, D) {
    for (var H = 0; H < D.length; H++) {
      var _ = D[H];
      _.enumerable = _.enumerable || false, _.configurable = true, "value" in _ && (_.writable = true), Object.defineProperty(q, w(_.key), _);
    }
  }
  function R(q, D, H) {
    return D && E(q.prototype, D), Object.defineProperty(q, "prototype", { writable: false }), q;
  }
  function k(q, D, H) {
    return (D = w(D)) in q ? Object.defineProperty(q, D, { value: H, enumerable: true, configurable: true, writable: true }) : q[D] = H, q;
  }
  function w(q) {
    var D = F(q, "string");
    return a(D) == "symbol" ? D : D + "";
  }
  function F(q, D) {
    if (a(q) != "object" || !q) return q;
    var H = q[Symbol.toPrimitive];
    if (H !== void 0) {
      var _ = H.call(q, D);
      if (a(_) != "object") return _;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (D === "string" ? String : Number)(q);
  }
  var I = ks.SentTransaction = function() {
    function q(D) {
      var H = this, _;
      S(this, q), k(this, "send", b(l().mark(function T() {
        var L, j, z;
        return l().wrap(function(te) {
          for (; ; ) switch (te.prev = te.next) {
            case 0:
              return te.next = 2, H.server.sendTransaction(H.assembled.signed);
            case 2:
              if (H.sendTransactionResponse = te.sent, H.sendTransactionResponse.status === "PENDING") {
                te.next = 5;
                break;
              }
              throw new q.Errors.SendFailed(`Sending the transaction to the network failed!
`.concat(JSON.stringify(H.sendTransactionResponse, null, 2)));
            case 5:
              return j = H.sendTransactionResponse.hash, z = (L = H.assembled.options.timeoutInSeconds) !== null && L !== void 0 ? L : i.DEFAULT_TIMEOUT, te.next = 9, (0, n.withExponentialBackoff)(function() {
                return H.server.getTransaction(j);
              }, function(G) {
                return G.status === e.Api.GetTransactionStatus.NOT_FOUND;
              }, z);
            case 9:
              if (H.getTransactionResponseAll = te.sent, H.getTransactionResponse = H.getTransactionResponseAll[H.getTransactionResponseAll.length - 1], H.getTransactionResponse.status !== e.Api.GetTransactionStatus.NOT_FOUND) {
                te.next = 13;
                break;
              }
              throw new q.Errors.TransactionStillPending("Waited ".concat(z, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(H.sendTransactionResponse, null, 2), `
`) + "All attempts to get the result: ".concat(JSON.stringify(H.getTransactionResponseAll, null, 2)));
            case 13:
              return te.abrupt("return", H);
            case 14:
            case "end":
              return te.stop();
          }
        }, T);
      }))), this.assembled = D, this.server = new v.Server(this.assembled.options.rpcUrl, { allowHttp: (_ = this.assembled.options.allowHttp) !== null && _ !== void 0 ? _ : false });
    }
    return R(q, [{ key: "result", get: function() {
      if ("getTransactionResponse" in this && this.getTransactionResponse) {
        if ("returnValue" in this.getTransactionResponse) return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
        throw new Error("Transaction failed! Cannot parse result.");
      }
      if (this.sendTransactionResponse) {
        var H, _ = (H = this.sendTransactionResponse.errorResult) === null || H === void 0 ? void 0 : H.result();
        throw _ ? new q.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(_)) : new q.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
      }
      throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
    } }]);
  }();
  return s = I, k(I, "Errors", { SendFailed: function(q) {
    function D() {
      return S(this, D), y(this, D, arguments);
    }
    return u(D, q), R(D);
  }(c(Error)), SendResultOnly: function(q) {
    function D() {
      return S(this, D), y(this, D, arguments);
    }
    return u(D, q), R(D);
  }(c(Error)), TransactionStillPending: function(q) {
    function D() {
      return S(this, D), y(this, D, arguments);
    }
    return u(D, q), R(D);
  }(c(Error)) }), k(I, "init", function() {
    var q = b(l().mark(function D(H) {
      var _, T;
      return l().wrap(function(j) {
        for (; ; ) switch (j.prev = j.next) {
          case 0:
            return _ = new s(H), j.next = 3, _.send();
          case 3:
            return T = j.sent, j.abrupt("return", T);
          case 5:
          case "end":
            return j.stop();
        }
      }, D);
    }));
    return function(D) {
      return q.apply(this, arguments);
    };
  }()), ks;
}
var Bd;
function Xm() {
  if (Bd) return Ts;
  Bd = 1, Object.defineProperty(Ts, "__esModule", { value: true }), Ts.AssembledTransaction = void 0;
  var v = ko(), e = Ac(), n = Ia(), i = af(), s = mf(), y = yf(), t = kc(), o = Km();
  function u($, oe, ce) {
    return oe = d(oe), c($, g() ? Reflect.construct(oe, ce || [], d($).constructor) : oe.apply($, ce));
  }
  function c($, oe) {
    if (oe && (b(oe) == "object" || typeof oe == "function")) return oe;
    if (oe !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return h($);
  }
  function h($) {
    if ($ === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return $;
  }
  function f($, oe) {
    if (typeof oe != "function" && oe !== null) throw new TypeError("Super expression must either be null or a function");
    $.prototype = Object.create(oe && oe.prototype, { constructor: { value: $, writable: true, configurable: true } }), Object.defineProperty($, "prototype", { writable: false }), oe && l($, oe);
  }
  function r($) {
    var oe = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return r = function(ye) {
      if (ye === null || !a(ye)) return ye;
      if (typeof ye != "function") throw new TypeError("Super expression must either be null or a function");
      if (oe !== void 0) {
        if (oe.has(ye)) return oe.get(ye);
        oe.set(ye, ae);
      }
      function ae() {
        return m(ye, arguments, d(this).constructor);
      }
      return ae.prototype = Object.create(ye.prototype, { constructor: { value: ae, enumerable: false, writable: true, configurable: true } }), l(ae, ye);
    }, r($);
  }
  function m($, oe, ce) {
    if (g()) return Reflect.construct.apply(null, arguments);
    var ye = [null];
    ye.push.apply(ye, oe);
    var ae = new ($.bind.apply($, ye))();
    return ce && l(ae, ce.prototype), ae;
  }
  function g() {
    try {
      var $ = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (g = function() {
      return !!$;
    })();
  }
  function a($) {
    try {
      return Function.toString.call($).indexOf("[native code]") !== -1;
    } catch {
      return typeof $ == "function";
    }
  }
  function l($, oe) {
    return l = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(ce, ye) {
      return ce.__proto__ = ye, ce;
    }, l($, oe);
  }
  function d($) {
    return d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(oe) {
      return oe.__proto__ || Object.getPrototypeOf(oe);
    }, d($);
  }
  function b($) {
    "@babel/helpers - typeof";
    return b = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
      return typeof oe;
    } : function(oe) {
      return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
    }, b($);
  }
  function S($, oe) {
    var ce = Object.keys($);
    if (Object.getOwnPropertySymbols) {
      var ye = Object.getOwnPropertySymbols($);
      oe && (ye = ye.filter(function(ae) {
        return Object.getOwnPropertyDescriptor($, ae).enumerable;
      })), ce.push.apply(ce, ye);
    }
    return ce;
  }
  function E($) {
    for (var oe = 1; oe < arguments.length; oe++) {
      var ce = arguments[oe] != null ? arguments[oe] : {};
      oe % 2 ? S(Object(ce), true).forEach(function(ye) {
        J($, ye, ce[ye]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($, Object.getOwnPropertyDescriptors(ce)) : S(Object(ce)).forEach(function(ye) {
        Object.defineProperty($, ye, Object.getOwnPropertyDescriptor(ce, ye));
      });
    }
    return $;
  }
  function R($, oe) {
    return F($) || w($, oe) || _($, oe) || k();
  }
  function k() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function w($, oe) {
    var ce = $ == null ? null : typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
    if (ce != null) {
      var ye, ae, ue, ne, ge = [], Te = true, pe = false;
      try {
        if (ue = (ce = ce.call($)).next, oe !== 0) for (; !(Te = (ye = ue.call(ce)).done) && (ge.push(ye.value), ge.length !== oe); Te = true) ;
      } catch (Oe) {
        pe = true, ae = Oe;
      } finally {
        try {
          if (!Te && ce.return != null && (ne = ce.return(), Object(ne) !== ne)) return;
        } finally {
          if (pe) throw ae;
        }
      }
      return ge;
    }
  }
  function F($) {
    if (Array.isArray($)) return $;
  }
  function I($, oe) {
    var ce = typeof Symbol < "u" && $[Symbol.iterator] || $["@@iterator"];
    if (!ce) {
      if (Array.isArray($) || (ce = _($)) || oe) {
        ce && ($ = ce);
        var ye = 0, ae = function() {
        };
        return { s: ae, n: function() {
          return ye >= $.length ? { done: true } : { done: false, value: $[ye++] };
        }, e: function(pe) {
          throw pe;
        }, f: ae };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var ue, ne = true, ge = false;
    return { s: function() {
      ce = ce.call($);
    }, n: function() {
      var pe = ce.next();
      return ne = pe.done, pe;
    }, e: function(pe) {
      ge = true, ue = pe;
    }, f: function() {
      try {
        ne || ce.return == null || ce.return();
      } finally {
        if (ge) throw ue;
      }
    } };
  }
  function q() {
    q = function() {
      return oe;
    };
    var $, oe = {}, ce = Object.prototype, ye = ce.hasOwnProperty, ae = Object.defineProperty || function(ut, Ze, Et) {
      ut[Ze] = Et.value;
    }, ue = typeof Symbol == "function" ? Symbol : {}, ne = ue.iterator || "@@iterator", ge = ue.asyncIterator || "@@asyncIterator", Te = ue.toStringTag || "@@toStringTag";
    function pe(ut, Ze, Et) {
      return Object.defineProperty(ut, Ze, { value: Et, enumerable: true, configurable: true, writable: true }), ut[Ze];
    }
    try {
      pe({}, "");
    } catch {
      pe = function(Et, rr, je) {
        return Et[rr] = je;
      };
    }
    function Oe(ut, Ze, Et, rr) {
      var je = Ze && Ze.prototype instanceof P ? Ze : P, Ge = Object.create(je.prototype), at = new tt(rr || []);
      return ae(Ge, "_invoke", { value: Q(ut, Et, at) }), Ge;
    }
    function xe(ut, Ze, Et) {
      try {
        return { type: "normal", arg: ut.call(Ze, Et) };
      } catch (rr) {
        return { type: "throw", arg: rr };
      }
    }
    oe.wrap = Oe;
    var Ve = "suspendedStart", _e = "suspendedYield", Be = "executing", Qe = "completed", ee = {};
    function P() {
    }
    function x() {
    }
    function O() {
    }
    var V = {};
    pe(V, ne, function() {
      return this;
    });
    var N = Object.getPrototypeOf, C = N && N(N(Ne([])));
    C && C !== ce && ye.call(C, ne) && (V = C);
    var p = O.prototype = P.prototype = Object.create(V);
    function A(ut) {
      ["next", "throw", "return"].forEach(function(Ze) {
        pe(ut, Ze, function(Et) {
          return this._invoke(Ze, Et);
        });
      });
    }
    function U(ut, Ze) {
      function Et(je, Ge, at, Ae) {
        var qe = xe(ut[je], ut, Ge);
        if (qe.type !== "throw") {
          var Ft = qe.arg, Dt = Ft.value;
          return Dt && b(Dt) == "object" && ye.call(Dt, "__await") ? Ze.resolve(Dt.__await).then(function(wr) {
            Et("next", wr, at, Ae);
          }, function(wr) {
            Et("throw", wr, at, Ae);
          }) : Ze.resolve(Dt).then(function(wr) {
            Ft.value = wr, at(Ft);
          }, function(wr) {
            return Et("throw", wr, at, Ae);
          });
        }
        Ae(qe.arg);
      }
      var rr;
      ae(this, "_invoke", { value: function(Ge, at) {
        function Ae() {
          return new Ze(function(qe, Ft) {
            Et(Ge, at, qe, Ft);
          });
        }
        return rr = rr ? rr.then(Ae, Ae) : Ae();
      } });
    }
    function Q(ut, Ze, Et) {
      var rr = Ve;
      return function(je, Ge) {
        if (rr === Be) throw Error("Generator is already running");
        if (rr === Qe) {
          if (je === "throw") throw Ge;
          return { value: $, done: true };
        }
        for (Et.method = je, Et.arg = Ge; ; ) {
          var at = Et.delegate;
          if (at) {
            var Ae = se(at, Et);
            if (Ae) {
              if (Ae === ee) continue;
              return Ae;
            }
          }
          if (Et.method === "next") Et.sent = Et._sent = Et.arg;
          else if (Et.method === "throw") {
            if (rr === Ve) throw rr = Qe, Et.arg;
            Et.dispatchException(Et.arg);
          } else Et.method === "return" && Et.abrupt("return", Et.arg);
          rr = Be;
          var qe = xe(ut, Ze, Et);
          if (qe.type === "normal") {
            if (rr = Et.done ? Qe : _e, qe.arg === ee) continue;
            return { value: qe.arg, done: Et.done };
          }
          qe.type === "throw" && (rr = Qe, Et.method = "throw", Et.arg = qe.arg);
        }
      };
    }
    function se(ut, Ze) {
      var Et = Ze.method, rr = ut.iterator[Et];
      if (rr === $) return Ze.delegate = null, Et === "throw" && ut.iterator.return && (Ze.method = "return", Ze.arg = $, se(ut, Ze), Ze.method === "throw") || Et !== "return" && (Ze.method = "throw", Ze.arg = new TypeError("The iterator does not provide a '" + Et + "' method")), ee;
      var je = xe(rr, ut.iterator, Ze.arg);
      if (je.type === "throw") return Ze.method = "throw", Ze.arg = je.arg, Ze.delegate = null, ee;
      var Ge = je.arg;
      return Ge ? Ge.done ? (Ze[ut.resultName] = Ge.value, Ze.next = ut.nextLoc, Ze.method !== "return" && (Ze.method = "next", Ze.arg = $), Ze.delegate = null, ee) : Ge : (Ze.method = "throw", Ze.arg = new TypeError("iterator result is not an object"), Ze.delegate = null, ee);
    }
    function X(ut) {
      var Ze = { tryLoc: ut[0] };
      1 in ut && (Ze.catchLoc = ut[1]), 2 in ut && (Ze.finallyLoc = ut[2], Ze.afterLoc = ut[3]), this.tryEntries.push(Ze);
    }
    function de(ut) {
      var Ze = ut.completion || {};
      Ze.type = "normal", delete Ze.arg, ut.completion = Ze;
    }
    function tt(ut) {
      this.tryEntries = [{ tryLoc: "root" }], ut.forEach(X, this), this.reset(true);
    }
    function Ne(ut) {
      if (ut || ut === "") {
        var Ze = ut[ne];
        if (Ze) return Ze.call(ut);
        if (typeof ut.next == "function") return ut;
        if (!isNaN(ut.length)) {
          var Et = -1, rr = function je() {
            for (; ++Et < ut.length; ) if (ye.call(ut, Et)) return je.value = ut[Et], je.done = false, je;
            return je.value = $, je.done = true, je;
          };
          return rr.next = rr;
        }
      }
      throw new TypeError(b(ut) + " is not iterable");
    }
    return x.prototype = O, ae(p, "constructor", { value: O, configurable: true }), ae(O, "constructor", { value: x, configurable: true }), x.displayName = pe(O, Te, "GeneratorFunction"), oe.isGeneratorFunction = function(ut) {
      var Ze = typeof ut == "function" && ut.constructor;
      return !!Ze && (Ze === x || (Ze.displayName || Ze.name) === "GeneratorFunction");
    }, oe.mark = function(ut) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(ut, O) : (ut.__proto__ = O, pe(ut, Te, "GeneratorFunction")), ut.prototype = Object.create(p), ut;
    }, oe.awrap = function(ut) {
      return { __await: ut };
    }, A(U.prototype), pe(U.prototype, ge, function() {
      return this;
    }), oe.AsyncIterator = U, oe.async = function(ut, Ze, Et, rr, je) {
      je === void 0 && (je = Promise);
      var Ge = new U(Oe(ut, Ze, Et, rr), je);
      return oe.isGeneratorFunction(Ze) ? Ge : Ge.next().then(function(at) {
        return at.done ? at.value : Ge.next();
      });
    }, A(p), pe(p, Te, "Generator"), pe(p, ne, function() {
      return this;
    }), pe(p, "toString", function() {
      return "[object Generator]";
    }), oe.keys = function(ut) {
      var Ze = Object(ut), Et = [];
      for (var rr in Ze) Et.push(rr);
      return Et.reverse(), function je() {
        for (; Et.length; ) {
          var Ge = Et.pop();
          if (Ge in Ze) return je.value = Ge, je.done = false, je;
        }
        return je.done = true, je;
      };
    }, oe.values = Ne, tt.prototype = { constructor: tt, reset: function(Ze) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = $, this.done = false, this.delegate = null, this.method = "next", this.arg = $, this.tryEntries.forEach(de), !Ze) for (var Et in this) Et.charAt(0) === "t" && ye.call(this, Et) && !isNaN(+Et.slice(1)) && (this[Et] = $);
    }, stop: function() {
      this.done = true;
      var Ze = this.tryEntries[0].completion;
      if (Ze.type === "throw") throw Ze.arg;
      return this.rval;
    }, dispatchException: function(Ze) {
      if (this.done) throw Ze;
      var Et = this;
      function rr(Ft, Dt) {
        return at.type = "throw", at.arg = Ze, Et.next = Ft, Dt && (Et.method = "next", Et.arg = $), !!Dt;
      }
      for (var je = this.tryEntries.length - 1; je >= 0; --je) {
        var Ge = this.tryEntries[je], at = Ge.completion;
        if (Ge.tryLoc === "root") return rr("end");
        if (Ge.tryLoc <= this.prev) {
          var Ae = ye.call(Ge, "catchLoc"), qe = ye.call(Ge, "finallyLoc");
          if (Ae && qe) {
            if (this.prev < Ge.catchLoc) return rr(Ge.catchLoc, true);
            if (this.prev < Ge.finallyLoc) return rr(Ge.finallyLoc);
          } else if (Ae) {
            if (this.prev < Ge.catchLoc) return rr(Ge.catchLoc, true);
          } else {
            if (!qe) throw Error("try statement without catch or finally");
            if (this.prev < Ge.finallyLoc) return rr(Ge.finallyLoc);
          }
        }
      }
    }, abrupt: function(Ze, Et) {
      for (var rr = this.tryEntries.length - 1; rr >= 0; --rr) {
        var je = this.tryEntries[rr];
        if (je.tryLoc <= this.prev && ye.call(je, "finallyLoc") && this.prev < je.finallyLoc) {
          var Ge = je;
          break;
        }
      }
      Ge && (Ze === "break" || Ze === "continue") && Ge.tryLoc <= Et && Et <= Ge.finallyLoc && (Ge = null);
      var at = Ge ? Ge.completion : {};
      return at.type = Ze, at.arg = Et, Ge ? (this.method = "next", this.next = Ge.finallyLoc, ee) : this.complete(at);
    }, complete: function(Ze, Et) {
      if (Ze.type === "throw") throw Ze.arg;
      return Ze.type === "break" || Ze.type === "continue" ? this.next = Ze.arg : Ze.type === "return" ? (this.rval = this.arg = Ze.arg, this.method = "return", this.next = "end") : Ze.type === "normal" && Et && (this.next = Et), ee;
    }, finish: function(Ze) {
      for (var Et = this.tryEntries.length - 1; Et >= 0; --Et) {
        var rr = this.tryEntries[Et];
        if (rr.finallyLoc === Ze) return this.complete(rr.completion, rr.afterLoc), de(rr), ee;
      }
    }, catch: function(Ze) {
      for (var Et = this.tryEntries.length - 1; Et >= 0; --Et) {
        var rr = this.tryEntries[Et];
        if (rr.tryLoc === Ze) {
          var je = rr.completion;
          if (je.type === "throw") {
            var Ge = je.arg;
            de(rr);
          }
          return Ge;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(Ze, Et, rr) {
      return this.delegate = { iterator: Ne(Ze), resultName: Et, nextLoc: rr }, this.method === "next" && (this.arg = $), ee;
    } }, oe;
  }
  function D($) {
    return L($) || T($) || _($) || H();
  }
  function H() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _($, oe) {
    if ($) {
      if (typeof $ == "string") return j($, oe);
      var ce = {}.toString.call($).slice(8, -1);
      return ce === "Object" && $.constructor && (ce = $.constructor.name), ce === "Map" || ce === "Set" ? Array.from($) : ce === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(ce) ? j($, oe) : void 0;
    }
  }
  function T($) {
    if (typeof Symbol < "u" && $[Symbol.iterator] != null || $["@@iterator"] != null) return Array.from($);
  }
  function L($) {
    if (Array.isArray($)) return j($);
  }
  function j($, oe) {
    (oe == null || oe > $.length) && (oe = $.length);
    for (var ce = 0, ye = Array(oe); ce < oe; ce++) ye[ce] = $[ce];
    return ye;
  }
  function z($, oe, ce, ye, ae, ue, ne) {
    try {
      var ge = $[ue](ne), Te = ge.value;
    } catch (pe) {
      return void ce(pe);
    }
    ge.done ? oe(Te) : Promise.resolve(Te).then(ye, ae);
  }
  function Y($) {
    return function() {
      var oe = this, ce = arguments;
      return new Promise(function(ye, ae) {
        var ue = $.apply(oe, ce);
        function ne(Te) {
          z(ue, ye, ae, ne, ge, "next", Te);
        }
        function ge(Te) {
          z(ue, ye, ae, ne, ge, "throw", Te);
        }
        ne(void 0);
      });
    };
  }
  function te($, oe) {
    if (!($ instanceof oe)) throw new TypeError("Cannot call a class as a function");
  }
  function G($, oe) {
    for (var ce = 0; ce < oe.length; ce++) {
      var ye = oe[ce];
      ye.enumerable = ye.enumerable || false, ye.configurable = true, "value" in ye && (ye.writable = true), Object.defineProperty($, B(ye.key), ye);
    }
  }
  function K($, oe, ce) {
    return oe && G($.prototype, oe), ce && G($, ce), Object.defineProperty($, "prototype", { writable: false }), $;
  }
  function J($, oe, ce) {
    return (oe = B(oe)) in $ ? Object.defineProperty($, oe, { value: ce, enumerable: true, configurable: true, writable: true }) : $[oe] = ce, $;
  }
  function B($) {
    var oe = Z($, "string");
    return b(oe) == "symbol" ? oe : oe + "";
  }
  function Z($, oe) {
    if (b($) != "object" || !$) return $;
    var ce = $[Symbol.toPrimitive];
    if (ce !== void 0) {
      var ye = ce.call($, oe);
      if (b(ye) != "object") return ye;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (oe === "string" ? String : Number)($);
  }
  var ie = Ts.AssembledTransaction = function() {
    function $(oe) {
      var ce = this, ye, ae;
      te(this, $), J(this, "simulate", Y(q().mark(function ue() {
        var ne, ge, Te, pe, Oe, xe, Ve, _e, Be = arguments;
        return q().wrap(function(ee) {
          for (; ; ) switch (ee.prev = ee.next) {
            case 0:
              if (ne = Be.length > 0 && Be[0] !== void 0 ? Be[0] : {}, ge = ne.restore, ce.built) {
                ee.next = 5;
                break;
              }
              if (ce.raw) {
                ee.next = 4;
                break;
              }
              throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
            case 4:
              ce.built = ce.raw.build();
            case 5:
              return ge = ge ?? ce.options.restore, delete ce.simulationResult, delete ce.simulationTransactionData, ee.next = 10, ce.server.simulateTransaction(ce.built);
            case 10:
              if (ce.simulation = ee.sent, !(ge && n.Api.isSimulationRestore(ce.simulation))) {
                ee.next = 25;
                break;
              }
              return ee.next = 14, (0, y.getAccount)(ce.options, ce.server);
            case 14:
              return Te = ee.sent, ee.next = 17, ce.restoreFootprint(ce.simulation.restorePreamble, Te);
            case 17:
              if (pe = ee.sent, pe.status !== n.Api.GetTransactionStatus.SUCCESS) {
                ee.next = 24;
                break;
              }
              return _e = new v.Contract(ce.options.contractId), ce.raw = new v.TransactionBuilder(Te, { fee: (Oe = ce.options.fee) !== null && Oe !== void 0 ? Oe : v.BASE_FEE, networkPassphrase: ce.options.networkPassphrase }).addOperation(_e.call.apply(_e, [ce.options.method].concat(D((xe = ce.options.args) !== null && xe !== void 0 ? xe : [])))).setTimeout((Ve = ce.options.timeoutInSeconds) !== null && Ve !== void 0 ? Ve : t.DEFAULT_TIMEOUT), ee.next = 23, ce.simulate();
            case 23:
              return ee.abrupt("return", ce);
            case 24:
              throw new $.Errors.RestorationFailure(`Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:
`.concat(JSON.stringify(pe)));
            case 25:
              return n.Api.isSimulationSuccess(ce.simulation) && (ce.built = (0, i.assembleTransaction)(ce.built, ce.simulation).build()), ee.abrupt("return", ce);
            case 27:
            case "end":
              return ee.stop();
          }
        }, ue);
      }))), J(this, "sign", Y(q().mark(function ue() {
        var ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P, x = arguments;
        return q().wrap(function(V) {
          for (; ; ) switch (V.prev = V.next) {
            case 0:
              if (ge = x.length > 0 && x[0] !== void 0 ? x[0] : {}, Te = ge.force, pe = Te === void 0 ? false : Te, Oe = ge.signTransaction, xe = Oe === void 0 ? ce.options.signTransaction : Oe, ce.built) {
                V.next = 3;
                break;
              }
              throw new Error("Transaction has not yet been simulated");
            case 3:
              if (!(!pe && ce.isReadCall)) {
                V.next = 5;
                break;
              }
              throw new $.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
            case 5:
              if (xe) {
                V.next = 7;
                break;
              }
              throw new $.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
            case 7:
              if (Ve = ce.needsNonInvokerSigningBy().filter(function(N) {
                return !N.startsWith("C");
              }), !Ve.length) {
                V.next = 10;
                break;
              }
              throw new $.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(Ve, ". ") + "See `needsNonInvokerSigningBy` for details.");
            case 10:
              return _e = (ne = ce.options.timeoutInSeconds) !== null && ne !== void 0 ? ne : t.DEFAULT_TIMEOUT, ce.built = v.TransactionBuilder.cloneFrom(ce.built, { fee: ce.built.fee, timebounds: void 0, sorobanData: ce.simulationData.transactionData }).setTimeout(_e).build(), Be = { networkPassphrase: ce.options.networkPassphrase }, ce.options.address && (Be.address = ce.options.address), ce.options.submit !== void 0 && (Be.submit = ce.options.submit), ce.options.submitUrl && (Be.submitUrl = ce.options.submitUrl), V.next = 18, xe(ce.built.toXDR(), Be);
            case 18:
              Qe = V.sent, ee = Qe.signedTxXdr, P = Qe.error, ce.handleWalletError(P), ce.signed = v.TransactionBuilder.fromXDR(ee, ce.options.networkPassphrase);
            case 23:
            case "end":
              return V.stop();
          }
        }, ue);
      }))), J(this, "signAndSend", Y(q().mark(function ue() {
        var ne, ge, Te, pe, Oe, xe, Ve = arguments;
        return q().wrap(function(Be) {
          for (; ; ) switch (Be.prev = Be.next) {
            case 0:
              if (ne = Ve.length > 0 && Ve[0] !== void 0 ? Ve[0] : {}, ge = ne.force, Te = ge === void 0 ? false : ge, pe = ne.signTransaction, Oe = pe === void 0 ? ce.options.signTransaction : pe, ce.signed) {
                Be.next = 10;
                break;
              }
              return xe = ce.options.submit, ce.options.submit && (ce.options.submit = false), Be.prev = 4, Be.next = 7, ce.sign({ force: Te, signTransaction: Oe });
            case 7:
              return Be.prev = 7, ce.options.submit = xe, Be.finish(7);
            case 10:
              return Be.abrupt("return", ce.send());
            case 11:
            case "end":
              return Be.stop();
          }
        }, ue, null, [[4, , 7, 10]]);
      }))), J(this, "needsNonInvokerSigningBy", function() {
        var ue, ne = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ge = ne.includeAlreadySigned, Te = ge === void 0 ? false : ge;
        if (!ce.built) throw new Error("Transaction has not yet been simulated");
        if (!("operations" in ce.built)) throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(ce.built)));
        var pe = ce.built.operations[0];
        return D(new Set(((ue = pe.auth) !== null && ue !== void 0 ? ue : []).filter(function(Oe) {
          return Oe.credentials().switch() === v.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (Te || Oe.credentials().address().signature().switch().name === "scvVoid");
        }).map(function(Oe) {
          return v.Address.fromScAddress(Oe.credentials().address().address()).toString();
        })));
      }), J(this, "signAuthEntries", Y(q().mark(function ue() {
        var ne, ge, Te, pe, Oe, xe, Ve, _e, Be, Qe, ee, P, x, O, V, N, C, p = arguments;
        return q().wrap(function(U) {
          for (; ; ) switch (U.prev = U.next) {
            case 0:
              if (ge = p.length > 0 && p[0] !== void 0 ? p[0] : {}, Te = ge.expiration, pe = Te === void 0 ? Y(q().mark(function Q() {
                return q().wrap(function(X) {
                  for (; ; ) switch (X.prev = X.next) {
                    case 0:
                      return X.next = 2, ce.server.getLatestLedger();
                    case 2:
                      return X.t0 = X.sent.sequence, X.abrupt("return", X.t0 + 100);
                    case 4:
                    case "end":
                      return X.stop();
                  }
                }, Q);
              }))() : Te, Oe = ge.signAuthEntry, xe = Oe === void 0 ? ce.options.signAuthEntry : Oe, Ve = ge.address, _e = Ve === void 0 ? ce.options.publicKey : Ve, Be = ge.authorizeEntry, Qe = Be === void 0 ? v.authorizeEntry : Be, ce.built) {
                U.next = 3;
                break;
              }
              throw new Error("Transaction has not yet been assembled or simulated");
            case 3:
              if (Qe !== v.authorizeEntry) {
                U.next = 11;
                break;
              }
              if (ee = ce.needsNonInvokerSigningBy(), ee.length !== 0) {
                U.next = 7;
                break;
              }
              throw new $.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
            case 7:
              if (ee.indexOf(_e ?? "") !== -1) {
                U.next = 9;
                break;
              }
              throw new $.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(_e, '"'));
            case 9:
              if (xe) {
                U.next = 11;
                break;
              }
              throw new $.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
            case 11:
              P = ce.built.operations[0], x = (ne = P.auth) !== null && ne !== void 0 ? ne : [], O = I(x.entries()), U.prev = 14, N = q().mark(function Q() {
                var se, X, de, tt, Ne, ut;
                return q().wrap(function(Et) {
                  for (; ; ) switch (Et.prev = Et.next) {
                    case 0:
                      if (se = R(V.value, 2), X = se[0], de = se[1], tt = v.xdr.SorobanCredentials.fromXDR(de.credentials().toXDR()), tt.switch() === v.xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {
                        Et.next = 4;
                        break;
                      }
                      return Et.abrupt("return", 0);
                    case 4:
                      if (Ne = v.Address.fromScAddress(tt.address().address()).toString(), Ne === _e) {
                        Et.next = 7;
                        break;
                      }
                      return Et.abrupt("return", 0);
                    case 7:
                      return ut = xe ?? Promise.resolve, Et.t0 = Qe, Et.t1 = de, Et.t2 = function() {
                        var rr = Y(q().mark(function je(Ge) {
                          var at, Ae, qe;
                          return q().wrap(function(Dt) {
                            for (; ; ) switch (Dt.prev = Dt.next) {
                              case 0:
                                return Dt.next = 2, ut(Ge.toXDR("base64"), { address: _e });
                              case 2:
                                return at = Dt.sent, Ae = at.signedAuthEntry, qe = at.error, ce.handleWalletError(qe), Dt.abrupt("return", Buffer.from(Ae, "base64"));
                              case 7:
                              case "end":
                                return Dt.stop();
                            }
                          }, je);
                        }));
                        return function(je) {
                          return rr.apply(this, arguments);
                        };
                      }(), Et.next = 13, pe;
                    case 13:
                      return Et.t3 = Et.sent, Et.t4 = ce.options.networkPassphrase, Et.next = 17, (0, Et.t0)(Et.t1, Et.t2, Et.t3, Et.t4);
                    case 17:
                      x[X] = Et.sent;
                    case 18:
                    case "end":
                      return Et.stop();
                  }
                }, Q);
              }), O.s();
            case 17:
              if ((V = O.n()).done) {
                U.next = 24;
                break;
              }
              return U.delegateYield(N(), "t0", 19);
            case 19:
              if (C = U.t0, C !== 0) {
                U.next = 22;
                break;
              }
              return U.abrupt("continue", 22);
            case 22:
              U.next = 17;
              break;
            case 24:
              U.next = 29;
              break;
            case 26:
              U.prev = 26, U.t1 = U.catch(14), O.e(U.t1);
            case 29:
              return U.prev = 29, O.f(), U.finish(29);
            case 32:
            case "end":
              return U.stop();
          }
        }, ue, null, [[14, 26, 29, 32]]);
      }))), this.options = oe, this.options.simulate = (ye = this.options.simulate) !== null && ye !== void 0 ? ye : true, this.server = new e.Server(this.options.rpcUrl, { allowHttp: (ae = this.options.allowHttp) !== null && ae !== void 0 ? ae : false });
    }
    return K($, [{ key: "toJSON", value: function() {
      var ce;
      return JSON.stringify({ method: this.options.method, tx: (ce = this.built) === null || ce === void 0 ? void 0 : ce.toXDR(), simulationResult: { auth: this.simulationData.result.auth.map(function(ye) {
        return ye.toXDR("base64");
      }), retval: this.simulationData.result.retval.toXDR("base64") }, simulationTransactionData: this.simulationData.transactionData.toXDR("base64") });
    } }, { key: "toXDR", value: function() {
      var ce;
      if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
      return (ce = this.built) === null || ce === void 0 ? void 0 : ce.toEnvelope().toXDR("base64");
    } }, { key: "handleWalletError", value: function(ce) {
      if (ce) {
        var ye = ce.message, ae = ce.code, ue = "".concat(ye).concat(ce.ext ? " (".concat(ce.ext.join(", "), ")") : "");
        switch (ae) {
          case -1:
            throw new $.Errors.InternalWalletError(ue);
          case -2:
            throw new $.Errors.ExternalServiceError(ue);
          case -3:
            throw new $.Errors.InvalidClientRequest(ue);
          case -4:
            throw new $.Errors.UserRejected(ue);
          default:
            throw new Error("Unhandled error: ".concat(ue));
        }
      }
    } }, { key: "simulationData", get: function() {
      var ce;
      if (this.simulationResult && this.simulationTransactionData) return { result: this.simulationResult, transactionData: this.simulationTransactionData };
      var ye = this.simulation;
      if (!ye) throw new $.Errors.NotYetSimulated("Transaction has not yet been simulated");
      if (n.Api.isSimulationError(ye)) throw new $.Errors.SimulationFailed('Transaction simulation failed: "'.concat(ye.error, '"'));
      if (n.Api.isSimulationRestore(ye)) throw new $.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
      return this.simulationResult = (ce = ye.result) !== null && ce !== void 0 ? ce : { auth: [], retval: v.xdr.ScVal.scvVoid() }, this.simulationTransactionData = ye.transactionData.build(), { result: this.simulationResult, transactionData: this.simulationTransactionData };
    } }, { key: "result", get: function() {
      try {
        if (!this.simulationData.result) throw new Error("No simulation result!");
        return this.options.parseResultXdr(this.simulationData.result.retval);
      } catch (ye) {
        if (!(0, y.implementsToString)(ye)) throw ye;
        var ce = this.parseError(ye.toString());
        if (ce) return ce;
        throw ye;
      }
    } }, { key: "parseError", value: function(ce) {
      if (this.options.errorTypes) {
        var ye = ce.match(y.contractErrorPattern);
        if (ye) {
          var ae = parseInt(ye[1], 10), ue = this.options.errorTypes[ae];
          if (ue) return new s.Err(ue);
        }
      }
    } }, { key: "send", value: function() {
      var oe = Y(q().mark(function ye() {
        var ae;
        return q().wrap(function(ne) {
          for (; ; ) switch (ne.prev = ne.next) {
            case 0:
              if (this.signed) {
                ne.next = 2;
                break;
              }
              throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
            case 2:
              return ne.next = 4, o.SentTransaction.init(this);
            case 4:
              return ae = ne.sent, ne.abrupt("return", ae);
            case 6:
            case "end":
              return ne.stop();
          }
        }, ye, this);
      }));
      function ce() {
        return oe.apply(this, arguments);
      }
      return ce;
    }() }, { key: "isReadCall", get: function() {
      var ce = this.simulationData.result.auth.length, ye = this.simulationData.transactionData.resources().footprint().readWrite().length;
      return ce === 0 && ye === 0;
    } }, { key: "restoreFootprint", value: function() {
      var oe = Y(q().mark(function ye(ae, ue) {
        var ne, ge;
        return q().wrap(function(pe) {
          for (; ; ) switch (pe.prev = pe.next) {
            case 0:
              if (this.options.signTransaction) {
                pe.next = 2;
                break;
              }
              throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
            case 2:
              if (ue == null) {
                pe.next = 6;
                break;
              }
              pe.t0 = ue, pe.next = 9;
              break;
            case 6:
              return pe.next = 8, (0, y.getAccount)(this.options, this.server);
            case 8:
              pe.t0 = pe.sent;
            case 9:
              return ue = pe.t0, pe.next = 12, $.buildFootprintRestoreTransaction(E({}, this.options), ae.transactionData, ue, ae.minResourceFee);
            case 12:
              return ne = pe.sent, pe.next = 15, ne.signAndSend();
            case 15:
              if (ge = pe.sent, ge.getTransactionResponse) {
                pe.next = 18;
                break;
              }
              throw new $.Errors.RestorationFailure(`The attempt at automatic restore failed. 
`.concat(JSON.stringify(ge)));
            case 18:
              return pe.abrupt("return", ge.getTransactionResponse);
            case 19:
            case "end":
              return pe.stop();
          }
        }, ye, this);
      }));
      function ce(ye, ae) {
        return oe.apply(this, arguments);
      }
      return ce;
    }() }], [{ key: "fromJSON", value: function(ce, ye) {
      var ae = ye.tx, ue = ye.simulationResult, ne = ye.simulationTransactionData, ge = new $(ce);
      return ge.built = v.TransactionBuilder.fromXDR(ae, ce.networkPassphrase), ge.simulationResult = { auth: ue.auth.map(function(Te) {
        return v.xdr.SorobanAuthorizationEntry.fromXDR(Te, "base64");
      }), retval: v.xdr.ScVal.fromXDR(ue.retval, "base64") }, ge.simulationTransactionData = v.xdr.SorobanTransactionData.fromXDR(ne, "base64"), ge;
    } }, { key: "fromXDR", value: function(ce, ye, ae) {
      var ue, ne = v.xdr.TransactionEnvelope.fromXDR(ye, "base64"), ge = v.TransactionBuilder.fromXDR(ne, ce.networkPassphrase), Te = ge.operations[0];
      if (!(Te != null && (ue = Te.func) !== null && ue !== void 0 && ue.value) || typeof Te.func.value != "function") throw new Error("Could not extract the method from the transaction envelope.");
      var pe = Te.func.value();
      if (!(pe != null && pe.functionName)) throw new Error("Could not extract the method name from the transaction envelope.");
      var Oe = pe.functionName().toString("utf-8"), xe = new $(E(E({}, ce), {}, { method: Oe, parseResultXdr: function(_e) {
        return ae.funcResToNative(Oe, _e);
      } }));
      return xe.built = ge, xe;
    } }, { key: "build", value: function(ce) {
      var ye, ae = new v.Contract(ce.contractId);
      return $.buildWithOp(ae.call.apply(ae, [ce.method].concat(D((ye = ce.args) !== null && ye !== void 0 ? ye : []))), ce);
    } }, { key: "buildWithOp", value: function() {
      var oe = Y(q().mark(function ye(ae, ue) {
        var ne, ge, Te, pe;
        return q().wrap(function(xe) {
          for (; ; ) switch (xe.prev = xe.next) {
            case 0:
              return Te = new $(ue), xe.next = 3, (0, y.getAccount)(ue, Te.server);
            case 3:
              if (pe = xe.sent, Te.raw = new v.TransactionBuilder(pe, { fee: (ne = ue.fee) !== null && ne !== void 0 ? ne : v.BASE_FEE, networkPassphrase: ue.networkPassphrase }).setTimeout((ge = ue.timeoutInSeconds) !== null && ge !== void 0 ? ge : t.DEFAULT_TIMEOUT).addOperation(ae), !ue.simulate) {
                xe.next = 8;
                break;
              }
              return xe.next = 8, Te.simulate();
            case 8:
              return xe.abrupt("return", Te);
            case 9:
            case "end":
              return xe.stop();
          }
        }, ye);
      }));
      function ce(ye, ae) {
        return oe.apply(this, arguments);
      }
      return ce;
    }() }, { key: "buildFootprintRestoreTransaction", value: function() {
      var oe = Y(q().mark(function ye(ae, ue, ne, ge) {
        var Te, pe;
        return q().wrap(function(xe) {
          for (; ; ) switch (xe.prev = xe.next) {
            case 0:
              return pe = new $(ae), pe.raw = new v.TransactionBuilder(ne, { fee: ge, networkPassphrase: ae.networkPassphrase }).setSorobanData(ue instanceof v.SorobanDataBuilder ? ue.build() : ue).addOperation(v.Operation.restoreFootprint({})).setTimeout((Te = ae.timeoutInSeconds) !== null && Te !== void 0 ? Te : t.DEFAULT_TIMEOUT), xe.next = 4, pe.simulate({ restore: false });
            case 4:
              return xe.abrupt("return", pe);
            case 5:
            case "end":
              return xe.stop();
          }
        }, ye);
      }));
      function ce(ye, ae, ue, ne) {
        return oe.apply(this, arguments);
      }
      return ce;
    }() }]);
  }();
  return J(ie, "Errors", { ExpiredState: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), RestorationFailure: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), NeedsMoreSignatures: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), NoSignatureNeeded: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), NoUnsignedNonInvokerAuthEntries: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), NoSigner: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), NotYetSimulated: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), FakeAccount: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), SimulationFailed: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), InternalWalletError: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), ExternalServiceError: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), InvalidClientRequest: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)), UserRejected: function($) {
    function oe() {
      return te(this, oe), u(this, oe, arguments);
    }
    return f(oe, $), K(oe);
  }(r(Error)) }), Ts;
}
var Os = {}, Nd;
function _E() {
  if (Nd) return Os;
  Nd = 1;
  function v(y) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, v(y);
  }
  Object.defineProperty(Os, "__esModule", { value: true }), Os.basicNodeSigner = void 0;
  var e = ko();
  function n() {
    n = function() {
      return t;
    };
    var y, t = {}, o = Object.prototype, u = o.hasOwnProperty, c = Object.defineProperty || function(K, J, B) {
      K[J] = B.value;
    }, h = typeof Symbol == "function" ? Symbol : {}, f = h.iterator || "@@iterator", r = h.asyncIterator || "@@asyncIterator", m = h.toStringTag || "@@toStringTag";
    function g(K, J, B) {
      return Object.defineProperty(K, J, { value: B, enumerable: true, configurable: true, writable: true }), K[J];
    }
    try {
      g({}, "");
    } catch {
      g = function(B, Z, ie) {
        return B[Z] = ie;
      };
    }
    function a(K, J, B, Z) {
      var ie = J && J.prototype instanceof k ? J : k, $ = Object.create(ie.prototype), oe = new te(Z || []);
      return c($, "_invoke", { value: L(K, B, oe) }), $;
    }
    function l(K, J, B) {
      try {
        return { type: "normal", arg: K.call(J, B) };
      } catch (Z) {
        return { type: "throw", arg: Z };
      }
    }
    t.wrap = a;
    var d = "suspendedStart", b = "suspendedYield", S = "executing", E = "completed", R = {};
    function k() {
    }
    function w() {
    }
    function F() {
    }
    var I = {};
    g(I, f, function() {
      return this;
    });
    var q = Object.getPrototypeOf, D = q && q(q(G([])));
    D && D !== o && u.call(D, f) && (I = D);
    var H = F.prototype = k.prototype = Object.create(I);
    function _(K) {
      ["next", "throw", "return"].forEach(function(J) {
        g(K, J, function(B) {
          return this._invoke(J, B);
        });
      });
    }
    function T(K, J) {
      function B(ie, $, oe, ce) {
        var ye = l(K[ie], K, $);
        if (ye.type !== "throw") {
          var ae = ye.arg, ue = ae.value;
          return ue && v(ue) == "object" && u.call(ue, "__await") ? J.resolve(ue.__await).then(function(ne) {
            B("next", ne, oe, ce);
          }, function(ne) {
            B("throw", ne, oe, ce);
          }) : J.resolve(ue).then(function(ne) {
            ae.value = ne, oe(ae);
          }, function(ne) {
            return B("throw", ne, oe, ce);
          });
        }
        ce(ye.arg);
      }
      var Z;
      c(this, "_invoke", { value: function($, oe) {
        function ce() {
          return new J(function(ye, ae) {
            B($, oe, ye, ae);
          });
        }
        return Z = Z ? Z.then(ce, ce) : ce();
      } });
    }
    function L(K, J, B) {
      var Z = d;
      return function(ie, $) {
        if (Z === S) throw Error("Generator is already running");
        if (Z === E) {
          if (ie === "throw") throw $;
          return { value: y, done: true };
        }
        for (B.method = ie, B.arg = $; ; ) {
          var oe = B.delegate;
          if (oe) {
            var ce = j(oe, B);
            if (ce) {
              if (ce === R) continue;
              return ce;
            }
          }
          if (B.method === "next") B.sent = B._sent = B.arg;
          else if (B.method === "throw") {
            if (Z === d) throw Z = E, B.arg;
            B.dispatchException(B.arg);
          } else B.method === "return" && B.abrupt("return", B.arg);
          Z = S;
          var ye = l(K, J, B);
          if (ye.type === "normal") {
            if (Z = B.done ? E : b, ye.arg === R) continue;
            return { value: ye.arg, done: B.done };
          }
          ye.type === "throw" && (Z = E, B.method = "throw", B.arg = ye.arg);
        }
      };
    }
    function j(K, J) {
      var B = J.method, Z = K.iterator[B];
      if (Z === y) return J.delegate = null, B === "throw" && K.iterator.return && (J.method = "return", J.arg = y, j(K, J), J.method === "throw") || B !== "return" && (J.method = "throw", J.arg = new TypeError("The iterator does not provide a '" + B + "' method")), R;
      var ie = l(Z, K.iterator, J.arg);
      if (ie.type === "throw") return J.method = "throw", J.arg = ie.arg, J.delegate = null, R;
      var $ = ie.arg;
      return $ ? $.done ? (J[K.resultName] = $.value, J.next = K.nextLoc, J.method !== "return" && (J.method = "next", J.arg = y), J.delegate = null, R) : $ : (J.method = "throw", J.arg = new TypeError("iterator result is not an object"), J.delegate = null, R);
    }
    function z(K) {
      var J = { tryLoc: K[0] };
      1 in K && (J.catchLoc = K[1]), 2 in K && (J.finallyLoc = K[2], J.afterLoc = K[3]), this.tryEntries.push(J);
    }
    function Y(K) {
      var J = K.completion || {};
      J.type = "normal", delete J.arg, K.completion = J;
    }
    function te(K) {
      this.tryEntries = [{ tryLoc: "root" }], K.forEach(z, this), this.reset(true);
    }
    function G(K) {
      if (K || K === "") {
        var J = K[f];
        if (J) return J.call(K);
        if (typeof K.next == "function") return K;
        if (!isNaN(K.length)) {
          var B = -1, Z = function ie() {
            for (; ++B < K.length; ) if (u.call(K, B)) return ie.value = K[B], ie.done = false, ie;
            return ie.value = y, ie.done = true, ie;
          };
          return Z.next = Z;
        }
      }
      throw new TypeError(v(K) + " is not iterable");
    }
    return w.prototype = F, c(H, "constructor", { value: F, configurable: true }), c(F, "constructor", { value: w, configurable: true }), w.displayName = g(F, m, "GeneratorFunction"), t.isGeneratorFunction = function(K) {
      var J = typeof K == "function" && K.constructor;
      return !!J && (J === w || (J.displayName || J.name) === "GeneratorFunction");
    }, t.mark = function(K) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(K, F) : (K.__proto__ = F, g(K, m, "GeneratorFunction")), K.prototype = Object.create(H), K;
    }, t.awrap = function(K) {
      return { __await: K };
    }, _(T.prototype), g(T.prototype, r, function() {
      return this;
    }), t.AsyncIterator = T, t.async = function(K, J, B, Z, ie) {
      ie === void 0 && (ie = Promise);
      var $ = new T(a(K, J, B, Z), ie);
      return t.isGeneratorFunction(J) ? $ : $.next().then(function(oe) {
        return oe.done ? oe.value : $.next();
      });
    }, _(H), g(H, m, "Generator"), g(H, f, function() {
      return this;
    }), g(H, "toString", function() {
      return "[object Generator]";
    }), t.keys = function(K) {
      var J = Object(K), B = [];
      for (var Z in J) B.push(Z);
      return B.reverse(), function ie() {
        for (; B.length; ) {
          var $ = B.pop();
          if ($ in J) return ie.value = $, ie.done = false, ie;
        }
        return ie.done = true, ie;
      };
    }, t.values = G, te.prototype = { constructor: te, reset: function(J) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = y, this.done = false, this.delegate = null, this.method = "next", this.arg = y, this.tryEntries.forEach(Y), !J) for (var B in this) B.charAt(0) === "t" && u.call(this, B) && !isNaN(+B.slice(1)) && (this[B] = y);
    }, stop: function() {
      this.done = true;
      var J = this.tryEntries[0].completion;
      if (J.type === "throw") throw J.arg;
      return this.rval;
    }, dispatchException: function(J) {
      if (this.done) throw J;
      var B = this;
      function Z(ae, ue) {
        return oe.type = "throw", oe.arg = J, B.next = ae, ue && (B.method = "next", B.arg = y), !!ue;
      }
      for (var ie = this.tryEntries.length - 1; ie >= 0; --ie) {
        var $ = this.tryEntries[ie], oe = $.completion;
        if ($.tryLoc === "root") return Z("end");
        if ($.tryLoc <= this.prev) {
          var ce = u.call($, "catchLoc"), ye = u.call($, "finallyLoc");
          if (ce && ye) {
            if (this.prev < $.catchLoc) return Z($.catchLoc, true);
            if (this.prev < $.finallyLoc) return Z($.finallyLoc);
          } else if (ce) {
            if (this.prev < $.catchLoc) return Z($.catchLoc, true);
          } else {
            if (!ye) throw Error("try statement without catch or finally");
            if (this.prev < $.finallyLoc) return Z($.finallyLoc);
          }
        }
      }
    }, abrupt: function(J, B) {
      for (var Z = this.tryEntries.length - 1; Z >= 0; --Z) {
        var ie = this.tryEntries[Z];
        if (ie.tryLoc <= this.prev && u.call(ie, "finallyLoc") && this.prev < ie.finallyLoc) {
          var $ = ie;
          break;
        }
      }
      $ && (J === "break" || J === "continue") && $.tryLoc <= B && B <= $.finallyLoc && ($ = null);
      var oe = $ ? $.completion : {};
      return oe.type = J, oe.arg = B, $ ? (this.method = "next", this.next = $.finallyLoc, R) : this.complete(oe);
    }, complete: function(J, B) {
      if (J.type === "throw") throw J.arg;
      return J.type === "break" || J.type === "continue" ? this.next = J.arg : J.type === "return" ? (this.rval = this.arg = J.arg, this.method = "return", this.next = "end") : J.type === "normal" && B && (this.next = B), R;
    }, finish: function(J) {
      for (var B = this.tryEntries.length - 1; B >= 0; --B) {
        var Z = this.tryEntries[B];
        if (Z.finallyLoc === J) return this.complete(Z.completion, Z.afterLoc), Y(Z), R;
      }
    }, catch: function(J) {
      for (var B = this.tryEntries.length - 1; B >= 0; --B) {
        var Z = this.tryEntries[B];
        if (Z.tryLoc === J) {
          var ie = Z.completion;
          if (ie.type === "throw") {
            var $ = ie.arg;
            Y(Z);
          }
          return $;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(J, B, Z) {
      return this.delegate = { iterator: G(J), resultName: B, nextLoc: Z }, this.method === "next" && (this.arg = y), R;
    } }, t;
  }
  function i(y, t, o, u, c, h, f) {
    try {
      var r = y[h](f), m = r.value;
    } catch (g) {
      return void o(g);
    }
    r.done ? t(m) : Promise.resolve(m).then(u, c);
  }
  function s(y) {
    return function() {
      var t = this, o = arguments;
      return new Promise(function(u, c) {
        var h = y.apply(t, o);
        function f(m) {
          i(h, u, c, f, r, "next", m);
        }
        function r(m) {
          i(h, u, c, f, r, "throw", m);
        }
        f(void 0);
      });
    };
  }
  return Os.basicNodeSigner = function(t, o) {
    return { signTransaction: function() {
      var u = s(n().mark(function h(f, r) {
        var m;
        return n().wrap(function(a) {
          for (; ; ) switch (a.prev = a.next) {
            case 0:
              return m = e.TransactionBuilder.fromXDR(f, (r == null ? void 0 : r.networkPassphrase) || o), m.sign(t), a.abrupt("return", { signedTxXdr: m.toXDR(), signerAddress: t.publicKey() });
            case 3:
            case "end":
              return a.stop();
          }
        }, h);
      }));
      function c(h, f) {
        return u.apply(this, arguments);
      }
      return c;
    }(), signAuthEntry: function() {
      var u = s(n().mark(function h(f) {
        var r;
        return n().wrap(function(g) {
          for (; ; ) switch (g.prev = g.next) {
            case 0:
              return r = t.sign((0, e.hash)(Buffer.from(f, "base64"))).toString("base64"), g.abrupt("return", { signedAuthEntry: r, signerAddress: t.publicKey() });
            case 2:
            case "end":
              return g.stop();
          }
        }, h);
      }));
      function c(h) {
        return u.apply(this, arguments);
      }
      return c;
    }() };
  }, Os;
}
var Ps = {}, Cs = {}, Dd;
function $m() {
  if (Dd) return Cs;
  Dd = 1, Object.defineProperty(Cs, "__esModule", { value: true }), Cs.Spec = void 0;
  var v = ko(), e = mf();
  function n(_, T) {
    var L = Object.keys(_);
    if (Object.getOwnPropertySymbols) {
      var j = Object.getOwnPropertySymbols(_);
      T && (j = j.filter(function(z) {
        return Object.getOwnPropertyDescriptor(_, z).enumerable;
      })), L.push.apply(L, j);
    }
    return L;
  }
  function i(_) {
    for (var T = 1; T < arguments.length; T++) {
      var L = arguments[T] != null ? arguments[T] : {};
      T % 2 ? n(Object(L), true).forEach(function(j) {
        u(_, j, L[j]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_, Object.getOwnPropertyDescriptors(L)) : n(Object(L)).forEach(function(j) {
        Object.defineProperty(_, j, Object.getOwnPropertyDescriptor(L, j));
      });
    }
    return _;
  }
  function s(_) {
    "@babel/helpers - typeof";
    return s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(T) {
      return typeof T;
    } : function(T) {
      return T && typeof Symbol == "function" && T.constructor === Symbol && T !== Symbol.prototype ? "symbol" : typeof T;
    }, s(_);
  }
  function y(_, T) {
    if (!(_ instanceof T)) throw new TypeError("Cannot call a class as a function");
  }
  function t(_, T) {
    for (var L = 0; L < T.length; L++) {
      var j = T[L];
      j.enumerable = j.enumerable || false, j.configurable = true, "value" in j && (j.writable = true), Object.defineProperty(_, c(j.key), j);
    }
  }
  function o(_, T, L) {
    return T && t(_.prototype, T), Object.defineProperty(_, "prototype", { writable: false }), _;
  }
  function u(_, T, L) {
    return (T = c(T)) in _ ? Object.defineProperty(_, T, { value: L, enumerable: true, configurable: true, writable: true }) : _[T] = L, _;
  }
  function c(_) {
    var T = h(_, "string");
    return s(T) == "symbol" ? T : T + "";
  }
  function h(_, T) {
    if (s(_) != "object" || !_) return _;
    var L = _[Symbol.toPrimitive];
    if (L !== void 0) {
      var j = L.call(_, T);
      if (s(j) != "object") return j;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(_);
  }
  function f(_, T) {
    return l(_) || a(_, T) || m(_, T) || r();
  }
  function r() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function m(_, T) {
    if (_) {
      if (typeof _ == "string") return g(_, T);
      var L = {}.toString.call(_).slice(8, -1);
      return L === "Object" && _.constructor && (L = _.constructor.name), L === "Map" || L === "Set" ? Array.from(_) : L === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(L) ? g(_, T) : void 0;
    }
  }
  function g(_, T) {
    (T == null || T > _.length) && (T = _.length);
    for (var L = 0, j = Array(T); L < T; L++) j[L] = _[L];
    return j;
  }
  function a(_, T) {
    var L = _ == null ? null : typeof Symbol < "u" && _[Symbol.iterator] || _["@@iterator"];
    if (L != null) {
      var j, z, Y, te, G = [], K = true, J = false;
      try {
        if (Y = (L = L.call(_)).next, T === 0) {
          if (Object(L) !== L) return;
          K = false;
        } else for (; !(K = (j = Y.call(L)).done) && (G.push(j.value), G.length !== T); K = true) ;
      } catch (B) {
        J = true, z = B;
      } finally {
        try {
          if (!K && L.return != null && (te = L.return(), Object(te) !== te)) return;
        } finally {
          if (J) throw z;
        }
      }
      return G;
    }
  }
  function l(_) {
    if (Array.isArray(_)) return _;
  }
  function d(_) {
    var T = _.doc().toString(), L = _.cases(), j = [];
    L.forEach(function(Y) {
      var te = Y.name().toString(), G = Y.doc().toString();
      j.push({ description: G, title: te, enum: [Y.value()], type: "number" });
    });
    var z = { oneOf: j };
    return T.length > 0 && (z.description = T), z;
  }
  function b(_) {
    return /^\d+$/.test(_.name().toString());
  }
  function S(_, T) {
    var L = T.name().toString(), j = Object.entries(_).find(function(z) {
      var Y = f(z, 1), te = Y[0];
      return te === L;
    });
    if (!j) throw new Error("Missing field ".concat(L));
    return j[1];
  }
  function E(_) {
    return function(L) {
      switch (L.switch().value) {
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
          var j = L.tupleCase();
          return j.name().toString() === _;
        }
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
          var z = L.voidCase();
          return z.name().toString() === _;
        }
        default:
          return false;
      }
    };
  }
  function R(_, T) {
    switch (T.value) {
      case v.xdr.ScSpecType.scSpecTypeString().value:
        return v.xdr.ScVal.scvString(_);
      case v.xdr.ScSpecType.scSpecTypeSymbol().value:
        return v.xdr.ScVal.scvSymbol(_);
      case v.xdr.ScSpecType.scSpecTypeAddress().value: {
        var L = v.Address.fromString(_);
        return v.xdr.ScVal.scvAddress(L.toScAddress());
      }
      case v.xdr.ScSpecType.scSpecTypeU64().value:
        return new v.XdrLargeInt("u64", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeI64().value:
        return new v.XdrLargeInt("i64", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeU128().value:
        return new v.XdrLargeInt("u128", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeI128().value:
        return new v.XdrLargeInt("i128", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeU256().value:
        return new v.XdrLargeInt("u256", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeI256().value:
        return new v.XdrLargeInt("i256", _).toScVal();
      case v.xdr.ScSpecType.scSpecTypeBytes().value:
      case v.xdr.ScSpecType.scSpecTypeBytesN().value:
        return v.xdr.ScVal.scvBytes(Buffer.from(_, "base64"));
      default:
        throw new TypeError("invalid type ".concat(T.name, " specified for string value"));
    }
  }
  var k = { U32: { type: "integer", minimum: 0, maximum: 4294967295 }, I32: { type: "integer", minimum: -2147483648, maximum: 2147483647 }, U64: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 20 }, I64: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 21 }, U128: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 39 }, I128: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 40 }, U256: { type: "string", pattern: "^([1-9][0-9]*|0)$", minLength: 1, maxLength: 78 }, I256: { type: "string", pattern: "^(-?[1-9][0-9]*|0)$", minLength: 1, maxLength: 79 }, Address: { type: "string", format: "address", description: "Address can be a public key or contract id" }, ScString: { type: "string", description: "ScString is a string" }, ScSymbol: { type: "string", description: "ScSymbol is a string" }, DataUrl: { type: "string", pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$" } };
  function w(_) {
    var T = _.switch(), L = T.value, j;
    switch (L) {
      case v.xdr.ScSpecType.scSpecTypeVal().value: {
        j = "Val";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeBool().value:
        return { type: "boolean" };
      case v.xdr.ScSpecType.scSpecTypeVoid().value:
        return { type: "null" };
      case v.xdr.ScSpecType.scSpecTypeError().value: {
        j = "Error";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeU32().value: {
        j = "U32";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeI32().value: {
        j = "I32";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeU64().value: {
        j = "U64";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeI64().value: {
        j = "I64";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeTimepoint().value:
        throw new Error("Timepoint type not supported");
      case v.xdr.ScSpecType.scSpecTypeDuration().value:
        throw new Error("Duration not supported");
      case v.xdr.ScSpecType.scSpecTypeU128().value: {
        j = "U128";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeI128().value: {
        j = "I128";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeU256().value: {
        j = "U256";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeI256().value: {
        j = "I256";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeBytes().value: {
        j = "DataUrl";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeString().value: {
        j = "ScString";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeSymbol().value: {
        j = "ScSymbol";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeAddress().value: {
        j = "Address";
        break;
      }
      case v.xdr.ScSpecType.scSpecTypeOption().value: {
        var z = _.option();
        return w(z.valueType());
      }
      case v.xdr.ScSpecType.scSpecTypeResult().value:
        break;
      case v.xdr.ScSpecType.scSpecTypeVec().value: {
        var Y = _.vec(), te = w(Y.elementType());
        return { type: "array", items: te };
      }
      case v.xdr.ScSpecType.scSpecTypeMap().value: {
        var G = _.map(), K = [w(G.keyType()), w(G.valueType())];
        return { type: "array", items: { type: "array", items: K, minItems: 2, maxItems: 2 } };
      }
      case v.xdr.ScSpecType.scSpecTypeTuple().value: {
        var J = _.tuple(), B = J.valueTypes().length, Z = B, ie = J.valueTypes().map(w);
        return { type: "array", items: ie, minItems: B, maxItems: Z };
      }
      case v.xdr.ScSpecType.scSpecTypeBytesN().value: {
        var $ = _.bytesN();
        return { $ref: "#/definitions/DataUrl", maxLength: $.n() };
      }
      case v.xdr.ScSpecType.scSpecTypeUdt().value: {
        var oe = _.udt();
        j = oe.name().toString();
        break;
      }
    }
    return { $ref: "#/definitions/".concat(j) };
  }
  function F(_) {
    return _.switch().value !== v.xdr.ScSpecType.scSpecTypeOption().value;
  }
  function I(_) {
    var T = {}, L = [];
    _.forEach(function(z) {
      var Y = z.type(), te = z.name().toString();
      T[te] = w(Y), F(Y) && L.push(te);
    });
    var j = { properties: T };
    return L.length > 0 && (j.required = L), j;
  }
  function q(_) {
    var T = _.fields();
    if (T.some(b)) {
      if (!T.every(b)) throw new Error("mixed numeric and non-numeric field names are not allowed");
      var L = T.map(function(G, K) {
        return w(T[K].type());
      });
      return { type: "array", items: L, minItems: T.length, maxItems: T.length };
    }
    var j = _.doc().toString(), z = I(T), Y = z.properties, te = z.required;
    return Y.additionalProperties = false, { description: j, properties: Y, required: te, type: "object" };
  }
  function D(_) {
    var T = I(_.inputs()), L = T.properties, j = T.required, z = { additionalProperties: false, properties: L, type: "object" };
    (j == null ? void 0 : j.length) > 0 && (z.required = j);
    var Y = { properties: { args: z } }, te = _.outputs(), G = te.length > 0 ? w(te[0]) : w(v.xdr.ScSpecTypeDef.scSpecTypeVoid()), K = _.doc().toString();
    return K.length > 0 && (Y.description = K), Y.additionalProperties = false, G.additionalProperties = false, { input: Y, output: G };
  }
  function H(_) {
    var T = _.doc().toString(), L = _.cases(), j = [];
    L.forEach(function(Y) {
      switch (Y.switch().value) {
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
          var te = Y.voidCase(), G = te.name().toString();
          j.push({ type: "object", title: G, properties: { tag: G }, additionalProperties: false, required: ["tag"] });
          break;
        }
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
          var K = Y.tupleCase(), J = K.name().toString();
          j.push({ type: "object", title: J, properties: { tag: J, values: { type: "array", items: K.type().map(w) } }, required: ["tag", "values"], additionalProperties: false });
        }
      }
    });
    var z = { oneOf: j };
    return T.length > 0 && (z.description = T), z;
  }
  return Cs.Spec = function() {
    function _(T) {
      if (y(this, _), u(this, "entries", []), T.length === 0) throw new Error("Contract spec must have at least one entry");
      var L = T[0];
      typeof L == "string" ? this.entries = T.map(function(j) {
        return v.xdr.ScSpecEntry.fromXDR(j, "base64");
      }) : this.entries = T;
    }
    return o(_, [{ key: "funcs", value: function() {
      return this.entries.filter(function(L) {
        return L.switch().value === v.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
      }).map(function(L) {
        return L.functionV0();
      });
    } }, { key: "getFunc", value: function(L) {
      var j = this.findEntry(L);
      if (j.switch().value !== v.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) throw new Error("".concat(L, " is not a function"));
      return j.functionV0();
    } }, { key: "funcArgsToScVals", value: function(L, j) {
      var z = this, Y = this.getFunc(L);
      return Y.inputs().map(function(te) {
        return z.nativeToScVal(S(j, te), te.type());
      });
    } }, { key: "funcResToNative", value: function(L, j) {
      var z = typeof j == "string" ? v.xdr.ScVal.fromXDR(j, "base64") : j, Y = this.getFunc(L), te = Y.outputs();
      if (te.length === 0) {
        var G = z.switch();
        if (G.value !== v.xdr.ScValType.scvVoid().value) throw new Error("Expected void, got ".concat(G.name));
        return null;
      }
      if (te.length > 1) throw new Error("Multiple outputs not supported");
      var K = te[0];
      return K.switch().value === v.xdr.ScSpecType.scSpecTypeResult().value ? new e.Ok(this.scValToNative(z, K.result().okType())) : this.scValToNative(z, K);
    } }, { key: "findEntry", value: function(L) {
      var j = this.entries.find(function(z) {
        return z.value().name().toString() === L;
      });
      if (!j) throw new Error("no such entry: ".concat(L));
      return j;
    } }, { key: "nativeToScVal", value: function(L, j) {
      var z = this, Y = j.switch(), te = Y.value;
      if (Y.value === v.xdr.ScSpecType.scSpecTypeUdt().value) {
        var G = j.udt();
        return this.nativeToUdt(L, G.name().toString());
      }
      if (te === v.xdr.ScSpecType.scSpecTypeOption().value) {
        var K = j.option();
        return L === void 0 ? v.xdr.ScVal.scvVoid() : this.nativeToScVal(L, K.valueType());
      }
      switch (s(L)) {
        case "object": {
          var J, B;
          if (L === null) switch (te) {
            case v.xdr.ScSpecType.scSpecTypeVoid().value:
              return v.xdr.ScVal.scvVoid();
            default:
              throw new TypeError("Type ".concat(j, " was not void, but value was null"));
          }
          if (L instanceof v.xdr.ScVal) return L;
          if (L instanceof v.Address) {
            if (j.switch().value !== v.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(j, " was not address, but value was Address"));
            return L.toScVal();
          }
          if (L instanceof v.Contract) {
            if (j.switch().value !== v.xdr.ScSpecType.scSpecTypeAddress().value) throw new TypeError("Type ".concat(j, " was not address, but value was Address"));
            return L.address().toScVal();
          }
          if (L instanceof Uint8Array || Buffer.isBuffer(L)) {
            var Z = Uint8Array.from(L);
            switch (te) {
              case v.xdr.ScSpecType.scSpecTypeBytesN().value: {
                var ie = j.bytesN();
                if (Z.length !== ie.n()) throw new TypeError("expected ".concat(ie.n(), " bytes, but got ").concat(Z.length));
                return v.xdr.ScVal.scvBytes(Z);
              }
              case v.xdr.ScSpecType.scSpecTypeBytes().value:
                return v.xdr.ScVal.scvBytes(Z);
              default:
                throw new TypeError("invalid type (".concat(j, ") specified for Bytes and BytesN"));
            }
          }
          if (Array.isArray(L)) switch (te) {
            case v.xdr.ScSpecType.scSpecTypeVec().value: {
              var $ = j.vec(), oe = $.elementType();
              return v.xdr.ScVal.scvVec(L.map(function(O) {
                return z.nativeToScVal(O, oe);
              }));
            }
            case v.xdr.ScSpecType.scSpecTypeTuple().value: {
              var ce = j.tuple(), ye = ce.valueTypes();
              if (L.length !== ye.length) throw new TypeError("Tuple expects ".concat(ye.length, " values, but ").concat(L.length, " were provided"));
              return v.xdr.ScVal.scvVec(L.map(function(O, V) {
                return z.nativeToScVal(O, ye[V]);
              }));
            }
            case v.xdr.ScSpecType.scSpecTypeMap().value: {
              var ae = j.map(), ue = ae.keyType(), ne = ae.valueType();
              return v.xdr.ScVal.scvMap(L.map(function(O) {
                var V = z.nativeToScVal(O[0], ue), N = z.nativeToScVal(O[1], ne);
                return new v.xdr.ScMapEntry({ key: V, val: N });
              }));
            }
            default:
              throw new TypeError("Type ".concat(j, " was not vec, but value was Array"));
          }
          if (L.constructor === Map) {
            if (te !== v.xdr.ScSpecType.scSpecTypeMap().value) throw new TypeError("Type ".concat(j, " was not map, but value was Map"));
            for (var ge = j.map(), Te = L, pe = [], Oe = Te.entries(), xe = Oe.next(); !xe.done; ) {
              var Ve = f(xe.value, 2), _e = Ve[0], Be = Ve[1], Qe = this.nativeToScVal(_e, ge.keyType()), ee = this.nativeToScVal(Be, ge.valueType());
              pe.push(new v.xdr.ScMapEntry({ key: Qe, val: ee })), xe = Oe.next();
            }
            return v.xdr.ScVal.scvMap(pe);
          }
          if (((J = (B = L.constructor) === null || B === void 0 ? void 0 : B.name) !== null && J !== void 0 ? J : "") !== "Object") {
            var P;
            throw new TypeError("cannot interpret ".concat((P = L.constructor) === null || P === void 0 ? void 0 : P.name, " value as ScVal (").concat(JSON.stringify(L), ")"));
          }
          throw new TypeError("Received object ".concat(L, "  did not match the provided type ").concat(j));
        }
        case "number":
        case "bigint":
          switch (te) {
            case v.xdr.ScSpecType.scSpecTypeU32().value:
              return v.xdr.ScVal.scvU32(L);
            case v.xdr.ScSpecType.scSpecTypeI32().value:
              return v.xdr.ScVal.scvI32(L);
            case v.xdr.ScSpecType.scSpecTypeU64().value:
            case v.xdr.ScSpecType.scSpecTypeI64().value:
            case v.xdr.ScSpecType.scSpecTypeU128().value:
            case v.xdr.ScSpecType.scSpecTypeI128().value:
            case v.xdr.ScSpecType.scSpecTypeU256().value:
            case v.xdr.ScSpecType.scSpecTypeI256().value: {
              var x = Y.name.substring(10).toLowerCase();
              return new v.XdrLargeInt(x, L).toScVal();
            }
            default:
              throw new TypeError("invalid type (".concat(j, ") specified for integer"));
          }
        case "string":
          return R(L, Y);
        case "boolean": {
          if (te !== v.xdr.ScSpecType.scSpecTypeBool().value) throw TypeError("Type ".concat(j, " was not bool, but value was bool"));
          return v.xdr.ScVal.scvBool(L);
        }
        case "undefined": {
          if (!j) return v.xdr.ScVal.scvVoid();
          switch (te) {
            case v.xdr.ScSpecType.scSpecTypeVoid().value:
            case v.xdr.ScSpecType.scSpecTypeOption().value:
              return v.xdr.ScVal.scvVoid();
            default:
              throw new TypeError("Type ".concat(j, " was not void, but value was undefined"));
          }
        }
        case "function":
          return this.nativeToScVal(L(), j);
        default:
          throw new TypeError("failed to convert typeof ".concat(s(L), " (").concat(L, ")"));
      }
    } }, { key: "nativeToUdt", value: function(L, j) {
      var z = this.findEntry(j);
      switch (z.switch()) {
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          if (typeof L != "number") throw new TypeError("expected number for enum ".concat(j, ", but got ").concat(s(L)));
          return this.nativeToEnum(L, z.udtEnumV0());
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.nativeToStruct(L, z.udtStructV0());
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.nativeToUnion(L, z.udtUnionV0());
        default:
          throw new Error("failed to parse udt ".concat(j));
      }
    } }, { key: "nativeToUnion", value: function(L, j) {
      var z = this, Y = L.tag, te = j.cases().find(function(B) {
        var Z = B.value().name().toString();
        return Z === Y;
      });
      if (!te) throw new TypeError("no such enum entry: ".concat(Y, " in ").concat(j));
      var G = v.xdr.ScVal.scvSymbol(Y);
      switch (te.switch()) {
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0():
          return v.xdr.ScVal.scvVec([G]);
        case v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
          var K = te.tupleCase().type();
          if (Array.isArray(L.values)) {
            if (L.values.length !== K.length) throw new TypeError("union ".concat(j, " expects ").concat(K.length, " values, but got ").concat(L.values.length));
            var J = L.values.map(function(B, Z) {
              return z.nativeToScVal(B, K[Z]);
            });
            return J.unshift(G), v.xdr.ScVal.scvVec(J);
          }
          throw new Error("failed to parse union case ".concat(te, " with ").concat(L));
        }
        default:
          throw new Error("failed to parse union ".concat(j, " with ").concat(L));
      }
    } }, { key: "nativeToStruct", value: function(L, j) {
      var z = this, Y = j.fields();
      if (Y.some(b)) {
        if (!Y.every(b)) throw new Error("mixed numeric and non-numeric field names are not allowed");
        return v.xdr.ScVal.scvVec(Y.map(function(te, G) {
          return z.nativeToScVal(L[G], Y[G].type());
        }));
      }
      return v.xdr.ScVal.scvMap(Y.map(function(te) {
        var G = te.name().toString();
        return new v.xdr.ScMapEntry({ key: z.nativeToScVal(G, v.xdr.ScSpecTypeDef.scSpecTypeSymbol()), val: z.nativeToScVal(L[G], te.type()) });
      }));
    } }, { key: "nativeToEnum", value: function(L, j) {
      if (j.cases().some(function(z) {
        return z.value() === L;
      })) return v.xdr.ScVal.scvU32(L);
      throw new TypeError("no such enum entry: ".concat(L, " in ").concat(j));
    } }, { key: "scValStrToNative", value: function(L, j) {
      return this.scValToNative(v.xdr.ScVal.fromXDR(L, "base64"), j);
    } }, { key: "scValToNative", value: function(L, j) {
      var z = this, Y = j.switch(), te = Y.value;
      if (te === v.xdr.ScSpecType.scSpecTypeUdt().value) return this.scValUdtToNative(L, j.udt());
      switch (L.switch().value) {
        case v.xdr.ScValType.scvVoid().value:
          return;
        case v.xdr.ScValType.scvU64().value:
        case v.xdr.ScValType.scvI64().value:
        case v.xdr.ScValType.scvU128().value:
        case v.xdr.ScValType.scvI128().value:
        case v.xdr.ScValType.scvU256().value:
        case v.xdr.ScValType.scvI256().value:
          return (0, v.scValToBigInt)(L);
        case v.xdr.ScValType.scvVec().value: {
          if (te === v.xdr.ScSpecType.scSpecTypeVec().value) {
            var G, K = j.vec();
            return ((G = L.vec()) !== null && G !== void 0 ? G : []).map(function(ne) {
              return z.scValToNative(ne, K.elementType());
            });
          }
          if (te === v.xdr.ScSpecType.scSpecTypeTuple().value) {
            var J, B = j.tuple(), Z = B.valueTypes();
            return ((J = L.vec()) !== null && J !== void 0 ? J : []).map(function(ne, ge) {
              return z.scValToNative(ne, Z[ge]);
            });
          }
          throw new TypeError("Type ".concat(j, " was not vec, but ").concat(L, " is"));
        }
        case v.xdr.ScValType.scvAddress().value:
          return v.Address.fromScVal(L).toString();
        case v.xdr.ScValType.scvMap().value: {
          var ie, $ = (ie = L.map()) !== null && ie !== void 0 ? ie : [];
          if (te === v.xdr.ScSpecType.scSpecTypeMap().value) {
            var oe = j.map(), ce = oe.keyType(), ye = oe.valueType(), ae = $.map(function(ne) {
              return [z.scValToNative(ne.key(), ce), z.scValToNative(ne.val(), ye)];
            });
            return ae;
          }
          throw new TypeError("ScSpecType ".concat(Y.name, " was not map, but ").concat(JSON.stringify(L, null, 2), " is"));
        }
        case v.xdr.ScValType.scvBool().value:
        case v.xdr.ScValType.scvU32().value:
        case v.xdr.ScValType.scvI32().value:
        case v.xdr.ScValType.scvBytes().value:
          return L.value();
        case v.xdr.ScValType.scvString().value:
        case v.xdr.ScValType.scvSymbol().value: {
          var ue;
          if (te !== v.xdr.ScSpecType.scSpecTypeString().value && te !== v.xdr.ScSpecType.scSpecTypeSymbol().value) throw new Error("ScSpecType ".concat(Y.name, " was not string or symbol, but ").concat(JSON.stringify(L, null, 2), " is"));
          return (ue = L.value()) === null || ue === void 0 ? void 0 : ue.toString();
        }
        case v.xdr.ScValType.scvTimepoint().value:
        case v.xdr.ScValType.scvDuration().value:
          return (0, v.scValToBigInt)(v.xdr.ScVal.scvU64(L.u64()));
        default:
          throw new TypeError("failed to convert ".concat(JSON.stringify(L, null, 2), " to native type from type ").concat(Y.name));
      }
    } }, { key: "scValUdtToNative", value: function(L, j) {
      var z = this.findEntry(j.name().toString());
      switch (z.switch()) {
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
          return this.enumToNative(L);
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
          return this.structToNative(L, z.udtStructV0());
        case v.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
          return this.unionToNative(L, z.udtUnionV0());
        default:
          throw new Error("failed to parse udt ".concat(j.name().toString(), ": ").concat(z));
      }
    } }, { key: "unionToNative", value: function(L, j) {
      var z = this, Y = L.vec();
      if (!Y) throw new Error("".concat(JSON.stringify(L, null, 2), " is not a vec"));
      if (Y.length === 0 && j.cases.length !== 0) throw new Error("".concat(L, " has length 0, but the there are at least one case in the union"));
      var te = Y[0].sym().toString();
      if (Y[0].switch().value !== v.xdr.ScValType.scvSymbol().value) throw new Error("{vec[0]} is not a symbol");
      var G = j.cases().find(E(te));
      if (!G) throw new Error("failed to find entry ".concat(te, " in union {udt.name().toString()}"));
      var K = { tag: te };
      if (G.switch().value === v.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
        var J = G.tupleCase(), B = J.type(), Z = B.map(function(ie, $) {
          return z.scValToNative(Y[$ + 1], ie);
        });
        K.values = Z;
      }
      return K;
    } }, { key: "structToNative", value: function(L, j) {
      var z = this, Y, te = {}, G = j.fields();
      if (G.some(b)) {
        var K, J = (K = L.vec()) === null || K === void 0 ? void 0 : K.map(function(B, Z) {
          return z.scValToNative(B, G[Z].type());
        });
        return J;
      }
      return (Y = L.map()) === null || Y === void 0 || Y.forEach(function(B, Z) {
        var ie = G[Z];
        te[ie.name().toString()] = z.scValToNative(B.val(), ie.type());
      }), te;
    } }, { key: "enumToNative", value: function(L) {
      if (L.switch().value !== v.xdr.ScValType.scvU32().value) throw new Error("Enum must have a u32 value");
      var j = L.u32();
      return j;
    } }, { key: "errorCases", value: function() {
      return this.entries.filter(function(L) {
        return L.switch().value === v.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
      }).flatMap(function(L) {
        return L.value().cases();
      });
    } }, { key: "jsonSchema", value: function(L) {
      var j = {};
      this.entries.forEach(function(Y) {
        switch (Y.switch().value) {
          case v.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
            var te = Y.udtEnumV0();
            j[te.name().toString()] = d(te);
            break;
          }
          case v.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
            var G = Y.udtStructV0();
            j[G.name().toString()] = q(G);
            break;
          }
          case v.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
            var K = Y.udtUnionV0();
            j[K.name().toString()] = H(K);
            break;
          }
          case v.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
            var J = Y.functionV0(), B = J.name().toString(), Z = D(J), ie = Z.input;
            j[B] = ie;
            break;
          }
          case v.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value:
        }
      });
      var z = { $schema: "http://json-schema.org/draft-07/schema#", definitions: i(i({}, k), j) };
      return L && (z.$ref = "#/definitions/".concat(L)), z;
    } }]);
  }(), Cs;
}
var Fd;
function EE() {
  if (Fd) return Ps;
  Fd = 1;
  function v(z) {
    "@babel/helpers - typeof";
    return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Y) {
      return typeof Y;
    } : function(Y) {
      return Y && typeof Symbol == "function" && Y.constructor === Symbol && Y !== Symbol.prototype ? "symbol" : typeof Y;
    }, v(z);
  }
  Object.defineProperty(Ps, "__esModule", { value: true }), Ps.Client = void 0;
  var e = ko(), n = $m(), i = Ac(), s = Xm(), y = yf(), t = ["method"], o = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
  function u() {
    u = function() {
      return Y;
    };
    var z, Y = {}, te = Object.prototype, G = te.hasOwnProperty, K = Object.defineProperty || function(p, A, U) {
      p[A] = U.value;
    }, J = typeof Symbol == "function" ? Symbol : {}, B = J.iterator || "@@iterator", Z = J.asyncIterator || "@@asyncIterator", ie = J.toStringTag || "@@toStringTag";
    function $(p, A, U) {
      return Object.defineProperty(p, A, { value: U, enumerable: true, configurable: true, writable: true }), p[A];
    }
    try {
      $({}, "");
    } catch {
      $ = function(U, Q, se) {
        return U[Q] = se;
      };
    }
    function oe(p, A, U, Q) {
      var se = A && A.prototype instanceof Te ? A : Te, X = Object.create(se.prototype), de = new N(Q || []);
      return K(X, "_invoke", { value: P(p, U, de) }), X;
    }
    function ce(p, A, U) {
      try {
        return { type: "normal", arg: p.call(A, U) };
      } catch (Q) {
        return { type: "throw", arg: Q };
      }
    }
    Y.wrap = oe;
    var ye = "suspendedStart", ae = "suspendedYield", ue = "executing", ne = "completed", ge = {};
    function Te() {
    }
    function pe() {
    }
    function Oe() {
    }
    var xe = {};
    $(xe, B, function() {
      return this;
    });
    var Ve = Object.getPrototypeOf, _e = Ve && Ve(Ve(C([])));
    _e && _e !== te && G.call(_e, B) && (xe = _e);
    var Be = Oe.prototype = Te.prototype = Object.create(xe);
    function Qe(p) {
      ["next", "throw", "return"].forEach(function(A) {
        $(p, A, function(U) {
          return this._invoke(A, U);
        });
      });
    }
    function ee(p, A) {
      function U(se, X, de, tt) {
        var Ne = ce(p[se], p, X);
        if (Ne.type !== "throw") {
          var ut = Ne.arg, Ze = ut.value;
          return Ze && v(Ze) == "object" && G.call(Ze, "__await") ? A.resolve(Ze.__await).then(function(Et) {
            U("next", Et, de, tt);
          }, function(Et) {
            U("throw", Et, de, tt);
          }) : A.resolve(Ze).then(function(Et) {
            ut.value = Et, de(ut);
          }, function(Et) {
            return U("throw", Et, de, tt);
          });
        }
        tt(Ne.arg);
      }
      var Q;
      K(this, "_invoke", { value: function(X, de) {
        function tt() {
          return new A(function(Ne, ut) {
            U(X, de, Ne, ut);
          });
        }
        return Q = Q ? Q.then(tt, tt) : tt();
      } });
    }
    function P(p, A, U) {
      var Q = ye;
      return function(se, X) {
        if (Q === ue) throw Error("Generator is already running");
        if (Q === ne) {
          if (se === "throw") throw X;
          return { value: z, done: true };
        }
        for (U.method = se, U.arg = X; ; ) {
          var de = U.delegate;
          if (de) {
            var tt = x(de, U);
            if (tt) {
              if (tt === ge) continue;
              return tt;
            }
          }
          if (U.method === "next") U.sent = U._sent = U.arg;
          else if (U.method === "throw") {
            if (Q === ye) throw Q = ne, U.arg;
            U.dispatchException(U.arg);
          } else U.method === "return" && U.abrupt("return", U.arg);
          Q = ue;
          var Ne = ce(p, A, U);
          if (Ne.type === "normal") {
            if (Q = U.done ? ne : ae, Ne.arg === ge) continue;
            return { value: Ne.arg, done: U.done };
          }
          Ne.type === "throw" && (Q = ne, U.method = "throw", U.arg = Ne.arg);
        }
      };
    }
    function x(p, A) {
      var U = A.method, Q = p.iterator[U];
      if (Q === z) return A.delegate = null, U === "throw" && p.iterator.return && (A.method = "return", A.arg = z, x(p, A), A.method === "throw") || U !== "return" && (A.method = "throw", A.arg = new TypeError("The iterator does not provide a '" + U + "' method")), ge;
      var se = ce(Q, p.iterator, A.arg);
      if (se.type === "throw") return A.method = "throw", A.arg = se.arg, A.delegate = null, ge;
      var X = se.arg;
      return X ? X.done ? (A[p.resultName] = X.value, A.next = p.nextLoc, A.method !== "return" && (A.method = "next", A.arg = z), A.delegate = null, ge) : X : (A.method = "throw", A.arg = new TypeError("iterator result is not an object"), A.delegate = null, ge);
    }
    function O(p) {
      var A = { tryLoc: p[0] };
      1 in p && (A.catchLoc = p[1]), 2 in p && (A.finallyLoc = p[2], A.afterLoc = p[3]), this.tryEntries.push(A);
    }
    function V(p) {
      var A = p.completion || {};
      A.type = "normal", delete A.arg, p.completion = A;
    }
    function N(p) {
      this.tryEntries = [{ tryLoc: "root" }], p.forEach(O, this), this.reset(true);
    }
    function C(p) {
      if (p || p === "") {
        var A = p[B];
        if (A) return A.call(p);
        if (typeof p.next == "function") return p;
        if (!isNaN(p.length)) {
          var U = -1, Q = function se() {
            for (; ++U < p.length; ) if (G.call(p, U)) return se.value = p[U], se.done = false, se;
            return se.value = z, se.done = true, se;
          };
          return Q.next = Q;
        }
      }
      throw new TypeError(v(p) + " is not iterable");
    }
    return pe.prototype = Oe, K(Be, "constructor", { value: Oe, configurable: true }), K(Oe, "constructor", { value: pe, configurable: true }), pe.displayName = $(Oe, ie, "GeneratorFunction"), Y.isGeneratorFunction = function(p) {
      var A = typeof p == "function" && p.constructor;
      return !!A && (A === pe || (A.displayName || A.name) === "GeneratorFunction");
    }, Y.mark = function(p) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(p, Oe) : (p.__proto__ = Oe, $(p, ie, "GeneratorFunction")), p.prototype = Object.create(Be), p;
    }, Y.awrap = function(p) {
      return { __await: p };
    }, Qe(ee.prototype), $(ee.prototype, Z, function() {
      return this;
    }), Y.AsyncIterator = ee, Y.async = function(p, A, U, Q, se) {
      se === void 0 && (se = Promise);
      var X = new ee(oe(p, A, U, Q), se);
      return Y.isGeneratorFunction(A) ? X : X.next().then(function(de) {
        return de.done ? de.value : X.next();
      });
    }, Qe(Be), $(Be, ie, "Generator"), $(Be, B, function() {
      return this;
    }), $(Be, "toString", function() {
      return "[object Generator]";
    }), Y.keys = function(p) {
      var A = Object(p), U = [];
      for (var Q in A) U.push(Q);
      return U.reverse(), function se() {
        for (; U.length; ) {
          var X = U.pop();
          if (X in A) return se.value = X, se.done = false, se;
        }
        return se.done = true, se;
      };
    }, Y.values = C, N.prototype = { constructor: N, reset: function(A) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = z, this.done = false, this.delegate = null, this.method = "next", this.arg = z, this.tryEntries.forEach(V), !A) for (var U in this) U.charAt(0) === "t" && G.call(this, U) && !isNaN(+U.slice(1)) && (this[U] = z);
    }, stop: function() {
      this.done = true;
      var A = this.tryEntries[0].completion;
      if (A.type === "throw") throw A.arg;
      return this.rval;
    }, dispatchException: function(A) {
      if (this.done) throw A;
      var U = this;
      function Q(ut, Ze) {
        return de.type = "throw", de.arg = A, U.next = ut, Ze && (U.method = "next", U.arg = z), !!Ze;
      }
      for (var se = this.tryEntries.length - 1; se >= 0; --se) {
        var X = this.tryEntries[se], de = X.completion;
        if (X.tryLoc === "root") return Q("end");
        if (X.tryLoc <= this.prev) {
          var tt = G.call(X, "catchLoc"), Ne = G.call(X, "finallyLoc");
          if (tt && Ne) {
            if (this.prev < X.catchLoc) return Q(X.catchLoc, true);
            if (this.prev < X.finallyLoc) return Q(X.finallyLoc);
          } else if (tt) {
            if (this.prev < X.catchLoc) return Q(X.catchLoc, true);
          } else {
            if (!Ne) throw Error("try statement without catch or finally");
            if (this.prev < X.finallyLoc) return Q(X.finallyLoc);
          }
        }
      }
    }, abrupt: function(A, U) {
      for (var Q = this.tryEntries.length - 1; Q >= 0; --Q) {
        var se = this.tryEntries[Q];
        if (se.tryLoc <= this.prev && G.call(se, "finallyLoc") && this.prev < se.finallyLoc) {
          var X = se;
          break;
        }
      }
      X && (A === "break" || A === "continue") && X.tryLoc <= U && U <= X.finallyLoc && (X = null);
      var de = X ? X.completion : {};
      return de.type = A, de.arg = U, X ? (this.method = "next", this.next = X.finallyLoc, ge) : this.complete(de);
    }, complete: function(A, U) {
      if (A.type === "throw") throw A.arg;
      return A.type === "break" || A.type === "continue" ? this.next = A.arg : A.type === "return" ? (this.rval = this.arg = A.arg, this.method = "return", this.next = "end") : A.type === "normal" && U && (this.next = U), ge;
    }, finish: function(A) {
      for (var U = this.tryEntries.length - 1; U >= 0; --U) {
        var Q = this.tryEntries[U];
        if (Q.finallyLoc === A) return this.complete(Q.completion, Q.afterLoc), V(Q), ge;
      }
    }, catch: function(A) {
      for (var U = this.tryEntries.length - 1; U >= 0; --U) {
        var Q = this.tryEntries[U];
        if (Q.tryLoc === A) {
          var se = Q.completion;
          if (se.type === "throw") {
            var X = se.arg;
            V(Q);
          }
          return X;
        }
      }
      throw Error("illegal catch attempt");
    }, delegateYield: function(A, U, Q) {
      return this.delegate = { iterator: C(A), resultName: U, nextLoc: Q }, this.method === "next" && (this.arg = z), ge;
    } }, Y;
  }
  function c(z, Y) {
    var te = Object.keys(z);
    if (Object.getOwnPropertySymbols) {
      var G = Object.getOwnPropertySymbols(z);
      Y && (G = G.filter(function(K) {
        return Object.getOwnPropertyDescriptor(z, K).enumerable;
      })), te.push.apply(te, G);
    }
    return te;
  }
  function h(z) {
    for (var Y = 1; Y < arguments.length; Y++) {
      var te = arguments[Y] != null ? arguments[Y] : {};
      Y % 2 ? c(Object(te), true).forEach(function(G) {
        l(z, G, te[G]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(z, Object.getOwnPropertyDescriptors(te)) : c(Object(te)).forEach(function(G) {
        Object.defineProperty(z, G, Object.getOwnPropertyDescriptor(te, G));
      });
    }
    return z;
  }
  function f(z, Y) {
    if (z == null) return {};
    var te, G, K = r(z, Y);
    if (Object.getOwnPropertySymbols) {
      var J = Object.getOwnPropertySymbols(z);
      for (G = 0; G < J.length; G++) te = J[G], Y.indexOf(te) === -1 && {}.propertyIsEnumerable.call(z, te) && (K[te] = z[te]);
    }
    return K;
  }
  function r(z, Y) {
    if (z == null) return {};
    var te = {};
    for (var G in z) if ({}.hasOwnProperty.call(z, G)) {
      if (Y.indexOf(G) !== -1) continue;
      te[G] = z[G];
    }
    return te;
  }
  function m(z, Y) {
    if (!(z instanceof Y)) throw new TypeError("Cannot call a class as a function");
  }
  function g(z, Y) {
    for (var te = 0; te < Y.length; te++) {
      var G = Y[te];
      G.enumerable = G.enumerable || false, G.configurable = true, "value" in G && (G.writable = true), Object.defineProperty(z, d(G.key), G);
    }
  }
  function a(z, Y, te) {
    return te && g(z, te), Object.defineProperty(z, "prototype", { writable: false }), z;
  }
  function l(z, Y, te) {
    return (Y = d(Y)) in z ? Object.defineProperty(z, Y, { value: te, enumerable: true, configurable: true, writable: true }) : z[Y] = te, z;
  }
  function d(z) {
    var Y = b(z, "string");
    return v(Y) == "symbol" ? Y : Y + "";
  }
  function b(z, Y) {
    if (v(z) != "object" || !z) return z;
    var te = z[Symbol.toPrimitive];
    if (te !== void 0) {
      var G = te.call(z, Y);
      if (v(G) != "object") return G;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Y === "string" ? String : Number)(z);
  }
  function S(z) {
    return w(z) || k(z) || R(z) || E();
  }
  function E() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function R(z, Y) {
    if (z) {
      if (typeof z == "string") return F(z, Y);
      var te = {}.toString.call(z).slice(8, -1);
      return te === "Object" && z.constructor && (te = z.constructor.name), te === "Map" || te === "Set" ? Array.from(z) : te === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(te) ? F(z, Y) : void 0;
    }
  }
  function k(z) {
    if (typeof Symbol < "u" && z[Symbol.iterator] != null || z["@@iterator"] != null) return Array.from(z);
  }
  function w(z) {
    if (Array.isArray(z)) return F(z);
  }
  function F(z, Y) {
    (Y == null || Y > z.length) && (Y = z.length);
    for (var te = 0, G = Array(Y); te < Y; te++) G[te] = z[te];
    return G;
  }
  function I(z, Y, te, G, K, J, B) {
    try {
      var Z = z[J](B), ie = Z.value;
    } catch ($) {
      return void te($);
    }
    Z.done ? Y(ie) : Promise.resolve(ie).then(G, K);
  }
  function q(z) {
    return function() {
      var Y = this, te = arguments;
      return new Promise(function(G, K) {
        var J = z.apply(Y, te);
        function B(ie) {
          I(J, G, K, B, Z, "next", ie);
        }
        function Z(ie) {
          I(J, G, K, B, Z, "throw", ie);
        }
        B(void 0);
      });
    };
  }
  var D = "__constructor";
  function H(z) {
    return _.apply(this, arguments);
  }
  function _() {
    return _ = q(u().mark(function z(Y) {
      var te, G, K, J, B, Z;
      return u().wrap(function($) {
        for (; ; ) switch ($.prev = $.next) {
          case 0:
            return $.prev = 0, $.next = 3, WebAssembly.compile(Y);
          case 3:
            G = $.sent, te = WebAssembly.Module.customSections(G, "contractspecv0"), $.next = 11;
            break;
          case 7:
            $.prev = 7, $.t0 = $.catch(0), K = T(Y), te = K.get("contractspecv0");
          case 11:
            if (!(!te || te.length === 0)) {
              $.next = 13;
              break;
            }
            throw new Error("Could not obtain contract spec from wasm");
          case 13:
            return J = Buffer.from(te[0]), B = (0, y.processSpecEntryStream)(J), Z = new n.Spec(B), $.abrupt("return", Z);
          case 17:
          case "end":
            return $.stop();
        }
      }, z, null, [[0, 7]]);
    })), _.apply(this, arguments);
  }
  function T(z) {
    var Y = /* @__PURE__ */ new Map(), te = z.buffer.slice(z.byteOffset, z.byteOffset + z.byteLength), G = 0, K = function(ue) {
      if (G + ue > z.byteLength) throw new Error("Buffer overflow");
      var ne = new Uint8Array(te, G, ue);
      return G += ue, ne;
    };
    if (S(K(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
    if (S(K(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
    for (; G < z.byteLength; ) {
      var J = K(1)[0], B = ye(), Z = G;
      if (J === 0) {
        var ie = ye();
        if (ie === 0 || G + ie > Z + B) continue;
        var $ = K(ie), oe = K(B - (G - Z));
        try {
          var ce = new TextDecoder("utf-8", { fatal: true }).decode($);
          oe.length > 0 && Y.set(ce, (Y.get(ce) || []).concat(oe));
        } catch {
        }
      } else G += B;
    }
    function ye() {
      for (var ae = 0, ue = 0; ; ) {
        var ne = K(1)[0];
        if (ae |= (ne & 127) << ue, (ne & 128) === 0) break;
        if ((ue += 7) >= 32) throw new Error("Invalid WASM value");
      }
      return ae >>> 0;
    }
    return Y;
  }
  function L(z, Y) {
    return j.apply(this, arguments);
  }
  function j() {
    return j = q(u().mark(function z(Y, te) {
      var G, K, J, B, Z, ie, $ = arguments;
      return u().wrap(function(ce) {
        for (; ; ) switch (ce.prev = ce.next) {
          case 0:
            if (G = $.length > 2 && $[2] !== void 0 ? $[2] : "hex", !(!te || !te.rpcUrl)) {
              ce.next = 3;
              break;
            }
            throw new TypeError("options must contain rpcUrl");
          case 3:
            return K = te.rpcUrl, J = te.allowHttp, B = { allowHttp: J }, Z = new i.Server(K, B), ce.next = 8, Z.getContractWasmByHash(Y, G);
          case 8:
            return ie = ce.sent, ce.abrupt("return", H(ie));
          case 10:
          case "end":
            return ce.stop();
        }
      }, z);
    })), j.apply(this, arguments);
  }
  return Ps.Client = function() {
    function z(Y, te) {
      var G = this;
      m(this, z), l(this, "txFromJSON", function(K) {
        var J = JSON.parse(K), B = J.method, Z = f(J, t);
        return s.AssembledTransaction.fromJSON(h(h({}, G.options), {}, { method: B, parseResultXdr: function($) {
          return G.spec.funcResToNative(B, $);
        } }), Z);
      }), l(this, "txFromXDR", function(K) {
        return s.AssembledTransaction.fromXDR(G.options, K, G.spec);
      }), this.spec = Y, this.options = te, this.spec.funcs().forEach(function(K) {
        var J = K.name().toString();
        if (J !== D) {
          var B = function(ie, $) {
            return s.AssembledTransaction.build(h(h(h({ method: J, args: ie && Y.funcArgsToScVals(J, ie) }, te), $), {}, { errorTypes: Y.errorCases().reduce(function(oe, ce) {
              return h(h({}, oe), {}, l({}, ce.value(), { message: ce.doc().toString() }));
            }, {}), parseResultXdr: function(ce) {
              return Y.funcResToNative(J, ce);
            } }));
          };
          G[J] = Y.getFunc(J).inputs().length === 0 ? function(Z) {
            return B(void 0, Z);
          } : B;
        }
      });
    }
    return a(z, null, [{ key: "deploy", value: function() {
      var Y = q(u().mark(function G(K, J) {
        var B, Z, ie, $, oe, ce, ye, ae, ue;
        return u().wrap(function(ge) {
          for (; ; ) switch (ge.prev = ge.next) {
            case 0:
              return B = J.wasmHash, Z = J.salt, ie = J.format, $ = J.fee, oe = J.timeoutInSeconds, ce = J.simulate, ye = f(J, o), ge.next = 3, L(B, ye, ie);
            case 3:
              return ae = ge.sent, ue = e.Operation.createCustomContract({ address: new e.Address(J.address || J.publicKey), wasmHash: typeof B == "string" ? Buffer.from(B, ie ?? "hex") : B, salt: Z, constructorArgs: K ? ae.funcArgsToScVals(D, K) : [] }), ge.abrupt("return", s.AssembledTransaction.buildWithOp(ue, h(h({ fee: $, timeoutInSeconds: oe, simulate: ce }, ye), {}, { contractId: "ignored", method: D, parseResultXdr: function(pe) {
                return new z(ae, h(h({}, ye), {}, { contractId: e.Address.fromScVal(pe).toString() }));
              } })));
            case 6:
            case "end":
              return ge.stop();
          }
        }, G);
      }));
      function te(G, K) {
        return Y.apply(this, arguments);
      }
      return te;
    }() }, { key: "fromWasmHash", value: function() {
      var Y = q(u().mark(function G(K, J) {
        var B, Z, ie, $, oe, ce, ye = arguments;
        return u().wrap(function(ue) {
          for (; ; ) switch (ue.prev = ue.next) {
            case 0:
              if (B = ye.length > 2 && ye[2] !== void 0 ? ye[2] : "hex", !(!J || !J.rpcUrl)) {
                ue.next = 3;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 3:
              return Z = J.rpcUrl, ie = J.allowHttp, $ = { allowHttp: ie }, oe = new i.Server(Z, $), ue.next = 8, oe.getContractWasmByHash(K, B);
            case 8:
              return ce = ue.sent, ue.abrupt("return", z.fromWasm(ce, J));
            case 10:
            case "end":
              return ue.stop();
          }
        }, G);
      }));
      function te(G, K) {
        return Y.apply(this, arguments);
      }
      return te;
    }() }, { key: "fromWasm", value: function() {
      var Y = q(u().mark(function G(K, J) {
        var B;
        return u().wrap(function(ie) {
          for (; ; ) switch (ie.prev = ie.next) {
            case 0:
              return ie.next = 2, H(K);
            case 2:
              return B = ie.sent, ie.abrupt("return", new z(B, J));
            case 4:
            case "end":
              return ie.stop();
          }
        }, G);
      }));
      function te(G, K) {
        return Y.apply(this, arguments);
      }
      return te;
    }() }, { key: "from", value: function() {
      var Y = q(u().mark(function G(K) {
        var J, B, Z, ie, $, oe;
        return u().wrap(function(ye) {
          for (; ; ) switch (ye.prev = ye.next) {
            case 0:
              if (!(!K || !K.rpcUrl || !K.contractId)) {
                ye.next = 2;
                break;
              }
              throw new TypeError("options must contain rpcUrl and contractId");
            case 2:
              return J = K.rpcUrl, B = K.contractId, Z = K.allowHttp, ie = { allowHttp: Z }, $ = new i.Server(J, ie), ye.next = 7, $.getContractWasmByContractId(B);
            case 7:
              return oe = ye.sent, ye.abrupt("return", z.fromWasm(oe, K));
            case 9:
            case "end":
              return ye.stop();
          }
        }, G);
      }));
      function te(G) {
        return Y.apply(this, arguments);
      }
      return te;
    }() }]);
  }(), Ps;
}
var Ud;
function AE() {
  return Ud || (Ud = 1, function(v) {
    Object.defineProperty(v, "__esModule", { value: true });
    var e = Xm();
    Object.keys(e).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === e[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return e[u];
      } });
    });
    var n = _E();
    Object.keys(n).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === n[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return n[u];
      } });
    });
    var i = EE();
    Object.keys(i).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === i[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return i[u];
      } });
    });
    var s = mf();
    Object.keys(s).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === s[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return s[u];
      } });
    });
    var y = Km();
    Object.keys(y).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === y[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return y[u];
      } });
    });
    var t = $m();
    Object.keys(t).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === t[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return t[u];
      } });
    });
    var o = kc();
    Object.keys(o).forEach(function(u) {
      u === "default" || u === "__esModule" || u in v && v[u] === o[u] || Object.defineProperty(v, u, { enumerable: true, get: function() {
        return o[u];
      } });
    });
  }(Bl)), Bl;
}
var pc = AE();
typeof window < "u" && (window.Buffer = window.Buffer || $l.Buffer);
class xE extends pc.Client {
  constructor(e) {
    super(new pc.Spec(["AAAAAgAAAAAAAAAAAAAACFVzZXJEYXRhAAAABwAAAAAAAAAAAAAABVRva2VuAAAAAAAAAQAAAAAAAAAHQmFsYW5jZQAAAAABAAAAEwAAAAEAAAAAAAAABVNjb3JlAAAAAAAAAQAAABMAAAABAAAAAAAAAAlUdXJuU2NvcmUAAAAAAAABAAAAEwAAAAEAAAAAAAAABERpY2UAAAABAAAAEwAAAAEAAAAAAAAABU1hdGNoAAAAAAAAAQAAABMAAAABAAAAAAAAAARUdXJuAAAAAQAAABM=", "AAAAAgAAAAAAAAAAAAAACUFkbWluRGF0YQAAAAAAAAIAAAAAAAAAAAAAAAVUb2tlbgAAAAAAAAAAAAAAAAAABUFkbWluAAAA", "AAAABAAAAAAAAAAAAAAABUVycm9yAAAAAAAABwAAAAAAAAANSW52YWxpZEFtb3VudAAAAAAAAAAAAAAAAAAADk5vdEluaXRpYWxpemVkAAAAAAABAAAAAAAAAA5BbHJlYWR5UGxheWluZwAAAAAAAgAAAAAAAAAHVG9vUG9vcgAAAAADAAAAAAAAAAtOb3RZb3VyVHVybgAAAAAEAAAAAAAAAApXcm9uZ01hdGNoAAAAAAAFAAAAAAAAAApCYWREaWVIb2xkAAAAAAAG", "AAAAAAAAAK0qIEluaXRpYWxpemVzIHRoZSBnYW1lLgogICAgICoKICAgICAqICMgQXJndW1lbnRzCiAgICAgKgogICAgICogLSBgYWRtaW5gIC0gVGhlIG93bmVyIG9mIHRoaXMgaW5zdGFuY2Ugb2YgdGhlIGdhbWUuCiAgICAgKiAtIGB0b2tlbmAgLSBUaGUgdG9rZW4gdXNlZCBmb3Igd2FnZXJzIGluIHRoZSBnYW1lLgAAAAAAAA1fX2NvbnN0cnVjdG9yAAAAAAAAAgAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAV0b2tlbgAAAAAAABMAAAAA", "AAAAAAAAAChSZXR1cm5zIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGdhbWUuAAAAB3ZlcnNpb24AAAAAAAAAAAEAAAAE", "AAAAAAAAADJSZXR1cm5zIHRoZSBjdXJyZW50IHdhZ2VyIC8gY29zdCB0byBwbGF5IHRoZSBnYW1lLgAAAAAABXdhZ2VyAAAAAAAAAAAAAAEAAAAL", "AAAAAAAAADxBbGxvd3MgdGhlIGFkbWluIHRvIHVwZ3JhZGUgdGhlIGNvbnRyYWN0IHRvIGEgbmV3IFdhc20gYmxvYi4AAAAHdXBncmFkZQAAAAABAAAAAAAAAA1uZXdfd2FzbV9oYXNoAAAAAAAD7gAAACAAAAAA", "AAAAAAAAAQQqIE9mZmVycyBhIHBzZXVkby1zaHV0ZG93biBtZWNoYW5pc20gdGhhdCBkZS1pbml0aWFsaXplcyBldmVyeXRoaW5nLgogICAgICoKICAgICAqIFdlIHNheSAicHNldWRvIiBiZWNhdXNlIHRoZSBjb250cmFjdCBjb250aW51ZXMgdG8gZXhpc3QsIGJ1dCBub25lIG9mIHRoZQogICAgICogbWV0aG9kcyB3aWxsIHdvcmsgYmVzaWRlcyBgd2l0aGRyYXdgLCBhbGxvd2luZyBwbGF5ZXJzIHRvIHB1bGwgb3V0CiAgICAgKiB0aGVpciBjdXJyZW50IGhvbGRpbmdzLgAAAAhzaHV0ZG93bgAAAAAAAAABAAAACw==", "AAAAAAAAAERSZXR1cm5zIHRoZSBjdXJyZW50IGJhbGFuY2UgYSBwbGF5ZXIgaG9sZHMgaW4gdGhlIGdhbWUgZm9yIHdhZ2VyaW5nLgAAAAdiYWxhbmNlAAAAAAEAAAAAAAAABnBsYXllcgAAAAAAEwAAAAEAAAAL", "AAAAAAAAAT8qIERlcG9zaXRzIHRoZSB0b2tlbiBpbnRvIHRoZSBjb250cmFjdCBmb3Igd2FnZXJpbmcuCiAgICAgKgogICAgICogIyBBcmd1bWVudHMKICAgICAqCiAgICAgKiBgdG9gIC0gVGhlIGFkZHJlc3MgZnJvbSB3aGljaCB0byB0YWtlIGBhbW91bnRgIGFuZCB0cmFuc2ZlciB0byB0aGUgY29udHJhY3QuCiAgICAgKiBgYW1vdW50YCAtIFRoZSBxdWFudGl0eSBvZiB0aGUgdG9rZW4gdG8gdHJhbnNmZXIuCiAgICAgKgogICAgICogIyBSZXR1cm5zCiAgICAgKgogICAgICogVGhlIGN1cnJlbnQgYmFsYW5jZSBvZiB0aGUgYWNjb3VudCBhZnRlciB0aGlzIGRlcG9zaXQuAAAAAAdkZXBvc2l0AAAAAAIAAAAAAAAAAnRvAAAAAAATAAAAAAAAAAZhbW91bnQAAAAAAAsAAAABAAAACw==", "AAAAAAAAAM0qIFdpdGhkcmF3cyBmdW5kcyBmb3IgYW4gYWNjb3VudC4KICAgICAqCiAgICAgKiAjIEFyZ3VtZW50cwogICAgICoKICAgICAqIC0gYGZyb21gIC0gVGhlIGFjY291bnQgZm9yIHdoaWNoIHRvIHBlcmZvcm0gYSB3aXRoZHJhd2FsCiAgICAgKgogICAgICogIyBSZXR1cm5zCiAgICAgKgogICAgICogVGhlIGFtb3VudCB3aXRoZHJhd24sIGZvciByZWZlcmVuY2UuAAAAAAAACHdpdGhkcmF3AAAAAQAAAAAAAAAEZnJvbQAAABMAAAABAAAACw==", "AAAAAAAAAERSZXR1cm5zIHRoZSBjdXJyZW50IHNjb3JlIGZvciBhIHBsYXllciwgYXNzdW1pbmcgdGhleSdyZSBpbiBhIG1hdGNoLgAAAAVzY29yZQAAAAAAAAEAAAAAAAAABnBsYXllcgAAAAAAEwAAAAEAAAAE", "AAAAAAAABAAqIEJlZ2lucyBhIG1hdGNoIGJldHdlZW4gdHdvIHBsYXllcnMuCiAgICAgKgogICAgICogSWYgYm90aCBwbGF5ZXJzIGF1dGhvcml6ZSBiZWdpbm5pbmcgYSBtYXRjaCwgdGhpcyB3aWxsIHNldCB0aGUgZ2FtZSB1cAogICAgICogYnkgaG9sZGluZyB0aGUgd2FnZXIgYW1vdW50IGluIHRoZSBjb250cmFjdCBhcyBhbiBlc2Nyb3cgbWVjaGFuaXNtLiBJdAogICAgICogdGhlbiByYW5kb21seSBkZWNpZGVzIG9uIHdobyBzaG91bGQgZ28gZmlyc3QsIHJldHVybmluZyB0aGF0IGFkZHJlc3MuCiAgICAgKgogICAgICogSXQgd2lsbCBhbHNvIGVtaXQgYW4gZXZlbnQgY29ycmVzcG9uZGluZyB0byB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlCiAgICAgKiBtYXRjaCwgd2l0aCB0aGUgdG9waWNzIFsibWF0Y2giLCAiUGxheWVyIEEiLCAiUGxheWVyIEIiXSBhbmQgdGhlIGRhdGEKICAgICAqIGZpZWxkIGJlaW5nIHRoZSBhZGRyZXNzIHRoYXQgZ29lcyBmaXJzdC4gVGhpcyBzaG91bGQgYWxsb3cgcGxheWVycyB0bwogICAgICogb2JzZXJ2ZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYXRjaCB3aXRob3V0IG5lY2Vzc2FyaWx5IGJlaW5nIHRoZSBvbmVzCiAgICAgKiB0byBzdWJtaXQgdGhlIGludm9jYXRpb24uCiAgICAgKgogICAgICogIyBBcmd1bWVudHMKICAgICAqCiAgICAgKiBgYWAgLSBUaGUgcGxheWVyIG9uIG9uZSBzaWRlIG9mIHRoZSBtYXRjaAogICAgICogYGJgIC0gVGhlIHBsYXllciBvbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgbWF0Y2gKICAgICAqCiAgICAgKiAjIFJldHVybnMKICAgICAqCiAgICAgKiBUaGUgYWRkcmVzcyBvZiB0aGUgcGxheWVyIHdobyBzaG91bGQgZ28gKGNhbGwgYHJvbGxgKSBmaXJzdC4KICAgICAqCiAgICAgKiAjIFBhbmljcwogICAgICoKICAgICAqIC0gSWYgZWl0aGVyIHBsYXllciBpcyBhbHJlYWR5IGluIGEgZ2FtZS4KICAgICAqIC0gSWYgYSBwbGF5ZXIgZG9lc24ndCBoYXZlIGEgc3VmZmljaWVudCBhbW91bnQgZGVwb3NpdGVkIHRvIHdhZ2VyIGEgZ2FtZQogICAgAAAABmVuZ2FnZQAAAAAAAgAAAAAAAAABYQAAAAAAABMAAAAAAAAAAWIAAAAAAAATAAAAAQAAABM=", "AAAAAAAABAAqIFBlcmZvcm1zIGEgc2luZ2xlIHJvbGwgaW4gdGhlIGdhbWUgb2YgRmFya2xlLgogICAgICoKICAgICAqIEluIEZhcmtsZSwgZ2FtZXMgYXJlIHBsYXllZCB3aXRoIHJvdW5kcy4gSW4gZWFjaCByb3VuZCwgeW91IHBlcmZvcm0gbXVsdGlwbGUKICAgICAqIHJvbGxzLCBlaXRoZXIgc2V0dGluZyBhc2lkZSBkaWNlIHRvIGFjY3VtdWxhdGUgdG8geW91ciB0dXJuJ3Mgc2NvcmUgYW5kCiAgICAgKiByb2xsaW5nIGFnYWluLCBvciBzZXR0aW5nIGFzaWRlICsgcGFzc2luZyB0byBsb2NrIGluIHlvdXIgdHVybidzIHNjb3JlIGFuZAogICAgICogYWRkIGl0IHRvIHlvdXIgYWNjdW11bGF0ZWQgdG90YWwgc2NvcmUuCiAgICAgKgogICAgICogRmlyc3QgdG8gMjAwMCB3aW5zIQogICAgICoKICAgICAqICMgQXJndW1lbnRzCiAgICAgKgogICAgICogYHBsYXllcmAgLSBUaGUgcGVyc29uIHdobyBpcyByb2xsaW5nIHRoZSBkaWNlLgogICAgICogYHNhdmVgIC0gQSBsaXN0IG9mIGluZGljZXMgaW50byB0aGUgZGljZSB0byBrZWVwIGZyb20gdGhlIHByZXZpb3VzIHJvbGwuCiAgICAgKgogICAgICogICAgICBJbiBvdGhlciB3b3JkcywgaWYgdGhlIHByZXZpb3VzIGByb2xsYCBjYWxsIHJldHVybmVkIGEgNC1kaWNlIHJvbGwKICAgICAqICAgICAgd2l0aCBgWzEsIDYsIDIsIDFdYCAoYmVjYXVzZSB5b3UndmUgYWxyZWFkeSBzZXQgdGhlIG90aGVyIHR3byBhc2lkZSksCiAgICAgKiAgICAgIGFuZCB5b3Ugd2FudGVkIHRvIGtlZXAgYm90aCAxcywgdGhlIGBzYXZlYCBsaXN0IHNob3VsZCBiZSBbMCwgM10KICAgICAqICAgICAgYmVjYXVzZSB5b3Ugd2FudCB0byBrZWVwIHRoZSAxc3QgYW5kIDR0aCBkaWNlICgwLWJhc2VkIGluZGV4aW5nKS4KICAgICAqIGBzdG9wYCAtIFdoZXRoZXIgb3Igbm90IHlvdSB3YW50IHRvIHN0b3AgYWZ0ZXIgdGhpcyBhY2N1bXVsYXRpb24gb2YgcG9pbnRzLgogICAgICoKICAgICAqICMgUmV0dXJucwogICAgICoKICAgICAqIEEgbGlzdCByZXByZXNlbnRpbmcgdGhlIGxhdGVzdCBkAAAABHJvbGwAAAADAAAAAAAAAAZwbGF5ZXIAAAAAABMAAAAAAAAABHNhdmUAAAPqAAAABAAAAAAAAAAEc3RvcAAAAAEAAAABAAAD6gAAAAQ=", "AAAAAAAAADBSZXR1cm5zIHRoZSB0b2tlbiBhZGRyZXNzIGJlaW5nIHVzZWQgZm9yIHdhZ2Vycy4AAAAFdG9rZW4AAAAAAAAAAAAAAQAAABM=", "AAAAAAAAAClQYW5pY3MgaWYgdGhlIGNvbnRyYWN0IGlzbid0IGluaXRpYWxpemVkLgAAAAAAAApjaGVja19pbml0AAAAAAAAAAAAAA==", "AAAAAAAAADdCdW1wcyB0aGUgdGltZS10by1saXZlIGZvciBhIG1hdGNoIGJldHdlZW4gdHdvIHBsYXllcnMuAAAAAA5idW1wX21hdGNoX3R0bAAAAAAAAgAAAAAAAAABYQAAAAAAABMAAAAAAAAAAWIAAAAAAAATAAAAAA==", "AAAAAAAAAAAAAAAJZW5kX21hdGNoAAAAAAAAAgAAAAAAAAAGcGxheWVyAAAAAAATAAAAAAAAAANvcHAAAAAAEwAAAAEAAAAB"]), e);
    __publicField(this, "fromJSON", { version: this.txFromJSON, wager: this.txFromJSON, upgrade: this.txFromJSON, shutdown: this.txFromJSON, balance: this.txFromJSON, deposit: this.txFromJSON, withdraw: this.txFromJSON, score: this.txFromJSON, engage: this.txFromJSON, roll: this.txFromJSON, token: this.txFromJSON, check_init: this.txFromJSON, bump_match_ttl: this.txFromJSON, end_match: this.txFromJSON });
    this.options = e;
  }
  static async deploy({ admin: e, token: n }, i) {
    return pc.Client.deploy({ admin: e, token: n }, i);
  }
}
const Ra = 10000000n, Ma = "https://soroban-testnet.stellar.org", gf = "CDYTZZSG3IL7XWDUNNVHD5MZ4AVIPH2EQVCA6XWFGSUVL3CXFOBHVQWA", TE = 180, Sc = Yn.Networks.TESTNET, kE = window.location.toString();
async function vf(v) {
  const { address: e } = await v.getAddress(), { networkPassphrase: n } = await v.getNetwork();
  return new xE({ contractId: gf, publicKey: e, rpcUrl: Ma, networkPassphrase: n, signTransaction: v.signTransaction, signAuthEntry: v.signAuthEntry });
}
function OE(v, e) {
  let n = v.map((s) => Yn.scValToNative(s)), i = Yn.scValToNative(e);
  switch (n[0]) {
    case "match":
      return { type: n[0], player: n[1], otherPlayer: n[2], first: i };
    case "roll":
      return { type: n[0], player: n[1], dice: i };
    case "reroll":
      return { type: n[0], player: n[1], dice: i[0], score: i[1], stop: i[2] };
    case "bust":
      return { type: n[0], player: n[1], dice: i };
    case "win":
      return { type: n[0], player: n[1], score: i };
    default:
      throw v;
  }
}
class PE {
  constructor() {
    __publicField(this, "listener");
    __publicField(this, "rpc", new no.Server(Ma));
    window.addEventListener("farkle", (e) => {
      const n = e.detail;
      console.debug("Farkle Event:", n), dispatchEvent(new CustomEvent(`farkle-${n.type}`, { bubbles: true, detail: n }));
    });
  }
  stop() {
    clearInterval(this.listener);
  }
  listen(e) {
    const n = { contractIds: [gf], type: "contract", topics: e.map((y) => ["*", Yn.nativeToScVal(y, { type: "address" }).toXDR("base64")]) };
    let i, s;
    this.listener = setInterval(async () => {
      let y = await this.rpc.getLatestLedger();
      i && i.sequence >= y.sequence || (i = y, s ? s = await this.rpc.getEvents({ filters: [n], cursor: s.cursor, limit: 100 }) : s = await this.rpc.getEvents({ filters: [n], startLedger: i.sequence - 10, limit: 100 }), s.events.forEach((t) => {
        const o = OE(t.topic, t.value);
        dispatchEvent(new CustomEvent("farkle", { detail: o, bubbles: true }));
      }));
    }, 1500);
  }
  on(e, n) {
    window.addEventListener(`farkle-${e}`, n);
  }
}
async function CE(v) {
  const { address: e } = await v.getAddress(), n = Yn.Keypair.fromPublicKey(e);
  let y = (await new no.Server(Ma).getLedgerEntries(Yn.xdr.LedgerKey.account(new Yn.xdr.LedgerKeyAccount({ accountId: n.xdrAccountId() })))).entries[0].val.account().balance().toBigInt();
  y <= Number.MAX_SAFE_INTEGER ? y = Number(y) / Number(Ra) : y /= Ra, console.debug(`Loaded account info for ${n.publicKey().substring(0, 6)}: ${y} XLM.`);
  const t = $r("#account-balance"), o = t.text(), u = y.toString();
  return t.text(Number(y).toFixed(2)), { element: t, oldBalance: o, newBalance: u };
}
async function RE(v) {
  const e = await vf(v), { address: n } = await v.getAddress(), i = await e.balance({ player: n });
  let s;
  i.result === -1n ? s = 0 : i.result <= Number.MAX_SAFE_INTEGER ? s = Number(i.result) / Number(Ra) : s = i.result / Ra;
  const y = $r("#in-game-balance"), t = y.text(), o = s.toString();
  return y.text(parseFloat(o).toFixed(2)), { element: y, oldBalance: t, newBalance: o };
}
function Ym(v = 3e3) {
  return new Promise((e) => setTimeout(e, v));
}
async function ME(v, e, n, i) {
  const s = Math.ceil(40180), { address: y } = await v.getAddress(), o = await (await vf(v)).roll({ player: y, save: n ?? [], stop: i ?? false }, { ...!i && { fee: parseInt(Yn.BASE_FEE) + s } });
  if (!i) {
    const c = [Ju("TurnScore", y), Ju("Dice", y), Ju("Turn", y), Ju("Turn", e)];
    if (no.Api.isSimulationSuccess(o.simulation)) {
      const h = o.simulation.transactionData.build(), f = h.resources().instructions(), r = h.resources().readBytes(), m = h.resources().writeBytes(), a = h.resourceFee().toBigInt() + BigInt(s), l = c.map((d) => d.toXDR("base64"));
      o.simulation.transactionData.setReadWrite(o.simulation.transactionData.getReadWrite().filter((d) => !l.includes(d.toXDR("base64"))).concat(c)).setReadOnly(o.simulation.transactionData.getReadOnly().filter((d) => !l.includes(d.toXDR("base64")))).setResources(f, Math.ceil(r + 1e3), Math.ceil(m + 1e3)).setResourceFee(a.toString());
    }
  }
  return _c(o);
}
async function _c(v) {
  var _a2, _b2, _c2, _d2, _e, _f2, _g2;
  let e = null;
  try {
    e = await v.signAndSend();
  } catch (n) {
    return console.debug("Transaction envelope:", v.built.toXDR()), console.error(n), n.toString().includes("TRY_AGAIN_LATER") ? (await Ym(5e3), _c(v)) : (console.log("Returning rejection..."), Promise.reject(n));
  } finally {
    console.debug("Transaction envelope:", (_a2 = v.signed) == null ? void 0 : _a2.toXDR()), (_c2 = (_b2 = e == null ? void 0 : e.sendTransactionResponse) == null ? void 0 : _b2.diagnosticEvents) == null ? void 0 : _c2.forEach((n) => {
      console.error(n.toXDR("base64"));
    });
  }
  switch (console.debug("Transaction status:", (_d2 = e.getTransactionResponse) == null ? void 0 : _d2.status), (_e = e.getTransactionResponse) == null ? void 0 : _e.status) {
    case no.Api.GetTransactionStatus.SUCCESS:
    case no.Api.GetTransactionStatus.FAILED:
      console.log(e.getTransactionResponse.resultMetaXdr.toXDR("base64"));
      break;
    default:
      console.log(e);
  }
  switch ((_f2 = e.getTransactionResponse) == null ? void 0 : _f2.status) {
    case no.Api.GetTransactionStatus.SUCCESS:
      return Yn.scValToNative(e.getTransactionResponse.returnValue);
    case no.Api.GetTransactionStatus.FAILED:
      (_g2 = e.getTransactionResponse.diagnosticEventsXdr) == null ? void 0 : _g2.forEach((n, i) => {
        console.error(`Event ${i + 1}:`, n), console.error(`Event ${i + 1}:`, n.toXDR("base64"));
      });
      break;
  }
}
function IE(v) {
  const e = (t, o) => t.length >= o.length && o.every((u) => t.includes(u)), n = /* @__PURE__ */ new Map();
  v.forEach((t) => {
    n.set(t, (n.get(t) ?? 0) + 1);
  });
  const i = Array.from(n.keys()), s = [1, 2, 3, 4, 5, 6];
  let y = 0;
  return e(i, s) ? 1500 : (e(i, s.slice(0, -1)) ? (y += 500, n.forEach((t, o) => {
    o <= 5 && n.set(o, t - 1);
  })) : e(i, s.slice(1)) && (y += 750, n.forEach((t, o) => {
    o >= 2 && o <= 6 && n.set(o, t - 1);
  })), s.forEach((t) => {
    let o = Math.max(0, n.get(t) ?? 0);
    if (o < 3) return;
    let u = t === 1 ? 1e3 : t * 100;
    o > 3 && (u *= Math.pow(2, o - 3)), y += u, n.set(t, 0);
  }), y += 100 * (n.get(1) ?? 0), y += 50 * (n.get(5) ?? 0), n.set(1, 0), n.set(5, 0), Array.from(n.values()).some((t) => t > 0) ? 0 : y);
}
function Ju(v, e) {
  return Yn.xdr.LedgerKey.contractData(new Yn.xdr.LedgerKeyContractData({ contract: new Yn.Address(gf).toScAddress(), key: Yn.xdr.ScVal.scvVec([Yn.nativeToScVal(v, { type: "symbol" }), Yn.nativeToScVal(e, { type: "address" })]), durability: Yn.xdr.ContractDataDurability.temporary() }));
}
function Nl(v) {
  if (v.length === 1) return `a ${v[0]}`;
  const e = v.length > 2 ? "," : "", n = Array.from(v).sort();
  return `${n.slice(0, -1).join(", ")}${e} and ${n.slice(-1)}`;
}
const so = /* @__PURE__ */ Object.create(null);
so.open = "0";
so.close = "1";
so.ping = "2";
so.pong = "3";
so.message = "4";
so.upgrade = "5";
so.noop = "6";
const hc = /* @__PURE__ */ Object.create(null);
Object.keys(so).forEach((v) => {
  hc[so[v]] = v;
});
const zl = { type: "error", data: "parser error" }, Qm = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Zm = typeof ArrayBuffer == "function", Jm = (v) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(v) : v && v.buffer instanceof ArrayBuffer, bf = ({ type: v, data: e }, n, i) => Qm && e instanceof Blob ? n ? i(e) : jd(e, i) : Zm && (e instanceof ArrayBuffer || Jm(e)) ? n ? i(e) : jd(new Blob([e]), i) : i(so[v] + (e || "")), jd = (v, e) => {
  const n = new FileReader();
  return n.onload = function() {
    const i = n.result.split(",")[1];
    e("b" + (i || ""));
  }, n.readAsDataURL(v);
};
function Vd(v) {
  return v instanceof Uint8Array ? v : v instanceof ArrayBuffer ? new Uint8Array(v) : new Uint8Array(v.buffer, v.byteOffset, v.byteLength);
}
let Dl;
function LE(v, e) {
  if (Qm && v.data instanceof Blob) return v.data.arrayBuffer().then(Vd).then(e);
  if (Zm && (v.data instanceof ArrayBuffer || Jm(v.data))) return e(Vd(v.data));
  bf(v, false, (n) => {
    Dl || (Dl = new TextEncoder()), e(Dl.encode(n));
  });
}
const qd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ns = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let v = 0; v < qd.length; v++) Ns[qd.charCodeAt(v)] = v;
const BE = (v) => {
  let e = v.length * 0.75, n = v.length, i, s = 0, y, t, o, u;
  v[v.length - 1] === "=" && (e--, v[v.length - 2] === "=" && e--);
  const c = new ArrayBuffer(e), h = new Uint8Array(c);
  for (i = 0; i < n; i += 4) y = Ns[v.charCodeAt(i)], t = Ns[v.charCodeAt(i + 1)], o = Ns[v.charCodeAt(i + 2)], u = Ns[v.charCodeAt(i + 3)], h[s++] = y << 2 | t >> 4, h[s++] = (t & 15) << 4 | o >> 2, h[s++] = (o & 3) << 6 | u & 63;
  return c;
}, NE = typeof ArrayBuffer == "function", wf = (v, e) => {
  if (typeof v != "string") return { type: "message", data: ey(v, e) };
  const n = v.charAt(0);
  return n === "b" ? { type: "message", data: DE(v.substring(1), e) } : hc[n] ? v.length > 1 ? { type: hc[n], data: v.substring(1) } : { type: hc[n] } : zl;
}, DE = (v, e) => {
  if (NE) {
    const n = BE(v);
    return ey(n, e);
  } else return { base64: true, data: v };
}, ey = (v, e) => {
  switch (e) {
    case "blob":
      return v instanceof Blob ? v : new Blob([v]);
    case "arraybuffer":
    default:
      return v instanceof ArrayBuffer ? v : v.buffer;
  }
}, ty = "", FE = (v, e) => {
  const n = v.length, i = new Array(n);
  let s = 0;
  v.forEach((y, t) => {
    bf(y, false, (o) => {
      i[t] = o, ++s === n && e(i.join(ty));
    });
  });
}, UE = (v, e) => {
  const n = v.split(ty), i = [];
  for (let s = 0; s < n.length; s++) {
    const y = wf(n[s], e);
    if (i.push(y), y.type === "error") break;
  }
  return i;
};
function jE() {
  return new TransformStream({ transform(v, e) {
    LE(v, (n) => {
      const i = n.length;
      let s;
      if (i < 126) s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, i);
      else if (i < 65536) {
        s = new Uint8Array(3);
        const y = new DataView(s.buffer);
        y.setUint8(0, 126), y.setUint16(1, i);
      } else {
        s = new Uint8Array(9);
        const y = new DataView(s.buffer);
        y.setUint8(0, 127), y.setBigUint64(1, BigInt(i));
      }
      v.data && typeof v.data != "string" && (s[0] |= 128), e.enqueue(s), e.enqueue(n);
    });
  } });
}
let Fl;
function ec(v) {
  return v.reduce((e, n) => e + n.length, 0);
}
function tc(v, e) {
  if (v[0].length === e) return v.shift();
  const n = new Uint8Array(e);
  let i = 0;
  for (let s = 0; s < e; s++) n[s] = v[0][i++], i === v[0].length && (v.shift(), i = 0);
  return v.length && i < v[0].length && (v[0] = v[0].slice(i)), n;
}
function VE(v, e) {
  Fl || (Fl = new TextDecoder());
  const n = [];
  let i = 0, s = -1, y = false;
  return new TransformStream({ transform(t, o) {
    for (n.push(t); ; ) {
      if (i === 0) {
        if (ec(n) < 1) break;
        const u = tc(n, 1);
        y = (u[0] & 128) === 128, s = u[0] & 127, s < 126 ? i = 3 : s === 126 ? i = 1 : i = 2;
      } else if (i === 1) {
        if (ec(n) < 2) break;
        const u = tc(n, 2);
        s = new DataView(u.buffer, u.byteOffset, u.length).getUint16(0), i = 3;
      } else if (i === 2) {
        if (ec(n) < 8) break;
        const u = tc(n, 8), c = new DataView(u.buffer, u.byteOffset, u.length), h = c.getUint32(0);
        if (h > Math.pow(2, 21) - 1) {
          o.enqueue(zl);
          break;
        }
        s = h * Math.pow(2, 32) + c.getUint32(4), i = 3;
      } else {
        if (ec(n) < s) break;
        const u = tc(n, s);
        o.enqueue(wf(y ? u : Fl.decode(u), e)), i = 0;
      }
      if (s === 0 || s > v) {
        o.enqueue(zl);
        break;
      }
    }
  } });
}
const ry = 4;
function ri(v) {
  if (v) return qE(v);
}
function qE(v) {
  for (var e in ri.prototype) v[e] = ri.prototype[e];
  return v;
}
ri.prototype.on = ri.prototype.addEventListener = function(v, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + v] = this._callbacks["$" + v] || []).push(e), this;
};
ri.prototype.once = function(v, e) {
  function n() {
    this.off(v, n), e.apply(this, arguments);
  }
  return n.fn = e, this.on(v, n), this;
};
ri.prototype.off = ri.prototype.removeListener = ri.prototype.removeAllListeners = ri.prototype.removeEventListener = function(v, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this;
  var n = this._callbacks["$" + v];
  if (!n) return this;
  if (arguments.length == 1) return delete this._callbacks["$" + v], this;
  for (var i, s = 0; s < n.length; s++) if (i = n[s], i === e || i.fn === e) {
    n.splice(s, 1);
    break;
  }
  return n.length === 0 && delete this._callbacks["$" + v], this;
};
ri.prototype.emit = function(v) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), n = this._callbacks["$" + v], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
  if (n) {
    n = n.slice(0);
    for (var i = 0, s = n.length; i < s; ++i) n[i].apply(this, e);
  }
  return this;
};
ri.prototype.emitReserved = ri.prototype.emit;
ri.prototype.listeners = function(v) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + v] || [];
};
ri.prototype.hasListeners = function(v) {
  return !!this.listeners(v).length;
};
const Oc = typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, n) => n(e, 0), ji = typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")(), zE = "arraybuffer";
function ny(v, ...e) {
  return e.reduce((n, i) => (v.hasOwnProperty(i) && (n[i] = v[i]), n), {});
}
const HE = ji.setTimeout, GE = ji.clearTimeout;
function Pc(v, e) {
  e.useNativeTimers ? (v.setTimeoutFn = HE.bind(ji), v.clearTimeoutFn = GE.bind(ji)) : (v.setTimeoutFn = ji.setTimeout.bind(ji), v.clearTimeoutFn = ji.clearTimeout.bind(ji));
}
const WE = 1.33;
function KE(v) {
  return typeof v == "string" ? XE(v) : Math.ceil((v.byteLength || v.size) * WE);
}
function XE(v) {
  let e = 0, n = 0;
  for (let i = 0, s = v.length; i < s; i++) e = v.charCodeAt(i), e < 128 ? n += 1 : e < 2048 ? n += 2 : e < 55296 || e >= 57344 ? n += 3 : (i++, n += 4);
  return n;
}
function iy() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function $E(v) {
  let e = "";
  for (let n in v) v.hasOwnProperty(n) && (e.length && (e += "&"), e += encodeURIComponent(n) + "=" + encodeURIComponent(v[n]));
  return e;
}
function YE(v) {
  let e = {}, n = v.split("&");
  for (let i = 0, s = n.length; i < s; i++) {
    let y = n[i].split("=");
    e[decodeURIComponent(y[0])] = decodeURIComponent(y[1]);
  }
  return e;
}
class QE extends Error {
  constructor(e, n, i) {
    super(e), this.description = n, this.context = i, this.type = "TransportError";
  }
}
class Sf extends ri {
  constructor(e) {
    super(), this.writable = false, Pc(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64;
  }
  onError(e, n, i) {
    return super.emitReserved("error", new QE(e, n, i)), this;
  }
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    this.readyState = "open", this.writable = true, super.emitReserved("open");
  }
  onData(e) {
    const n = wf(e, this.socket.binaryType);
    this.onPacket(n);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
  pause(e) {
  }
  createUri(e, n = {}) {
    return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(n);
  }
  _hostname() {
    const e = this.opts.hostname;
    return e.indexOf(":") === -1 ? e : "[" + e + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(e) {
    const n = $E(e);
    return n.length ? "?" + n : "";
  }
}
class ZE extends Sf {
  constructor() {
    super(...arguments), this._polling = false;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this._poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const n = () => {
      this.readyState = "paused", e();
    };
    if (this._polling || !this.writable) {
      let i = 0;
      this._polling && (i++, this.once("pollComplete", function() {
        --i || n();
      })), this.writable || (i++, this.once("drain", function() {
        --i || n();
      }));
    } else n();
  }
  _poll() {
    this._polling = true, this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const n = (i) => {
      if (this.readyState === "opening" && i.type === "open" && this.onOpen(), i.type === "close") return this.onClose({ description: "transport closed by the server" }), false;
      this.onPacket(i);
    };
    UE(e, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this._polling = false, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    this.writable = false, FE(e, (n) => {
      this.doWrite(n, () => {
        this.writable = true, this.emitReserved("drain");
      });
    });
  }
  uri() {
    const e = this.opts.secure ? "https" : "http", n = this.query || {};
    return this.opts.timestampRequests !== false && (n[this.opts.timestampParam] = iy()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(e, n);
  }
}
let oy = false;
try {
  oy = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const JE = oy;
function eA() {
}
class tA extends ZE {
  constructor(e) {
    if (super(e), typeof location < "u") {
      const n = location.protocol === "https:";
      let i = location.port;
      i || (i = n ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || i !== e.port;
    }
  }
  doWrite(e, n) {
    const i = this.request({ method: "POST", data: e });
    i.on("success", n), i.on("error", (s, y) => {
      this.onError("xhr post error", s, y);
    });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (n, i) => {
      this.onError("xhr poll error", n, i);
    }), this.pollXhr = e;
  }
}
let Pa = class dc extends ri {
  constructor(e, n, i) {
    super(), this.createRequest = e, Pc(this, i), this._opts = i, this._method = i.method || "GET", this._uri = n, this._data = i.data !== void 0 ? i.data : null, this._create();
  }
  _create() {
    var e;
    const n = ny(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n.xdomain = !!this._opts.xd;
    const i = this._xhr = this.createRequest(n);
    try {
      i.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          i.setDisableHeaderCheck && i.setDisableHeaderCheck(true);
          for (let s in this._opts.extraHeaders) this._opts.extraHeaders.hasOwnProperty(s) && i.setRequestHeader(s, this._opts.extraHeaders[s]);
        }
      } catch {
      }
      if (this._method === "POST") try {
        i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
      } catch {
      }
      try {
        i.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(i), "withCredentials" in i && (i.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (i.timeout = this._opts.requestTimeout), i.onreadystatechange = () => {
        var s;
        i.readyState === 3 && ((s = this._opts.cookieJar) === null || s === void 0 || s.parseCookies(i.getResponseHeader("set-cookie"))), i.readyState === 4 && (i.status === 200 || i.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => {
          this._onError(typeof i.status == "number" ? i.status : 0);
        }, 0));
      }, i.send(this._data);
    } catch (s) {
      this.setTimeoutFn(() => {
        this._onError(s);
      }, 0);
      return;
    }
    typeof document < "u" && (this._index = dc.requestsCount++, dc.requests[this._index] = this);
  }
  _onError(e) {
    this.emitReserved("error", e, this._xhr), this._cleanup(true);
  }
  _cleanup(e) {
    if (!(typeof this._xhr > "u" || this._xhr === null)) {
      if (this._xhr.onreadystatechange = eA, e) try {
        this._xhr.abort();
      } catch {
      }
      typeof document < "u" && delete dc.requests[this._index], this._xhr = null;
    }
  }
  _onLoad() {
    const e = this._xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup());
  }
  abort() {
    this._cleanup();
  }
};
Pa.requestsCount = 0;
Pa.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function") attachEvent("onunload", zd);
  else if (typeof addEventListener == "function") {
    const v = "onpagehide" in ji ? "pagehide" : "unload";
    addEventListener(v, zd, false);
  }
}
function zd() {
  for (let v in Pa.requests) Pa.requests.hasOwnProperty(v) && Pa.requests[v].abort();
}
const rA = function() {
  const v = ay({ xdomain: false });
  return v && v.responseType !== null;
}();
class nA extends tA {
  constructor(e) {
    super(e);
    const n = e && e.forceBase64;
    this.supportsBinary = rA && !n;
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd }, this.opts), new Pa(ay, this.uri(), e);
  }
}
function ay(v) {
  const e = v.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || JE)) return new XMLHttpRequest();
  } catch {
  }
  if (!e) try {
    return new ji[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
  } catch {
  }
}
const sy = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class iA extends Sf {
  get name() {
    return "websocket";
  }
  doOpen() {
    const e = this.uri(), n = this.opts.protocols, i = sy ? {} : ny(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (i.headers = this.opts.extraHeaders);
    try {
      this.ws = this.createSocket(e, n, i);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = false;
    for (let n = 0; n < e.length; n++) {
      const i = e[n], s = n === e.length - 1;
      bf(i, this.supportsBinary, (y) => {
        try {
          this.doWrite(i, y);
        } catch {
        }
        s && Oc(() => {
          this.writable = true, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.onerror = () => {
    }, this.ws.close(), this.ws = null);
  }
  uri() {
    const e = this.opts.secure ? "wss" : "ws", n = this.query || {};
    return this.opts.timestampRequests && (n[this.opts.timestampParam] = iy()), this.supportsBinary || (n.b64 = 1), this.createUri(e, n);
  }
}
const Ul = ji.WebSocket || ji.MozWebSocket;
class oA extends iA {
  createSocket(e, n, i) {
    return sy ? new Ul(e, n, i) : n ? new Ul(e, n) : new Ul(e);
  }
  doWrite(e, n) {
    this.ws.send(n);
  }
}
class aA extends Sf {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (e) {
      return this.emitReserved("error", e);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((e) => {
      this.onError("webtransport error", e);
    }), this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((e) => {
        const n = VE(Number.MAX_SAFE_INTEGER, this.socket.binaryType), i = e.readable.pipeThrough(n).getReader(), s = jE();
        s.readable.pipeTo(e.writable), this._writer = s.writable.getWriter();
        const y = () => {
          i.read().then(({ done: o, value: u }) => {
            o || (this.onPacket(u), y());
          }).catch((o) => {
          });
        };
        y();
        const t = { type: "open" };
        this.query.sid && (t.data = `{"sid":"${this.query.sid}"}`), this._writer.write(t).then(() => this.onOpen());
      });
    });
  }
  write(e) {
    this.writable = false;
    for (let n = 0; n < e.length; n++) {
      const i = e[n], s = n === e.length - 1;
      this._writer.write(i).then(() => {
        s && Oc(() => {
          this.writable = true, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var e;
    (e = this._transport) === null || e === void 0 || e.close();
  }
}
const sA = { websocket: oA, webtransport: aA, polling: nA }, uA = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, cA = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
function Hl(v) {
  if (v.length > 8e3) throw "URI too long";
  const e = v, n = v.indexOf("["), i = v.indexOf("]");
  n != -1 && i != -1 && (v = v.substring(0, n) + v.substring(n, i).replace(/:/g, ";") + v.substring(i, v.length));
  let s = uA.exec(v || ""), y = {}, t = 14;
  for (; t--; ) y[cA[t]] = s[t] || "";
  return n != -1 && i != -1 && (y.source = e, y.host = y.host.substring(1, y.host.length - 1).replace(/;/g, ":"), y.authority = y.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), y.ipv6uri = true), y.pathNames = lA(y, y.path), y.queryKey = fA(y, y.query), y;
}
function lA(v, e) {
  const n = /\/{2,9}/g, i = e.replace(n, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && i.splice(0, 1), e.slice(-1) == "/" && i.splice(i.length - 1, 1), i;
}
function fA(v, e) {
  const n = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(i, s, y) {
    s && (n[s] = y);
  }), n;
}
const Gl = typeof addEventListener == "function" && typeof removeEventListener == "function", mc = [];
Gl && addEventListener("offline", () => {
  mc.forEach((v) => v());
}, false);
class Fo extends ri {
  constructor(e, n) {
    if (super(), this.binaryType = zE, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (n = e, e = null), e) {
      const i = Hl(e);
      n.hostname = i.host, n.secure = i.protocol === "https" || i.protocol === "wss", n.port = i.port, i.query && (n.query = i.query);
    } else n.host && (n.hostname = Hl(n.host).host);
    Pc(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, n.transports.forEach((i) => {
      const s = i.prototype.name;
      this.transports.push(s), this._transportsByName[s] = i;
    }), this.opts = Object.assign({ path: "/engine.io", agent: false, withCredentials: false, upgrade: true, timestampParam: "t", rememberUpgrade: false, addTrailingSlash: true, rejectUnauthorized: true, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: false }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = YE(this.opts.query)), Gl && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this._beforeunloadEventListener, false)), this.hostname !== "localhost" && (this._offlineEventListener = () => {
      this._onClose("transport close", { description: "network connection lost" });
    }, mc.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open();
  }
  createTransport(e) {
    const n = Object.assign({}, this.opts.query);
    n.EIO = ry, n.transport = e, this.id && (n.sid = this.id);
    const i = Object.assign({}, this.opts, { query: n, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }, this.opts.transportOptions[e]);
    return new this._transportsByName[e](i);
  }
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const e = this.opts.rememberUpgrade && Fo.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const n = this.createTransport(e);
    n.open(), this.setTransport(n);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (n) => this._onClose("transport close", n));
  }
  onOpen() {
    this.readyState = "open", Fo.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush();
  }
  _onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
      case "open":
        this.onHandshake(JSON.parse(e.data));
        break;
      case "ping":
        this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout();
        break;
      case "error":
        const n = new Error("server error");
        n.code = e.data, this._onError(n);
        break;
      case "message":
        this.emitReserved("data", e.data), this.emitReserved("message", e.data);
        break;
    }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout();
  }
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const e = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref();
  }
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this._getWritablePackets();
      this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  _getWritablePackets() {
    if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer;
    let n = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const s = this.writeBuffer[i].data;
      if (s && (n += KE(s)), i > 0 && n > this._maxPayload) return this.writeBuffer.slice(0, i);
      n += 2;
    }
    return this.writeBuffer;
  }
  _hasPingExpired() {
    if (!this._pingTimeoutTime) return true;
    const e = Date.now() > this._pingTimeoutTime;
    return e && (this._pingTimeoutTime = 0, Oc(() => {
      this._onClose("ping timeout");
    }, this.setTimeoutFn)), e;
  }
  write(e, n, i) {
    return this._sendPacket("message", e, n, i), this;
  }
  send(e, n, i) {
    return this._sendPacket("message", e, n, i), this;
  }
  _sendPacket(e, n, i, s) {
    if (typeof n == "function" && (s = n, n = void 0), typeof i == "function" && (s = i, i = null), this.readyState === "closing" || this.readyState === "closed") return;
    i = i || {}, i.compress = i.compress !== false;
    const y = { type: e, data: n, options: i };
    this.emitReserved("packetCreate", y), this.writeBuffer.push(y), s && this.once("flush", s), this.flush();
  }
  close() {
    const e = () => {
      this._onClose("forced close"), this.transport.close();
    }, n = () => {
      this.off("upgrade", n), this.off("upgradeError", n), e();
    }, i = () => {
      this.once("upgrade", n), this.once("upgradeError", n);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? i() : e();
    }) : this.upgrading ? i() : e()), this;
  }
  _onError(e) {
    if (Fo.priorWebsocketSuccess = false, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") return this.transports.shift(), this._open();
    this.emitReserved("error", e), this._onClose("transport error", e);
  }
  _onClose(e, n) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
      if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), Gl && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, false), this._offlineEventListener)) {
        const i = mc.indexOf(this._offlineEventListener);
        i !== -1 && mc.splice(i, 1);
      }
      this.readyState = "closed", this.id = null, this.emitReserved("close", e, n), this.writeBuffer = [], this._prevBufferLen = 0;
    }
  }
}
Fo.protocol = ry;
class pA extends Fo {
  constructor() {
    super(...arguments), this._upgrades = [];
  }
  onOpen() {
    if (super.onOpen(), this.readyState === "open" && this.opts.upgrade) for (let e = 0; e < this._upgrades.length; e++) this._probe(this._upgrades[e]);
  }
  _probe(e) {
    let n = this.createTransport(e), i = false;
    Fo.priorWebsocketSuccess = false;
    const s = () => {
      i || (n.send([{ type: "ping", data: "probe" }]), n.once("packet", (f) => {
        if (!i) if (f.type === "pong" && f.data === "probe") {
          if (this.upgrading = true, this.emitReserved("upgrading", n), !n) return;
          Fo.priorWebsocketSuccess = n.name === "websocket", this.transport.pause(() => {
            i || this.readyState !== "closed" && (h(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = false, this.flush());
          });
        } else {
          const r = new Error("probe error");
          r.transport = n.name, this.emitReserved("upgradeError", r);
        }
      }));
    };
    function y() {
      i || (i = true, h(), n.close(), n = null);
    }
    const t = (f) => {
      const r = new Error("probe error: " + f);
      r.transport = n.name, y(), this.emitReserved("upgradeError", r);
    };
    function o() {
      t("transport closed");
    }
    function u() {
      t("socket closed");
    }
    function c(f) {
      n && f.name !== n.name && y();
    }
    const h = () => {
      n.removeListener("open", s), n.removeListener("error", t), n.removeListener("close", o), this.off("close", u), this.off("upgrading", c);
    };
    n.once("open", s), n.once("error", t), n.once("close", o), this.once("close", u), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => {
      i || n.open();
    }, 200) : n.open();
  }
  onHandshake(e) {
    this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e);
  }
  _filterUpgrades(e) {
    const n = [];
    for (let i = 0; i < e.length; i++) ~this.transports.indexOf(e[i]) && n.push(e[i]);
    return n;
  }
}
let hA = class extends pA {
  constructor(e, n = {}) {
    const i = typeof e == "object" ? e : n;
    (!i.transports || i.transports && typeof i.transports[0] == "string") && (i.transports = (i.transports || ["polling", "websocket", "webtransport"]).map((s) => sA[s]).filter((s) => !!s)), super(e, i);
  }
};
function dA(v, e = "", n) {
  let i = v;
  n = n || typeof location < "u" && location, v == null && (v = n.protocol + "//" + n.host), typeof v == "string" && (v.charAt(0) === "/" && (v.charAt(1) === "/" ? v = n.protocol + v : v = n.host + v), /^(https?|wss?):\/\//.test(v) || (typeof n < "u" ? v = n.protocol + "//" + v : v = "https://" + v), i = Hl(v)), i.port || (/^(http|ws)$/.test(i.protocol) ? i.port = "80" : /^(http|ws)s$/.test(i.protocol) && (i.port = "443")), i.path = i.path || "/";
  const y = i.host.indexOf(":") !== -1 ? "[" + i.host + "]" : i.host;
  return i.id = i.protocol + "://" + y + ":" + i.port + e, i.href = i.protocol + "://" + y + (n && n.port === i.port ? "" : ":" + i.port), i;
}
const mA = typeof ArrayBuffer == "function", yA = (v) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(v) : v.buffer instanceof ArrayBuffer, uy = Object.prototype.toString, gA = typeof Blob == "function" || typeof Blob < "u" && uy.call(Blob) === "[object BlobConstructor]", vA = typeof File == "function" || typeof File < "u" && uy.call(File) === "[object FileConstructor]";
function _f(v) {
  return mA && (v instanceof ArrayBuffer || yA(v)) || gA && v instanceof Blob || vA && v instanceof File;
}
function yc(v, e) {
  if (!v || typeof v != "object") return false;
  if (Array.isArray(v)) {
    for (let n = 0, i = v.length; n < i; n++) if (yc(v[n])) return true;
    return false;
  }
  if (_f(v)) return true;
  if (v.toJSON && typeof v.toJSON == "function" && arguments.length === 1) return yc(v.toJSON(), true);
  for (const n in v) if (Object.prototype.hasOwnProperty.call(v, n) && yc(v[n])) return true;
  return false;
}
function bA(v) {
  const e = [], n = v.data, i = v;
  return i.data = Wl(n, e), i.attachments = e.length, { packet: i, buffers: e };
}
function Wl(v, e) {
  if (!v) return v;
  if (_f(v)) {
    const n = { _placeholder: true, num: e.length };
    return e.push(v), n;
  } else if (Array.isArray(v)) {
    const n = new Array(v.length);
    for (let i = 0; i < v.length; i++) n[i] = Wl(v[i], e);
    return n;
  } else if (typeof v == "object" && !(v instanceof Date)) {
    const n = {};
    for (const i in v) Object.prototype.hasOwnProperty.call(v, i) && (n[i] = Wl(v[i], e));
    return n;
  }
  return v;
}
function wA(v, e) {
  return v.data = Kl(v.data, e), delete v.attachments, v;
}
function Kl(v, e) {
  if (!v) return v;
  if (v && v._placeholder === true) {
    if (typeof v.num == "number" && v.num >= 0 && v.num < e.length) return e[v.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(v)) for (let n = 0; n < v.length; n++) v[n] = Kl(v[n], e);
  else if (typeof v == "object") for (const n in v) Object.prototype.hasOwnProperty.call(v, n) && (v[n] = Kl(v[n], e));
  return v;
}
const SA = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"], _A = 5;
var Cn;
(function(v) {
  v[v.CONNECT = 0] = "CONNECT", v[v.DISCONNECT = 1] = "DISCONNECT", v[v.EVENT = 2] = "EVENT", v[v.ACK = 3] = "ACK", v[v.CONNECT_ERROR = 4] = "CONNECT_ERROR", v[v.BINARY_EVENT = 5] = "BINARY_EVENT", v[v.BINARY_ACK = 6] = "BINARY_ACK";
})(Cn || (Cn = {}));
class EA {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === Cn.EVENT || e.type === Cn.ACK) && yc(e) ? this.encodeAsBinary({ type: e.type === Cn.EVENT ? Cn.BINARY_EVENT : Cn.BINARY_ACK, nsp: e.nsp, data: e.data, id: e.id }) : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let n = "" + e.type;
    return (e.type === Cn.BINARY_EVENT || e.type === Cn.BINARY_ACK) && (n += e.attachments + "-"), e.nsp && e.nsp !== "/" && (n += e.nsp + ","), e.id != null && (n += e.id), e.data != null && (n += JSON.stringify(e.data, this.replacer)), n;
  }
  encodeAsBinary(e) {
    const n = bA(e), i = this.encodeAsString(n.packet), s = n.buffers;
    return s.unshift(i), s;
  }
}
function Hd(v) {
  return Object.prototype.toString.call(v) === "[object Object]";
}
class Ef extends ri {
  constructor(e) {
    super(), this.reviver = e;
  }
  add(e) {
    let n;
    if (typeof e == "string") {
      if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet");
      n = this.decodeString(e);
      const i = n.type === Cn.BINARY_EVENT;
      i || n.type === Cn.BINARY_ACK ? (n.type = i ? Cn.EVENT : Cn.ACK, this.reconstructor = new AA(n), n.attachments === 0 && super.emitReserved("decoded", n)) : super.emitReserved("decoded", n);
    } else if (_f(e) || e.base64) if (this.reconstructor) n = this.reconstructor.takeBinaryData(e), n && (this.reconstructor = null, super.emitReserved("decoded", n));
    else throw new Error("got binary data when not reconstructing a packet");
    else throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let n = 0;
    const i = { type: Number(e.charAt(0)) };
    if (Cn[i.type] === void 0) throw new Error("unknown packet type " + i.type);
    if (i.type === Cn.BINARY_EVENT || i.type === Cn.BINARY_ACK) {
      const y = n + 1;
      for (; e.charAt(++n) !== "-" && n != e.length; ) ;
      const t = e.substring(y, n);
      if (t != Number(t) || e.charAt(n) !== "-") throw new Error("Illegal attachments");
      i.attachments = Number(t);
    }
    if (e.charAt(n + 1) === "/") {
      const y = n + 1;
      for (; ++n && !(e.charAt(n) === "," || n === e.length); ) ;
      i.nsp = e.substring(y, n);
    } else i.nsp = "/";
    const s = e.charAt(n + 1);
    if (s !== "" && Number(s) == s) {
      const y = n + 1;
      for (; ++n; ) {
        const t = e.charAt(n);
        if (t == null || Number(t) != t) {
          --n;
          break;
        }
        if (n === e.length) break;
      }
      i.id = Number(e.substring(y, n + 1));
    }
    if (e.charAt(++n)) {
      const y = this.tryParse(e.substr(n));
      if (Ef.isPayloadValid(i.type, y)) i.data = y;
      else throw new Error("invalid payload");
    }
    return i;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return false;
    }
  }
  static isPayloadValid(e, n) {
    switch (e) {
      case Cn.CONNECT:
        return Hd(n);
      case Cn.DISCONNECT:
        return n === void 0;
      case Cn.CONNECT_ERROR:
        return typeof n == "string" || Hd(n);
      case Cn.EVENT:
      case Cn.BINARY_EVENT:
        return Array.isArray(n) && (typeof n[0] == "number" || typeof n[0] == "string" && SA.indexOf(n[0]) === -1);
      case Cn.ACK:
      case Cn.BINARY_ACK:
        return Array.isArray(n);
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class AA {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const n = wA(this.reconPack, this.buffers);
      return this.finishedReconstruction(), n;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const xA = Object.freeze(Object.defineProperty({ __proto__: null, Decoder: Ef, Encoder: EA, get PacketType() {
  return Cn;
}, protocol: _A }, Symbol.toStringTag, { value: "Module" }));
function Ki(v, e, n) {
  return v.on(e, n), function() {
    v.off(e, n);
  };
}
const TA = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 });
class cy extends ri {
  constructor(e, n, i) {
    super(), this.connected = false, this.recovered = false, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = n, i && i.auth && (this.auth = i.auth), this._opts = Object.assign({}, i), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs) return;
    const e = this.io;
    this.subs = [Ki(e, "open", this.onopen.bind(this)), Ki(e, "packet", this.onpacket.bind(this)), Ki(e, "error", this.onerror.bind(this)), Ki(e, "close", this.onclose.bind(this))];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...n) {
    var i, s, y;
    if (TA.hasOwnProperty(e)) throw new Error('"' + e.toString() + '" is a reserved event name');
    if (n.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(n), this;
    const t = { type: Cn.EVENT, data: n };
    if (t.options = {}, t.options.compress = this.flags.compress !== false, typeof n[n.length - 1] == "function") {
      const h = this.ids++, f = n.pop();
      this._registerAckCallback(h, f), t.id = h;
    }
    const o = (s = (i = this.io.engine) === null || i === void 0 ? void 0 : i.transport) === null || s === void 0 ? void 0 : s.writable, u = this.connected && !(!((y = this.io.engine) === null || y === void 0) && y._hasPingExpired());
    return this.flags.volatile && !o || (u ? (this.notifyOutgoingListeners(t), this.packet(t)) : this.sendBuffer.push(t)), this.flags = {}, this;
  }
  _registerAckCallback(e, n) {
    var i;
    const s = (i = this.flags.timeout) !== null && i !== void 0 ? i : this._opts.ackTimeout;
    if (s === void 0) {
      this.acks[e] = n;
      return;
    }
    const y = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let o = 0; o < this.sendBuffer.length; o++) this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);
      n.call(this, new Error("operation has timed out"));
    }, s), t = (...o) => {
      this.io.clearTimeoutFn(y), n.apply(this, o);
    };
    t.withError = true, this.acks[e] = t;
  }
  emitWithAck(e, ...n) {
    return new Promise((i, s) => {
      const y = (t, o) => t ? s(t) : i(o);
      y.withError = true, n.push(y), this.emit(e, ...n);
    });
  }
  _addToQueue(e) {
    let n;
    typeof e[e.length - 1] == "function" && (n = e.pop());
    const i = { id: this._queueSeq++, tryCount: 0, pending: false, args: e, flags: Object.assign({ fromQueue: true }, this.flags) };
    e.push((s, ...y) => i !== this._queue[0] ? void 0 : (s !== null ? i.tryCount > this._opts.retries && (this._queue.shift(), n && n(s)) : (this._queue.shift(), n && n(null, ...y)), i.pending = false, this._drainQueue())), this._queue.push(i), this._drainQueue();
  }
  _drainQueue(e = false) {
    if (!this.connected || this._queue.length === 0) return;
    const n = this._queue[0];
    n.pending && !e || (n.pending = true, n.tryCount++, this.flags = n.flags, this.emit.apply(this, n.args));
  }
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this._sendConnectPacket(e);
    }) : this._sendConnectPacket(this.auth);
  }
  _sendConnectPacket(e) {
    this.packet({ type: Cn.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, n) {
    this.connected = false, delete this.id, this.emitReserved("disconnect", e, n), this._clearAcks();
  }
  _clearAcks() {
    Object.keys(this.acks).forEach((e) => {
      if (!this.sendBuffer.some((i) => String(i.id) === e)) {
        const i = this.acks[e];
        delete this.acks[e], i.withError && i.call(this, new Error("socket has been disconnected"));
      }
    });
  }
  onpacket(e) {
    if (e.nsp === this.nsp) switch (e.type) {
      case Cn.CONNECT:
        e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        break;
      case Cn.EVENT:
      case Cn.BINARY_EVENT:
        this.onevent(e);
        break;
      case Cn.ACK:
      case Cn.BINARY_ACK:
        this.onack(e);
        break;
      case Cn.DISCONNECT:
        this.ondisconnect();
        break;
      case Cn.CONNECT_ERROR:
        this.destroy();
        const i = new Error(e.data.message);
        i.data = e.data.data, this.emitReserved("connect_error", i);
        break;
    }
  }
  onevent(e) {
    const n = e.data || [];
    e.id != null && n.push(this.ack(e.id)), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice();
      for (const i of n) i.apply(this, e);
    }
    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]);
  }
  ack(e) {
    const n = this;
    let i = false;
    return function(...s) {
      i || (i = true, n.packet({ type: Cn.ACK, id: e, data: s }));
    };
  }
  onack(e) {
    const n = this.acks[e.id];
    typeof n == "function" && (delete this.acks[e.id], n.withError && e.data.unshift(null), n.apply(this, e.data));
  }
  onconnect(e, n) {
    this.id = e, this.recovered = n && this._pid === n, this._pid = n, this.connected = true, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(true);
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: Cn.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return this.flags.compress = e, this;
  }
  get volatile() {
    return this.flags.volatile = true, this;
  }
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  offAny(e) {
    if (!this._anyListeners) return this;
    if (e) {
      const n = this._anyListeners;
      for (let i = 0; i < n.length; i++) if (e === n[i]) return n.splice(i, 1), this;
    } else this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners) return this;
    if (e) {
      const n = this._anyOutgoingListeners;
      for (let i = 0; i < n.length; i++) if (e === n[i]) return n.splice(i, 1), this;
    } else this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice();
      for (const i of n) i.apply(this, e.data);
    }
  }
}
function Ua(v) {
  v = v || {}, this.ms = v.min || 100, this.max = v.max || 1e4, this.factor = v.factor || 2, this.jitter = v.jitter > 0 && v.jitter <= 1 ? v.jitter : 0, this.attempts = 0;
}
Ua.prototype.duration = function() {
  var v = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), n = Math.floor(e * this.jitter * v);
    v = (Math.floor(e * 10) & 1) == 0 ? v - n : v + n;
  }
  return Math.min(v, this.max) | 0;
};
Ua.prototype.reset = function() {
  this.attempts = 0;
};
Ua.prototype.setMin = function(v) {
  this.ms = v;
};
Ua.prototype.setMax = function(v) {
  this.max = v;
};
Ua.prototype.setJitter = function(v) {
  this.jitter = v;
};
class Xl extends ri {
  constructor(e, n) {
    var i;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (n = e, e = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, Pc(this, n), this.reconnection(n.reconnection !== false), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((i = n.randomizationFactor) !== null && i !== void 0 ? i : 0.5), this.backoff = new Ua({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = e;
    const s = n.parser || xA;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = n.autoConnect !== false, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = true), this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var n;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (n = this.backoff) === null || n === void 0 || n.setMin(e), this);
  }
  randomizationFactor(e) {
    var n;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (n = this.backoff) === null || n === void 0 || n.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var n;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (n = this.backoff) === null || n === void 0 || n.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open")) return this;
    this.engine = new hA(this.uri, this.opts);
    const n = this.engine, i = this;
    this._readyState = "opening", this.skipReconnect = false;
    const s = Ki(n, "open", function() {
      i.onopen(), e && e();
    }), y = (o) => {
      this.cleanup(), this._readyState = "closed", this.emitReserved("error", o), e ? e(o) : this.maybeReconnectOnOpen();
    }, t = Ki(n, "error", y);
    if (this._timeout !== false) {
      const o = this._timeout, u = this.setTimeoutFn(() => {
        s(), y(new Error("timeout")), n.close();
      }, o);
      this.opts.autoUnref && u.unref(), this.subs.push(() => {
        this.clearTimeoutFn(u);
      });
    }
    return this.subs.push(s), this.subs.push(t), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(Ki(e, "ping", this.onping.bind(this)), Ki(e, "data", this.ondata.bind(this)), Ki(e, "error", this.onerror.bind(this)), Ki(e, "close", this.onclose.bind(this)), Ki(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    try {
      this.decoder.add(e);
    } catch (n) {
      this.onclose("parse error", n);
    }
  }
  ondecoded(e) {
    Oc(() => {
      this.emitReserved("packet", e);
    }, this.setTimeoutFn);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, n) {
    let i = this.nsps[e];
    return i ? this._autoConnect && !i.active && i.connect() : (i = new cy(this, e, n), this.nsps[e] = i), i;
  }
  _destroy(e) {
    const n = Object.keys(this.nsps);
    for (const i of n) if (this.nsps[i].active) return;
    this._close();
  }
  _packet(e) {
    const n = this.encoder.encode(e);
    for (let i = 0; i < n.length; i++) this.engine.write(n[i], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = true, this._reconnecting = false, this.onclose("forced close");
  }
  disconnect() {
    return this._close();
  }
  onclose(e, n) {
    var i;
    this.cleanup(), (i = this.engine) === null || i === void 0 || i.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, n), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect) return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = false;
    else {
      const n = this.backoff.duration();
      this._reconnecting = true;
      const i = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = false, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, n);
      this.opts.autoUnref && i.unref(), this.subs.push(() => {
        this.clearTimeoutFn(i);
      });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = false, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const Rs = {};
function gc(v, e) {
  typeof v == "object" && (e = v, v = void 0), e = e || {};
  const n = dA(v, e.path || "/socket.io"), i = n.source, s = n.id, y = n.path, t = Rs[s] && y in Rs[s].nsps, o = e.forceNew || e["force new connection"] || e.multiplex === false || t;
  let u;
  return o ? u = new Xl(i, e) : (Rs[s] || (Rs[s] = new Xl(i, e)), u = Rs[s]), n.query && !e.query && (e.query = n.queryKey), u.socket(n.path, e);
}
Object.assign(gc, { Manager: Xl, Socket: cy, io: gc, connect: gc });
let yi = gc(kE ?? window.location.toString(), { reconnection: true, reconnectionAttempts: 10, reconnectionDelay: 250, reconnectionDelayMax: 2e3, ackTimeout: 1e3 });
function Cc(v, e) {
  const n = $r("#connectionStatus"), i = $r("#innerConnectionStatus"), s = () => n.children(".status-icon").attr("id", "").removeClass().addClass("status-icon");
  switch (v) {
    case "connected":
      s().addClass(v), i.text("Connected to server.");
      break;
    case "disconnected":
      break;
    case "reconnecting":
      let y = "Reconnecting...";
      (e ?? 0) < 0 ? (y = "Reconnecting failed... click the icon to try again.", s().addClass("disconnected").attr("id", "reconnectBtn"), $r("#reconnectBtn").on("click", () => {
        yi.connect();
      })) : (s().addClass("connecting"), (e ?? 0) > 1 && (y += ` (attempt ${e}).`)), i.text(y);
      break;
    default:
      console.error(`Unexpected server status: ${v}.`);
  }
}
yi.on("connect", () => {
  Cc("connected");
});
yi.on("disconnect", () => {
  Cc("disconnected");
});
yi.io.on("reconnect_attempt", (v) => {
  Cc("reconnecting", v);
});
yi.io.on("reconnect_failed", () => {
  Cc("reconnecting", -1);
});
function Af(v) {
  const e = $r(".waiting-modal-content");
  Gd(), e.append($r("<button>").addClass("close-button").on("click", () => {
    e.children("div").removeClass().addClass("spinner"), Gd(), $r("#wait-status").text(""), $r("#waitingModal").hide(), v && v();
  }).html("&times;"));
}
function Gd() {
  $r(".waiting-modal-content button").remove();
}
function Eo(v, e) {
  xf(v, "error-icon"), Af(e);
}
function rc(v, e) {
  xf(v, "check-icon").html("&#10003;"), Af(e);
}
function Ms(v, e) {
  xf(v, "spinner");
}
function xf(v, e) {
  return $r("#waitingModal").css("display", "flex"), $r("#wait-status").text(v), $r(".waiting-modal-content").children("div").removeClass().addClass(e).html("");
}
function kA(v, e = "#eee", n = 3e3) {
  let i = $r("#popup");
  i.length === 0 && (i = $r('<div id="popup">').addClass("popup"), $r(document.body).append(i)), i.html(v).css("color", e).removeClass("hide"), i.get(0).offsetWidth, i.addClass("show"), setTimeout(() => {
    i.removeClass("show"), i.addClass("hide");
  }, n);
}
function Wd(v) {
  const e = $r("#topPopup").text(v);
  e.addClass("show"), e.on("animationend", () => {
    e.removeClass("show");
  });
}
function Kd(v) {
  const e = pc.basicNodeSigner(v, Sc);
  class n {
    constructor() {
      __publicField(this, "signTransaction", e.signTransaction);
      __publicField(this, "signAuthEntry", e.signAuthEntry);
    }
    getAddress() {
      return Promise.resolve({ address: v.publicKey() });
    }
    isConnected() {
      return Promise.resolve({ isConnected: true });
    }
    requestAccess() {
      return this.getAddress();
    }
    getNetwork() {
      return Promise.resolve({ network: "TESTNET", networkPassphrase: Sc });
    }
    kp() {
      return v;
    }
  }
  return new n();
}
globalThis.Buffer = window.Buffer = $l.Buffer;
class OA {
  constructor() {
    __publicField(this, "handle");
    __publicField(this, "forfeitLedger", 0);
    __publicField(this, "ledElem");
    __publicField(this, "secElem");
    this.secElem = $r("#forfeitSec"), this.ledElem = $r("#forfeitLed");
  }
  async start() {
    $r(".forfeit").show();
    const e = new no.Server(Ma), n = await e.getLatestLedger();
    this.forfeitLedger = n.sequence + TE, this.handle = setInterval(async () => {
      const i = await e.getLatestLedger(), s = 180 - (i.sequence - n.sequence);
      console.log(i, s), this.ledElem.text(s.toString()), i.sequence >= this.forfeitLedger && this.secElem.text("0");
    }, 2500);
  }
  reset() {
    clearInterval(this.handle), $r(".forfeit").hide();
  }
}
async function Xd() {
  let v, e, n, i;
  function s() {
    window.localStorage.clear(), window.location.href = "/";
  }
  async function y() {
    switch (window.localStorage.getItem("walletMethod")) {
      case "import":
        let [Y, te] = ["username", "secretKey"].map(($) => window.localStorage.getItem($));
        e = Y, n = Yn.Keypair.fromSecret(te), v = Kd(n), console.debug(`Logged in ${e} as ${(await v.getAddress()).address}`);
        break;
      case "generate":
        const G = new no.Server(Ma);
        n = Yn.Keypair.random(), Ms("Generating account w/ play money...");
        try {
          await G.requestAirdrop(n.publicKey());
        } catch ($) {
          alert(`Generating account failed: ${$.message}`), s();
        }
        rc(`Account ${n.publicKey().substring(0, 6)}... funded!`), window.localStorage.setItem("secretKey", n.secret()), window.localStorage.setItem("walletMethod", "import"), e = window.localStorage.getItem("username"), v = Kd(n);
        break;
      case "freighter":
        const { isConnected: K } = await Tu.isConnected();
        K || s();
        const { address: J, error: B } = await Tu.requestAccess();
        J || (alert(`Failed to connect to Freighter: ${B}`), s());
        const { network: Z, networkPassphrase: ie } = await Tu.getNetwork();
        ie != Sc && (console.error(Z, ie), alert("Account is on the wrong network! Please switch to a testnet account."), s()), v = Tu, e = window.localStorage.getItem("username"), n = Yn.Keypair.fromPublicKey(await I());
        break;
      default:
        alert("Invalid login! Redirecting to login page..."), s();
    }
  }
  window.localStorage.getItem("signedUp") || s(), await y();
  const t = new PE(), o = await vf(v), u = new SE(".game-area", { theme_surface: "taverntable", theme_texture: "wood", theme_material: "wood", sounds: true, sound_dieMaterial: "wood", strength: 2.5, light_intensity: 1, gravity_multiplier: 600, baseScale: 100 }), c = new OA();
  async function h() {
    $r("#username").text(e), $r("#account-id").text(`${n.publicKey().substring(0, 8)}...`).attr("title", `${n.publicKey()} (click to copy)`).on("click", () => {
      navigator.clipboard.writeText(n.publicKey());
    }), q(), u.initialize(), o.wager().then((Y) => {
      $r("#wager").text((Y.result / Ra).toString());
    }), $r(".deposit").on("click", a), $r(".withdraw").on("click", l), $r(".refresh").on("click", () => q()), $r("#play").on("click", g), $r("#logout").on("click", () => s()), $r("#rules").on("click", () => $r("#rulesModal").css("display", "flex")), $r(".got-it").on("click", () => $r("#rulesModal").hide()), $r("#refundBtn").on("click", () => {
    }), $r("#holdReroll").on("click", () => d(false)), $r("#holdPass").on("click", () => d(true)), yi.onAny((Y, ...te) => console.debug(Y, ...te)), yi.on("auth_request", f), yi.on("match_start", m), yi.on("match_error", r), t.on("roll", b), t.on("reroll", S), t.on("bust", E), t.on("win", R);
  }
  async function f(Y) {
    $r("#wait-status").text("Authorizing game...");
    let te = 0;
    const { network: G, networkPassphrase: K } = await v.getNetwork();
    switch (G) {
      case "TESTNET":
        te = (await new no.Server(Ma).getLatestLedger()).sequence + Math.floor(60 / 5);
        break;
      default:
        throw `Wrong network: ${G}.`;
    }
    const J = Yn.xdr.SorobanAuthorizationEntry.fromXDR(Y.entry, "base64");
    return console.log(J.toXDR("base64")), Yn.authorizeEntry(J, async (B) => {
      console.debug("Signing payload:", B.toXDR("base64"));
      const { signedAuthEntry: Z, signerAddress: ie, error: $ } = await v.signAuthEntry(B.toXDR("base64"), { address: n.publicKey(), networkPassphrase: Sc });
      if (!Z || $) throw $;
      return { signature: typeof Z == "string" ? $l.Buffer.from(Z, "base64") : Z, publicKey: n.publicKey() };
    }, te, K).then((B) => {
      yi.emit("auth_response", { match_id: Y.match_id, player: n.publicKey(), entry: B.toXDR("base64") });
    }, (B) => {
      Eo(`Authorization failed: ${(B == null ? void 0 : B.message) ?? JSON.stringify(B)}`);
    });
  }
  async function r(Y) {
    Eo(Y.error ?? JSON.stringify(Y), () => {
      $r("#play").show(), yi.disconnect(), yi.connect();
    });
  }
  async function m(Y) {
    q(), $r("#wait-status").text("Joined!"), $r("#waitingModal").hide(), $r("#play").hide(), $r(".scoreboard").show(), $r("#forfeit").show(), window.matchMedia("(max-width: 768px)") && $r(".mobile-game-area").attr("display", "flex");
    const [te, G] = Y.match_id.split("|"), K = Y.users.filter((B) => B !== e)[0], J = n.publicKey();
    if (i = te === J ? G : te, t.listen([te, G]), $r("#name").text(e).attr("title", J), $r("#opponent-name").text(K).attr("title", i), T(), Y.first_player === J) try {
      const B = await k(v, i, "Building first roll transaction...");
      await u.roll(w(B));
    } catch (B) {
      L([]), Eo(B.toString(), () => {
        m(Y);
      });
    }
  }
  async function g() {
    yi.disconnected ? Eo("Not connected to server :( Try refreshing?") : yi.emit("join", { address: n.publicKey(), username: e }, (Y) => {
      console.log("Ack:", Y), Ms("Waiting for opponent...");
    }), Af(() => {
      yi.disconnect(), yi.connect();
    });
  }
  async function a() {
    return Ms("Depositing 20 XLM..."), console.debug("Depositing 20 XLM into the contract..."), _c(await o.deposit({ to: n.publicKey(), amount: 20n * Ra }).then((Y) => ($r("#wait-status").text("Authorizing & sending deposit transaction..."), Y))).then(() => {
      rc("Funds deposited."), q();
    }, (Y) => {
      Eo(`Authorization failed! Reason: ${Y.message}`);
    });
  }
  async function l() {
    return Ms("Withdrawing funds..."), console.debug("Withdrawing all XLM from the contract..."), _c(await o.withdraw({ from: n.publicKey() }).then((Y) => ($r("#wait-status").text("Authorizing & sending withdrawal transaction..."), Y))).then(() => {
      rc("Funds withdrawn."), q();
    }, (Y) => {
      Eo(`Authorization failed! Reason: ${Y.message}`);
    });
  }
  async function d(Y) {
    $r("#dicePanel").hide();
    const te = $r("#dicePanel .die.active").map(function() {
      return parseInt($r(this).data("value"));
    }).toArray(), G = $r("#dicePanel .die.active").map(function() {
      return parseInt($r(this).data("index"));
    }).toArray(), K = IE(te);
    if (console.log(`Roll ${te} scored ${K}.`), K === 0) {
      Eo("Invalid dice hold! You must only keep scoring dice.", () => {
        F($r(".die").map(function() {
          return parseInt($r(this).data("value"));
        }).toArray());
      });
      return;
    }
    let J = `Building roll transaction to save ${Nl(te)} for ${K} points `, B = $r("#dicePanel .die").length - G.length;
    Y ? J += "and pass..." : (B <= 0 && (B = 6), J += `and re-roll ${B} ${B === 1 ? "die" : "dice"}...`);
    try {
      T(Y ? 6 : B);
      const Z = await k(v, i, J, G, Y);
      Z.length > 0 && u.roll(w(Z));
    } catch (Z) {
      console.error(`Caught error, letting player re-choose: ${Z}`), F($r("#dicePanel .die").map(function() {
        return parseInt($r(this).text());
      }).toArray());
    }
  }
  async function b(Y) {
    const te = Y.detail;
    if (te.dice.length === 0) {
      const G = te.player === n.publicKey() ? "their" : "your";
      if (kA(`It's ${G} turn!`), T(6), G === "your") {
        c.reset();
        try {
          const K = await k(v, i);
          L(K), await u.roll(w(K));
        } catch {
          L(te.dice), F(te.dice);
        }
      }
      return;
    }
    T(te.dice.length), te.player === n.publicKey() ? (F(te.dice), L(te.dice)) : (c.start(), L(te.dice), await u.roll(w(te.dice)));
  }
  async function S(Y) {
    const te = Y.detail;
    if (te.player !== n.publicKey() && te.dice.length > 0) {
      const B = $r("#opponent-name").text(), Z = Nl(te.dice), ie = te.stop ? " and passed to you" : "";
      Wd(`${B} kept ${Z} for ${te.score} points${ie}.`);
    }
    let G = te.player !== n.publicKey() ? "opponent-" : "", K = $r(`#${G}turn-score`);
    const J = parseInt(K.text());
    if (K.text(J + te.score), te.stop) {
      const B = $r(`#${G}total-score`);
      B.text(parseInt(B.text()) + J + te.score), K.text("0"), o.score({ player: te.player }).then((Z) => Z.simulate()).then((Z) => {
        B.text(Z.result.toString());
      });
    }
  }
  async function E(Y) {
    const te = Y.detail;
    L(te.dice);
    const G = te.player === n.publicKey();
    G || await u.roll(w(te.dice)), Wd(`${G ? "You" : "Opponent"} busted with ${Nl(te.dice)}!`), $r(`#${G ? "" : "opponent-"}turn-score`).text("0"), G || (await Ym(3e3), k(v, i, "Building a fresh roll transaction..."));
  }
  async function R(Y) {
    const te = Y.detail;
    u.clearDice(), L([]);
    const G = () => {
      q(), $r(".scoreboard").fadeOut(), $r(".chat-panel").fadeOut(), $r("#play").show();
    };
    te.player === n.publicKey() ? rc(`You won with ${te.score} points! Winnings have been transferred to your account.`, G) : Eo(`You lost :( Your opponent finished with ${te.score} points.`, G), c.reset();
  }
  function k(Y, te, G, K, J) {
    return Ms(G ?? "Building roll transaction..."), console.debug(`Rolling against ${te}, saving ${K} and stop: ${J}`), ME(Y, te, K, J).then((B) => ($r("#waitingModal").hide(), B), (B) => (Eo(`Authorization failed! Reason: ${B.message}`), Promise.reject(B)));
  }
  function w(Y) {
    const te = `${Y.length}d6@${Y.map((G) => G.toString()).join(",")}`;
    return console.info("Rolling", te), te;
  }
  function F(Y) {
    const te = $r(".dice-container").html("");
    Y.forEach((G, K) => {
      const J = $r("<div>");
      J.addClass(["die", `p${G}`]).data("value", G).data("index", K).on("click", () => J.toggleClass("active")).append(new Array(G).fill(0).map(() => $r("<div>").addClass("pip"))), te.append(J);
    }), $r("#dicePanel").show();
  }
  async function I() {
    const { address: Y } = await v.getAddress();
    return Y;
  }
  async function q() {
    console.log(`Refreshing balances for ${n.publicKey().substring(0, 6)}...`);
    let { element: Y, oldBalance: te, newBalance: G } = await CE(v);
    D(Y, te, G), { element: Y, oldBalance: te, newBalance: G } = await RE(v), D(Y, te, G);
  }
  function D(Y, te, G) {
    const K = parseFloat(G) - parseFloat(te);
    if (Math.round(K) === 0) return;
    const J = $r("<span>").addClass("balance-change");
    J.addClass(K > 0 ? "win" : "loss").text(`${K > 0 ? "+" : ""}${K.toFixed(2)}`), Y.parent().append(J), setTimeout(() => J.remove(), 2500);
  }
  const H = [1, 2, 3, 4, 5, 6];
  let _ = null;
  function T(Y = 6) {
    _ !== null && (clearInterval(_), _ = null), console.log(`Shuffling ${Y} dice`);
    const te = $r("#mobileRoller .dice-container").empty();
    for (let G = 0; G < Y; G++) te.append(j(1));
    $r("#mobileRoller").show(), _ = window.setInterval(() => {
      $r("#mobileRoller .die").each((G, K) => {
        const J = H[Math.floor(Math.random() * 6)];
        z($r(K), J);
      });
    }, 90);
  }
  function L(Y) {
    console.log(`Stopping shuffle with ${Y}`), _ !== null && (clearInterval(_), _ = null), $r("#mobileRoller .die").each((te, G) => {
      te > Y.length - 1 ? $r(G).remove() : z($r(G), Y[te] ?? 1);
    }), Y.length === 0 && $r("#mobileRoller .dice-container").html("");
  }
  function j(Y) {
    const te = $r("<div>").addClass("die");
    return z(te, Y), te;
  }
  function z(Y, te) {
    for (let G = 1; G <= 6; G++) Y.removeClass(`p${G}`);
    Y.empty().addClass(`p${te}`);
    for (let G = 0; G < te; G++) Y.append($r("<span>").addClass("pip"));
  }
  h();
}
$r(() => {
  if (localStorage.getItem("signedUp")) {
    $r("#landingContainer").hide(), $r(".container").show(), Xd();
    return;
  }
  $r("#landingForm").on("change", () => {
    $r("#methodImport").is(":checked") ? $r("#importKeyField").show() : $r("#importKeyField").hide();
  }), $r("#landingForm").on("submit", (v) => {
    v.preventDefault();
    const e = $r("#form-username").val().trim(), n = $r("input[name='walletMethod']:checked").val(), i = $r("#secretKey").val().trim();
    if (i && !Yn.StrKey.isValidEd25519SecretSeed(i)) {
      alert("Invalid secret key format!");
      return;
    }
    localStorage.setItem("signedUp", "true"), localStorage.setItem("username", e), localStorage.setItem("walletMethod", n), n === "import" ? localStorage.setItem("secretKey", i) : localStorage.removeItem("secretKey"), $r("#landingContainer").hide(), $r(".container").show(), Xd();
  });
});
